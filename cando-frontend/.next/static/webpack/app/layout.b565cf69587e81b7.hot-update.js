"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/layout",{

/***/ "(app-pages-browser)/./node_modules/next/dist/api/image.js":
/*!*********************************************!*\
  !*** ./node_modules/next/dist/api/image.js ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* reexport default from dynamic */ _shared_lib_image_external__WEBPACK_IMPORTED_MODULE_0___default.a; }\n/* harmony export */ });\n/* harmony import */ var _shared_lib_image_external__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../shared/lib/image-external */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/image-external.js\");\n/* harmony import */ var _shared_lib_image_external__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_shared_lib_image_external__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};\n/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in _shared_lib_image_external__WEBPACK_IMPORTED_MODULE_0__) if(__WEBPACK_IMPORT_KEY__ !== \"default\") __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = function(key) { return _shared_lib_image_external__WEBPACK_IMPORTED_MODULE_0__[key]; }.bind(0, __WEBPACK_IMPORT_KEY__)\n/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);\n\n //# sourceMappingURL=image.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYXBpL2ltYWdlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUF1RDtBQUNWLENBRTdDLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2FwaS9pbWFnZS5qcz9kMTAxIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCB7IGRlZmF1bHQgfSBmcm9tIFwiLi4vc2hhcmVkL2xpYi9pbWFnZS1leHRlcm5hbFwiO1xuZXhwb3J0ICogZnJvbSBcIi4uL3NoYXJlZC9saWIvaW1hZ2UtZXh0ZXJuYWxcIjtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW1hZ2UuanMubWFwIl0sIm5hbWVzIjpbImRlZmF1bHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/api/image.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/micromatch/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/next/dist/compiled/micromatch/index.js ***!
  \*************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var __dirname = \"/\";\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js\");\n\n(()=>{\n    \"use strict\";\n    var e = {\n        333: (e, t, r)=>{\n            const n = r(137);\n            const u = r(179);\n            const s = r(13);\n            const o = r(719);\n            const braces = function(e) {\n                let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n                let r = [];\n                if (Array.isArray(e)) {\n                    for (let n of e){\n                        let e = braces.create(n, t);\n                        if (Array.isArray(e)) {\n                            r.push(...e);\n                        } else {\n                            r.push(e);\n                        }\n                    }\n                } else {\n                    r = [].concat(braces.create(e, t));\n                }\n                if (t && t.expand === true && t.nodupes === true) {\n                    r = [\n                        ...new Set(r)\n                    ];\n                }\n                return r;\n            };\n            braces.parse = function(e) {\n                let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n                return o(e, t);\n            };\n            braces.stringify = function(e) {\n                let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n                if (typeof e === \"string\") {\n                    return n(braces.parse(e, t), t);\n                }\n                return n(e, t);\n            };\n            braces.compile = function(e) {\n                let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n                if (typeof e === \"string\") {\n                    e = braces.parse(e, t);\n                }\n                return u(e, t);\n            };\n            braces.expand = function(e) {\n                let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n                if (typeof e === \"string\") {\n                    e = braces.parse(e, t);\n                }\n                let r = s(e, t);\n                if (t.noempty === true) {\n                    r = r.filter(Boolean);\n                }\n                if (t.nodupes === true) {\n                    r = [\n                        ...new Set(r)\n                    ];\n                }\n                return r;\n            };\n            braces.create = function(e) {\n                let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n                if (e === \"\" || e.length < 3) {\n                    return [\n                        e\n                    ];\n                }\n                return t.expand !== true ? braces.compile(e, t) : braces.expand(e, t);\n            };\n            e.exports = braces;\n        },\n        179: (e, t, r)=>{\n            const n = r(783);\n            const u = r(617);\n            const compile = function(e) {\n                let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n                let walk = function(e) {\n                    let r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n                    let s = u.isInvalidBrace(r);\n                    let o = e.invalid === true && t.escapeInvalid === true;\n                    let i = s === true || o === true;\n                    let a = t.escapeInvalid === true ? \"\\\\\" : \"\";\n                    let l = \"\";\n                    if (e.isOpen === true) {\n                        return a + e.value;\n                    }\n                    if (e.isClose === true) {\n                        return a + e.value;\n                    }\n                    if (e.type === \"open\") {\n                        return i ? a + e.value : \"(\";\n                    }\n                    if (e.type === \"close\") {\n                        return i ? a + e.value : \")\";\n                    }\n                    if (e.type === \"comma\") {\n                        return e.prev.type === \"comma\" ? \"\" : i ? e.value : \"|\";\n                    }\n                    if (e.value) {\n                        return e.value;\n                    }\n                    if (e.nodes && e.ranges > 0) {\n                        let r = u.reduce(e.nodes);\n                        let s = n(...r, {\n                            ...t,\n                            wrap: false,\n                            toRegex: true\n                        });\n                        if (s.length !== 0) {\n                            return r.length > 1 && s.length > 1 ? \"(\".concat(s, \")\") : s;\n                        }\n                    }\n                    if (e.nodes) {\n                        for (let t of e.nodes){\n                            l += walk(t, e);\n                        }\n                    }\n                    return l;\n                };\n                return walk(e);\n            };\n            e.exports = compile;\n        },\n        457: (e)=>{\n            e.exports = {\n                MAX_LENGTH: 1024 * 64,\n                CHAR_0: \"0\",\n                CHAR_9: \"9\",\n                CHAR_UPPERCASE_A: \"A\",\n                CHAR_LOWERCASE_A: \"a\",\n                CHAR_UPPERCASE_Z: \"Z\",\n                CHAR_LOWERCASE_Z: \"z\",\n                CHAR_LEFT_PARENTHESES: \"(\",\n                CHAR_RIGHT_PARENTHESES: \")\",\n                CHAR_ASTERISK: \"*\",\n                CHAR_AMPERSAND: \"&\",\n                CHAR_AT: \"@\",\n                CHAR_BACKSLASH: \"\\\\\",\n                CHAR_BACKTICK: \"`\",\n                CHAR_CARRIAGE_RETURN: \"\\r\",\n                CHAR_CIRCUMFLEX_ACCENT: \"^\",\n                CHAR_COLON: \":\",\n                CHAR_COMMA: \",\",\n                CHAR_DOLLAR: \"$\",\n                CHAR_DOT: \".\",\n                CHAR_DOUBLE_QUOTE: '\"',\n                CHAR_EQUAL: \"=\",\n                CHAR_EXCLAMATION_MARK: \"!\",\n                CHAR_FORM_FEED: \"\\f\",\n                CHAR_FORWARD_SLASH: \"/\",\n                CHAR_HASH: \"#\",\n                CHAR_HYPHEN_MINUS: \"-\",\n                CHAR_LEFT_ANGLE_BRACKET: \"<\",\n                CHAR_LEFT_CURLY_BRACE: \"{\",\n                CHAR_LEFT_SQUARE_BRACKET: \"[\",\n                CHAR_LINE_FEED: \"\\n\",\n                CHAR_NO_BREAK_SPACE: \"\\xa0\",\n                CHAR_PERCENT: \"%\",\n                CHAR_PLUS: \"+\",\n                CHAR_QUESTION_MARK: \"?\",\n                CHAR_RIGHT_ANGLE_BRACKET: \">\",\n                CHAR_RIGHT_CURLY_BRACE: \"}\",\n                CHAR_RIGHT_SQUARE_BRACKET: \"]\",\n                CHAR_SEMICOLON: \";\",\n                CHAR_SINGLE_QUOTE: \"'\",\n                CHAR_SPACE: \" \",\n                CHAR_TAB: \"\t\",\n                CHAR_UNDERSCORE: \"_\",\n                CHAR_VERTICAL_LINE: \"|\",\n                CHAR_ZERO_WIDTH_NOBREAK_SPACE: \"\\uFEFF\"\n            };\n        },\n        13: (e, t, r)=>{\n            const n = r(783);\n            const u = r(137);\n            const s = r(617);\n            const append = function() {\n                let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : \"\", t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \"\", r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;\n                let n = [];\n                e = [].concat(e);\n                t = [].concat(t);\n                if (!t.length) return e;\n                if (!e.length) {\n                    return r ? s.flatten(t).map((e)=>\"{\".concat(e, \"}\")) : t;\n                }\n                for (let u of e){\n                    if (Array.isArray(u)) {\n                        for (let e of u){\n                            n.push(append(e, t, r));\n                        }\n                    } else {\n                        for (let e of t){\n                            if (r === true && typeof e === \"string\") e = \"{\".concat(e, \"}\");\n                            n.push(Array.isArray(e) ? append(u, e, r) : u + e);\n                        }\n                    }\n                }\n                return s.flatten(n);\n            };\n            const expand = function(e) {\n                let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n                let r = t.rangeLimit === void 0 ? 1e3 : t.rangeLimit;\n                let walk = function(e) {\n                    let o = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n                    e.queue = [];\n                    let i = o;\n                    let a = o.queue;\n                    while(i.type !== \"brace\" && i.type !== \"root\" && i.parent){\n                        i = i.parent;\n                        a = i.queue;\n                    }\n                    if (e.invalid || e.dollar) {\n                        a.push(append(a.pop(), u(e, t)));\n                        return;\n                    }\n                    if (e.type === \"brace\" && e.invalid !== true && e.nodes.length === 2) {\n                        a.push(append(a.pop(), [\n                            \"{}\"\n                        ]));\n                        return;\n                    }\n                    if (e.nodes && e.ranges > 0) {\n                        let o = s.reduce(e.nodes);\n                        if (s.exceedsLimit(...o, t.step, r)) {\n                            throw new RangeError(\"expanded array length exceeds range limit. Use options.rangeLimit to increase or disable the limit.\");\n                        }\n                        let i = n(...o, t);\n                        if (i.length === 0) {\n                            i = u(e, t);\n                        }\n                        a.push(append(a.pop(), i));\n                        e.nodes = [];\n                        return;\n                    }\n                    let l = s.encloseBrace(e);\n                    let c = e.queue;\n                    let p = e;\n                    while(p.type !== \"brace\" && p.type !== \"root\" && p.parent){\n                        p = p.parent;\n                        c = p.queue;\n                    }\n                    for(let t = 0; t < e.nodes.length; t++){\n                        let r = e.nodes[t];\n                        if (r.type === \"comma\" && e.type === \"brace\") {\n                            if (t === 1) c.push(\"\");\n                            c.push(\"\");\n                            continue;\n                        }\n                        if (r.type === \"close\") {\n                            a.push(append(a.pop(), c, l));\n                            continue;\n                        }\n                        if (r.value && r.type !== \"open\") {\n                            c.push(append(c.pop(), r.value));\n                            continue;\n                        }\n                        if (r.nodes) {\n                            walk(r, e);\n                        }\n                    }\n                    return c;\n                };\n                return s.flatten(walk(e));\n            };\n            e.exports = expand;\n        },\n        719: (e, t, r)=>{\n            const n = r(137);\n            const { MAX_LENGTH: u, CHAR_BACKSLASH: s, CHAR_BACKTICK: o, CHAR_COMMA: i, CHAR_DOT: a, CHAR_LEFT_PARENTHESES: l, CHAR_RIGHT_PARENTHESES: c, CHAR_LEFT_CURLY_BRACE: p, CHAR_RIGHT_CURLY_BRACE: f, CHAR_LEFT_SQUARE_BRACKET: A, CHAR_RIGHT_SQUARE_BRACKET: R, CHAR_DOUBLE_QUOTE: _, CHAR_SINGLE_QUOTE: h, CHAR_NO_BREAK_SPACE: g, CHAR_ZERO_WIDTH_NOBREAK_SPACE: E } = r(457);\n            const parse = function(e) {\n                let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n                if (typeof e !== \"string\") {\n                    throw new TypeError(\"Expected a string\");\n                }\n                let r = t || {};\n                let C = typeof r.maxLength === \"number\" ? Math.min(u, r.maxLength) : u;\n                if (e.length > C) {\n                    throw new SyntaxError(\"Input length (\".concat(e.length, \"), exceeds max characters (\").concat(C, \")\"));\n                }\n                let y = {\n                    type: \"root\",\n                    input: e,\n                    nodes: []\n                };\n                let d = [\n                    y\n                ];\n                let x = y;\n                let b = y;\n                let S = 0;\n                let H = e.length;\n                let v = 0;\n                let $ = 0;\n                let m;\n                let T = {};\n                const advance = ()=>e[v++];\n                const push = (e)=>{\n                    if (e.type === \"text\" && b.type === \"dot\") {\n                        b.type = \"text\";\n                    }\n                    if (b && b.type === \"text\" && e.type === \"text\") {\n                        b.value += e.value;\n                        return;\n                    }\n                    x.nodes.push(e);\n                    e.parent = x;\n                    e.prev = b;\n                    b = e;\n                    return e;\n                };\n                push({\n                    type: \"bos\"\n                });\n                while(v < H){\n                    x = d[d.length - 1];\n                    m = advance();\n                    if (m === E || m === g) {\n                        continue;\n                    }\n                    if (m === s) {\n                        push({\n                            type: \"text\",\n                            value: (t.keepEscaping ? m : \"\") + advance()\n                        });\n                        continue;\n                    }\n                    if (m === R) {\n                        push({\n                            type: \"text\",\n                            value: \"\\\\\" + m\n                        });\n                        continue;\n                    }\n                    if (m === A) {\n                        S++;\n                        let e = true;\n                        let t;\n                        while(v < H && (t = advance())){\n                            m += t;\n                            if (t === A) {\n                                S++;\n                                continue;\n                            }\n                            if (t === s) {\n                                m += advance();\n                                continue;\n                            }\n                            if (t === R) {\n                                S--;\n                                if (S === 0) {\n                                    break;\n                                }\n                            }\n                        }\n                        push({\n                            type: \"text\",\n                            value: m\n                        });\n                        continue;\n                    }\n                    if (m === l) {\n                        x = push({\n                            type: \"paren\",\n                            nodes: []\n                        });\n                        d.push(x);\n                        push({\n                            type: \"text\",\n                            value: m\n                        });\n                        continue;\n                    }\n                    if (m === c) {\n                        if (x.type !== \"paren\") {\n                            push({\n                                type: \"text\",\n                                value: m\n                            });\n                            continue;\n                        }\n                        x = d.pop();\n                        push({\n                            type: \"text\",\n                            value: m\n                        });\n                        x = d[d.length - 1];\n                        continue;\n                    }\n                    if (m === _ || m === h || m === o) {\n                        let e = m;\n                        let r;\n                        if (t.keepQuotes !== true) {\n                            m = \"\";\n                        }\n                        while(v < H && (r = advance())){\n                            if (r === s) {\n                                m += r + advance();\n                                continue;\n                            }\n                            if (r === e) {\n                                if (t.keepQuotes === true) m += r;\n                                break;\n                            }\n                            m += r;\n                        }\n                        push({\n                            type: \"text\",\n                            value: m\n                        });\n                        continue;\n                    }\n                    if (m === p) {\n                        $++;\n                        let e = b.value && b.value.slice(-1) === \"$\" || x.dollar === true;\n                        let t = {\n                            type: \"brace\",\n                            open: true,\n                            close: false,\n                            dollar: e,\n                            depth: $,\n                            commas: 0,\n                            ranges: 0,\n                            nodes: []\n                        };\n                        x = push(t);\n                        d.push(x);\n                        push({\n                            type: \"open\",\n                            value: m\n                        });\n                        continue;\n                    }\n                    if (m === f) {\n                        if (x.type !== \"brace\") {\n                            push({\n                                type: \"text\",\n                                value: m\n                            });\n                            continue;\n                        }\n                        let e = \"close\";\n                        x = d.pop();\n                        x.close = true;\n                        push({\n                            type: e,\n                            value: m\n                        });\n                        $--;\n                        x = d[d.length - 1];\n                        continue;\n                    }\n                    if (m === i && $ > 0) {\n                        if (x.ranges > 0) {\n                            x.ranges = 0;\n                            let e = x.nodes.shift();\n                            x.nodes = [\n                                e,\n                                {\n                                    type: \"text\",\n                                    value: n(x)\n                                }\n                            ];\n                        }\n                        push({\n                            type: \"comma\",\n                            value: m\n                        });\n                        x.commas++;\n                        continue;\n                    }\n                    if (m === a && $ > 0 && x.commas === 0) {\n                        let e = x.nodes;\n                        if ($ === 0 || e.length === 0) {\n                            push({\n                                type: \"text\",\n                                value: m\n                            });\n                            continue;\n                        }\n                        if (b.type === \"dot\") {\n                            x.range = [];\n                            b.value += m;\n                            b.type = \"range\";\n                            if (x.nodes.length !== 3 && x.nodes.length !== 5) {\n                                x.invalid = true;\n                                x.ranges = 0;\n                                b.type = \"text\";\n                                continue;\n                            }\n                            x.ranges++;\n                            x.args = [];\n                            continue;\n                        }\n                        if (b.type === \"range\") {\n                            e.pop();\n                            let t = e[e.length - 1];\n                            t.value += b.value + m;\n                            b = t;\n                            x.ranges--;\n                            continue;\n                        }\n                        push({\n                            type: \"dot\",\n                            value: m\n                        });\n                        continue;\n                    }\n                    push({\n                        type: \"text\",\n                        value: m\n                    });\n                }\n                do {\n                    x = d.pop();\n                    if (x.type !== \"root\") {\n                        x.nodes.forEach((e)=>{\n                            if (!e.nodes) {\n                                if (e.type === \"open\") e.isOpen = true;\n                                if (e.type === \"close\") e.isClose = true;\n                                if (!e.nodes) e.type = \"text\";\n                                e.invalid = true;\n                            }\n                        });\n                        let e = d[d.length - 1];\n                        let t = e.nodes.indexOf(x);\n                        e.nodes.splice(t, 1, ...x.nodes);\n                    }\n                }while (d.length > 0);\n                push({\n                    type: \"eos\"\n                });\n                return y;\n            };\n            e.exports = parse;\n        },\n        137: (e, t, r)=>{\n            const n = r(617);\n            e.exports = function(e) {\n                let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n                let stringify = function(e) {\n                    let r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n                    let u = t.escapeInvalid && n.isInvalidBrace(r);\n                    let s = e.invalid === true && t.escapeInvalid === true;\n                    let o = \"\";\n                    if (e.value) {\n                        if ((u || s) && n.isOpenOrClose(e)) {\n                            return \"\\\\\" + e.value;\n                        }\n                        return e.value;\n                    }\n                    if (e.value) {\n                        return e.value;\n                    }\n                    if (e.nodes) {\n                        for (let t of e.nodes){\n                            o += stringify(t);\n                        }\n                    }\n                    return o;\n                };\n                return stringify(e);\n            };\n        },\n        617: (e, t)=>{\n            t.isInteger = (e)=>{\n                if (typeof e === \"number\") {\n                    return Number.isInteger(e);\n                }\n                if (typeof e === \"string\" && e.trim() !== \"\") {\n                    return Number.isInteger(Number(e));\n                }\n                return false;\n            };\n            t.find = (e, t)=>e.nodes.find((e)=>e.type === t);\n            t.exceedsLimit = function(e, r) {\n                let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1, u = arguments.length > 3 ? arguments[3] : void 0;\n                if (u === false) return false;\n                if (!t.isInteger(e) || !t.isInteger(r)) return false;\n                return (Number(r) - Number(e)) / Number(n) >= u;\n            };\n            t.escapeNode = function(e) {\n                let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, r = arguments.length > 2 ? arguments[2] : void 0;\n                let n = e.nodes[t];\n                if (!n) return;\n                if (r && n.type === r || n.type === \"open\" || n.type === \"close\") {\n                    if (n.escaped !== true) {\n                        n.value = \"\\\\\" + n.value;\n                        n.escaped = true;\n                    }\n                }\n            };\n            t.encloseBrace = (e)=>{\n                if (e.type !== \"brace\") return false;\n                if (e.commas >> 0 + e.ranges >> 0 === 0) {\n                    e.invalid = true;\n                    return true;\n                }\n                return false;\n            };\n            t.isInvalidBrace = (e)=>{\n                if (e.type !== \"brace\") return false;\n                if (e.invalid === true || e.dollar) return true;\n                if (e.commas >> 0 + e.ranges >> 0 === 0) {\n                    e.invalid = true;\n                    return true;\n                }\n                if (e.open !== true || e.close !== true) {\n                    e.invalid = true;\n                    return true;\n                }\n                return false;\n            };\n            t.isOpenOrClose = (e)=>{\n                if (e.type === \"open\" || e.type === \"close\") {\n                    return true;\n                }\n                return e.open === true || e.close === true;\n            };\n            t.reduce = (e)=>e.reduce((e, t)=>{\n                    if (t.type === \"text\") e.push(t.value);\n                    if (t.type === \"range\") t.type = \"text\";\n                    return e;\n                }, []);\n            t.flatten = function() {\n                for(var _len = arguments.length, e = new Array(_len), _key = 0; _key < _len; _key++){\n                    e[_key] = arguments[_key];\n                }\n                const t = [];\n                const flat = (e)=>{\n                    for(let r = 0; r < e.length; r++){\n                        let n = e[r];\n                        Array.isArray(n) ? flat(n, t) : n !== void 0 && t.push(n);\n                    }\n                    return t;\n                };\n                flat(e);\n                return t;\n            };\n        },\n        783: (e, t, r)=>{\n            /*!\n * fill-range <https://github.com/jonschlinkert/fill-range>\n *\n * Copyright (c) 2014-present, Jon Schlinkert.\n * Licensed under the MIT License.\n */ const n = r(837);\n            const u = r(492);\n            const isObject = (e)=>e !== null && typeof e === \"object\" && !Array.isArray(e);\n            const transform = (e)=>(t)=>e === true ? Number(t) : String(t);\n            const isValidValue = (e)=>typeof e === \"number\" || typeof e === \"string\" && e !== \"\";\n            const isNumber = (e)=>Number.isInteger(+e);\n            const zeros = (e)=>{\n                let t = \"\".concat(e);\n                let r = -1;\n                if (t[0] === \"-\") t = t.slice(1);\n                if (t === \"0\") return false;\n                while(t[++r] === \"0\");\n                return r > 0;\n            };\n            const stringify = (e, t, r)=>{\n                if (typeof e === \"string\" || typeof t === \"string\") {\n                    return true;\n                }\n                return r.stringify === true;\n            };\n            const pad = (e, t, r)=>{\n                if (t > 0) {\n                    let r = e[0] === \"-\" ? \"-\" : \"\";\n                    if (r) e = e.slice(1);\n                    e = r + e.padStart(r ? t - 1 : t, \"0\");\n                }\n                if (r === false) {\n                    return String(e);\n                }\n                return e;\n            };\n            const toMaxLen = (e, t)=>{\n                let r = e[0] === \"-\" ? \"-\" : \"\";\n                if (r) {\n                    e = e.slice(1);\n                    t--;\n                }\n                while(e.length < t)e = \"0\" + e;\n                return r ? \"-\" + e : e;\n            };\n            const toSequence = (e, t)=>{\n                e.negatives.sort((e, t)=>e < t ? -1 : e > t ? 1 : 0);\n                e.positives.sort((e, t)=>e < t ? -1 : e > t ? 1 : 0);\n                let r = t.capture ? \"\" : \"?:\";\n                let n = \"\";\n                let u = \"\";\n                let s;\n                if (e.positives.length) {\n                    n = e.positives.join(\"|\");\n                }\n                if (e.negatives.length) {\n                    u = \"-(\".concat(r).concat(e.negatives.join(\"|\"), \")\");\n                }\n                if (n && u) {\n                    s = \"\".concat(n, \"|\").concat(u);\n                } else {\n                    s = n || u;\n                }\n                if (t.wrap) {\n                    return \"(\".concat(r).concat(s, \")\");\n                }\n                return s;\n            };\n            const toRange = (e, t, r, n)=>{\n                if (r) {\n                    return u(e, t, {\n                        wrap: false,\n                        ...n\n                    });\n                }\n                let s = String.fromCharCode(e);\n                if (e === t) return s;\n                let o = String.fromCharCode(t);\n                return \"[\".concat(s, \"-\").concat(o, \"]\");\n            };\n            const toRegex = (e, t, r)=>{\n                if (Array.isArray(e)) {\n                    let t = r.wrap === true;\n                    let n = r.capture ? \"\" : \"?:\";\n                    return t ? \"(\".concat(n).concat(e.join(\"|\"), \")\") : e.join(\"|\");\n                }\n                return u(e, t, r);\n            };\n            const rangeError = function() {\n                for(var _len = arguments.length, e = new Array(_len), _key = 0; _key < _len; _key++){\n                    e[_key] = arguments[_key];\n                }\n                return new RangeError(\"Invalid range arguments: \" + n.inspect(...e));\n            };\n            const invalidRange = (e, t, r)=>{\n                if (r.strictRanges === true) throw rangeError([\n                    e,\n                    t\n                ]);\n                return [];\n            };\n            const invalidStep = (e, t)=>{\n                if (t.strictRanges === true) {\n                    throw new TypeError('Expected step \"'.concat(e, '\" to be a number'));\n                }\n                return [];\n            };\n            const fillNumbers = function(e, t) {\n                let r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1, n = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};\n                let u = Number(e);\n                let s = Number(t);\n                if (!Number.isInteger(u) || !Number.isInteger(s)) {\n                    if (n.strictRanges === true) throw rangeError([\n                        e,\n                        t\n                    ]);\n                    return [];\n                }\n                if (u === 0) u = 0;\n                if (s === 0) s = 0;\n                let o = u > s;\n                let i = String(e);\n                let a = String(t);\n                let l = String(r);\n                r = Math.max(Math.abs(r), 1);\n                let c = zeros(i) || zeros(a) || zeros(l);\n                let p = c ? Math.max(i.length, a.length, l.length) : 0;\n                let f = c === false && stringify(e, t, n) === false;\n                let A = n.transform || transform(f);\n                if (n.toRegex && r === 1) {\n                    return toRange(toMaxLen(e, p), toMaxLen(t, p), true, n);\n                }\n                let R = {\n                    negatives: [],\n                    positives: []\n                };\n                let push = (e)=>R[e < 0 ? \"negatives\" : \"positives\"].push(Math.abs(e));\n                let _ = [];\n                let h = 0;\n                while(o ? u >= s : u <= s){\n                    if (n.toRegex === true && r > 1) {\n                        push(u);\n                    } else {\n                        _.push(pad(A(u, h), p, f));\n                    }\n                    u = o ? u - r : u + r;\n                    h++;\n                }\n                if (n.toRegex === true) {\n                    return r > 1 ? toSequence(R, n) : toRegex(_, null, {\n                        wrap: false,\n                        ...n\n                    });\n                }\n                return _;\n            };\n            const fillLetters = function(e, t) {\n                let r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1, n = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};\n                if (!isNumber(e) && e.length > 1 || !isNumber(t) && t.length > 1) {\n                    return invalidRange(e, t, n);\n                }\n                let u = n.transform || ((e)=>String.fromCharCode(e));\n                let s = \"\".concat(e).charCodeAt(0);\n                let o = \"\".concat(t).charCodeAt(0);\n                let i = s > o;\n                let a = Math.min(s, o);\n                let l = Math.max(s, o);\n                if (n.toRegex && r === 1) {\n                    return toRange(a, l, false, n);\n                }\n                let c = [];\n                let p = 0;\n                while(i ? s >= o : s <= o){\n                    c.push(u(s, p));\n                    s = i ? s - r : s + r;\n                    p++;\n                }\n                if (n.toRegex === true) {\n                    return toRegex(c, null, {\n                        wrap: false,\n                        options: n\n                    });\n                }\n                return c;\n            };\n            const fill = function(e, t, r) {\n                let n = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};\n                if (t == null && isValidValue(e)) {\n                    return [\n                        e\n                    ];\n                }\n                if (!isValidValue(e) || !isValidValue(t)) {\n                    return invalidRange(e, t, n);\n                }\n                if (typeof r === \"function\") {\n                    return fill(e, t, 1, {\n                        transform: r\n                    });\n                }\n                if (isObject(r)) {\n                    return fill(e, t, 0, r);\n                }\n                let u = {\n                    ...n\n                };\n                if (u.capture === true) u.wrap = true;\n                r = r || u.step || 1;\n                if (!isNumber(r)) {\n                    if (r != null && !isObject(r)) return invalidStep(r, u);\n                    return fill(e, t, 1, r);\n                }\n                if (isNumber(e) && isNumber(t)) {\n                    return fillNumbers(e, t, r, u);\n                }\n                return fillLetters(e, t, Math.max(Math.abs(r), 1), u);\n            };\n            e.exports = fill;\n        },\n        357: (e)=>{\n            /*!\n * is-number <https://github.com/jonschlinkert/is-number>\n *\n * Copyright (c) 2014-present, Jon Schlinkert.\n * Released under the MIT License.\n */ e.exports = function(e) {\n                if (typeof e === \"number\") {\n                    return e - e === 0;\n                }\n                if (typeof e === \"string\" && e.trim() !== \"\") {\n                    return Number.isFinite ? Number.isFinite(+e) : isFinite(+e);\n                }\n                return false;\n            };\n        },\n        971: (e, t, r)=>{\n            const n = r(837);\n            const u = r(333);\n            const s = r(251);\n            const o = r(513);\n            const isEmptyString = (e)=>e === \"\" || e === \"./\";\n            const micromatch = (e, t, r)=>{\n                t = [].concat(t);\n                e = [].concat(e);\n                let n = new Set;\n                let u = new Set;\n                let o = new Set;\n                let i = 0;\n                let onResult = (e)=>{\n                    o.add(e.output);\n                    if (r && r.onResult) {\n                        r.onResult(e);\n                    }\n                };\n                for(let o = 0; o < t.length; o++){\n                    let a = s(String(t[o]), {\n                        ...r,\n                        onResult: onResult\n                    }, true);\n                    let l = a.state.negated || a.state.negatedExtglob;\n                    if (l) i++;\n                    for (let t of e){\n                        let e = a(t, true);\n                        let r = l ? !e.isMatch : e.isMatch;\n                        if (!r) continue;\n                        if (l) {\n                            n.add(e.output);\n                        } else {\n                            n.delete(e.output);\n                            u.add(e.output);\n                        }\n                    }\n                }\n                let a = i === t.length ? [\n                    ...o\n                ] : [\n                    ...u\n                ];\n                let l = a.filter((e)=>!n.has(e));\n                if (r && l.length === 0) {\n                    if (r.failglob === true) {\n                        throw new Error('No matches found for \"'.concat(t.join(\", \"), '\"'));\n                    }\n                    if (r.nonull === true || r.nullglob === true) {\n                        return r.unescape ? t.map((e)=>e.replace(/\\\\/g, \"\")) : t;\n                    }\n                }\n                return l;\n            };\n            micromatch.match = micromatch;\n            micromatch.matcher = (e, t)=>s(e, t);\n            micromatch.isMatch = (e, t, r)=>s(t, r)(e);\n            micromatch.any = micromatch.isMatch;\n            micromatch.not = function(e, t) {\n                let r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n                t = [].concat(t).map(String);\n                let n = new Set;\n                let u = [];\n                let onResult = (e)=>{\n                    if (r.onResult) r.onResult(e);\n                    u.push(e.output);\n                };\n                let s = micromatch(e, t, {\n                    ...r,\n                    onResult: onResult\n                });\n                for (let e of u){\n                    if (!s.includes(e)) {\n                        n.add(e);\n                    }\n                }\n                return [\n                    ...n\n                ];\n            };\n            micromatch.contains = (e, t, r)=>{\n                if (typeof e !== \"string\") {\n                    throw new TypeError('Expected a string: \"'.concat(n.inspect(e), '\"'));\n                }\n                if (Array.isArray(t)) {\n                    return t.some((t)=>micromatch.contains(e, t, r));\n                }\n                if (typeof t === \"string\") {\n                    if (isEmptyString(e) || isEmptyString(t)) {\n                        return false;\n                    }\n                    if (e.includes(t) || e.startsWith(\"./\") && e.slice(2).includes(t)) {\n                        return true;\n                    }\n                }\n                return micromatch.isMatch(e, t, {\n                    ...r,\n                    contains: true\n                });\n            };\n            micromatch.matchKeys = (e, t, r)=>{\n                if (!o.isObject(e)) {\n                    throw new TypeError(\"Expected the first argument to be an object\");\n                }\n                let n = micromatch(Object.keys(e), t, r);\n                let u = {};\n                for (let t of n)u[t] = e[t];\n                return u;\n            };\n            micromatch.some = (e, t, r)=>{\n                let n = [].concat(e);\n                for (let e of [].concat(t)){\n                    let t = s(String(e), r);\n                    if (n.some((e)=>t(e))) {\n                        return true;\n                    }\n                }\n                return false;\n            };\n            micromatch.every = (e, t, r)=>{\n                let n = [].concat(e);\n                for (let e of [].concat(t)){\n                    let t = s(String(e), r);\n                    if (!n.every((e)=>t(e))) {\n                        return false;\n                    }\n                }\n                return true;\n            };\n            micromatch.all = (e, t, r)=>{\n                if (typeof e !== \"string\") {\n                    throw new TypeError('Expected a string: \"'.concat(n.inspect(e), '\"'));\n                }\n                return [].concat(t).every((t)=>s(t, r)(e));\n            };\n            micromatch.capture = (e, t, r)=>{\n                let n = o.isWindows(r);\n                let u = s.makeRe(String(e), {\n                    ...r,\n                    capture: true\n                });\n                let i = u.exec(n ? o.toPosixSlashes(t) : t);\n                if (i) {\n                    return i.slice(1).map((e)=>e === void 0 ? \"\" : e);\n                }\n            };\n            micromatch.makeRe = function() {\n                for(var _len = arguments.length, e = new Array(_len), _key = 0; _key < _len; _key++){\n                    e[_key] = arguments[_key];\n                }\n                return s.makeRe(...e);\n            };\n            micromatch.scan = function() {\n                for(var _len = arguments.length, e = new Array(_len), _key = 0; _key < _len; _key++){\n                    e[_key] = arguments[_key];\n                }\n                return s.scan(...e);\n            };\n            micromatch.parse = (e, t)=>{\n                let r = [];\n                for (let n of [].concat(e || [])){\n                    for (let e of u(String(n), t)){\n                        r.push(s.parse(e, t));\n                    }\n                }\n                return r;\n            };\n            micromatch.braces = (e, t)=>{\n                if (typeof e !== \"string\") throw new TypeError(\"Expected a string\");\n                if (t && t.nobrace === true || !/\\{.*\\}/.test(e)) {\n                    return [\n                        e\n                    ];\n                }\n                return u(e, t);\n            };\n            micromatch.braceExpand = (e, t)=>{\n                if (typeof e !== \"string\") throw new TypeError(\"Expected a string\");\n                return micromatch.braces(e, {\n                    ...t,\n                    expand: true\n                });\n            };\n            e.exports = micromatch;\n        },\n        251: (e, t, r)=>{\n            e.exports = r(683);\n        },\n        356: (e, t, r)=>{\n            const n = r(17);\n            const u = \"\\\\\\\\/\";\n            const s = \"[^\".concat(u, \"]\");\n            const o = \"\\\\.\";\n            const i = \"\\\\+\";\n            const a = \"\\\\?\";\n            const l = \"\\\\/\";\n            const c = \"(?=.)\";\n            const p = \"[^/]\";\n            const f = \"(?:\".concat(l, \"|$)\");\n            const A = \"(?:^|\".concat(l, \")\");\n            const R = \"\".concat(o, \"{1,2}\").concat(f);\n            const _ = \"(?!\".concat(o, \")\");\n            const h = \"(?!\".concat(A).concat(R, \")\");\n            const g = \"(?!\".concat(o, \"{0,1}\").concat(f, \")\");\n            const E = \"(?!\".concat(R, \")\");\n            const C = \"[^.\".concat(l, \"]\");\n            const y = \"\".concat(p, \"*?\");\n            const d = {\n                DOT_LITERAL: o,\n                PLUS_LITERAL: i,\n                QMARK_LITERAL: a,\n                SLASH_LITERAL: l,\n                ONE_CHAR: c,\n                QMARK: p,\n                END_ANCHOR: f,\n                DOTS_SLASH: R,\n                NO_DOT: _,\n                NO_DOTS: h,\n                NO_DOT_SLASH: g,\n                NO_DOTS_SLASH: E,\n                QMARK_NO_DOT: C,\n                STAR: y,\n                START_ANCHOR: A\n            };\n            const x = {\n                ...d,\n                SLASH_LITERAL: \"[\".concat(u, \"]\"),\n                QMARK: s,\n                STAR: \"\".concat(s, \"*?\"),\n                DOTS_SLASH: \"\".concat(o, \"{1,2}(?:[\").concat(u, \"]|$)\"),\n                NO_DOT: \"(?!\".concat(o, \")\"),\n                NO_DOTS: \"(?!(?:^|[\".concat(u, \"])\").concat(o, \"{1,2}(?:[\").concat(u, \"]|$))\"),\n                NO_DOT_SLASH: \"(?!\".concat(o, \"{0,1}(?:[\").concat(u, \"]|$))\"),\n                NO_DOTS_SLASH: \"(?!\".concat(o, \"{1,2}(?:[\").concat(u, \"]|$))\"),\n                QMARK_NO_DOT: \"[^.\".concat(u, \"]\"),\n                START_ANCHOR: \"(?:^|[\".concat(u, \"])\"),\n                END_ANCHOR: \"(?:[\".concat(u, \"]|$)\")\n            };\n            const b = {\n                alnum: \"a-zA-Z0-9\",\n                alpha: \"a-zA-Z\",\n                ascii: \"\\\\x00-\\\\x7F\",\n                blank: \" \\\\t\",\n                cntrl: \"\\\\x00-\\\\x1F\\\\x7F\",\n                digit: \"0-9\",\n                graph: \"\\\\x21-\\\\x7E\",\n                lower: \"a-z\",\n                print: \"\\\\x20-\\\\x7E \",\n                punct: \"\\\\-!\\\"#$%&'()\\\\*+,./:;<=>?@[\\\\]^_`{|}~\",\n                space: \" \\\\t\\\\r\\\\n\\\\v\\\\f\",\n                upper: \"A-Z\",\n                word: \"A-Za-z0-9_\",\n                xdigit: \"A-Fa-f0-9\"\n            };\n            e.exports = {\n                MAX_LENGTH: 1024 * 64,\n                POSIX_REGEX_SOURCE: b,\n                REGEX_BACKSLASH: /\\\\(?![*+?^${}(|)[\\]])/g,\n                REGEX_NON_SPECIAL_CHARS: /^[^@![\\].,$*+?^{}()|\\\\/]+/,\n                REGEX_SPECIAL_CHARS: /[-*+?.^${}(|)[\\]]/,\n                REGEX_SPECIAL_CHARS_BACKREF: /(\\\\?)((\\W)(\\3*))/g,\n                REGEX_SPECIAL_CHARS_GLOBAL: /([-*+?.^${}(|)[\\]])/g,\n                REGEX_REMOVE_BACKSLASH: /(?:\\[.*?[^\\\\]\\]|\\\\(?=.))/g,\n                REPLACEMENTS: {\n                    \"***\": \"*\",\n                    \"**/**\": \"**\",\n                    \"**/**/**\": \"**\"\n                },\n                CHAR_0: 48,\n                CHAR_9: 57,\n                CHAR_UPPERCASE_A: 65,\n                CHAR_LOWERCASE_A: 97,\n                CHAR_UPPERCASE_Z: 90,\n                CHAR_LOWERCASE_Z: 122,\n                CHAR_LEFT_PARENTHESES: 40,\n                CHAR_RIGHT_PARENTHESES: 41,\n                CHAR_ASTERISK: 42,\n                CHAR_AMPERSAND: 38,\n                CHAR_AT: 64,\n                CHAR_BACKWARD_SLASH: 92,\n                CHAR_CARRIAGE_RETURN: 13,\n                CHAR_CIRCUMFLEX_ACCENT: 94,\n                CHAR_COLON: 58,\n                CHAR_COMMA: 44,\n                CHAR_DOT: 46,\n                CHAR_DOUBLE_QUOTE: 34,\n                CHAR_EQUAL: 61,\n                CHAR_EXCLAMATION_MARK: 33,\n                CHAR_FORM_FEED: 12,\n                CHAR_FORWARD_SLASH: 47,\n                CHAR_GRAVE_ACCENT: 96,\n                CHAR_HASH: 35,\n                CHAR_HYPHEN_MINUS: 45,\n                CHAR_LEFT_ANGLE_BRACKET: 60,\n                CHAR_LEFT_CURLY_BRACE: 123,\n                CHAR_LEFT_SQUARE_BRACKET: 91,\n                CHAR_LINE_FEED: 10,\n                CHAR_NO_BREAK_SPACE: 160,\n                CHAR_PERCENT: 37,\n                CHAR_PLUS: 43,\n                CHAR_QUESTION_MARK: 63,\n                CHAR_RIGHT_ANGLE_BRACKET: 62,\n                CHAR_RIGHT_CURLY_BRACE: 125,\n                CHAR_RIGHT_SQUARE_BRACKET: 93,\n                CHAR_SEMICOLON: 59,\n                CHAR_SINGLE_QUOTE: 39,\n                CHAR_SPACE: 32,\n                CHAR_TAB: 9,\n                CHAR_UNDERSCORE: 95,\n                CHAR_VERTICAL_LINE: 124,\n                CHAR_ZERO_WIDTH_NOBREAK_SPACE: 65279,\n                SEP: n.sep,\n                extglobChars (e) {\n                    return {\n                        \"!\": {\n                            type: \"negate\",\n                            open: \"(?:(?!(?:\",\n                            close: \"))\".concat(e.STAR, \")\")\n                        },\n                        \"?\": {\n                            type: \"qmark\",\n                            open: \"(?:\",\n                            close: \")?\"\n                        },\n                        \"+\": {\n                            type: \"plus\",\n                            open: \"(?:\",\n                            close: \")+\"\n                        },\n                        \"*\": {\n                            type: \"star\",\n                            open: \"(?:\",\n                            close: \")*\"\n                        },\n                        \"@\": {\n                            type: \"at\",\n                            open: \"(?:\",\n                            close: \")\"\n                        }\n                    };\n                },\n                globChars (e) {\n                    return e === true ? x : d;\n                }\n            };\n        },\n        754: (e, t, r)=>{\n            const n = r(356);\n            const u = r(513);\n            const { MAX_LENGTH: s, POSIX_REGEX_SOURCE: o, REGEX_NON_SPECIAL_CHARS: i, REGEX_SPECIAL_CHARS_BACKREF: a, REPLACEMENTS: l } = n;\n            const expandRange = (e, t)=>{\n                if (typeof t.expandRange === \"function\") {\n                    return t.expandRange(...e, t);\n                }\n                e.sort();\n                const r = \"[\".concat(e.join(\"-\"), \"]\");\n                try {\n                    new RegExp(r);\n                } catch (t) {\n                    return e.map((e)=>u.escapeRegex(e)).join(\"..\");\n                }\n                return r;\n            };\n            const syntaxError = (e, t)=>\"Missing \".concat(e, ': \"').concat(t, '\" - use \"\\\\\\\\').concat(t, '\" to match literal characters');\n            const parse = (e, t)=>{\n                if (typeof e !== \"string\") {\n                    throw new TypeError(\"Expected a string\");\n                }\n                e = l[e] || e;\n                const r = {\n                    ...t\n                };\n                const c = typeof r.maxLength === \"number\" ? Math.min(s, r.maxLength) : s;\n                let p = e.length;\n                if (p > c) {\n                    throw new SyntaxError(\"Input length: \".concat(p, \", exceeds maximum allowed length: \").concat(c));\n                }\n                const f = {\n                    type: \"bos\",\n                    value: \"\",\n                    output: r.prepend || \"\"\n                };\n                const A = [\n                    f\n                ];\n                const R = r.capture ? \"\" : \"?:\";\n                const _ = u.isWindows(t);\n                const h = n.globChars(_);\n                const g = n.extglobChars(h);\n                const { DOT_LITERAL: E, PLUS_LITERAL: C, SLASH_LITERAL: y, ONE_CHAR: d, DOTS_SLASH: x, NO_DOT: b, NO_DOT_SLASH: S, NO_DOTS_SLASH: H, QMARK: v, QMARK_NO_DOT: $, STAR: m, START_ANCHOR: T } = h;\n                const globstar = (e)=>\"(\".concat(R, \"(?:(?!\").concat(T).concat(e.dot ? x : E, \").)*?)\");\n                const L = r.dot ? \"\" : b;\n                const O = r.dot ? v : $;\n                let w = r.bash === true ? globstar(r) : m;\n                if (r.capture) {\n                    w = \"(\".concat(w, \")\");\n                }\n                if (typeof r.noext === \"boolean\") {\n                    r.noextglob = r.noext;\n                }\n                const N = {\n                    input: e,\n                    index: -1,\n                    start: 0,\n                    dot: r.dot === true,\n                    consumed: \"\",\n                    output: \"\",\n                    prefix: \"\",\n                    backtrack: false,\n                    negated: false,\n                    brackets: 0,\n                    braces: 0,\n                    parens: 0,\n                    quotes: 0,\n                    globstar: false,\n                    tokens: A\n                };\n                e = u.removePrefix(e, N);\n                p = e.length;\n                const k = [];\n                const I = [];\n                const M = [];\n                let P = f;\n                let B;\n                const eos = ()=>N.index === p - 1;\n                const G = N.peek = function() {\n                    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 1;\n                    return e[N.index + t];\n                };\n                const D = N.advance = ()=>e[++N.index];\n                const remaining = ()=>e.slice(N.index + 1);\n                const consume = function() {\n                    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : \"\", t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;\n                    N.consumed += e;\n                    N.index += t;\n                };\n                const append = (e)=>{\n                    N.output += e.output != null ? e.output : e.value;\n                    consume(e.value);\n                };\n                const negate = ()=>{\n                    let e = 1;\n                    while(G() === \"!\" && (G(2) !== \"(\" || G(3) === \"?\")){\n                        D();\n                        N.start++;\n                        e++;\n                    }\n                    if (e % 2 === 0) {\n                        return false;\n                    }\n                    N.negated = true;\n                    N.start++;\n                    return true;\n                };\n                const increment = (e)=>{\n                    N[e]++;\n                    M.push(e);\n                };\n                const decrement = (e)=>{\n                    N[e]--;\n                    M.pop();\n                };\n                const push = (e)=>{\n                    if (P.type === \"globstar\") {\n                        const t = N.braces > 0 && (e.type === \"comma\" || e.type === \"brace\");\n                        const r = e.extglob === true || k.length && (e.type === \"pipe\" || e.type === \"paren\");\n                        if (e.type !== \"slash\" && e.type !== \"paren\" && !t && !r) {\n                            N.output = N.output.slice(0, -P.output.length);\n                            P.type = \"star\";\n                            P.value = \"*\";\n                            P.output = w;\n                            N.output += P.output;\n                        }\n                    }\n                    if (k.length && e.type !== \"paren\" && !g[e.value]) {\n                        k[k.length - 1].inner += e.value;\n                    }\n                    if (e.value || e.output) append(e);\n                    if (P && P.type === \"text\" && e.type === \"text\") {\n                        P.value += e.value;\n                        P.output = (P.output || \"\") + e.value;\n                        return;\n                    }\n                    e.prev = P;\n                    A.push(e);\n                    P = e;\n                };\n                const extglobOpen = (e, t)=>{\n                    const n = {\n                        ...g[t],\n                        conditions: 1,\n                        inner: \"\"\n                    };\n                    n.prev = P;\n                    n.parens = N.parens;\n                    n.output = N.output;\n                    const u = (r.capture ? \"(\" : \"\") + n.open;\n                    increment(\"parens\");\n                    push({\n                        type: e,\n                        value: t,\n                        output: N.output ? \"\" : d\n                    });\n                    push({\n                        type: \"paren\",\n                        extglob: true,\n                        value: D(),\n                        output: u\n                    });\n                    k.push(n);\n                };\n                const extglobClose = (e)=>{\n                    let t = e.close + (r.capture ? \")\" : \"\");\n                    if (e.type === \"negate\") {\n                        let n = w;\n                        if (e.inner && e.inner.length > 1 && e.inner.includes(\"/\")) {\n                            n = globstar(r);\n                        }\n                        if (n !== w || eos() || /^\\)+$/.test(remaining())) {\n                            t = e.close = \")$))\".concat(n);\n                        }\n                        if (e.prev.type === \"bos\") {\n                            N.negatedExtglob = true;\n                        }\n                    }\n                    push({\n                        type: \"paren\",\n                        extglob: true,\n                        value: B,\n                        output: t\n                    });\n                    decrement(\"parens\");\n                };\n                if (r.fastpaths !== false && !/(^[*!]|[/()[\\]{}\"])/.test(e)) {\n                    let n = false;\n                    let s = e.replace(a, (e, t, r, u, s, o)=>{\n                        if (u === \"\\\\\") {\n                            n = true;\n                            return e;\n                        }\n                        if (u === \"?\") {\n                            if (t) {\n                                return t + u + (s ? v.repeat(s.length) : \"\");\n                            }\n                            if (o === 0) {\n                                return O + (s ? v.repeat(s.length) : \"\");\n                            }\n                            return v.repeat(r.length);\n                        }\n                        if (u === \".\") {\n                            return E.repeat(r.length);\n                        }\n                        if (u === \"*\") {\n                            if (t) {\n                                return t + u + (s ? w : \"\");\n                            }\n                            return w;\n                        }\n                        return t ? e : \"\\\\\".concat(e);\n                    });\n                    if (n === true) {\n                        if (r.unescape === true) {\n                            s = s.replace(/\\\\/g, \"\");\n                        } else {\n                            s = s.replace(/\\\\+/g, (e)=>e.length % 2 === 0 ? \"\\\\\\\\\" : e ? \"\\\\\" : \"\");\n                        }\n                    }\n                    if (s === e && r.contains === true) {\n                        N.output = e;\n                        return N;\n                    }\n                    N.output = u.wrapOutput(s, N, t);\n                    return N;\n                }\n                while(!eos()){\n                    B = D();\n                    if (B === \"\\x00\") {\n                        continue;\n                    }\n                    if (B === \"\\\\\") {\n                        const e = G();\n                        if (e === \"/\" && r.bash !== true) {\n                            continue;\n                        }\n                        if (e === \".\" || e === \";\") {\n                            continue;\n                        }\n                        if (!e) {\n                            B += \"\\\\\";\n                            push({\n                                type: \"text\",\n                                value: B\n                            });\n                            continue;\n                        }\n                        const t = /^\\\\+/.exec(remaining());\n                        let n = 0;\n                        if (t && t[0].length > 2) {\n                            n = t[0].length;\n                            N.index += n;\n                            if (n % 2 !== 0) {\n                                B += \"\\\\\";\n                            }\n                        }\n                        if (r.unescape === true) {\n                            B = D() || \"\";\n                        } else {\n                            B += D() || \"\";\n                        }\n                        if (N.brackets === 0) {\n                            push({\n                                type: \"text\",\n                                value: B\n                            });\n                            continue;\n                        }\n                    }\n                    if (N.brackets > 0 && (B !== \"]\" || P.value === \"[\" || P.value === \"[^\")) {\n                        if (r.posix !== false && B === \":\") {\n                            const e = P.value.slice(1);\n                            if (e.includes(\"[\")) {\n                                P.posix = true;\n                                if (e.includes(\":\")) {\n                                    const e = P.value.lastIndexOf(\"[\");\n                                    const t = P.value.slice(0, e);\n                                    const r = P.value.slice(e + 2);\n                                    const n = o[r];\n                                    if (n) {\n                                        P.value = t + n;\n                                        N.backtrack = true;\n                                        D();\n                                        if (!f.output && A.indexOf(P) === 1) {\n                                            f.output = d;\n                                        }\n                                        continue;\n                                    }\n                                }\n                            }\n                        }\n                        if (B === \"[\" && G() !== \":\" || B === \"-\" && G() === \"]\") {\n                            B = \"\\\\\".concat(B);\n                        }\n                        if (B === \"]\" && (P.value === \"[\" || P.value === \"[^\")) {\n                            B = \"\\\\\".concat(B);\n                        }\n                        if (r.posix === true && B === \"!\" && P.value === \"[\") {\n                            B = \"^\";\n                        }\n                        P.value += B;\n                        append({\n                            value: B\n                        });\n                        continue;\n                    }\n                    if (N.quotes === 1 && B !== '\"') {\n                        B = u.escapeRegex(B);\n                        P.value += B;\n                        append({\n                            value: B\n                        });\n                        continue;\n                    }\n                    if (B === '\"') {\n                        N.quotes = N.quotes === 1 ? 0 : 1;\n                        if (r.keepQuotes === true) {\n                            push({\n                                type: \"text\",\n                                value: B\n                            });\n                        }\n                        continue;\n                    }\n                    if (B === \"(\") {\n                        increment(\"parens\");\n                        push({\n                            type: \"paren\",\n                            value: B\n                        });\n                        continue;\n                    }\n                    if (B === \")\") {\n                        if (N.parens === 0 && r.strictBrackets === true) {\n                            throw new SyntaxError(syntaxError(\"opening\", \"(\"));\n                        }\n                        const e = k[k.length - 1];\n                        if (e && N.parens === e.parens + 1) {\n                            extglobClose(k.pop());\n                            continue;\n                        }\n                        push({\n                            type: \"paren\",\n                            value: B,\n                            output: N.parens ? \")\" : \"\\\\)\"\n                        });\n                        decrement(\"parens\");\n                        continue;\n                    }\n                    if (B === \"[\") {\n                        if (r.nobracket === true || !remaining().includes(\"]\")) {\n                            if (r.nobracket !== true && r.strictBrackets === true) {\n                                throw new SyntaxError(syntaxError(\"closing\", \"]\"));\n                            }\n                            B = \"\\\\\".concat(B);\n                        } else {\n                            increment(\"brackets\");\n                        }\n                        push({\n                            type: \"bracket\",\n                            value: B\n                        });\n                        continue;\n                    }\n                    if (B === \"]\") {\n                        if (r.nobracket === true || P && P.type === \"bracket\" && P.value.length === 1) {\n                            push({\n                                type: \"text\",\n                                value: B,\n                                output: \"\\\\\".concat(B)\n                            });\n                            continue;\n                        }\n                        if (N.brackets === 0) {\n                            if (r.strictBrackets === true) {\n                                throw new SyntaxError(syntaxError(\"opening\", \"[\"));\n                            }\n                            push({\n                                type: \"text\",\n                                value: B,\n                                output: \"\\\\\".concat(B)\n                            });\n                            continue;\n                        }\n                        decrement(\"brackets\");\n                        const e = P.value.slice(1);\n                        if (P.posix !== true && e[0] === \"^\" && !e.includes(\"/\")) {\n                            B = \"/\".concat(B);\n                        }\n                        P.value += B;\n                        append({\n                            value: B\n                        });\n                        if (r.literalBrackets === false || u.hasRegexChars(e)) {\n                            continue;\n                        }\n                        const t = u.escapeRegex(P.value);\n                        N.output = N.output.slice(0, -P.value.length);\n                        if (r.literalBrackets === true) {\n                            N.output += t;\n                            P.value = t;\n                            continue;\n                        }\n                        P.value = \"(\".concat(R).concat(t, \"|\").concat(P.value, \")\");\n                        N.output += P.value;\n                        continue;\n                    }\n                    if (B === \"{\" && r.nobrace !== true) {\n                        increment(\"braces\");\n                        const e = {\n                            type: \"brace\",\n                            value: B,\n                            output: \"(\",\n                            outputIndex: N.output.length,\n                            tokensIndex: N.tokens.length\n                        };\n                        I.push(e);\n                        push(e);\n                        continue;\n                    }\n                    if (B === \"}\") {\n                        const e = I[I.length - 1];\n                        if (r.nobrace === true || !e) {\n                            push({\n                                type: \"text\",\n                                value: B,\n                                output: B\n                            });\n                            continue;\n                        }\n                        let t = \")\";\n                        if (e.dots === true) {\n                            const e = A.slice();\n                            const n = [];\n                            for(let t = e.length - 1; t >= 0; t--){\n                                A.pop();\n                                if (e[t].type === \"brace\") {\n                                    break;\n                                }\n                                if (e[t].type !== \"dots\") {\n                                    n.unshift(e[t].value);\n                                }\n                            }\n                            t = expandRange(n, r);\n                            N.backtrack = true;\n                        }\n                        if (e.comma !== true && e.dots !== true) {\n                            const r = N.output.slice(0, e.outputIndex);\n                            const n = N.tokens.slice(e.tokensIndex);\n                            e.value = e.output = \"\\\\{\";\n                            B = t = \"\\\\}\";\n                            N.output = r;\n                            for (const e of n){\n                                N.output += e.output || e.value;\n                            }\n                        }\n                        push({\n                            type: \"brace\",\n                            value: B,\n                            output: t\n                        });\n                        decrement(\"braces\");\n                        I.pop();\n                        continue;\n                    }\n                    if (B === \"|\") {\n                        if (k.length > 0) {\n                            k[k.length - 1].conditions++;\n                        }\n                        push({\n                            type: \"text\",\n                            value: B\n                        });\n                        continue;\n                    }\n                    if (B === \",\") {\n                        let e = B;\n                        const t = I[I.length - 1];\n                        if (t && M[M.length - 1] === \"braces\") {\n                            t.comma = true;\n                            e = \"|\";\n                        }\n                        push({\n                            type: \"comma\",\n                            value: B,\n                            output: e\n                        });\n                        continue;\n                    }\n                    if (B === \"/\") {\n                        if (P.type === \"dot\" && N.index === N.start + 1) {\n                            N.start = N.index + 1;\n                            N.consumed = \"\";\n                            N.output = \"\";\n                            A.pop();\n                            P = f;\n                            continue;\n                        }\n                        push({\n                            type: \"slash\",\n                            value: B,\n                            output: y\n                        });\n                        continue;\n                    }\n                    if (B === \".\") {\n                        if (N.braces > 0 && P.type === \"dot\") {\n                            if (P.value === \".\") P.output = E;\n                            const e = I[I.length - 1];\n                            P.type = \"dots\";\n                            P.output += B;\n                            P.value += B;\n                            e.dots = true;\n                            continue;\n                        }\n                        if (N.braces + N.parens === 0 && P.type !== \"bos\" && P.type !== \"slash\") {\n                            push({\n                                type: \"text\",\n                                value: B,\n                                output: E\n                            });\n                            continue;\n                        }\n                        push({\n                            type: \"dot\",\n                            value: B,\n                            output: E\n                        });\n                        continue;\n                    }\n                    if (B === \"?\") {\n                        const e = P && P.value === \"(\";\n                        if (!e && r.noextglob !== true && G() === \"(\" && G(2) !== \"?\") {\n                            extglobOpen(\"qmark\", B);\n                            continue;\n                        }\n                        if (P && P.type === \"paren\") {\n                            const e = G();\n                            let t = B;\n                            if (e === \"<\" && !u.supportsLookbehinds()) {\n                                throw new Error(\"Node.js v10 or higher is required for regex lookbehinds\");\n                            }\n                            if (P.value === \"(\" && !/[!=<:]/.test(e) || e === \"<\" && !/<([!=]|\\w+>)/.test(remaining())) {\n                                t = \"\\\\\".concat(B);\n                            }\n                            push({\n                                type: \"text\",\n                                value: B,\n                                output: t\n                            });\n                            continue;\n                        }\n                        if (r.dot !== true && (P.type === \"slash\" || P.type === \"bos\")) {\n                            push({\n                                type: \"qmark\",\n                                value: B,\n                                output: $\n                            });\n                            continue;\n                        }\n                        push({\n                            type: \"qmark\",\n                            value: B,\n                            output: v\n                        });\n                        continue;\n                    }\n                    if (B === \"!\") {\n                        if (r.noextglob !== true && G() === \"(\") {\n                            if (G(2) !== \"?\" || !/[!=<:]/.test(G(3))) {\n                                extglobOpen(\"negate\", B);\n                                continue;\n                            }\n                        }\n                        if (r.nonegate !== true && N.index === 0) {\n                            negate();\n                            continue;\n                        }\n                    }\n                    if (B === \"+\") {\n                        if (r.noextglob !== true && G() === \"(\" && G(2) !== \"?\") {\n                            extglobOpen(\"plus\", B);\n                            continue;\n                        }\n                        if (P && P.value === \"(\" || r.regex === false) {\n                            push({\n                                type: \"plus\",\n                                value: B,\n                                output: C\n                            });\n                            continue;\n                        }\n                        if (P && (P.type === \"bracket\" || P.type === \"paren\" || P.type === \"brace\") || N.parens > 0) {\n                            push({\n                                type: \"plus\",\n                                value: B\n                            });\n                            continue;\n                        }\n                        push({\n                            type: \"plus\",\n                            value: C\n                        });\n                        continue;\n                    }\n                    if (B === \"@\") {\n                        if (r.noextglob !== true && G() === \"(\" && G(2) !== \"?\") {\n                            push({\n                                type: \"at\",\n                                extglob: true,\n                                value: B,\n                                output: \"\"\n                            });\n                            continue;\n                        }\n                        push({\n                            type: \"text\",\n                            value: B\n                        });\n                        continue;\n                    }\n                    if (B !== \"*\") {\n                        if (B === \"$\" || B === \"^\") {\n                            B = \"\\\\\".concat(B);\n                        }\n                        const e = i.exec(remaining());\n                        if (e) {\n                            B += e[0];\n                            N.index += e[0].length;\n                        }\n                        push({\n                            type: \"text\",\n                            value: B\n                        });\n                        continue;\n                    }\n                    if (P && (P.type === \"globstar\" || P.star === true)) {\n                        P.type = \"star\";\n                        P.star = true;\n                        P.value += B;\n                        P.output = w;\n                        N.backtrack = true;\n                        N.globstar = true;\n                        consume(B);\n                        continue;\n                    }\n                    let t = remaining();\n                    if (r.noextglob !== true && /^\\([^?]/.test(t)) {\n                        extglobOpen(\"star\", B);\n                        continue;\n                    }\n                    if (P.type === \"star\") {\n                        if (r.noglobstar === true) {\n                            consume(B);\n                            continue;\n                        }\n                        const n = P.prev;\n                        const u = n.prev;\n                        const s = n.type === \"slash\" || n.type === \"bos\";\n                        const o = u && (u.type === \"star\" || u.type === \"globstar\");\n                        if (r.bash === true && (!s || t[0] && t[0] !== \"/\")) {\n                            push({\n                                type: \"star\",\n                                value: B,\n                                output: \"\"\n                            });\n                            continue;\n                        }\n                        const i = N.braces > 0 && (n.type === \"comma\" || n.type === \"brace\");\n                        const a = k.length && (n.type === \"pipe\" || n.type === \"paren\");\n                        if (!s && n.type !== \"paren\" && !i && !a) {\n                            push({\n                                type: \"star\",\n                                value: B,\n                                output: \"\"\n                            });\n                            continue;\n                        }\n                        while(t.slice(0, 3) === \"/**\"){\n                            const r = e[N.index + 4];\n                            if (r && r !== \"/\") {\n                                break;\n                            }\n                            t = t.slice(3);\n                            consume(\"/**\", 3);\n                        }\n                        if (n.type === \"bos\" && eos()) {\n                            P.type = \"globstar\";\n                            P.value += B;\n                            P.output = globstar(r);\n                            N.output = P.output;\n                            N.globstar = true;\n                            consume(B);\n                            continue;\n                        }\n                        if (n.type === \"slash\" && n.prev.type !== \"bos\" && !o && eos()) {\n                            N.output = N.output.slice(0, -(n.output + P.output).length);\n                            n.output = \"(?:\".concat(n.output);\n                            P.type = \"globstar\";\n                            P.output = globstar(r) + (r.strictSlashes ? \")\" : \"|$)\");\n                            P.value += B;\n                            N.globstar = true;\n                            N.output += n.output + P.output;\n                            consume(B);\n                            continue;\n                        }\n                        if (n.type === \"slash\" && n.prev.type !== \"bos\" && t[0] === \"/\") {\n                            const e = t[1] !== void 0 ? \"|$\" : \"\";\n                            N.output = N.output.slice(0, -(n.output + P.output).length);\n                            n.output = \"(?:\".concat(n.output);\n                            P.type = \"globstar\";\n                            P.output = \"\".concat(globstar(r)).concat(y, \"|\").concat(y).concat(e, \")\");\n                            P.value += B;\n                            N.output += n.output + P.output;\n                            N.globstar = true;\n                            consume(B + D());\n                            push({\n                                type: \"slash\",\n                                value: \"/\",\n                                output: \"\"\n                            });\n                            continue;\n                        }\n                        if (n.type === \"bos\" && t[0] === \"/\") {\n                            P.type = \"globstar\";\n                            P.value += B;\n                            P.output = \"(?:^|\".concat(y, \"|\").concat(globstar(r)).concat(y, \")\");\n                            N.output = P.output;\n                            N.globstar = true;\n                            consume(B + D());\n                            push({\n                                type: \"slash\",\n                                value: \"/\",\n                                output: \"\"\n                            });\n                            continue;\n                        }\n                        N.output = N.output.slice(0, -P.output.length);\n                        P.type = \"globstar\";\n                        P.output = globstar(r);\n                        P.value += B;\n                        N.output += P.output;\n                        N.globstar = true;\n                        consume(B);\n                        continue;\n                    }\n                    const n = {\n                        type: \"star\",\n                        value: B,\n                        output: w\n                    };\n                    if (r.bash === true) {\n                        n.output = \".*?\";\n                        if (P.type === \"bos\" || P.type === \"slash\") {\n                            n.output = L + n.output;\n                        }\n                        push(n);\n                        continue;\n                    }\n                    if (P && (P.type === \"bracket\" || P.type === \"paren\") && r.regex === true) {\n                        n.output = B;\n                        push(n);\n                        continue;\n                    }\n                    if (N.index === N.start || P.type === \"slash\" || P.type === \"dot\") {\n                        if (P.type === \"dot\") {\n                            N.output += S;\n                            P.output += S;\n                        } else if (r.dot === true) {\n                            N.output += H;\n                            P.output += H;\n                        } else {\n                            N.output += L;\n                            P.output += L;\n                        }\n                        if (G() !== \"*\") {\n                            N.output += d;\n                            P.output += d;\n                        }\n                    }\n                    push(n);\n                }\n                while(N.brackets > 0){\n                    if (r.strictBrackets === true) throw new SyntaxError(syntaxError(\"closing\", \"]\"));\n                    N.output = u.escapeLast(N.output, \"[\");\n                    decrement(\"brackets\");\n                }\n                while(N.parens > 0){\n                    if (r.strictBrackets === true) throw new SyntaxError(syntaxError(\"closing\", \")\"));\n                    N.output = u.escapeLast(N.output, \"(\");\n                    decrement(\"parens\");\n                }\n                while(N.braces > 0){\n                    if (r.strictBrackets === true) throw new SyntaxError(syntaxError(\"closing\", \"}\"));\n                    N.output = u.escapeLast(N.output, \"{\");\n                    decrement(\"braces\");\n                }\n                if (r.strictSlashes !== true && (P.type === \"star\" || P.type === \"bracket\")) {\n                    push({\n                        type: \"maybe_slash\",\n                        value: \"\",\n                        output: \"\".concat(y, \"?\")\n                    });\n                }\n                if (N.backtrack === true) {\n                    N.output = \"\";\n                    for (const e of N.tokens){\n                        N.output += e.output != null ? e.output : e.value;\n                        if (e.suffix) {\n                            N.output += e.suffix;\n                        }\n                    }\n                }\n                return N;\n            };\n            parse.fastpaths = (e, t)=>{\n                const r = {\n                    ...t\n                };\n                const o = typeof r.maxLength === \"number\" ? Math.min(s, r.maxLength) : s;\n                const i = e.length;\n                if (i > o) {\n                    throw new SyntaxError(\"Input length: \".concat(i, \", exceeds maximum allowed length: \").concat(o));\n                }\n                e = l[e] || e;\n                const a = u.isWindows(t);\n                const { DOT_LITERAL: c, SLASH_LITERAL: p, ONE_CHAR: f, DOTS_SLASH: A, NO_DOT: R, NO_DOTS: _, NO_DOTS_SLASH: h, STAR: g, START_ANCHOR: E } = n.globChars(a);\n                const C = r.dot ? _ : R;\n                const y = r.dot ? h : R;\n                const d = r.capture ? \"\" : \"?:\";\n                const x = {\n                    negated: false,\n                    prefix: \"\"\n                };\n                let b = r.bash === true ? \".*?\" : g;\n                if (r.capture) {\n                    b = \"(\".concat(b, \")\");\n                }\n                const globstar = (e)=>{\n                    if (e.noglobstar === true) return b;\n                    return \"(\".concat(d, \"(?:(?!\").concat(E).concat(e.dot ? A : c, \").)*?)\");\n                };\n                const create = (e)=>{\n                    switch(e){\n                        case \"*\":\n                            return \"\".concat(C).concat(f).concat(b);\n                        case \".*\":\n                            return \"\".concat(c).concat(f).concat(b);\n                        case \"*.*\":\n                            return \"\".concat(C).concat(b).concat(c).concat(f).concat(b);\n                        case \"*/*\":\n                            return \"\".concat(C).concat(b).concat(p).concat(f).concat(y).concat(b);\n                        case \"**\":\n                            return C + globstar(r);\n                        case \"**/*\":\n                            return \"(?:\".concat(C).concat(globstar(r)).concat(p, \")?\").concat(y).concat(f).concat(b);\n                        case \"**/*.*\":\n                            return \"(?:\".concat(C).concat(globstar(r)).concat(p, \")?\").concat(y).concat(b).concat(c).concat(f).concat(b);\n                        case \"**/.*\":\n                            return \"(?:\".concat(C).concat(globstar(r)).concat(p, \")?\").concat(c).concat(f).concat(b);\n                        default:\n                            {\n                                const t = /^(.*?)\\.(\\w+)$/.exec(e);\n                                if (!t) return;\n                                const r = create(t[1]);\n                                if (!r) return;\n                                return r + c + t[2];\n                            }\n                    }\n                };\n                const S = u.removePrefix(e, x);\n                let H = create(S);\n                if (H && r.strictSlashes !== true) {\n                    H += \"\".concat(p, \"?\");\n                }\n                return H;\n            };\n            e.exports = parse;\n        },\n        683: (e, t, r)=>{\n            const n = r(17);\n            const u = r(700);\n            const s = r(754);\n            const o = r(513);\n            const i = r(356);\n            const isObject = (e)=>e && typeof e === \"object\" && !Array.isArray(e);\n            const picomatch = function(e, t) {\n                let r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;\n                if (Array.isArray(e)) {\n                    const n = e.map((e)=>picomatch(e, t, r));\n                    const arrayMatcher = (e)=>{\n                        for (const t of n){\n                            const r = t(e);\n                            if (r) return r;\n                        }\n                        return false;\n                    };\n                    return arrayMatcher;\n                }\n                const n = isObject(e) && e.tokens && e.input;\n                if (e === \"\" || typeof e !== \"string\" && !n) {\n                    throw new TypeError(\"Expected pattern to be a non-empty string\");\n                }\n                const u = t || {};\n                const s = o.isWindows(t);\n                const i = n ? picomatch.compileRe(e, t) : picomatch.makeRe(e, t, false, true);\n                const a = i.state;\n                delete i.state;\n                let isIgnored = ()=>false;\n                if (u.ignore) {\n                    const e = {\n                        ...t,\n                        ignore: null,\n                        onMatch: null,\n                        onResult: null\n                    };\n                    isIgnored = picomatch(u.ignore, e, r);\n                }\n                const matcher = function(r) {\n                    let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;\n                    const { isMatch: o, match: l, output: c } = picomatch.test(r, i, t, {\n                        glob: e,\n                        posix: s\n                    });\n                    const p = {\n                        glob: e,\n                        state: a,\n                        regex: i,\n                        posix: s,\n                        input: r,\n                        output: c,\n                        match: l,\n                        isMatch: o\n                    };\n                    if (typeof u.onResult === \"function\") {\n                        u.onResult(p);\n                    }\n                    if (o === false) {\n                        p.isMatch = false;\n                        return n ? p : false;\n                    }\n                    if (isIgnored(r)) {\n                        if (typeof u.onIgnore === \"function\") {\n                            u.onIgnore(p);\n                        }\n                        p.isMatch = false;\n                        return n ? p : false;\n                    }\n                    if (typeof u.onMatch === \"function\") {\n                        u.onMatch(p);\n                    }\n                    return n ? p : true;\n                };\n                if (r) {\n                    matcher.state = a;\n                }\n                return matcher;\n            };\n            picomatch.test = function(e, t, r) {\n                let { glob: n, posix: u } = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};\n                if (typeof e !== \"string\") {\n                    throw new TypeError(\"Expected input to be a string\");\n                }\n                if (e === \"\") {\n                    return {\n                        isMatch: false,\n                        output: \"\"\n                    };\n                }\n                const s = r || {};\n                const i = s.format || (u ? o.toPosixSlashes : null);\n                let a = e === n;\n                let l = a && i ? i(e) : e;\n                if (a === false) {\n                    l = i ? i(e) : e;\n                    a = l === n;\n                }\n                if (a === false || s.capture === true) {\n                    if (s.matchBase === true || s.basename === true) {\n                        a = picomatch.matchBase(e, t, r, u);\n                    } else {\n                        a = t.exec(l);\n                    }\n                }\n                return {\n                    isMatch: Boolean(a),\n                    match: a,\n                    output: l\n                };\n            };\n            picomatch.matchBase = function(e, t, r) {\n                let u = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : o.isWindows(r);\n                const s = t instanceof RegExp ? t : picomatch.makeRe(t, r);\n                return s.test(n.basename(e));\n            };\n            picomatch.isMatch = (e, t, r)=>picomatch(t, r)(e);\n            picomatch.parse = (e, t)=>{\n                if (Array.isArray(e)) return e.map((e)=>picomatch.parse(e, t));\n                return s(e, {\n                    ...t,\n                    fastpaths: false\n                });\n            };\n            picomatch.scan = (e, t)=>u(e, t);\n            picomatch.compileRe = function(e, t) {\n                let r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false, n = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;\n                if (r === true) {\n                    return e.output;\n                }\n                const u = t || {};\n                const s = u.contains ? \"\" : \"^\";\n                const o = u.contains ? \"\" : \"$\";\n                let i = \"\".concat(s, \"(?:\").concat(e.output, \")\").concat(o);\n                if (e && e.negated === true) {\n                    i = \"^(?!\".concat(i, \").*$\");\n                }\n                const a = picomatch.toRegex(i, t);\n                if (n === true) {\n                    a.state = e;\n                }\n                return a;\n            };\n            picomatch.makeRe = function(e, t) {\n                let r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false, n = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;\n                if (!e || typeof e !== \"string\") {\n                    throw new TypeError(\"Expected a non-empty string\");\n                }\n                const u = t || {};\n                let o = {\n                    negated: false,\n                    fastpaths: true\n                };\n                let i = \"\";\n                let a;\n                if (e.startsWith(\"./\")) {\n                    e = e.slice(2);\n                    i = o.prefix = \"./\";\n                }\n                if (u.fastpaths !== false && (e[0] === \".\" || e[0] === \"*\")) {\n                    a = s.fastpaths(e, t);\n                }\n                if (a === undefined) {\n                    o = s(e, t);\n                    o.prefix = i + (o.prefix || \"\");\n                } else {\n                    o.output = a;\n                }\n                return picomatch.compileRe(o, t, r, n);\n            };\n            picomatch.toRegex = (e, t)=>{\n                try {\n                    const r = t || {};\n                    return new RegExp(e, r.flags || (r.nocase ? \"i\" : \"\"));\n                } catch (e) {\n                    if (t && t.debug === true) throw e;\n                    return /$^/;\n                }\n            };\n            picomatch.constants = i;\n            e.exports = picomatch;\n        },\n        700: (e, t, r)=>{\n            const n = r(513);\n            const { CHAR_ASTERISK: u, CHAR_AT: s, CHAR_BACKWARD_SLASH: o, CHAR_COMMA: i, CHAR_DOT: a, CHAR_EXCLAMATION_MARK: l, CHAR_FORWARD_SLASH: c, CHAR_LEFT_CURLY_BRACE: p, CHAR_LEFT_PARENTHESES: f, CHAR_LEFT_SQUARE_BRACKET: A, CHAR_PLUS: R, CHAR_QUESTION_MARK: _, CHAR_RIGHT_CURLY_BRACE: h, CHAR_RIGHT_PARENTHESES: g, CHAR_RIGHT_SQUARE_BRACKET: E } = r(356);\n            const isPathSeparator = (e)=>e === c || e === o;\n            const depth = (e)=>{\n                if (e.isPrefix !== true) {\n                    e.depth = e.isGlobstar ? Infinity : 1;\n                }\n            };\n            const scan = (e, t)=>{\n                const r = t || {};\n                const C = e.length - 1;\n                const y = r.parts === true || r.scanToEnd === true;\n                const d = [];\n                const x = [];\n                const b = [];\n                let S = e;\n                let H = -1;\n                let v = 0;\n                let $ = 0;\n                let m = false;\n                let T = false;\n                let L = false;\n                let O = false;\n                let w = false;\n                let N = false;\n                let k = false;\n                let I = false;\n                let M = false;\n                let P = 0;\n                let B;\n                let G;\n                let D = {\n                    value: \"\",\n                    depth: 0,\n                    isGlob: false\n                };\n                const eos = ()=>H >= C;\n                const peek = ()=>S.charCodeAt(H + 1);\n                const advance = ()=>{\n                    B = G;\n                    return S.charCodeAt(++H);\n                };\n                while(H < C){\n                    G = advance();\n                    let e;\n                    if (G === o) {\n                        k = D.backslashes = true;\n                        G = advance();\n                        if (G === p) {\n                            N = true;\n                        }\n                        continue;\n                    }\n                    if (N === true || G === p) {\n                        P++;\n                        while(eos() !== true && (G = advance())){\n                            if (G === o) {\n                                k = D.backslashes = true;\n                                advance();\n                                continue;\n                            }\n                            if (G === p) {\n                                P++;\n                                continue;\n                            }\n                            if (N !== true && G === a && (G = advance()) === a) {\n                                m = D.isBrace = true;\n                                L = D.isGlob = true;\n                                M = true;\n                                if (y === true) {\n                                    continue;\n                                }\n                                break;\n                            }\n                            if (N !== true && G === i) {\n                                m = D.isBrace = true;\n                                L = D.isGlob = true;\n                                M = true;\n                                if (y === true) {\n                                    continue;\n                                }\n                                break;\n                            }\n                            if (G === h) {\n                                P--;\n                                if (P === 0) {\n                                    N = false;\n                                    m = D.isBrace = true;\n                                    M = true;\n                                    break;\n                                }\n                            }\n                        }\n                        if (y === true) {\n                            continue;\n                        }\n                        break;\n                    }\n                    if (G === c) {\n                        d.push(H);\n                        x.push(D);\n                        D = {\n                            value: \"\",\n                            depth: 0,\n                            isGlob: false\n                        };\n                        if (M === true) continue;\n                        if (B === a && H === v + 1) {\n                            v += 2;\n                            continue;\n                        }\n                        $ = H + 1;\n                        continue;\n                    }\n                    if (r.noext !== true) {\n                        const e = G === R || G === s || G === u || G === _ || G === l;\n                        if (e === true && peek() === f) {\n                            L = D.isGlob = true;\n                            O = D.isExtglob = true;\n                            M = true;\n                            if (y === true) {\n                                while(eos() !== true && (G = advance())){\n                                    if (G === o) {\n                                        k = D.backslashes = true;\n                                        G = advance();\n                                        continue;\n                                    }\n                                    if (G === g) {\n                                        L = D.isGlob = true;\n                                        M = true;\n                                        break;\n                                    }\n                                }\n                                continue;\n                            }\n                            break;\n                        }\n                    }\n                    if (G === u) {\n                        if (B === u) w = D.isGlobstar = true;\n                        L = D.isGlob = true;\n                        M = true;\n                        if (y === true) {\n                            continue;\n                        }\n                        break;\n                    }\n                    if (G === _) {\n                        L = D.isGlob = true;\n                        M = true;\n                        if (y === true) {\n                            continue;\n                        }\n                        break;\n                    }\n                    if (G === A) {\n                        while(eos() !== true && (e = advance())){\n                            if (e === o) {\n                                k = D.backslashes = true;\n                                advance();\n                                continue;\n                            }\n                            if (e === E) {\n                                T = D.isBracket = true;\n                                L = D.isGlob = true;\n                                M = true;\n                                break;\n                            }\n                        }\n                        if (y === true) {\n                            continue;\n                        }\n                        break;\n                    }\n                    if (r.nonegate !== true && G === l && H === v) {\n                        I = D.negated = true;\n                        v++;\n                        continue;\n                    }\n                    if (r.noparen !== true && G === f) {\n                        L = D.isGlob = true;\n                        if (y === true) {\n                            while(eos() !== true && (G = advance())){\n                                if (G === f) {\n                                    k = D.backslashes = true;\n                                    G = advance();\n                                    continue;\n                                }\n                                if (G === g) {\n                                    M = true;\n                                    break;\n                                }\n                            }\n                            continue;\n                        }\n                        break;\n                    }\n                    if (L === true) {\n                        M = true;\n                        if (y === true) {\n                            continue;\n                        }\n                        break;\n                    }\n                }\n                if (r.noext === true) {\n                    O = false;\n                    L = false;\n                }\n                let U = S;\n                let K = \"\";\n                let F = \"\";\n                if (v > 0) {\n                    K = S.slice(0, v);\n                    S = S.slice(v);\n                    $ -= v;\n                }\n                if (U && L === true && $ > 0) {\n                    U = S.slice(0, $);\n                    F = S.slice($);\n                } else if (L === true) {\n                    U = \"\";\n                    F = S;\n                } else {\n                    U = S;\n                }\n                if (U && U !== \"\" && U !== \"/\" && U !== S) {\n                    if (isPathSeparator(U.charCodeAt(U.length - 1))) {\n                        U = U.slice(0, -1);\n                    }\n                }\n                if (r.unescape === true) {\n                    if (F) F = n.removeBackslashes(F);\n                    if (U && k === true) {\n                        U = n.removeBackslashes(U);\n                    }\n                }\n                const Q = {\n                    prefix: K,\n                    input: e,\n                    start: v,\n                    base: U,\n                    glob: F,\n                    isBrace: m,\n                    isBracket: T,\n                    isGlob: L,\n                    isExtglob: O,\n                    isGlobstar: w,\n                    negated: I\n                };\n                if (r.tokens === true) {\n                    Q.maxDepth = 0;\n                    if (!isPathSeparator(G)) {\n                        x.push(D);\n                    }\n                    Q.tokens = x;\n                }\n                if (r.parts === true || r.tokens === true) {\n                    let t;\n                    for(let n = 0; n < d.length; n++){\n                        const u = t ? t + 1 : v;\n                        const s = d[n];\n                        const o = e.slice(u, s);\n                        if (r.tokens) {\n                            if (n === 0 && v !== 0) {\n                                x[n].isPrefix = true;\n                                x[n].value = K;\n                            } else {\n                                x[n].value = o;\n                            }\n                            depth(x[n]);\n                            Q.maxDepth += x[n].depth;\n                        }\n                        if (n !== 0 || o !== \"\") {\n                            b.push(o);\n                        }\n                        t = s;\n                    }\n                    if (t && t + 1 < e.length) {\n                        const n = e.slice(t + 1);\n                        b.push(n);\n                        if (r.tokens) {\n                            x[x.length - 1].value = n;\n                            depth(x[x.length - 1]);\n                            Q.maxDepth += x[x.length - 1].depth;\n                        }\n                    }\n                    Q.slashes = d;\n                    Q.parts = b;\n                }\n                return Q;\n            };\n            e.exports = scan;\n        },\n        513: (e, t, r)=>{\n            const n = r(17);\n            const u = process.platform === \"win32\";\n            const { REGEX_BACKSLASH: s, REGEX_REMOVE_BACKSLASH: o, REGEX_SPECIAL_CHARS: i, REGEX_SPECIAL_CHARS_GLOBAL: a } = r(356);\n            t.isObject = (e)=>e !== null && typeof e === \"object\" && !Array.isArray(e);\n            t.hasRegexChars = (e)=>i.test(e);\n            t.isRegexChar = (e)=>e.length === 1 && t.hasRegexChars(e);\n            t.escapeRegex = (e)=>e.replace(a, \"\\\\$1\");\n            t.toPosixSlashes = (e)=>e.replace(s, \"/\");\n            t.removeBackslashes = (e)=>e.replace(o, (e)=>e === \"\\\\\" ? \"\" : e);\n            t.supportsLookbehinds = ()=>{\n                const e = process.version.slice(1).split(\".\").map(Number);\n                if (e.length === 3 && e[0] >= 9 || e[0] === 8 && e[1] >= 10) {\n                    return true;\n                }\n                return false;\n            };\n            t.isWindows = (e)=>{\n                if (e && typeof e.windows === \"boolean\") {\n                    return e.windows;\n                }\n                return u === true || n.sep === \"\\\\\";\n            };\n            t.escapeLast = (e, r, n)=>{\n                const u = e.lastIndexOf(r, n);\n                if (u === -1) return e;\n                if (e[u - 1] === \"\\\\\") return t.escapeLast(e, r, u - 1);\n                return \"\".concat(e.slice(0, u), \"\\\\\").concat(e.slice(u));\n            };\n            t.removePrefix = function(e) {\n                let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n                let r = e;\n                if (r.startsWith(\"./\")) {\n                    r = r.slice(2);\n                    t.prefix = \"./\";\n                }\n                return r;\n            };\n            t.wrapOutput = function(e) {\n                let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n                const n = r.contains ? \"\" : \"^\";\n                const u = r.contains ? \"\" : \"$\";\n                let s = \"\".concat(n, \"(?:\").concat(e, \")\").concat(u);\n                if (t.negated === true) {\n                    s = \"(?:^(?!\".concat(s, \").*$)\");\n                }\n                return s;\n            };\n        },\n        492: (e, t, r)=>{\n            /*!\n * to-regex-range <https://github.com/micromatch/to-regex-range>\n *\n * Copyright (c) 2015-present, Jon Schlinkert.\n * Released under the MIT License.\n */ const n = r(357);\n            const toRegexRange = (e, t, r)=>{\n                if (n(e) === false) {\n                    throw new TypeError(\"toRegexRange: expected the first argument to be a number\");\n                }\n                if (t === void 0 || e === t) {\n                    return String(e);\n                }\n                if (n(t) === false) {\n                    throw new TypeError(\"toRegexRange: expected the second argument to be a number.\");\n                }\n                let u = {\n                    relaxZeros: true,\n                    ...r\n                };\n                if (typeof u.strictZeros === \"boolean\") {\n                    u.relaxZeros = u.strictZeros === false;\n                }\n                let s = String(u.relaxZeros);\n                let o = String(u.shorthand);\n                let i = String(u.capture);\n                let a = String(u.wrap);\n                let l = e + \":\" + t + \"=\" + s + o + i + a;\n                if (toRegexRange.cache.hasOwnProperty(l)) {\n                    return toRegexRange.cache[l].result;\n                }\n                let c = Math.min(e, t);\n                let p = Math.max(e, t);\n                if (Math.abs(c - p) === 1) {\n                    let r = e + \"|\" + t;\n                    if (u.capture) {\n                        return \"(\".concat(r, \")\");\n                    }\n                    if (u.wrap === false) {\n                        return r;\n                    }\n                    return \"(?:\".concat(r, \")\");\n                }\n                let f = hasPadding(e) || hasPadding(t);\n                let A = {\n                    min: e,\n                    max: t,\n                    a: c,\n                    b: p\n                };\n                let R = [];\n                let _ = [];\n                if (f) {\n                    A.isPadded = f;\n                    A.maxLen = String(A.max).length;\n                }\n                if (c < 0) {\n                    let e = p < 0 ? Math.abs(p) : 1;\n                    _ = splitToPatterns(e, Math.abs(c), A, u);\n                    c = A.a = 0;\n                }\n                if (p >= 0) {\n                    R = splitToPatterns(c, p, A, u);\n                }\n                A.negatives = _;\n                A.positives = R;\n                A.result = collatePatterns(_, R, u);\n                if (u.capture === true) {\n                    A.result = \"(\".concat(A.result, \")\");\n                } else if (u.wrap !== false && R.length + _.length > 1) {\n                    A.result = \"(?:\".concat(A.result, \")\");\n                }\n                toRegexRange.cache[l] = A;\n                return A.result;\n            };\n            function collatePatterns(e, t, r) {\n                let n = filterPatterns(e, t, \"-\", false, r) || [];\n                let u = filterPatterns(t, e, \"\", false, r) || [];\n                let s = filterPatterns(e, t, \"-?\", true, r) || [];\n                let o = n.concat(s).concat(u);\n                return o.join(\"|\");\n            }\n            function splitToRanges(e, t) {\n                let r = 1;\n                let n = 1;\n                let u = countNines(e, r);\n                let s = new Set([\n                    t\n                ]);\n                while(e <= u && u <= t){\n                    s.add(u);\n                    r += 1;\n                    u = countNines(e, r);\n                }\n                u = countZeros(t + 1, n) - 1;\n                while(e < u && u <= t){\n                    s.add(u);\n                    n += 1;\n                    u = countZeros(t + 1, n) - 1;\n                }\n                s = [\n                    ...s\n                ];\n                s.sort(compare);\n                return s;\n            }\n            function rangeToPattern(e, t, r) {\n                if (e === t) {\n                    return {\n                        pattern: e,\n                        count: [],\n                        digits: 0\n                    };\n                }\n                let n = zip(e, t);\n                let u = n.length;\n                let s = \"\";\n                let o = 0;\n                for(let e = 0; e < u; e++){\n                    let [t, u] = n[e];\n                    if (t === u) {\n                        s += t;\n                    } else if (t !== \"0\" || u !== \"9\") {\n                        s += toCharacterClass(t, u, r);\n                    } else {\n                        o++;\n                    }\n                }\n                if (o) {\n                    s += r.shorthand === true ? \"\\\\d\" : \"[0-9]\";\n                }\n                return {\n                    pattern: s,\n                    count: [\n                        o\n                    ],\n                    digits: u\n                };\n            }\n            function splitToPatterns(e, t, r, n) {\n                let u = splitToRanges(e, t);\n                let s = [];\n                let o = e;\n                let i;\n                for(let e = 0; e < u.length; e++){\n                    let t = u[e];\n                    let a = rangeToPattern(String(o), String(t), n);\n                    let l = \"\";\n                    if (!r.isPadded && i && i.pattern === a.pattern) {\n                        if (i.count.length > 1) {\n                            i.count.pop();\n                        }\n                        i.count.push(a.count[0]);\n                        i.string = i.pattern + toQuantifier(i.count);\n                        o = t + 1;\n                        continue;\n                    }\n                    if (r.isPadded) {\n                        l = padZeros(t, r, n);\n                    }\n                    a.string = l + a.pattern + toQuantifier(a.count);\n                    s.push(a);\n                    o = t + 1;\n                    i = a;\n                }\n                return s;\n            }\n            function filterPatterns(e, t, r, n, u) {\n                let s = [];\n                for (let u of e){\n                    let { string: e } = u;\n                    if (!n && !contains(t, \"string\", e)) {\n                        s.push(r + e);\n                    }\n                    if (n && contains(t, \"string\", e)) {\n                        s.push(r + e);\n                    }\n                }\n                return s;\n            }\n            function zip(e, t) {\n                let r = [];\n                for(let n = 0; n < e.length; n++)r.push([\n                    e[n],\n                    t[n]\n                ]);\n                return r;\n            }\n            function compare(e, t) {\n                return e > t ? 1 : t > e ? -1 : 0;\n            }\n            function contains(e, t, r) {\n                return e.some((e)=>e[t] === r);\n            }\n            function countNines(e, t) {\n                return Number(String(e).slice(0, -t) + \"9\".repeat(t));\n            }\n            function countZeros(e, t) {\n                return e - e % Math.pow(10, t);\n            }\n            function toQuantifier(e) {\n                let [t = 0, r = \"\"] = e;\n                if (r || t > 1) {\n                    return \"{\".concat(t + (r ? \",\" + r : \"\"), \"}\");\n                }\n                return \"\";\n            }\n            function toCharacterClass(e, t, r) {\n                return \"[\".concat(e).concat(t - e === 1 ? \"\" : \"-\").concat(t, \"]\");\n            }\n            function hasPadding(e) {\n                return /^-?(0+)\\d/.test(e);\n            }\n            function padZeros(e, t, r) {\n                if (!t.isPadded) {\n                    return e;\n                }\n                let n = Math.abs(t.maxLen - String(e).length);\n                let u = r.relaxZeros !== false;\n                switch(n){\n                    case 0:\n                        return \"\";\n                    case 1:\n                        return u ? \"0?\" : \"0\";\n                    case 2:\n                        return u ? \"0{0,2}\" : \"00\";\n                    default:\n                        {\n                            return u ? \"0{0,\".concat(n, \"}\") : \"0{\".concat(n, \"}\");\n                        }\n                }\n            }\n            toRegexRange.cache = {};\n            toRegexRange.clearCache = ()=>toRegexRange.cache = {};\n            e.exports = toRegexRange;\n        },\n        17: (e)=>{\n            e.exports = __webpack_require__(/*! path */ \"(app-pages-browser)/./node_modules/next/dist/compiled/path-browserify/index.js\");\n        },\n        837: (e)=>{\n            e.exports = __webpack_require__(/*! util */ \"(app-pages-browser)/./node_modules/next/dist/compiled/util/util.js\");\n        }\n    };\n    var t = {};\n    function __nccwpck_require__(r) {\n        var n = t[r];\n        if (n !== undefined) {\n            return n.exports;\n        }\n        var u = t[r] = {\n            exports: {}\n        };\n        var s = true;\n        try {\n            e[r](u, u.exports, __nccwpck_require__);\n            s = false;\n        } finally{\n            if (s) delete t[r];\n        }\n        return u.exports;\n    }\n    if (typeof __nccwpck_require__ !== \"undefined\") __nccwpck_require__.ab = __dirname + \"/\";\n    var r = __nccwpck_require__(971);\n    module.exports = r;\n})();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvbWljcm9tYXRjaC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7QUFBQztJQUFLO0lBQWEsSUFBSUEsSUFBRTtRQUFDLEtBQUksQ0FBQ0EsR0FBRUMsR0FBRUM7WUFBSyxNQUFNQyxJQUFFRCxFQUFFO1lBQUssTUFBTUUsSUFBRUYsRUFBRTtZQUFLLE1BQU1HLElBQUVILEVBQUU7WUFBSSxNQUFNSSxJQUFFSixFQUFFO1lBQUssTUFBTUssU0FBTyxTQUFDUDtvQkFBRUMscUVBQUUsQ0FBQztnQkFBSyxJQUFJQyxJQUFFLEVBQUU7Z0JBQUMsSUFBR00sTUFBTUMsT0FBTyxDQUFDVCxJQUFHO29CQUFDLEtBQUksSUFBSUcsS0FBS0gsRUFBRTt3QkFBQyxJQUFJQSxJQUFFTyxPQUFPRyxNQUFNLENBQUNQLEdBQUVGO3dCQUFHLElBQUdPLE1BQU1DLE9BQU8sQ0FBQ1QsSUFBRzs0QkFBQ0UsRUFBRVMsSUFBSSxJQUFJWDt3QkFBRSxPQUFLOzRCQUFDRSxFQUFFUyxJQUFJLENBQUNYO3dCQUFFO29CQUFDO2dCQUFDLE9BQUs7b0JBQUNFLElBQUUsRUFBRSxDQUFDVSxNQUFNLENBQUNMLE9BQU9HLE1BQU0sQ0FBQ1YsR0FBRUM7Z0JBQUc7Z0JBQUMsSUFBR0EsS0FBR0EsRUFBRVksTUFBTSxLQUFHLFFBQU1aLEVBQUVhLE9BQU8sS0FBRyxNQUFLO29CQUFDWixJQUFFOzJCQUFJLElBQUlhLElBQUliO3FCQUFHO2dCQUFBO2dCQUFDLE9BQU9BO1lBQUM7WUFBRUssT0FBT1MsS0FBSyxHQUFDLFNBQUNoQjtvQkFBRUMscUVBQUUsQ0FBQzt1QkFBSUssRUFBRU4sR0FBRUM7O1lBQUdNLE9BQU9VLFNBQVMsR0FBQyxTQUFDakI7b0JBQUVDLHFFQUFFLENBQUM7Z0JBQUssSUFBRyxPQUFPRCxNQUFJLFVBQVM7b0JBQUMsT0FBT0csRUFBRUksT0FBT1MsS0FBSyxDQUFDaEIsR0FBRUMs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QUFFO2dCQUFDO1lBQUM7WUFBQ3lXLGFBQWFJLEtBQUssR0FBQyxDQUFDO1lBQUVKLGFBQWEyQixVQUFVLEdBQUMsSUFBSTNCLGFBQWFJLEtBQUssR0FBQyxDQUFDO1lBQUVoWCxFQUFFdUIsT0FBTyxHQUFDcVY7UUFBWTtRQUFFLElBQUc1VyxDQUFBQTtZQUFJQSxFQUFFdUIsT0FBTyxHQUFDaVgsbUJBQU9BLENBQUMsNEZBQU07UUFBQztRQUFFLEtBQUl4WSxDQUFBQTtZQUFJQSxFQUFFdUIsT0FBTyxHQUFDaVgsbUJBQU9BLENBQUMsZ0ZBQU07UUFBQztJQUFDO0lBQUUsSUFBSXZZLElBQUUsQ0FBQztJQUFFLFNBQVN3WSxvQkFBb0J2WSxDQUFDO1FBQUUsSUFBSUMsSUFBRUYsQ0FBQyxDQUFDQyxFQUFFO1FBQUMsSUFBR0MsTUFBSTBVLFdBQVU7WUFBQyxPQUFPMVUsRUFBRW9CLE9BQU87UUFBQTtRQUFDLElBQUluQixJQUFFSCxDQUFDLENBQUNDLEVBQUUsR0FBQztZQUFDcUIsU0FBUSxDQUFDO1FBQUM7UUFBRSxJQUFJbEIsSUFBRTtRQUFLLElBQUc7WUFBQ0wsQ0FBQyxDQUFDRSxFQUFFLENBQUNFLEdBQUVBLEVBQUVtQixPQUFPLEVBQUNrWDtZQUFxQnBZLElBQUU7UUFBSyxTQUFRO1lBQUMsSUFBR0EsR0FBRSxPQUFPSixDQUFDLENBQUNDLEVBQUU7UUFBQTtRQUFDLE9BQU9FLEVBQUVtQixPQUFPO0lBQUE7SUFBQyxJQUFHLE9BQU9rWCx3QkFBc0IsYUFBWUEsb0JBQW9CQyxFQUFFLEdBQUNDLFNBQVNBLEdBQUM7SUFBSSxJQUFJelksSUFBRXVZLG9CQUFvQjtJQUFLRyxPQUFPclgsT0FBTyxHQUFDckI7QUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL21pY3JvbWF0Y2gvaW5kZXguanM/M2NlZCJdLCJzb3VyY2VzQ29udGVudCI6WyIoKCk9PntcInVzZSBzdHJpY3RcIjt2YXIgZT17MzMzOihlLHQscik9Pntjb25zdCBuPXIoMTM3KTtjb25zdCB1PXIoMTc5KTtjb25zdCBzPXIoMTMpO2NvbnN0IG89cig3MTkpO2NvbnN0IGJyYWNlcz0oZSx0PXt9KT0+e2xldCByPVtdO2lmKEFycmF5LmlzQXJyYXkoZSkpe2ZvcihsZXQgbiBvZiBlKXtsZXQgZT1icmFjZXMuY3JlYXRlKG4sdCk7aWYoQXJyYXkuaXNBcnJheShlKSl7ci5wdXNoKC4uLmUpfWVsc2V7ci5wdXNoKGUpfX19ZWxzZXtyPVtdLmNvbmNhdChicmFjZXMuY3JlYXRlKGUsdCkpfWlmKHQmJnQuZXhwYW5kPT09dHJ1ZSYmdC5ub2R1cGVzPT09dHJ1ZSl7cj1bLi4ubmV3IFNldChyKV19cmV0dXJuIHJ9O2JyYWNlcy5wYXJzZT0oZSx0PXt9KT0+byhlLHQpO2JyYWNlcy5zdHJpbmdpZnk9KGUsdD17fSk9PntpZih0eXBlb2YgZT09PVwic3RyaW5nXCIpe3JldHVybiBuKGJyYWNlcy5wYXJzZShlLHQpLHQpfXJldHVybiBuKGUsdCl9O2JyYWNlcy5jb21waWxlPShlLHQ9e30pPT57aWYodHlwZW9mIGU9PT1cInN0cmluZ1wiKXtlPWJyYWNlcy5wYXJzZShlLHQpfXJldHVybiB1KGUsdCl9O2JyYWNlcy5leHBhbmQ9KGUsdD17fSk9PntpZih0eXBlb2YgZT09PVwic3RyaW5nXCIpe2U9YnJhY2VzLnBhcnNlKGUsdCl9bGV0IHI9cyhlLHQpO2lmKHQubm9lbXB0eT09PXRydWUpe3I9ci5maWx0ZXIoQm9vbGVhbil9aWYodC5ub2R1cGVzPT09dHJ1ZSl7cj1bLi4ubmV3IFNldChyKV19cmV0dXJuIHJ9O2JyYWNlcy5jcmVhdGU9KGUsdD17fSk9PntpZihlPT09XCJcInx8ZS5sZW5ndGg8Myl7cmV0dXJuW2VdfXJldHVybiB0LmV4cGFuZCE9PXRydWU/YnJhY2VzLmNvbXBpbGUoZSx0KTpicmFjZXMuZXhwYW5kKGUsdCl9O2UuZXhwb3J0cz1icmFjZXN9LDE3OTooZSx0LHIpPT57Y29uc3Qgbj1yKDc4Myk7Y29uc3QgdT1yKDYxNyk7Y29uc3QgY29tcGlsZT0oZSx0PXt9KT0+e2xldCB3YWxrPShlLHI9e30pPT57bGV0IHM9dS5pc0ludmFsaWRCcmFjZShyKTtsZXQgbz1lLmludmFsaWQ9PT10cnVlJiZ0LmVzY2FwZUludmFsaWQ9PT10cnVlO2xldCBpPXM9PT10cnVlfHxvPT09dHJ1ZTtsZXQgYT10LmVzY2FwZUludmFsaWQ9PT10cnVlP1wiXFxcXFwiOlwiXCI7bGV0IGw9XCJcIjtpZihlLmlzT3Blbj09PXRydWUpe3JldHVybiBhK2UudmFsdWV9aWYoZS5pc0Nsb3NlPT09dHJ1ZSl7cmV0dXJuIGErZS52YWx1ZX1pZihlLnR5cGU9PT1cIm9wZW5cIil7cmV0dXJuIGk/YStlLnZhbHVlOlwiKFwifWlmKGUudHlwZT09PVwiY2xvc2VcIil7cmV0dXJuIGk/YStlLnZhbHVlOlwiKVwifWlmKGUudHlwZT09PVwiY29tbWFcIil7cmV0dXJuIGUucHJldi50eXBlPT09XCJjb21tYVwiP1wiXCI6aT9lLnZhbHVlOlwifFwifWlmKGUudmFsdWUpe3JldHVybiBlLnZhbHVlfWlmKGUubm9kZXMmJmUucmFuZ2VzPjApe2xldCByPXUucmVkdWNlKGUubm9kZXMpO2xldCBzPW4oLi4ucix7Li4udCx3cmFwOmZhbHNlLHRvUmVnZXg6dHJ1ZX0pO2lmKHMubGVuZ3RoIT09MCl7cmV0dXJuIHIubGVuZ3RoPjEmJnMubGVuZ3RoPjE/YCgke3N9KWA6c319aWYoZS5ub2Rlcyl7Zm9yKGxldCB0IG9mIGUubm9kZXMpe2wrPXdhbGsodCxlKX19cmV0dXJuIGx9O3JldHVybiB3YWxrKGUpfTtlLmV4cG9ydHM9Y29tcGlsZX0sNDU3OmU9PntlLmV4cG9ydHM9e01BWF9MRU5HVEg6MTAyNCo2NCxDSEFSXzA6XCIwXCIsQ0hBUl85OlwiOVwiLENIQVJfVVBQRVJDQVNFX0E6XCJBXCIsQ0hBUl9MT1dFUkNBU0VfQTpcImFcIixDSEFSX1VQUEVSQ0FTRV9aOlwiWlwiLENIQVJfTE9XRVJDQVNFX1o6XCJ6XCIsQ0hBUl9MRUZUX1BBUkVOVEhFU0VTOlwiKFwiLENIQVJfUklHSFRfUEFSRU5USEVTRVM6XCIpXCIsQ0hBUl9BU1RFUklTSzpcIipcIixDSEFSX0FNUEVSU0FORDpcIiZcIixDSEFSX0FUOlwiQFwiLENIQVJfQkFDS1NMQVNIOlwiXFxcXFwiLENIQVJfQkFDS1RJQ0s6XCJgXCIsQ0hBUl9DQVJSSUFHRV9SRVRVUk46XCJcXHJcIixDSEFSX0NJUkNVTUZMRVhfQUNDRU5UOlwiXlwiLENIQVJfQ09MT046XCI6XCIsQ0hBUl9DT01NQTpcIixcIixDSEFSX0RPTExBUjpcIiRcIixDSEFSX0RPVDpcIi5cIixDSEFSX0RPVUJMRV9RVU9URTonXCInLENIQVJfRVFVQUw6XCI9XCIsQ0hBUl9FWENMQU1BVElPTl9NQVJLOlwiIVwiLENIQVJfRk9STV9GRUVEOlwiXFxmXCIsQ0hBUl9GT1JXQVJEX1NMQVNIOlwiL1wiLENIQVJfSEFTSDpcIiNcIixDSEFSX0hZUEhFTl9NSU5VUzpcIi1cIixDSEFSX0xFRlRfQU5HTEVfQlJBQ0tFVDpcIjxcIixDSEFSX0xFRlRfQ1VSTFlfQlJBQ0U6XCJ7XCIsQ0hBUl9MRUZUX1NRVUFSRV9CUkFDS0VUOlwiW1wiLENIQVJfTElORV9GRUVEOlwiXFxuXCIsQ0hBUl9OT19CUkVBS19TUEFDRTpcIsKgXCIsQ0hBUl9QRVJDRU5UOlwiJVwiLENIQVJfUExVUzpcIitcIixDSEFSX1FVRVNUSU9OX01BUks6XCI/XCIsQ0hBUl9SSUdIVF9BTkdMRV9CUkFDS0VUOlwiPlwiLENIQVJfUklHSFRfQ1VSTFlfQlJBQ0U6XCJ9XCIsQ0hBUl9SSUdIVF9TUVVBUkVfQlJBQ0tFVDpcIl1cIixDSEFSX1NFTUlDT0xPTjpcIjtcIixDSEFSX1NJTkdMRV9RVU9URTpcIidcIixDSEFSX1NQQUNFOlwiIFwiLENIQVJfVEFCOlwiXFx0XCIsQ0hBUl9VTkRFUlNDT1JFOlwiX1wiLENIQVJfVkVSVElDQUxfTElORTpcInxcIixDSEFSX1pFUk9fV0lEVEhfTk9CUkVBS19TUEFDRTpcIlxcdWZlZmZcIn19LDEzOihlLHQscik9Pntjb25zdCBuPXIoNzgzKTtjb25zdCB1PXIoMTM3KTtjb25zdCBzPXIoNjE3KTtjb25zdCBhcHBlbmQ9KGU9XCJcIix0PVwiXCIscj1mYWxzZSk9PntsZXQgbj1bXTtlPVtdLmNvbmNhdChlKTt0PVtdLmNvbmNhdCh0KTtpZighdC5sZW5ndGgpcmV0dXJuIGU7aWYoIWUubGVuZ3RoKXtyZXR1cm4gcj9zLmZsYXR0ZW4odCkubWFwKChlPT5geyR7ZX19YCkpOnR9Zm9yKGxldCB1IG9mIGUpe2lmKEFycmF5LmlzQXJyYXkodSkpe2ZvcihsZXQgZSBvZiB1KXtuLnB1c2goYXBwZW5kKGUsdCxyKSl9fWVsc2V7Zm9yKGxldCBlIG9mIHQpe2lmKHI9PT10cnVlJiZ0eXBlb2YgZT09PVwic3RyaW5nXCIpZT1geyR7ZX19YDtuLnB1c2goQXJyYXkuaXNBcnJheShlKT9hcHBlbmQodSxlLHIpOnUrZSl9fX1yZXR1cm4gcy5mbGF0dGVuKG4pfTtjb25zdCBleHBhbmQ9KGUsdD17fSk9PntsZXQgcj10LnJhbmdlTGltaXQ9PT12b2lkIDA/MWUzOnQucmFuZ2VMaW1pdDtsZXQgd2Fsaz0oZSxvPXt9KT0+e2UucXVldWU9W107bGV0IGk9bztsZXQgYT1vLnF1ZXVlO3doaWxlKGkudHlwZSE9PVwiYnJhY2VcIiYmaS50eXBlIT09XCJyb290XCImJmkucGFyZW50KXtpPWkucGFyZW50O2E9aS5xdWV1ZX1pZihlLmludmFsaWR8fGUuZG9sbGFyKXthLnB1c2goYXBwZW5kKGEucG9wKCksdShlLHQpKSk7cmV0dXJufWlmKGUudHlwZT09PVwiYnJhY2VcIiYmZS5pbnZhbGlkIT09dHJ1ZSYmZS5ub2Rlcy5sZW5ndGg9PT0yKXthLnB1c2goYXBwZW5kKGEucG9wKCksW1wie31cIl0pKTtyZXR1cm59aWYoZS5ub2RlcyYmZS5yYW5nZXM+MCl7bGV0IG89cy5yZWR1Y2UoZS5ub2Rlcyk7aWYocy5leGNlZWRzTGltaXQoLi4ubyx0LnN0ZXAscikpe3Rocm93IG5ldyBSYW5nZUVycm9yKFwiZXhwYW5kZWQgYXJyYXkgbGVuZ3RoIGV4Y2VlZHMgcmFuZ2UgbGltaXQuIFVzZSBvcHRpb25zLnJhbmdlTGltaXQgdG8gaW5jcmVhc2Ugb3IgZGlzYWJsZSB0aGUgbGltaXQuXCIpfWxldCBpPW4oLi4ubyx0KTtpZihpLmxlbmd0aD09PTApe2k9dShlLHQpfWEucHVzaChhcHBlbmQoYS5wb3AoKSxpKSk7ZS5ub2Rlcz1bXTtyZXR1cm59bGV0IGw9cy5lbmNsb3NlQnJhY2UoZSk7bGV0IGM9ZS5xdWV1ZTtsZXQgcD1lO3doaWxlKHAudHlwZSE9PVwiYnJhY2VcIiYmcC50eXBlIT09XCJyb290XCImJnAucGFyZW50KXtwPXAucGFyZW50O2M9cC5xdWV1ZX1mb3IobGV0IHQ9MDt0PGUubm9kZXMubGVuZ3RoO3QrKyl7bGV0IHI9ZS5ub2Rlc1t0XTtpZihyLnR5cGU9PT1cImNvbW1hXCImJmUudHlwZT09PVwiYnJhY2VcIil7aWYodD09PTEpYy5wdXNoKFwiXCIpO2MucHVzaChcIlwiKTtjb250aW51ZX1pZihyLnR5cGU9PT1cImNsb3NlXCIpe2EucHVzaChhcHBlbmQoYS5wb3AoKSxjLGwpKTtjb250aW51ZX1pZihyLnZhbHVlJiZyLnR5cGUhPT1cIm9wZW5cIil7Yy5wdXNoKGFwcGVuZChjLnBvcCgpLHIudmFsdWUpKTtjb250aW51ZX1pZihyLm5vZGVzKXt3YWxrKHIsZSl9fXJldHVybiBjfTtyZXR1cm4gcy5mbGF0dGVuKHdhbGsoZSkpfTtlLmV4cG9ydHM9ZXhwYW5kfSw3MTk6KGUsdCxyKT0+e2NvbnN0IG49cigxMzcpO2NvbnN0e01BWF9MRU5HVEg6dSxDSEFSX0JBQ0tTTEFTSDpzLENIQVJfQkFDS1RJQ0s6byxDSEFSX0NPTU1BOmksQ0hBUl9ET1Q6YSxDSEFSX0xFRlRfUEFSRU5USEVTRVM6bCxDSEFSX1JJR0hUX1BBUkVOVEhFU0VTOmMsQ0hBUl9MRUZUX0NVUkxZX0JSQUNFOnAsQ0hBUl9SSUdIVF9DVVJMWV9CUkFDRTpmLENIQVJfTEVGVF9TUVVBUkVfQlJBQ0tFVDpBLENIQVJfUklHSFRfU1FVQVJFX0JSQUNLRVQ6UixDSEFSX0RPVUJMRV9RVU9URTpfLENIQVJfU0lOR0xFX1FVT1RFOmgsQ0hBUl9OT19CUkVBS19TUEFDRTpnLENIQVJfWkVST19XSURUSF9OT0JSRUFLX1NQQUNFOkV9PXIoNDU3KTtjb25zdCBwYXJzZT0oZSx0PXt9KT0+e2lmKHR5cGVvZiBlIT09XCJzdHJpbmdcIil7dGhyb3cgbmV3IFR5cGVFcnJvcihcIkV4cGVjdGVkIGEgc3RyaW5nXCIpfWxldCByPXR8fHt9O2xldCBDPXR5cGVvZiByLm1heExlbmd0aD09PVwibnVtYmVyXCI/TWF0aC5taW4odSxyLm1heExlbmd0aCk6dTtpZihlLmxlbmd0aD5DKXt0aHJvdyBuZXcgU3ludGF4RXJyb3IoYElucHV0IGxlbmd0aCAoJHtlLmxlbmd0aH0pLCBleGNlZWRzIG1heCBjaGFyYWN0ZXJzICgke0N9KWApfWxldCB5PXt0eXBlOlwicm9vdFwiLGlucHV0OmUsbm9kZXM6W119O2xldCBkPVt5XTtsZXQgeD15O2xldCBiPXk7bGV0IFM9MDtsZXQgSD1lLmxlbmd0aDtsZXQgdj0wO2xldCAkPTA7bGV0IG07bGV0IFQ9e307Y29uc3QgYWR2YW5jZT0oKT0+ZVt2KytdO2NvbnN0IHB1c2g9ZT0+e2lmKGUudHlwZT09PVwidGV4dFwiJiZiLnR5cGU9PT1cImRvdFwiKXtiLnR5cGU9XCJ0ZXh0XCJ9aWYoYiYmYi50eXBlPT09XCJ0ZXh0XCImJmUudHlwZT09PVwidGV4dFwiKXtiLnZhbHVlKz1lLnZhbHVlO3JldHVybn14Lm5vZGVzLnB1c2goZSk7ZS5wYXJlbnQ9eDtlLnByZXY9YjtiPWU7cmV0dXJuIGV9O3B1c2goe3R5cGU6XCJib3NcIn0pO3doaWxlKHY8SCl7eD1kW2QubGVuZ3RoLTFdO209YWR2YW5jZSgpO2lmKG09PT1FfHxtPT09Zyl7Y29udGludWV9aWYobT09PXMpe3B1c2goe3R5cGU6XCJ0ZXh0XCIsdmFsdWU6KHQua2VlcEVzY2FwaW5nP206XCJcIikrYWR2YW5jZSgpfSk7Y29udGludWV9aWYobT09PVIpe3B1c2goe3R5cGU6XCJ0ZXh0XCIsdmFsdWU6XCJcXFxcXCIrbX0pO2NvbnRpbnVlfWlmKG09PT1BKXtTKys7bGV0IGU9dHJ1ZTtsZXQgdDt3aGlsZSh2PEgmJih0PWFkdmFuY2UoKSkpe20rPXQ7aWYodD09PUEpe1MrKztjb250aW51ZX1pZih0PT09cyl7bSs9YWR2YW5jZSgpO2NvbnRpbnVlfWlmKHQ9PT1SKXtTLS07aWYoUz09PTApe2JyZWFrfX19cHVzaCh7dHlwZTpcInRleHRcIix2YWx1ZTptfSk7Y29udGludWV9aWYobT09PWwpe3g9cHVzaCh7dHlwZTpcInBhcmVuXCIsbm9kZXM6W119KTtkLnB1c2goeCk7cHVzaCh7dHlwZTpcInRleHRcIix2YWx1ZTptfSk7Y29udGludWV9aWYobT09PWMpe2lmKHgudHlwZSE9PVwicGFyZW5cIil7cHVzaCh7dHlwZTpcInRleHRcIix2YWx1ZTptfSk7Y29udGludWV9eD1kLnBvcCgpO3B1c2goe3R5cGU6XCJ0ZXh0XCIsdmFsdWU6bX0pO3g9ZFtkLmxlbmd0aC0xXTtjb250aW51ZX1pZihtPT09X3x8bT09PWh8fG09PT1vKXtsZXQgZT1tO2xldCByO2lmKHQua2VlcFF1b3RlcyE9PXRydWUpe209XCJcIn13aGlsZSh2PEgmJihyPWFkdmFuY2UoKSkpe2lmKHI9PT1zKXttKz1yK2FkdmFuY2UoKTtjb250aW51ZX1pZihyPT09ZSl7aWYodC5rZWVwUXVvdGVzPT09dHJ1ZSltKz1yO2JyZWFrfW0rPXJ9cHVzaCh7dHlwZTpcInRleHRcIix2YWx1ZTptfSk7Y29udGludWV9aWYobT09PXApeyQrKztsZXQgZT1iLnZhbHVlJiZiLnZhbHVlLnNsaWNlKC0xKT09PVwiJFwifHx4LmRvbGxhcj09PXRydWU7bGV0IHQ9e3R5cGU6XCJicmFjZVwiLG9wZW46dHJ1ZSxjbG9zZTpmYWxzZSxkb2xsYXI6ZSxkZXB0aDokLGNvbW1hczowLHJhbmdlczowLG5vZGVzOltdfTt4PXB1c2godCk7ZC5wdXNoKHgpO3B1c2goe3R5cGU6XCJvcGVuXCIsdmFsdWU6bX0pO2NvbnRpbnVlfWlmKG09PT1mKXtpZih4LnR5cGUhPT1cImJyYWNlXCIpe3B1c2goe3R5cGU6XCJ0ZXh0XCIsdmFsdWU6bX0pO2NvbnRpbnVlfWxldCBlPVwiY2xvc2VcIjt4PWQucG9wKCk7eC5jbG9zZT10cnVlO3B1c2goe3R5cGU6ZSx2YWx1ZTptfSk7JC0tO3g9ZFtkLmxlbmd0aC0xXTtjb250aW51ZX1pZihtPT09aSYmJD4wKXtpZih4LnJhbmdlcz4wKXt4LnJhbmdlcz0wO2xldCBlPXgubm9kZXMuc2hpZnQoKTt4Lm5vZGVzPVtlLHt0eXBlOlwidGV4dFwiLHZhbHVlOm4oeCl9XX1wdXNoKHt0eXBlOlwiY29tbWFcIix2YWx1ZTptfSk7eC5jb21tYXMrKztjb250aW51ZX1pZihtPT09YSYmJD4wJiZ4LmNvbW1hcz09PTApe2xldCBlPXgubm9kZXM7aWYoJD09PTB8fGUubGVuZ3RoPT09MCl7cHVzaCh7dHlwZTpcInRleHRcIix2YWx1ZTptfSk7Y29udGludWV9aWYoYi50eXBlPT09XCJkb3RcIil7eC5yYW5nZT1bXTtiLnZhbHVlKz1tO2IudHlwZT1cInJhbmdlXCI7aWYoeC5ub2Rlcy5sZW5ndGghPT0zJiZ4Lm5vZGVzLmxlbmd0aCE9PTUpe3guaW52YWxpZD10cnVlO3gucmFuZ2VzPTA7Yi50eXBlPVwidGV4dFwiO2NvbnRpbnVlfXgucmFuZ2VzKys7eC5hcmdzPVtdO2NvbnRpbnVlfWlmKGIudHlwZT09PVwicmFuZ2VcIil7ZS5wb3AoKTtsZXQgdD1lW2UubGVuZ3RoLTFdO3QudmFsdWUrPWIudmFsdWUrbTtiPXQ7eC5yYW5nZXMtLTtjb250aW51ZX1wdXNoKHt0eXBlOlwiZG90XCIsdmFsdWU6bX0pO2NvbnRpbnVlfXB1c2goe3R5cGU6XCJ0ZXh0XCIsdmFsdWU6bX0pfWRve3g9ZC5wb3AoKTtpZih4LnR5cGUhPT1cInJvb3RcIil7eC5ub2Rlcy5mb3JFYWNoKChlPT57aWYoIWUubm9kZXMpe2lmKGUudHlwZT09PVwib3BlblwiKWUuaXNPcGVuPXRydWU7aWYoZS50eXBlPT09XCJjbG9zZVwiKWUuaXNDbG9zZT10cnVlO2lmKCFlLm5vZGVzKWUudHlwZT1cInRleHRcIjtlLmludmFsaWQ9dHJ1ZX19KSk7bGV0IGU9ZFtkLmxlbmd0aC0xXTtsZXQgdD1lLm5vZGVzLmluZGV4T2YoeCk7ZS5ub2Rlcy5zcGxpY2UodCwxLC4uLngubm9kZXMpfX13aGlsZShkLmxlbmd0aD4wKTtwdXNoKHt0eXBlOlwiZW9zXCJ9KTtyZXR1cm4geX07ZS5leHBvcnRzPXBhcnNlfSwxMzc6KGUsdCxyKT0+e2NvbnN0IG49cig2MTcpO2UuZXhwb3J0cz0oZSx0PXt9KT0+e2xldCBzdHJpbmdpZnk9KGUscj17fSk9PntsZXQgdT10LmVzY2FwZUludmFsaWQmJm4uaXNJbnZhbGlkQnJhY2Uocik7bGV0IHM9ZS5pbnZhbGlkPT09dHJ1ZSYmdC5lc2NhcGVJbnZhbGlkPT09dHJ1ZTtsZXQgbz1cIlwiO2lmKGUudmFsdWUpe2lmKCh1fHxzKSYmbi5pc09wZW5PckNsb3NlKGUpKXtyZXR1cm5cIlxcXFxcIitlLnZhbHVlfXJldHVybiBlLnZhbHVlfWlmKGUudmFsdWUpe3JldHVybiBlLnZhbHVlfWlmKGUubm9kZXMpe2ZvcihsZXQgdCBvZiBlLm5vZGVzKXtvKz1zdHJpbmdpZnkodCl9fXJldHVybiBvfTtyZXR1cm4gc3RyaW5naWZ5KGUpfX0sNjE3OihlLHQpPT57dC5pc0ludGVnZXI9ZT0+e2lmKHR5cGVvZiBlPT09XCJudW1iZXJcIil7cmV0dXJuIE51bWJlci5pc0ludGVnZXIoZSl9aWYodHlwZW9mIGU9PT1cInN0cmluZ1wiJiZlLnRyaW0oKSE9PVwiXCIpe3JldHVybiBOdW1iZXIuaXNJbnRlZ2VyKE51bWJlcihlKSl9cmV0dXJuIGZhbHNlfTt0LmZpbmQ9KGUsdCk9PmUubm9kZXMuZmluZCgoZT0+ZS50eXBlPT09dCkpO3QuZXhjZWVkc0xpbWl0PShlLHIsbj0xLHUpPT57aWYodT09PWZhbHNlKXJldHVybiBmYWxzZTtpZighdC5pc0ludGVnZXIoZSl8fCF0LmlzSW50ZWdlcihyKSlyZXR1cm4gZmFsc2U7cmV0dXJuKE51bWJlcihyKS1OdW1iZXIoZSkpL051bWJlcihuKT49dX07dC5lc2NhcGVOb2RlPShlLHQ9MCxyKT0+e2xldCBuPWUubm9kZXNbdF07aWYoIW4pcmV0dXJuO2lmKHImJm4udHlwZT09PXJ8fG4udHlwZT09PVwib3BlblwifHxuLnR5cGU9PT1cImNsb3NlXCIpe2lmKG4uZXNjYXBlZCE9PXRydWUpe24udmFsdWU9XCJcXFxcXCIrbi52YWx1ZTtuLmVzY2FwZWQ9dHJ1ZX19fTt0LmVuY2xvc2VCcmFjZT1lPT57aWYoZS50eXBlIT09XCJicmFjZVwiKXJldHVybiBmYWxzZTtpZihlLmNvbW1hcz4+MCtlLnJhbmdlcz4+MD09PTApe2UuaW52YWxpZD10cnVlO3JldHVybiB0cnVlfXJldHVybiBmYWxzZX07dC5pc0ludmFsaWRCcmFjZT1lPT57aWYoZS50eXBlIT09XCJicmFjZVwiKXJldHVybiBmYWxzZTtpZihlLmludmFsaWQ9PT10cnVlfHxlLmRvbGxhcilyZXR1cm4gdHJ1ZTtpZihlLmNvbW1hcz4+MCtlLnJhbmdlcz4+MD09PTApe2UuaW52YWxpZD10cnVlO3JldHVybiB0cnVlfWlmKGUub3BlbiE9PXRydWV8fGUuY2xvc2UhPT10cnVlKXtlLmludmFsaWQ9dHJ1ZTtyZXR1cm4gdHJ1ZX1yZXR1cm4gZmFsc2V9O3QuaXNPcGVuT3JDbG9zZT1lPT57aWYoZS50eXBlPT09XCJvcGVuXCJ8fGUudHlwZT09PVwiY2xvc2VcIil7cmV0dXJuIHRydWV9cmV0dXJuIGUub3Blbj09PXRydWV8fGUuY2xvc2U9PT10cnVlfTt0LnJlZHVjZT1lPT5lLnJlZHVjZSgoKGUsdCk9PntpZih0LnR5cGU9PT1cInRleHRcIillLnB1c2godC52YWx1ZSk7aWYodC50eXBlPT09XCJyYW5nZVwiKXQudHlwZT1cInRleHRcIjtyZXR1cm4gZX0pLFtdKTt0LmZsYXR0ZW49KC4uLmUpPT57Y29uc3QgdD1bXTtjb25zdCBmbGF0PWU9Pntmb3IobGV0IHI9MDtyPGUubGVuZ3RoO3IrKyl7bGV0IG49ZVtyXTtBcnJheS5pc0FycmF5KG4pP2ZsYXQobix0KTpuIT09dm9pZCAwJiZ0LnB1c2gobil9cmV0dXJuIHR9O2ZsYXQoZSk7cmV0dXJuIHR9fSw3ODM6KGUsdCxyKT0+e1xuLyohXG4gKiBmaWxsLXJhbmdlIDxodHRwczovL2dpdGh1Yi5jb20vam9uc2NobGlua2VydC9maWxsLXJhbmdlPlxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNC1wcmVzZW50LCBKb24gU2NobGlua2VydC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqL1xuY29uc3Qgbj1yKDgzNyk7Y29uc3QgdT1yKDQ5Mik7Y29uc3QgaXNPYmplY3Q9ZT0+ZSE9PW51bGwmJnR5cGVvZiBlPT09XCJvYmplY3RcIiYmIUFycmF5LmlzQXJyYXkoZSk7Y29uc3QgdHJhbnNmb3JtPWU9PnQ9PmU9PT10cnVlP051bWJlcih0KTpTdHJpbmcodCk7Y29uc3QgaXNWYWxpZFZhbHVlPWU9PnR5cGVvZiBlPT09XCJudW1iZXJcInx8dHlwZW9mIGU9PT1cInN0cmluZ1wiJiZlIT09XCJcIjtjb25zdCBpc051bWJlcj1lPT5OdW1iZXIuaXNJbnRlZ2VyKCtlKTtjb25zdCB6ZXJvcz1lPT57bGV0IHQ9YCR7ZX1gO2xldCByPS0xO2lmKHRbMF09PT1cIi1cIil0PXQuc2xpY2UoMSk7aWYodD09PVwiMFwiKXJldHVybiBmYWxzZTt3aGlsZSh0Wysrcl09PT1cIjBcIik7cmV0dXJuIHI+MH07Y29uc3Qgc3RyaW5naWZ5PShlLHQscik9PntpZih0eXBlb2YgZT09PVwic3RyaW5nXCJ8fHR5cGVvZiB0PT09XCJzdHJpbmdcIil7cmV0dXJuIHRydWV9cmV0dXJuIHIuc3RyaW5naWZ5PT09dHJ1ZX07Y29uc3QgcGFkPShlLHQscik9PntpZih0PjApe2xldCByPWVbMF09PT1cIi1cIj9cIi1cIjpcIlwiO2lmKHIpZT1lLnNsaWNlKDEpO2U9citlLnBhZFN0YXJ0KHI/dC0xOnQsXCIwXCIpfWlmKHI9PT1mYWxzZSl7cmV0dXJuIFN0cmluZyhlKX1yZXR1cm4gZX07Y29uc3QgdG9NYXhMZW49KGUsdCk9PntsZXQgcj1lWzBdPT09XCItXCI/XCItXCI6XCJcIjtpZihyKXtlPWUuc2xpY2UoMSk7dC0tfXdoaWxlKGUubGVuZ3RoPHQpZT1cIjBcIitlO3JldHVybiByP1wiLVwiK2U6ZX07Y29uc3QgdG9TZXF1ZW5jZT0oZSx0KT0+e2UubmVnYXRpdmVzLnNvcnQoKChlLHQpPT5lPHQ/LTE6ZT50PzE6MCkpO2UucG9zaXRpdmVzLnNvcnQoKChlLHQpPT5lPHQ/LTE6ZT50PzE6MCkpO2xldCByPXQuY2FwdHVyZT9cIlwiOlwiPzpcIjtsZXQgbj1cIlwiO2xldCB1PVwiXCI7bGV0IHM7aWYoZS5wb3NpdGl2ZXMubGVuZ3RoKXtuPWUucG9zaXRpdmVzLmpvaW4oXCJ8XCIpfWlmKGUubmVnYXRpdmVzLmxlbmd0aCl7dT1gLSgke3J9JHtlLm5lZ2F0aXZlcy5qb2luKFwifFwiKX0pYH1pZihuJiZ1KXtzPWAke259fCR7dX1gfWVsc2V7cz1ufHx1fWlmKHQud3JhcCl7cmV0dXJuYCgke3J9JHtzfSlgfXJldHVybiBzfTtjb25zdCB0b1JhbmdlPShlLHQscixuKT0+e2lmKHIpe3JldHVybiB1KGUsdCx7d3JhcDpmYWxzZSwuLi5ufSl9bGV0IHM9U3RyaW5nLmZyb21DaGFyQ29kZShlKTtpZihlPT09dClyZXR1cm4gcztsZXQgbz1TdHJpbmcuZnJvbUNoYXJDb2RlKHQpO3JldHVybmBbJHtzfS0ke299XWB9O2NvbnN0IHRvUmVnZXg9KGUsdCxyKT0+e2lmKEFycmF5LmlzQXJyYXkoZSkpe2xldCB0PXIud3JhcD09PXRydWU7bGV0IG49ci5jYXB0dXJlP1wiXCI6XCI/OlwiO3JldHVybiB0P2AoJHtufSR7ZS5qb2luKFwifFwiKX0pYDplLmpvaW4oXCJ8XCIpfXJldHVybiB1KGUsdCxyKX07Y29uc3QgcmFuZ2VFcnJvcj0oLi4uZSk9Pm5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCByYW5nZSBhcmd1bWVudHM6IFwiK24uaW5zcGVjdCguLi5lKSk7Y29uc3QgaW52YWxpZFJhbmdlPShlLHQscik9PntpZihyLnN0cmljdFJhbmdlcz09PXRydWUpdGhyb3cgcmFuZ2VFcnJvcihbZSx0XSk7cmV0dXJuW119O2NvbnN0IGludmFsaWRTdGVwPShlLHQpPT57aWYodC5zdHJpY3RSYW5nZXM9PT10cnVlKXt0aHJvdyBuZXcgVHlwZUVycm9yKGBFeHBlY3RlZCBzdGVwIFwiJHtlfVwiIHRvIGJlIGEgbnVtYmVyYCl9cmV0dXJuW119O2NvbnN0IGZpbGxOdW1iZXJzPShlLHQscj0xLG49e30pPT57bGV0IHU9TnVtYmVyKGUpO2xldCBzPU51bWJlcih0KTtpZighTnVtYmVyLmlzSW50ZWdlcih1KXx8IU51bWJlci5pc0ludGVnZXIocykpe2lmKG4uc3RyaWN0UmFuZ2VzPT09dHJ1ZSl0aHJvdyByYW5nZUVycm9yKFtlLHRdKTtyZXR1cm5bXX1pZih1PT09MCl1PTA7aWYocz09PTApcz0wO2xldCBvPXU+cztsZXQgaT1TdHJpbmcoZSk7bGV0IGE9U3RyaW5nKHQpO2xldCBsPVN0cmluZyhyKTtyPU1hdGgubWF4KE1hdGguYWJzKHIpLDEpO2xldCBjPXplcm9zKGkpfHx6ZXJvcyhhKXx8emVyb3MobCk7bGV0IHA9Yz9NYXRoLm1heChpLmxlbmd0aCxhLmxlbmd0aCxsLmxlbmd0aCk6MDtsZXQgZj1jPT09ZmFsc2UmJnN0cmluZ2lmeShlLHQsbik9PT1mYWxzZTtsZXQgQT1uLnRyYW5zZm9ybXx8dHJhbnNmb3JtKGYpO2lmKG4udG9SZWdleCYmcj09PTEpe3JldHVybiB0b1JhbmdlKHRvTWF4TGVuKGUscCksdG9NYXhMZW4odCxwKSx0cnVlLG4pfWxldCBSPXtuZWdhdGl2ZXM6W10scG9zaXRpdmVzOltdfTtsZXQgcHVzaD1lPT5SW2U8MD9cIm5lZ2F0aXZlc1wiOlwicG9zaXRpdmVzXCJdLnB1c2goTWF0aC5hYnMoZSkpO2xldCBfPVtdO2xldCBoPTA7d2hpbGUobz91Pj1zOnU8PXMpe2lmKG4udG9SZWdleD09PXRydWUmJnI+MSl7cHVzaCh1KX1lbHNle18ucHVzaChwYWQoQSh1LGgpLHAsZikpfXU9bz91LXI6dStyO2grK31pZihuLnRvUmVnZXg9PT10cnVlKXtyZXR1cm4gcj4xP3RvU2VxdWVuY2UoUixuKTp0b1JlZ2V4KF8sbnVsbCx7d3JhcDpmYWxzZSwuLi5ufSl9cmV0dXJuIF99O2NvbnN0IGZpbGxMZXR0ZXJzPShlLHQscj0xLG49e30pPT57aWYoIWlzTnVtYmVyKGUpJiZlLmxlbmd0aD4xfHwhaXNOdW1iZXIodCkmJnQubGVuZ3RoPjEpe3JldHVybiBpbnZhbGlkUmFuZ2UoZSx0LG4pfWxldCB1PW4udHJhbnNmb3JtfHwoZT0+U3RyaW5nLmZyb21DaGFyQ29kZShlKSk7bGV0IHM9YCR7ZX1gLmNoYXJDb2RlQXQoMCk7bGV0IG89YCR7dH1gLmNoYXJDb2RlQXQoMCk7bGV0IGk9cz5vO2xldCBhPU1hdGgubWluKHMsbyk7bGV0IGw9TWF0aC5tYXgocyxvKTtpZihuLnRvUmVnZXgmJnI9PT0xKXtyZXR1cm4gdG9SYW5nZShhLGwsZmFsc2Usbil9bGV0IGM9W107bGV0IHA9MDt3aGlsZShpP3M+PW86czw9byl7Yy5wdXNoKHUocyxwKSk7cz1pP3MtcjpzK3I7cCsrfWlmKG4udG9SZWdleD09PXRydWUpe3JldHVybiB0b1JlZ2V4KGMsbnVsbCx7d3JhcDpmYWxzZSxvcHRpb25zOm59KX1yZXR1cm4gY307Y29uc3QgZmlsbD0oZSx0LHIsbj17fSk9PntpZih0PT1udWxsJiZpc1ZhbGlkVmFsdWUoZSkpe3JldHVybltlXX1pZighaXNWYWxpZFZhbHVlKGUpfHwhaXNWYWxpZFZhbHVlKHQpKXtyZXR1cm4gaW52YWxpZFJhbmdlKGUsdCxuKX1pZih0eXBlb2Ygcj09PVwiZnVuY3Rpb25cIil7cmV0dXJuIGZpbGwoZSx0LDEse3RyYW5zZm9ybTpyfSl9aWYoaXNPYmplY3Qocikpe3JldHVybiBmaWxsKGUsdCwwLHIpfWxldCB1PXsuLi5ufTtpZih1LmNhcHR1cmU9PT10cnVlKXUud3JhcD10cnVlO3I9cnx8dS5zdGVwfHwxO2lmKCFpc051bWJlcihyKSl7aWYociE9bnVsbCYmIWlzT2JqZWN0KHIpKXJldHVybiBpbnZhbGlkU3RlcChyLHUpO3JldHVybiBmaWxsKGUsdCwxLHIpfWlmKGlzTnVtYmVyKGUpJiZpc051bWJlcih0KSl7cmV0dXJuIGZpbGxOdW1iZXJzKGUsdCxyLHUpfXJldHVybiBmaWxsTGV0dGVycyhlLHQsTWF0aC5tYXgoTWF0aC5hYnMociksMSksdSl9O2UuZXhwb3J0cz1maWxsfSwzNTc6ZT0+e1xuLyohXG4gKiBpcy1udW1iZXIgPGh0dHBzOi8vZ2l0aHViLmNvbS9qb25zY2hsaW5rZXJ0L2lzLW51bWJlcj5cbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQtcHJlc2VudCwgSm9uIFNjaGxpbmtlcnQuXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKi9cbmUuZXhwb3J0cz1mdW5jdGlvbihlKXtpZih0eXBlb2YgZT09PVwibnVtYmVyXCIpe3JldHVybiBlLWU9PT0wfWlmKHR5cGVvZiBlPT09XCJzdHJpbmdcIiYmZS50cmltKCkhPT1cIlwiKXtyZXR1cm4gTnVtYmVyLmlzRmluaXRlP051bWJlci5pc0Zpbml0ZSgrZSk6aXNGaW5pdGUoK2UpfXJldHVybiBmYWxzZX19LDk3MTooZSx0LHIpPT57Y29uc3Qgbj1yKDgzNyk7Y29uc3QgdT1yKDMzMyk7Y29uc3Qgcz1yKDI1MSk7Y29uc3Qgbz1yKDUxMyk7Y29uc3QgaXNFbXB0eVN0cmluZz1lPT5lPT09XCJcInx8ZT09PVwiLi9cIjtjb25zdCBtaWNyb21hdGNoPShlLHQscik9Pnt0PVtdLmNvbmNhdCh0KTtlPVtdLmNvbmNhdChlKTtsZXQgbj1uZXcgU2V0O2xldCB1PW5ldyBTZXQ7bGV0IG89bmV3IFNldDtsZXQgaT0wO2xldCBvblJlc3VsdD1lPT57by5hZGQoZS5vdXRwdXQpO2lmKHImJnIub25SZXN1bHQpe3Iub25SZXN1bHQoZSl9fTtmb3IobGV0IG89MDtvPHQubGVuZ3RoO28rKyl7bGV0IGE9cyhTdHJpbmcodFtvXSksey4uLnIsb25SZXN1bHQ6b25SZXN1bHR9LHRydWUpO2xldCBsPWEuc3RhdGUubmVnYXRlZHx8YS5zdGF0ZS5uZWdhdGVkRXh0Z2xvYjtpZihsKWkrKztmb3IobGV0IHQgb2YgZSl7bGV0IGU9YSh0LHRydWUpO2xldCByPWw/IWUuaXNNYXRjaDplLmlzTWF0Y2g7aWYoIXIpY29udGludWU7aWYobCl7bi5hZGQoZS5vdXRwdXQpfWVsc2V7bi5kZWxldGUoZS5vdXRwdXQpO3UuYWRkKGUub3V0cHV0KX19fWxldCBhPWk9PT10Lmxlbmd0aD9bLi4ub106Wy4uLnVdO2xldCBsPWEuZmlsdGVyKChlPT4hbi5oYXMoZSkpKTtpZihyJiZsLmxlbmd0aD09PTApe2lmKHIuZmFpbGdsb2I9PT10cnVlKXt0aHJvdyBuZXcgRXJyb3IoYE5vIG1hdGNoZXMgZm91bmQgZm9yIFwiJHt0LmpvaW4oXCIsIFwiKX1cImApfWlmKHIubm9udWxsPT09dHJ1ZXx8ci5udWxsZ2xvYj09PXRydWUpe3JldHVybiByLnVuZXNjYXBlP3QubWFwKChlPT5lLnJlcGxhY2UoL1xcXFwvZyxcIlwiKSkpOnR9fXJldHVybiBsfTttaWNyb21hdGNoLm1hdGNoPW1pY3JvbWF0Y2g7bWljcm9tYXRjaC5tYXRjaGVyPShlLHQpPT5zKGUsdCk7bWljcm9tYXRjaC5pc01hdGNoPShlLHQscik9PnModCxyKShlKTttaWNyb21hdGNoLmFueT1taWNyb21hdGNoLmlzTWF0Y2g7bWljcm9tYXRjaC5ub3Q9KGUsdCxyPXt9KT0+e3Q9W10uY29uY2F0KHQpLm1hcChTdHJpbmcpO2xldCBuPW5ldyBTZXQ7bGV0IHU9W107bGV0IG9uUmVzdWx0PWU9PntpZihyLm9uUmVzdWx0KXIub25SZXN1bHQoZSk7dS5wdXNoKGUub3V0cHV0KX07bGV0IHM9bWljcm9tYXRjaChlLHQsey4uLnIsb25SZXN1bHQ6b25SZXN1bHR9KTtmb3IobGV0IGUgb2YgdSl7aWYoIXMuaW5jbHVkZXMoZSkpe24uYWRkKGUpfX1yZXR1cm5bLi4ubl19O21pY3JvbWF0Y2guY29udGFpbnM9KGUsdCxyKT0+e2lmKHR5cGVvZiBlIT09XCJzdHJpbmdcIil7dGhyb3cgbmV3IFR5cGVFcnJvcihgRXhwZWN0ZWQgYSBzdHJpbmc6IFwiJHtuLmluc3BlY3QoZSl9XCJgKX1pZihBcnJheS5pc0FycmF5KHQpKXtyZXR1cm4gdC5zb21lKCh0PT5taWNyb21hdGNoLmNvbnRhaW5zKGUsdCxyKSkpfWlmKHR5cGVvZiB0PT09XCJzdHJpbmdcIil7aWYoaXNFbXB0eVN0cmluZyhlKXx8aXNFbXB0eVN0cmluZyh0KSl7cmV0dXJuIGZhbHNlfWlmKGUuaW5jbHVkZXModCl8fGUuc3RhcnRzV2l0aChcIi4vXCIpJiZlLnNsaWNlKDIpLmluY2x1ZGVzKHQpKXtyZXR1cm4gdHJ1ZX19cmV0dXJuIG1pY3JvbWF0Y2guaXNNYXRjaChlLHQsey4uLnIsY29udGFpbnM6dHJ1ZX0pfTttaWNyb21hdGNoLm1hdGNoS2V5cz0oZSx0LHIpPT57aWYoIW8uaXNPYmplY3QoZSkpe3Rocm93IG5ldyBUeXBlRXJyb3IoXCJFeHBlY3RlZCB0aGUgZmlyc3QgYXJndW1lbnQgdG8gYmUgYW4gb2JqZWN0XCIpfWxldCBuPW1pY3JvbWF0Y2goT2JqZWN0LmtleXMoZSksdCxyKTtsZXQgdT17fTtmb3IobGV0IHQgb2Ygbil1W3RdPWVbdF07cmV0dXJuIHV9O21pY3JvbWF0Y2guc29tZT0oZSx0LHIpPT57bGV0IG49W10uY29uY2F0KGUpO2ZvcihsZXQgZSBvZltdLmNvbmNhdCh0KSl7bGV0IHQ9cyhTdHJpbmcoZSkscik7aWYobi5zb21lKChlPT50KGUpKSkpe3JldHVybiB0cnVlfX1yZXR1cm4gZmFsc2V9O21pY3JvbWF0Y2guZXZlcnk9KGUsdCxyKT0+e2xldCBuPVtdLmNvbmNhdChlKTtmb3IobGV0IGUgb2ZbXS5jb25jYXQodCkpe2xldCB0PXMoU3RyaW5nKGUpLHIpO2lmKCFuLmV2ZXJ5KChlPT50KGUpKSkpe3JldHVybiBmYWxzZX19cmV0dXJuIHRydWV9O21pY3JvbWF0Y2guYWxsPShlLHQscik9PntpZih0eXBlb2YgZSE9PVwic3RyaW5nXCIpe3Rocm93IG5ldyBUeXBlRXJyb3IoYEV4cGVjdGVkIGEgc3RyaW5nOiBcIiR7bi5pbnNwZWN0KGUpfVwiYCl9cmV0dXJuW10uY29uY2F0KHQpLmV2ZXJ5KCh0PT5zKHQscikoZSkpKX07bWljcm9tYXRjaC5jYXB0dXJlPShlLHQscik9PntsZXQgbj1vLmlzV2luZG93cyhyKTtsZXQgdT1zLm1ha2VSZShTdHJpbmcoZSksey4uLnIsY2FwdHVyZTp0cnVlfSk7bGV0IGk9dS5leGVjKG4/by50b1Bvc2l4U2xhc2hlcyh0KTp0KTtpZihpKXtyZXR1cm4gaS5zbGljZSgxKS5tYXAoKGU9PmU9PT12b2lkIDA/XCJcIjplKSl9fTttaWNyb21hdGNoLm1ha2VSZT0oLi4uZSk9PnMubWFrZVJlKC4uLmUpO21pY3JvbWF0Y2guc2Nhbj0oLi4uZSk9PnMuc2NhbiguLi5lKTttaWNyb21hdGNoLnBhcnNlPShlLHQpPT57bGV0IHI9W107Zm9yKGxldCBuIG9mW10uY29uY2F0KGV8fFtdKSl7Zm9yKGxldCBlIG9mIHUoU3RyaW5nKG4pLHQpKXtyLnB1c2gocy5wYXJzZShlLHQpKX19cmV0dXJuIHJ9O21pY3JvbWF0Y2guYnJhY2VzPShlLHQpPT57aWYodHlwZW9mIGUhPT1cInN0cmluZ1wiKXRocm93IG5ldyBUeXBlRXJyb3IoXCJFeHBlY3RlZCBhIHN0cmluZ1wiKTtpZih0JiZ0Lm5vYnJhY2U9PT10cnVlfHwhL1xcey4qXFx9Ly50ZXN0KGUpKXtyZXR1cm5bZV19cmV0dXJuIHUoZSx0KX07bWljcm9tYXRjaC5icmFjZUV4cGFuZD0oZSx0KT0+e2lmKHR5cGVvZiBlIT09XCJzdHJpbmdcIil0aHJvdyBuZXcgVHlwZUVycm9yKFwiRXhwZWN0ZWQgYSBzdHJpbmdcIik7cmV0dXJuIG1pY3JvbWF0Y2guYnJhY2VzKGUsey4uLnQsZXhwYW5kOnRydWV9KX07ZS5leHBvcnRzPW1pY3JvbWF0Y2h9LDI1MTooZSx0LHIpPT57ZS5leHBvcnRzPXIoNjgzKX0sMzU2OihlLHQscik9Pntjb25zdCBuPXIoMTcpO2NvbnN0IHU9XCJcXFxcXFxcXC9cIjtjb25zdCBzPWBbXiR7dX1dYDtjb25zdCBvPVwiXFxcXC5cIjtjb25zdCBpPVwiXFxcXCtcIjtjb25zdCBhPVwiXFxcXD9cIjtjb25zdCBsPVwiXFxcXC9cIjtjb25zdCBjPVwiKD89LilcIjtjb25zdCBwPVwiW14vXVwiO2NvbnN0IGY9YCg/OiR7bH18JClgO2NvbnN0IEE9YCg/Ol58JHtsfSlgO2NvbnN0IFI9YCR7b317MSwyfSR7Zn1gO2NvbnN0IF89YCg/ISR7b30pYDtjb25zdCBoPWAoPyEke0F9JHtSfSlgO2NvbnN0IGc9YCg/ISR7b317MCwxfSR7Zn0pYDtjb25zdCBFPWAoPyEke1J9KWA7Y29uc3QgQz1gW14uJHtsfV1gO2NvbnN0IHk9YCR7cH0qP2A7Y29uc3QgZD17RE9UX0xJVEVSQUw6byxQTFVTX0xJVEVSQUw6aSxRTUFSS19MSVRFUkFMOmEsU0xBU0hfTElURVJBTDpsLE9ORV9DSEFSOmMsUU1BUks6cCxFTkRfQU5DSE9SOmYsRE9UU19TTEFTSDpSLE5PX0RPVDpfLE5PX0RPVFM6aCxOT19ET1RfU0xBU0g6ZyxOT19ET1RTX1NMQVNIOkUsUU1BUktfTk9fRE9UOkMsU1RBUjp5LFNUQVJUX0FOQ0hPUjpBfTtjb25zdCB4PXsuLi5kLFNMQVNIX0xJVEVSQUw6YFske3V9XWAsUU1BUks6cyxTVEFSOmAke3N9Kj9gLERPVFNfU0xBU0g6YCR7b317MSwyfSg/Olske3V9XXwkKWAsTk9fRE9UOmAoPyEke299KWAsTk9fRE9UUzpgKD8hKD86XnxbJHt1fV0pJHtvfXsxLDJ9KD86WyR7dX1dfCQpKWAsTk9fRE9UX1NMQVNIOmAoPyEke299ezAsMX0oPzpbJHt1fV18JCkpYCxOT19ET1RTX1NMQVNIOmAoPyEke299ezEsMn0oPzpbJHt1fV18JCkpYCxRTUFSS19OT19ET1Q6YFteLiR7dX1dYCxTVEFSVF9BTkNIT1I6YCg/Ol58WyR7dX1dKWAsRU5EX0FOQ0hPUjpgKD86WyR7dX1dfCQpYH07Y29uc3QgYj17YWxudW06XCJhLXpBLVowLTlcIixhbHBoYTpcImEtekEtWlwiLGFzY2lpOlwiXFxcXHgwMC1cXFxceDdGXCIsYmxhbms6XCIgXFxcXHRcIixjbnRybDpcIlxcXFx4MDAtXFxcXHgxRlxcXFx4N0ZcIixkaWdpdDpcIjAtOVwiLGdyYXBoOlwiXFxcXHgyMS1cXFxceDdFXCIsbG93ZXI6XCJhLXpcIixwcmludDpcIlxcXFx4MjAtXFxcXHg3RSBcIixwdW5jdDpcIlxcXFwtIVxcXCIjJCUmJygpXFxcXCorLC4vOjs8PT4/QFtcXFxcXV5fYHt8fX5cIixzcGFjZTpcIiBcXFxcdFxcXFxyXFxcXG5cXFxcdlxcXFxmXCIsdXBwZXI6XCJBLVpcIix3b3JkOlwiQS1aYS16MC05X1wiLHhkaWdpdDpcIkEtRmEtZjAtOVwifTtlLmV4cG9ydHM9e01BWF9MRU5HVEg6MTAyNCo2NCxQT1NJWF9SRUdFWF9TT1VSQ0U6YixSRUdFWF9CQUNLU0xBU0g6L1xcXFwoPyFbKis/XiR7fSh8KVtcXF1dKS9nLFJFR0VYX05PTl9TUEVDSUFMX0NIQVJTOi9eW15AIVtcXF0uLCQqKz9ee30oKXxcXFxcL10rLyxSRUdFWF9TUEVDSUFMX0NIQVJTOi9bLSorPy5eJHt9KHwpW1xcXV0vLFJFR0VYX1NQRUNJQUxfQ0hBUlNfQkFDS1JFRjovKFxcXFw/KSgoXFxXKShcXDMqKSkvZyxSRUdFWF9TUEVDSUFMX0NIQVJTX0dMT0JBTDovKFstKis/Ll4ke30ofClbXFxdXSkvZyxSRUdFWF9SRU1PVkVfQkFDS1NMQVNIOi8oPzpcXFsuKj9bXlxcXFxdXFxdfFxcXFwoPz0uKSkvZyxSRVBMQUNFTUVOVFM6e1wiKioqXCI6XCIqXCIsXCIqKi8qKlwiOlwiKipcIixcIioqLyoqLyoqXCI6XCIqKlwifSxDSEFSXzA6NDgsQ0hBUl85OjU3LENIQVJfVVBQRVJDQVNFX0E6NjUsQ0hBUl9MT1dFUkNBU0VfQTo5NyxDSEFSX1VQUEVSQ0FTRV9aOjkwLENIQVJfTE9XRVJDQVNFX1o6MTIyLENIQVJfTEVGVF9QQVJFTlRIRVNFUzo0MCxDSEFSX1JJR0hUX1BBUkVOVEhFU0VTOjQxLENIQVJfQVNURVJJU0s6NDIsQ0hBUl9BTVBFUlNBTkQ6MzgsQ0hBUl9BVDo2NCxDSEFSX0JBQ0tXQVJEX1NMQVNIOjkyLENIQVJfQ0FSUklBR0VfUkVUVVJOOjEzLENIQVJfQ0lSQ1VNRkxFWF9BQ0NFTlQ6OTQsQ0hBUl9DT0xPTjo1OCxDSEFSX0NPTU1BOjQ0LENIQVJfRE9UOjQ2LENIQVJfRE9VQkxFX1FVT1RFOjM0LENIQVJfRVFVQUw6NjEsQ0hBUl9FWENMQU1BVElPTl9NQVJLOjMzLENIQVJfRk9STV9GRUVEOjEyLENIQVJfRk9SV0FSRF9TTEFTSDo0NyxDSEFSX0dSQVZFX0FDQ0VOVDo5NixDSEFSX0hBU0g6MzUsQ0hBUl9IWVBIRU5fTUlOVVM6NDUsQ0hBUl9MRUZUX0FOR0xFX0JSQUNLRVQ6NjAsQ0hBUl9MRUZUX0NVUkxZX0JSQUNFOjEyMyxDSEFSX0xFRlRfU1FVQVJFX0JSQUNLRVQ6OTEsQ0hBUl9MSU5FX0ZFRUQ6MTAsQ0hBUl9OT19CUkVBS19TUEFDRToxNjAsQ0hBUl9QRVJDRU5UOjM3LENIQVJfUExVUzo0MyxDSEFSX1FVRVNUSU9OX01BUks6NjMsQ0hBUl9SSUdIVF9BTkdMRV9CUkFDS0VUOjYyLENIQVJfUklHSFRfQ1VSTFlfQlJBQ0U6MTI1LENIQVJfUklHSFRfU1FVQVJFX0JSQUNLRVQ6OTMsQ0hBUl9TRU1JQ09MT046NTksQ0hBUl9TSU5HTEVfUVVPVEU6MzksQ0hBUl9TUEFDRTozMixDSEFSX1RBQjo5LENIQVJfVU5ERVJTQ09SRTo5NSxDSEFSX1ZFUlRJQ0FMX0xJTkU6MTI0LENIQVJfWkVST19XSURUSF9OT0JSRUFLX1NQQUNFOjY1Mjc5LFNFUDpuLnNlcCxleHRnbG9iQ2hhcnMoZSl7cmV0dXJue1wiIVwiOnt0eXBlOlwibmVnYXRlXCIsb3BlbjpcIig/Oig/ISg/OlwiLGNsb3NlOmApKSR7ZS5TVEFSfSlgfSxcIj9cIjp7dHlwZTpcInFtYXJrXCIsb3BlbjpcIig/OlwiLGNsb3NlOlwiKT9cIn0sXCIrXCI6e3R5cGU6XCJwbHVzXCIsb3BlbjpcIig/OlwiLGNsb3NlOlwiKStcIn0sXCIqXCI6e3R5cGU6XCJzdGFyXCIsb3BlbjpcIig/OlwiLGNsb3NlOlwiKSpcIn0sXCJAXCI6e3R5cGU6XCJhdFwiLG9wZW46XCIoPzpcIixjbG9zZTpcIilcIn19fSxnbG9iQ2hhcnMoZSl7cmV0dXJuIGU9PT10cnVlP3g6ZH19fSw3NTQ6KGUsdCxyKT0+e2NvbnN0IG49cigzNTYpO2NvbnN0IHU9cig1MTMpO2NvbnN0e01BWF9MRU5HVEg6cyxQT1NJWF9SRUdFWF9TT1VSQ0U6byxSRUdFWF9OT05fU1BFQ0lBTF9DSEFSUzppLFJFR0VYX1NQRUNJQUxfQ0hBUlNfQkFDS1JFRjphLFJFUExBQ0VNRU5UUzpsfT1uO2NvbnN0IGV4cGFuZFJhbmdlPShlLHQpPT57aWYodHlwZW9mIHQuZXhwYW5kUmFuZ2U9PT1cImZ1bmN0aW9uXCIpe3JldHVybiB0LmV4cGFuZFJhbmdlKC4uLmUsdCl9ZS5zb3J0KCk7Y29uc3Qgcj1gWyR7ZS5qb2luKFwiLVwiKX1dYDt0cnl7bmV3IFJlZ0V4cChyKX1jYXRjaCh0KXtyZXR1cm4gZS5tYXAoKGU9PnUuZXNjYXBlUmVnZXgoZSkpKS5qb2luKFwiLi5cIil9cmV0dXJuIHJ9O2NvbnN0IHN5bnRheEVycm9yPShlLHQpPT5gTWlzc2luZyAke2V9OiBcIiR7dH1cIiAtIHVzZSBcIlxcXFxcXFxcJHt0fVwiIHRvIG1hdGNoIGxpdGVyYWwgY2hhcmFjdGVyc2A7Y29uc3QgcGFyc2U9KGUsdCk9PntpZih0eXBlb2YgZSE9PVwic3RyaW5nXCIpe3Rocm93IG5ldyBUeXBlRXJyb3IoXCJFeHBlY3RlZCBhIHN0cmluZ1wiKX1lPWxbZV18fGU7Y29uc3Qgcj17Li4udH07Y29uc3QgYz10eXBlb2Ygci5tYXhMZW5ndGg9PT1cIm51bWJlclwiP01hdGgubWluKHMsci5tYXhMZW5ndGgpOnM7bGV0IHA9ZS5sZW5ndGg7aWYocD5jKXt0aHJvdyBuZXcgU3ludGF4RXJyb3IoYElucHV0IGxlbmd0aDogJHtwfSwgZXhjZWVkcyBtYXhpbXVtIGFsbG93ZWQgbGVuZ3RoOiAke2N9YCl9Y29uc3QgZj17dHlwZTpcImJvc1wiLHZhbHVlOlwiXCIsb3V0cHV0OnIucHJlcGVuZHx8XCJcIn07Y29uc3QgQT1bZl07Y29uc3QgUj1yLmNhcHR1cmU/XCJcIjpcIj86XCI7Y29uc3QgXz11LmlzV2luZG93cyh0KTtjb25zdCBoPW4uZ2xvYkNoYXJzKF8pO2NvbnN0IGc9bi5leHRnbG9iQ2hhcnMoaCk7Y29uc3R7RE9UX0xJVEVSQUw6RSxQTFVTX0xJVEVSQUw6QyxTTEFTSF9MSVRFUkFMOnksT05FX0NIQVI6ZCxET1RTX1NMQVNIOngsTk9fRE9UOmIsTk9fRE9UX1NMQVNIOlMsTk9fRE9UU19TTEFTSDpILFFNQVJLOnYsUU1BUktfTk9fRE9UOiQsU1RBUjptLFNUQVJUX0FOQ0hPUjpUfT1oO2NvbnN0IGdsb2JzdGFyPWU9PmAoJHtSfSg/Oig/ISR7VH0ke2UuZG90P3g6RX0pLikqPylgO2NvbnN0IEw9ci5kb3Q/XCJcIjpiO2NvbnN0IE89ci5kb3Q/djokO2xldCB3PXIuYmFzaD09PXRydWU/Z2xvYnN0YXIocik6bTtpZihyLmNhcHR1cmUpe3c9YCgke3d9KWB9aWYodHlwZW9mIHIubm9leHQ9PT1cImJvb2xlYW5cIil7ci5ub2V4dGdsb2I9ci5ub2V4dH1jb25zdCBOPXtpbnB1dDplLGluZGV4Oi0xLHN0YXJ0OjAsZG90OnIuZG90PT09dHJ1ZSxjb25zdW1lZDpcIlwiLG91dHB1dDpcIlwiLHByZWZpeDpcIlwiLGJhY2t0cmFjazpmYWxzZSxuZWdhdGVkOmZhbHNlLGJyYWNrZXRzOjAsYnJhY2VzOjAscGFyZW5zOjAscXVvdGVzOjAsZ2xvYnN0YXI6ZmFsc2UsdG9rZW5zOkF9O2U9dS5yZW1vdmVQcmVmaXgoZSxOKTtwPWUubGVuZ3RoO2NvbnN0IGs9W107Y29uc3QgST1bXTtjb25zdCBNPVtdO2xldCBQPWY7bGV0IEI7Y29uc3QgZW9zPSgpPT5OLmluZGV4PT09cC0xO2NvbnN0IEc9Ti5wZWVrPSh0PTEpPT5lW04uaW5kZXgrdF07Y29uc3QgRD1OLmFkdmFuY2U9KCk9PmVbKytOLmluZGV4XTtjb25zdCByZW1haW5pbmc9KCk9PmUuc2xpY2UoTi5pbmRleCsxKTtjb25zdCBjb25zdW1lPShlPVwiXCIsdD0wKT0+e04uY29uc3VtZWQrPWU7Ti5pbmRleCs9dH07Y29uc3QgYXBwZW5kPWU9PntOLm91dHB1dCs9ZS5vdXRwdXQhPW51bGw/ZS5vdXRwdXQ6ZS52YWx1ZTtjb25zdW1lKGUudmFsdWUpfTtjb25zdCBuZWdhdGU9KCk9PntsZXQgZT0xO3doaWxlKEcoKT09PVwiIVwiJiYoRygyKSE9PVwiKFwifHxHKDMpPT09XCI/XCIpKXtEKCk7Ti5zdGFydCsrO2UrK31pZihlJTI9PT0wKXtyZXR1cm4gZmFsc2V9Ti5uZWdhdGVkPXRydWU7Ti5zdGFydCsrO3JldHVybiB0cnVlfTtjb25zdCBpbmNyZW1lbnQ9ZT0+e05bZV0rKztNLnB1c2goZSl9O2NvbnN0IGRlY3JlbWVudD1lPT57TltlXS0tO00ucG9wKCl9O2NvbnN0IHB1c2g9ZT0+e2lmKFAudHlwZT09PVwiZ2xvYnN0YXJcIil7Y29uc3QgdD1OLmJyYWNlcz4wJiYoZS50eXBlPT09XCJjb21tYVwifHxlLnR5cGU9PT1cImJyYWNlXCIpO2NvbnN0IHI9ZS5leHRnbG9iPT09dHJ1ZXx8ay5sZW5ndGgmJihlLnR5cGU9PT1cInBpcGVcInx8ZS50eXBlPT09XCJwYXJlblwiKTtpZihlLnR5cGUhPT1cInNsYXNoXCImJmUudHlwZSE9PVwicGFyZW5cIiYmIXQmJiFyKXtOLm91dHB1dD1OLm91dHB1dC5zbGljZSgwLC1QLm91dHB1dC5sZW5ndGgpO1AudHlwZT1cInN0YXJcIjtQLnZhbHVlPVwiKlwiO1Aub3V0cHV0PXc7Ti5vdXRwdXQrPVAub3V0cHV0fX1pZihrLmxlbmd0aCYmZS50eXBlIT09XCJwYXJlblwiJiYhZ1tlLnZhbHVlXSl7a1trLmxlbmd0aC0xXS5pbm5lcis9ZS52YWx1ZX1pZihlLnZhbHVlfHxlLm91dHB1dClhcHBlbmQoZSk7aWYoUCYmUC50eXBlPT09XCJ0ZXh0XCImJmUudHlwZT09PVwidGV4dFwiKXtQLnZhbHVlKz1lLnZhbHVlO1Aub3V0cHV0PShQLm91dHB1dHx8XCJcIikrZS52YWx1ZTtyZXR1cm59ZS5wcmV2PVA7QS5wdXNoKGUpO1A9ZX07Y29uc3QgZXh0Z2xvYk9wZW49KGUsdCk9Pntjb25zdCBuPXsuLi5nW3RdLGNvbmRpdGlvbnM6MSxpbm5lcjpcIlwifTtuLnByZXY9UDtuLnBhcmVucz1OLnBhcmVucztuLm91dHB1dD1OLm91dHB1dDtjb25zdCB1PShyLmNhcHR1cmU/XCIoXCI6XCJcIikrbi5vcGVuO2luY3JlbWVudChcInBhcmVuc1wiKTtwdXNoKHt0eXBlOmUsdmFsdWU6dCxvdXRwdXQ6Ti5vdXRwdXQ/XCJcIjpkfSk7cHVzaCh7dHlwZTpcInBhcmVuXCIsZXh0Z2xvYjp0cnVlLHZhbHVlOkQoKSxvdXRwdXQ6dX0pO2sucHVzaChuKX07Y29uc3QgZXh0Z2xvYkNsb3NlPWU9PntsZXQgdD1lLmNsb3NlKyhyLmNhcHR1cmU/XCIpXCI6XCJcIik7aWYoZS50eXBlPT09XCJuZWdhdGVcIil7bGV0IG49dztpZihlLmlubmVyJiZlLmlubmVyLmxlbmd0aD4xJiZlLmlubmVyLmluY2x1ZGVzKFwiL1wiKSl7bj1nbG9ic3RhcihyKX1pZihuIT09d3x8ZW9zKCl8fC9eXFwpKyQvLnRlc3QocmVtYWluaW5nKCkpKXt0PWUuY2xvc2U9YCkkKSkke259YH1pZihlLnByZXYudHlwZT09PVwiYm9zXCIpe04ubmVnYXRlZEV4dGdsb2I9dHJ1ZX19cHVzaCh7dHlwZTpcInBhcmVuXCIsZXh0Z2xvYjp0cnVlLHZhbHVlOkIsb3V0cHV0OnR9KTtkZWNyZW1lbnQoXCJwYXJlbnNcIil9O2lmKHIuZmFzdHBhdGhzIT09ZmFsc2UmJiEvKF5bKiFdfFsvKClbXFxde31cIl0pLy50ZXN0KGUpKXtsZXQgbj1mYWxzZTtsZXQgcz1lLnJlcGxhY2UoYSwoKGUsdCxyLHUscyxvKT0+e2lmKHU9PT1cIlxcXFxcIil7bj10cnVlO3JldHVybiBlfWlmKHU9PT1cIj9cIil7aWYodCl7cmV0dXJuIHQrdSsocz92LnJlcGVhdChzLmxlbmd0aCk6XCJcIil9aWYobz09PTApe3JldHVybiBPKyhzP3YucmVwZWF0KHMubGVuZ3RoKTpcIlwiKX1yZXR1cm4gdi5yZXBlYXQoci5sZW5ndGgpfWlmKHU9PT1cIi5cIil7cmV0dXJuIEUucmVwZWF0KHIubGVuZ3RoKX1pZih1PT09XCIqXCIpe2lmKHQpe3JldHVybiB0K3UrKHM/dzpcIlwiKX1yZXR1cm4gd31yZXR1cm4gdD9lOmBcXFxcJHtlfWB9KSk7aWYobj09PXRydWUpe2lmKHIudW5lc2NhcGU9PT10cnVlKXtzPXMucmVwbGFjZSgvXFxcXC9nLFwiXCIpfWVsc2V7cz1zLnJlcGxhY2UoL1xcXFwrL2csKGU9PmUubGVuZ3RoJTI9PT0wP1wiXFxcXFxcXFxcIjplP1wiXFxcXFwiOlwiXCIpKX19aWYocz09PWUmJnIuY29udGFpbnM9PT10cnVlKXtOLm91dHB1dD1lO3JldHVybiBOfU4ub3V0cHV0PXUud3JhcE91dHB1dChzLE4sdCk7cmV0dXJuIE59d2hpbGUoIWVvcygpKXtCPUQoKTtpZihCPT09XCJcXDBcIil7Y29udGludWV9aWYoQj09PVwiXFxcXFwiKXtjb25zdCBlPUcoKTtpZihlPT09XCIvXCImJnIuYmFzaCE9PXRydWUpe2NvbnRpbnVlfWlmKGU9PT1cIi5cInx8ZT09PVwiO1wiKXtjb250aW51ZX1pZighZSl7Qis9XCJcXFxcXCI7cHVzaCh7dHlwZTpcInRleHRcIix2YWx1ZTpCfSk7Y29udGludWV9Y29uc3QgdD0vXlxcXFwrLy5leGVjKHJlbWFpbmluZygpKTtsZXQgbj0wO2lmKHQmJnRbMF0ubGVuZ3RoPjIpe249dFswXS5sZW5ndGg7Ti5pbmRleCs9bjtpZihuJTIhPT0wKXtCKz1cIlxcXFxcIn19aWYoci51bmVzY2FwZT09PXRydWUpe0I9RCgpfHxcIlwifWVsc2V7Qis9RCgpfHxcIlwifWlmKE4uYnJhY2tldHM9PT0wKXtwdXNoKHt0eXBlOlwidGV4dFwiLHZhbHVlOkJ9KTtjb250aW51ZX19aWYoTi5icmFja2V0cz4wJiYoQiE9PVwiXVwifHxQLnZhbHVlPT09XCJbXCJ8fFAudmFsdWU9PT1cIlteXCIpKXtpZihyLnBvc2l4IT09ZmFsc2UmJkI9PT1cIjpcIil7Y29uc3QgZT1QLnZhbHVlLnNsaWNlKDEpO2lmKGUuaW5jbHVkZXMoXCJbXCIpKXtQLnBvc2l4PXRydWU7aWYoZS5pbmNsdWRlcyhcIjpcIikpe2NvbnN0IGU9UC52YWx1ZS5sYXN0SW5kZXhPZihcIltcIik7Y29uc3QgdD1QLnZhbHVlLnNsaWNlKDAsZSk7Y29uc3Qgcj1QLnZhbHVlLnNsaWNlKGUrMik7Y29uc3Qgbj1vW3JdO2lmKG4pe1AudmFsdWU9dCtuO04uYmFja3RyYWNrPXRydWU7RCgpO2lmKCFmLm91dHB1dCYmQS5pbmRleE9mKFApPT09MSl7Zi5vdXRwdXQ9ZH1jb250aW51ZX19fX1pZihCPT09XCJbXCImJkcoKSE9PVwiOlwifHxCPT09XCItXCImJkcoKT09PVwiXVwiKXtCPWBcXFxcJHtCfWB9aWYoQj09PVwiXVwiJiYoUC52YWx1ZT09PVwiW1wifHxQLnZhbHVlPT09XCJbXlwiKSl7Qj1gXFxcXCR7Qn1gfWlmKHIucG9zaXg9PT10cnVlJiZCPT09XCIhXCImJlAudmFsdWU9PT1cIltcIil7Qj1cIl5cIn1QLnZhbHVlKz1CO2FwcGVuZCh7dmFsdWU6Qn0pO2NvbnRpbnVlfWlmKE4ucXVvdGVzPT09MSYmQiE9PSdcIicpe0I9dS5lc2NhcGVSZWdleChCKTtQLnZhbHVlKz1CO2FwcGVuZCh7dmFsdWU6Qn0pO2NvbnRpbnVlfWlmKEI9PT0nXCInKXtOLnF1b3Rlcz1OLnF1b3Rlcz09PTE/MDoxO2lmKHIua2VlcFF1b3Rlcz09PXRydWUpe3B1c2goe3R5cGU6XCJ0ZXh0XCIsdmFsdWU6Qn0pfWNvbnRpbnVlfWlmKEI9PT1cIihcIil7aW5jcmVtZW50KFwicGFyZW5zXCIpO3B1c2goe3R5cGU6XCJwYXJlblwiLHZhbHVlOkJ9KTtjb250aW51ZX1pZihCPT09XCIpXCIpe2lmKE4ucGFyZW5zPT09MCYmci5zdHJpY3RCcmFja2V0cz09PXRydWUpe3Rocm93IG5ldyBTeW50YXhFcnJvcihzeW50YXhFcnJvcihcIm9wZW5pbmdcIixcIihcIikpfWNvbnN0IGU9a1trLmxlbmd0aC0xXTtpZihlJiZOLnBhcmVucz09PWUucGFyZW5zKzEpe2V4dGdsb2JDbG9zZShrLnBvcCgpKTtjb250aW51ZX1wdXNoKHt0eXBlOlwicGFyZW5cIix2YWx1ZTpCLG91dHB1dDpOLnBhcmVucz9cIilcIjpcIlxcXFwpXCJ9KTtkZWNyZW1lbnQoXCJwYXJlbnNcIik7Y29udGludWV9aWYoQj09PVwiW1wiKXtpZihyLm5vYnJhY2tldD09PXRydWV8fCFyZW1haW5pbmcoKS5pbmNsdWRlcyhcIl1cIikpe2lmKHIubm9icmFja2V0IT09dHJ1ZSYmci5zdHJpY3RCcmFja2V0cz09PXRydWUpe3Rocm93IG5ldyBTeW50YXhFcnJvcihzeW50YXhFcnJvcihcImNsb3NpbmdcIixcIl1cIikpfUI9YFxcXFwke0J9YH1lbHNle2luY3JlbWVudChcImJyYWNrZXRzXCIpfXB1c2goe3R5cGU6XCJicmFja2V0XCIsdmFsdWU6Qn0pO2NvbnRpbnVlfWlmKEI9PT1cIl1cIil7aWYoci5ub2JyYWNrZXQ9PT10cnVlfHxQJiZQLnR5cGU9PT1cImJyYWNrZXRcIiYmUC52YWx1ZS5sZW5ndGg9PT0xKXtwdXNoKHt0eXBlOlwidGV4dFwiLHZhbHVlOkIsb3V0cHV0OmBcXFxcJHtCfWB9KTtjb250aW51ZX1pZihOLmJyYWNrZXRzPT09MCl7aWYoci5zdHJpY3RCcmFja2V0cz09PXRydWUpe3Rocm93IG5ldyBTeW50YXhFcnJvcihzeW50YXhFcnJvcihcIm9wZW5pbmdcIixcIltcIikpfXB1c2goe3R5cGU6XCJ0ZXh0XCIsdmFsdWU6QixvdXRwdXQ6YFxcXFwke0J9YH0pO2NvbnRpbnVlfWRlY3JlbWVudChcImJyYWNrZXRzXCIpO2NvbnN0IGU9UC52YWx1ZS5zbGljZSgxKTtpZihQLnBvc2l4IT09dHJ1ZSYmZVswXT09PVwiXlwiJiYhZS5pbmNsdWRlcyhcIi9cIikpe0I9YC8ke0J9YH1QLnZhbHVlKz1CO2FwcGVuZCh7dmFsdWU6Qn0pO2lmKHIubGl0ZXJhbEJyYWNrZXRzPT09ZmFsc2V8fHUuaGFzUmVnZXhDaGFycyhlKSl7Y29udGludWV9Y29uc3QgdD11LmVzY2FwZVJlZ2V4KFAudmFsdWUpO04ub3V0cHV0PU4ub3V0cHV0LnNsaWNlKDAsLVAudmFsdWUubGVuZ3RoKTtpZihyLmxpdGVyYWxCcmFja2V0cz09PXRydWUpe04ub3V0cHV0Kz10O1AudmFsdWU9dDtjb250aW51ZX1QLnZhbHVlPWAoJHtSfSR7dH18JHtQLnZhbHVlfSlgO04ub3V0cHV0Kz1QLnZhbHVlO2NvbnRpbnVlfWlmKEI9PT1cIntcIiYmci5ub2JyYWNlIT09dHJ1ZSl7aW5jcmVtZW50KFwiYnJhY2VzXCIpO2NvbnN0IGU9e3R5cGU6XCJicmFjZVwiLHZhbHVlOkIsb3V0cHV0OlwiKFwiLG91dHB1dEluZGV4Ok4ub3V0cHV0Lmxlbmd0aCx0b2tlbnNJbmRleDpOLnRva2Vucy5sZW5ndGh9O0kucHVzaChlKTtwdXNoKGUpO2NvbnRpbnVlfWlmKEI9PT1cIn1cIil7Y29uc3QgZT1JW0kubGVuZ3RoLTFdO2lmKHIubm9icmFjZT09PXRydWV8fCFlKXtwdXNoKHt0eXBlOlwidGV4dFwiLHZhbHVlOkIsb3V0cHV0OkJ9KTtjb250aW51ZX1sZXQgdD1cIilcIjtpZihlLmRvdHM9PT10cnVlKXtjb25zdCBlPUEuc2xpY2UoKTtjb25zdCBuPVtdO2ZvcihsZXQgdD1lLmxlbmd0aC0xO3Q+PTA7dC0tKXtBLnBvcCgpO2lmKGVbdF0udHlwZT09PVwiYnJhY2VcIil7YnJlYWt9aWYoZVt0XS50eXBlIT09XCJkb3RzXCIpe24udW5zaGlmdChlW3RdLnZhbHVlKX19dD1leHBhbmRSYW5nZShuLHIpO04uYmFja3RyYWNrPXRydWV9aWYoZS5jb21tYSE9PXRydWUmJmUuZG90cyE9PXRydWUpe2NvbnN0IHI9Ti5vdXRwdXQuc2xpY2UoMCxlLm91dHB1dEluZGV4KTtjb25zdCBuPU4udG9rZW5zLnNsaWNlKGUudG9rZW5zSW5kZXgpO2UudmFsdWU9ZS5vdXRwdXQ9XCJcXFxce1wiO0I9dD1cIlxcXFx9XCI7Ti5vdXRwdXQ9cjtmb3IoY29uc3QgZSBvZiBuKXtOLm91dHB1dCs9ZS5vdXRwdXR8fGUudmFsdWV9fXB1c2goe3R5cGU6XCJicmFjZVwiLHZhbHVlOkIsb3V0cHV0OnR9KTtkZWNyZW1lbnQoXCJicmFjZXNcIik7SS5wb3AoKTtjb250aW51ZX1pZihCPT09XCJ8XCIpe2lmKGsubGVuZ3RoPjApe2tbay5sZW5ndGgtMV0uY29uZGl0aW9ucysrfXB1c2goe3R5cGU6XCJ0ZXh0XCIsdmFsdWU6Qn0pO2NvbnRpbnVlfWlmKEI9PT1cIixcIil7bGV0IGU9Qjtjb25zdCB0PUlbSS5sZW5ndGgtMV07aWYodCYmTVtNLmxlbmd0aC0xXT09PVwiYnJhY2VzXCIpe3QuY29tbWE9dHJ1ZTtlPVwifFwifXB1c2goe3R5cGU6XCJjb21tYVwiLHZhbHVlOkIsb3V0cHV0OmV9KTtjb250aW51ZX1pZihCPT09XCIvXCIpe2lmKFAudHlwZT09PVwiZG90XCImJk4uaW5kZXg9PT1OLnN0YXJ0KzEpe04uc3RhcnQ9Ti5pbmRleCsxO04uY29uc3VtZWQ9XCJcIjtOLm91dHB1dD1cIlwiO0EucG9wKCk7UD1mO2NvbnRpbnVlfXB1c2goe3R5cGU6XCJzbGFzaFwiLHZhbHVlOkIsb3V0cHV0Onl9KTtjb250aW51ZX1pZihCPT09XCIuXCIpe2lmKE4uYnJhY2VzPjAmJlAudHlwZT09PVwiZG90XCIpe2lmKFAudmFsdWU9PT1cIi5cIilQLm91dHB1dD1FO2NvbnN0IGU9SVtJLmxlbmd0aC0xXTtQLnR5cGU9XCJkb3RzXCI7UC5vdXRwdXQrPUI7UC52YWx1ZSs9QjtlLmRvdHM9dHJ1ZTtjb250aW51ZX1pZihOLmJyYWNlcytOLnBhcmVucz09PTAmJlAudHlwZSE9PVwiYm9zXCImJlAudHlwZSE9PVwic2xhc2hcIil7cHVzaCh7dHlwZTpcInRleHRcIix2YWx1ZTpCLG91dHB1dDpFfSk7Y29udGludWV9cHVzaCh7dHlwZTpcImRvdFwiLHZhbHVlOkIsb3V0cHV0OkV9KTtjb250aW51ZX1pZihCPT09XCI/XCIpe2NvbnN0IGU9UCYmUC52YWx1ZT09PVwiKFwiO2lmKCFlJiZyLm5vZXh0Z2xvYiE9PXRydWUmJkcoKT09PVwiKFwiJiZHKDIpIT09XCI/XCIpe2V4dGdsb2JPcGVuKFwicW1hcmtcIixCKTtjb250aW51ZX1pZihQJiZQLnR5cGU9PT1cInBhcmVuXCIpe2NvbnN0IGU9RygpO2xldCB0PUI7aWYoZT09PVwiPFwiJiYhdS5zdXBwb3J0c0xvb2tiZWhpbmRzKCkpe3Rocm93IG5ldyBFcnJvcihcIk5vZGUuanMgdjEwIG9yIGhpZ2hlciBpcyByZXF1aXJlZCBmb3IgcmVnZXggbG9va2JlaGluZHNcIil9aWYoUC52YWx1ZT09PVwiKFwiJiYhL1shPTw6XS8udGVzdChlKXx8ZT09PVwiPFwiJiYhLzwoWyE9XXxcXHcrPikvLnRlc3QocmVtYWluaW5nKCkpKXt0PWBcXFxcJHtCfWB9cHVzaCh7dHlwZTpcInRleHRcIix2YWx1ZTpCLG91dHB1dDp0fSk7Y29udGludWV9aWYoci5kb3QhPT10cnVlJiYoUC50eXBlPT09XCJzbGFzaFwifHxQLnR5cGU9PT1cImJvc1wiKSl7cHVzaCh7dHlwZTpcInFtYXJrXCIsdmFsdWU6QixvdXRwdXQ6JH0pO2NvbnRpbnVlfXB1c2goe3R5cGU6XCJxbWFya1wiLHZhbHVlOkIsb3V0cHV0OnZ9KTtjb250aW51ZX1pZihCPT09XCIhXCIpe2lmKHIubm9leHRnbG9iIT09dHJ1ZSYmRygpPT09XCIoXCIpe2lmKEcoMikhPT1cIj9cInx8IS9bIT08Ol0vLnRlc3QoRygzKSkpe2V4dGdsb2JPcGVuKFwibmVnYXRlXCIsQik7Y29udGludWV9fWlmKHIubm9uZWdhdGUhPT10cnVlJiZOLmluZGV4PT09MCl7bmVnYXRlKCk7Y29udGludWV9fWlmKEI9PT1cIitcIil7aWYoci5ub2V4dGdsb2IhPT10cnVlJiZHKCk9PT1cIihcIiYmRygyKSE9PVwiP1wiKXtleHRnbG9iT3BlbihcInBsdXNcIixCKTtjb250aW51ZX1pZihQJiZQLnZhbHVlPT09XCIoXCJ8fHIucmVnZXg9PT1mYWxzZSl7cHVzaCh7dHlwZTpcInBsdXNcIix2YWx1ZTpCLG91dHB1dDpDfSk7Y29udGludWV9aWYoUCYmKFAudHlwZT09PVwiYnJhY2tldFwifHxQLnR5cGU9PT1cInBhcmVuXCJ8fFAudHlwZT09PVwiYnJhY2VcIil8fE4ucGFyZW5zPjApe3B1c2goe3R5cGU6XCJwbHVzXCIsdmFsdWU6Qn0pO2NvbnRpbnVlfXB1c2goe3R5cGU6XCJwbHVzXCIsdmFsdWU6Q30pO2NvbnRpbnVlfWlmKEI9PT1cIkBcIil7aWYoci5ub2V4dGdsb2IhPT10cnVlJiZHKCk9PT1cIihcIiYmRygyKSE9PVwiP1wiKXtwdXNoKHt0eXBlOlwiYXRcIixleHRnbG9iOnRydWUsdmFsdWU6QixvdXRwdXQ6XCJcIn0pO2NvbnRpbnVlfXB1c2goe3R5cGU6XCJ0ZXh0XCIsdmFsdWU6Qn0pO2NvbnRpbnVlfWlmKEIhPT1cIipcIil7aWYoQj09PVwiJFwifHxCPT09XCJeXCIpe0I9YFxcXFwke0J9YH1jb25zdCBlPWkuZXhlYyhyZW1haW5pbmcoKSk7aWYoZSl7Qis9ZVswXTtOLmluZGV4Kz1lWzBdLmxlbmd0aH1wdXNoKHt0eXBlOlwidGV4dFwiLHZhbHVlOkJ9KTtjb250aW51ZX1pZihQJiYoUC50eXBlPT09XCJnbG9ic3RhclwifHxQLnN0YXI9PT10cnVlKSl7UC50eXBlPVwic3RhclwiO1Auc3Rhcj10cnVlO1AudmFsdWUrPUI7UC5vdXRwdXQ9dztOLmJhY2t0cmFjaz10cnVlO04uZ2xvYnN0YXI9dHJ1ZTtjb25zdW1lKEIpO2NvbnRpbnVlfWxldCB0PXJlbWFpbmluZygpO2lmKHIubm9leHRnbG9iIT09dHJ1ZSYmL15cXChbXj9dLy50ZXN0KHQpKXtleHRnbG9iT3BlbihcInN0YXJcIixCKTtjb250aW51ZX1pZihQLnR5cGU9PT1cInN0YXJcIil7aWYoci5ub2dsb2JzdGFyPT09dHJ1ZSl7Y29uc3VtZShCKTtjb250aW51ZX1jb25zdCBuPVAucHJldjtjb25zdCB1PW4ucHJldjtjb25zdCBzPW4udHlwZT09PVwic2xhc2hcInx8bi50eXBlPT09XCJib3NcIjtjb25zdCBvPXUmJih1LnR5cGU9PT1cInN0YXJcInx8dS50eXBlPT09XCJnbG9ic3RhclwiKTtpZihyLmJhc2g9PT10cnVlJiYoIXN8fHRbMF0mJnRbMF0hPT1cIi9cIikpe3B1c2goe3R5cGU6XCJzdGFyXCIsdmFsdWU6QixvdXRwdXQ6XCJcIn0pO2NvbnRpbnVlfWNvbnN0IGk9Ti5icmFjZXM+MCYmKG4udHlwZT09PVwiY29tbWFcInx8bi50eXBlPT09XCJicmFjZVwiKTtjb25zdCBhPWsubGVuZ3RoJiYobi50eXBlPT09XCJwaXBlXCJ8fG4udHlwZT09PVwicGFyZW5cIik7aWYoIXMmJm4udHlwZSE9PVwicGFyZW5cIiYmIWkmJiFhKXtwdXNoKHt0eXBlOlwic3RhclwiLHZhbHVlOkIsb3V0cHV0OlwiXCJ9KTtjb250aW51ZX13aGlsZSh0LnNsaWNlKDAsMyk9PT1cIi8qKlwiKXtjb25zdCByPWVbTi5pbmRleCs0XTtpZihyJiZyIT09XCIvXCIpe2JyZWFrfXQ9dC5zbGljZSgzKTtjb25zdW1lKFwiLyoqXCIsMyl9aWYobi50eXBlPT09XCJib3NcIiYmZW9zKCkpe1AudHlwZT1cImdsb2JzdGFyXCI7UC52YWx1ZSs9QjtQLm91dHB1dD1nbG9ic3RhcihyKTtOLm91dHB1dD1QLm91dHB1dDtOLmdsb2JzdGFyPXRydWU7Y29uc3VtZShCKTtjb250aW51ZX1pZihuLnR5cGU9PT1cInNsYXNoXCImJm4ucHJldi50eXBlIT09XCJib3NcIiYmIW8mJmVvcygpKXtOLm91dHB1dD1OLm91dHB1dC5zbGljZSgwLC0obi5vdXRwdXQrUC5vdXRwdXQpLmxlbmd0aCk7bi5vdXRwdXQ9YCg/OiR7bi5vdXRwdXR9YDtQLnR5cGU9XCJnbG9ic3RhclwiO1Aub3V0cHV0PWdsb2JzdGFyKHIpKyhyLnN0cmljdFNsYXNoZXM/XCIpXCI6XCJ8JClcIik7UC52YWx1ZSs9QjtOLmdsb2JzdGFyPXRydWU7Ti5vdXRwdXQrPW4ub3V0cHV0K1Aub3V0cHV0O2NvbnN1bWUoQik7Y29udGludWV9aWYobi50eXBlPT09XCJzbGFzaFwiJiZuLnByZXYudHlwZSE9PVwiYm9zXCImJnRbMF09PT1cIi9cIil7Y29uc3QgZT10WzFdIT09dm9pZCAwP1wifCRcIjpcIlwiO04ub3V0cHV0PU4ub3V0cHV0LnNsaWNlKDAsLShuLm91dHB1dCtQLm91dHB1dCkubGVuZ3RoKTtuLm91dHB1dD1gKD86JHtuLm91dHB1dH1gO1AudHlwZT1cImdsb2JzdGFyXCI7UC5vdXRwdXQ9YCR7Z2xvYnN0YXIocil9JHt5fXwke3l9JHtlfSlgO1AudmFsdWUrPUI7Ti5vdXRwdXQrPW4ub3V0cHV0K1Aub3V0cHV0O04uZ2xvYnN0YXI9dHJ1ZTtjb25zdW1lKEIrRCgpKTtwdXNoKHt0eXBlOlwic2xhc2hcIix2YWx1ZTpcIi9cIixvdXRwdXQ6XCJcIn0pO2NvbnRpbnVlfWlmKG4udHlwZT09PVwiYm9zXCImJnRbMF09PT1cIi9cIil7UC50eXBlPVwiZ2xvYnN0YXJcIjtQLnZhbHVlKz1CO1Aub3V0cHV0PWAoPzpefCR7eX18JHtnbG9ic3RhcihyKX0ke3l9KWA7Ti5vdXRwdXQ9UC5vdXRwdXQ7Ti5nbG9ic3Rhcj10cnVlO2NvbnN1bWUoQitEKCkpO3B1c2goe3R5cGU6XCJzbGFzaFwiLHZhbHVlOlwiL1wiLG91dHB1dDpcIlwifSk7Y29udGludWV9Ti5vdXRwdXQ9Ti5vdXRwdXQuc2xpY2UoMCwtUC5vdXRwdXQubGVuZ3RoKTtQLnR5cGU9XCJnbG9ic3RhclwiO1Aub3V0cHV0PWdsb2JzdGFyKHIpO1AudmFsdWUrPUI7Ti5vdXRwdXQrPVAub3V0cHV0O04uZ2xvYnN0YXI9dHJ1ZTtjb25zdW1lKEIpO2NvbnRpbnVlfWNvbnN0IG49e3R5cGU6XCJzdGFyXCIsdmFsdWU6QixvdXRwdXQ6d307aWYoci5iYXNoPT09dHJ1ZSl7bi5vdXRwdXQ9XCIuKj9cIjtpZihQLnR5cGU9PT1cImJvc1wifHxQLnR5cGU9PT1cInNsYXNoXCIpe24ub3V0cHV0PUwrbi5vdXRwdXR9cHVzaChuKTtjb250aW51ZX1pZihQJiYoUC50eXBlPT09XCJicmFja2V0XCJ8fFAudHlwZT09PVwicGFyZW5cIikmJnIucmVnZXg9PT10cnVlKXtuLm91dHB1dD1CO3B1c2gobik7Y29udGludWV9aWYoTi5pbmRleD09PU4uc3RhcnR8fFAudHlwZT09PVwic2xhc2hcInx8UC50eXBlPT09XCJkb3RcIil7aWYoUC50eXBlPT09XCJkb3RcIil7Ti5vdXRwdXQrPVM7UC5vdXRwdXQrPVN9ZWxzZSBpZihyLmRvdD09PXRydWUpe04ub3V0cHV0Kz1IO1Aub3V0cHV0Kz1IfWVsc2V7Ti5vdXRwdXQrPUw7UC5vdXRwdXQrPUx9aWYoRygpIT09XCIqXCIpe04ub3V0cHV0Kz1kO1Aub3V0cHV0Kz1kfX1wdXNoKG4pfXdoaWxlKE4uYnJhY2tldHM+MCl7aWYoci5zdHJpY3RCcmFja2V0cz09PXRydWUpdGhyb3cgbmV3IFN5bnRheEVycm9yKHN5bnRheEVycm9yKFwiY2xvc2luZ1wiLFwiXVwiKSk7Ti5vdXRwdXQ9dS5lc2NhcGVMYXN0KE4ub3V0cHV0LFwiW1wiKTtkZWNyZW1lbnQoXCJicmFja2V0c1wiKX13aGlsZShOLnBhcmVucz4wKXtpZihyLnN0cmljdEJyYWNrZXRzPT09dHJ1ZSl0aHJvdyBuZXcgU3ludGF4RXJyb3Ioc3ludGF4RXJyb3IoXCJjbG9zaW5nXCIsXCIpXCIpKTtOLm91dHB1dD11LmVzY2FwZUxhc3QoTi5vdXRwdXQsXCIoXCIpO2RlY3JlbWVudChcInBhcmVuc1wiKX13aGlsZShOLmJyYWNlcz4wKXtpZihyLnN0cmljdEJyYWNrZXRzPT09dHJ1ZSl0aHJvdyBuZXcgU3ludGF4RXJyb3Ioc3ludGF4RXJyb3IoXCJjbG9zaW5nXCIsXCJ9XCIpKTtOLm91dHB1dD11LmVzY2FwZUxhc3QoTi5vdXRwdXQsXCJ7XCIpO2RlY3JlbWVudChcImJyYWNlc1wiKX1pZihyLnN0cmljdFNsYXNoZXMhPT10cnVlJiYoUC50eXBlPT09XCJzdGFyXCJ8fFAudHlwZT09PVwiYnJhY2tldFwiKSl7cHVzaCh7dHlwZTpcIm1heWJlX3NsYXNoXCIsdmFsdWU6XCJcIixvdXRwdXQ6YCR7eX0/YH0pfWlmKE4uYmFja3RyYWNrPT09dHJ1ZSl7Ti5vdXRwdXQ9XCJcIjtmb3IoY29uc3QgZSBvZiBOLnRva2Vucyl7Ti5vdXRwdXQrPWUub3V0cHV0IT1udWxsP2Uub3V0cHV0OmUudmFsdWU7aWYoZS5zdWZmaXgpe04ub3V0cHV0Kz1lLnN1ZmZpeH19fXJldHVybiBOfTtwYXJzZS5mYXN0cGF0aHM9KGUsdCk9Pntjb25zdCByPXsuLi50fTtjb25zdCBvPXR5cGVvZiByLm1heExlbmd0aD09PVwibnVtYmVyXCI/TWF0aC5taW4ocyxyLm1heExlbmd0aCk6cztjb25zdCBpPWUubGVuZ3RoO2lmKGk+byl7dGhyb3cgbmV3IFN5bnRheEVycm9yKGBJbnB1dCBsZW5ndGg6ICR7aX0sIGV4Y2VlZHMgbWF4aW11bSBhbGxvd2VkIGxlbmd0aDogJHtvfWApfWU9bFtlXXx8ZTtjb25zdCBhPXUuaXNXaW5kb3dzKHQpO2NvbnN0e0RPVF9MSVRFUkFMOmMsU0xBU0hfTElURVJBTDpwLE9ORV9DSEFSOmYsRE9UU19TTEFTSDpBLE5PX0RPVDpSLE5PX0RPVFM6XyxOT19ET1RTX1NMQVNIOmgsU1RBUjpnLFNUQVJUX0FOQ0hPUjpFfT1uLmdsb2JDaGFycyhhKTtjb25zdCBDPXIuZG90P186Ujtjb25zdCB5PXIuZG90P2g6Ujtjb25zdCBkPXIuY2FwdHVyZT9cIlwiOlwiPzpcIjtjb25zdCB4PXtuZWdhdGVkOmZhbHNlLHByZWZpeDpcIlwifTtsZXQgYj1yLmJhc2g9PT10cnVlP1wiLio/XCI6ZztpZihyLmNhcHR1cmUpe2I9YCgke2J9KWB9Y29uc3QgZ2xvYnN0YXI9ZT0+e2lmKGUubm9nbG9ic3Rhcj09PXRydWUpcmV0dXJuIGI7cmV0dXJuYCgke2R9KD86KD8hJHtFfSR7ZS5kb3Q/QTpjfSkuKSo/KWB9O2NvbnN0IGNyZWF0ZT1lPT57c3dpdGNoKGUpe2Nhc2VcIipcIjpyZXR1cm5gJHtDfSR7Zn0ke2J9YDtjYXNlXCIuKlwiOnJldHVybmAke2N9JHtmfSR7Yn1gO2Nhc2VcIiouKlwiOnJldHVybmAke0N9JHtifSR7Y30ke2Z9JHtifWA7Y2FzZVwiKi8qXCI6cmV0dXJuYCR7Q30ke2J9JHtwfSR7Zn0ke3l9JHtifWA7Y2FzZVwiKipcIjpyZXR1cm4gQytnbG9ic3RhcihyKTtjYXNlXCIqKi8qXCI6cmV0dXJuYCg/OiR7Q30ke2dsb2JzdGFyKHIpfSR7cH0pPyR7eX0ke2Z9JHtifWA7Y2FzZVwiKiovKi4qXCI6cmV0dXJuYCg/OiR7Q30ke2dsb2JzdGFyKHIpfSR7cH0pPyR7eX0ke2J9JHtjfSR7Zn0ke2J9YDtjYXNlXCIqKi8uKlwiOnJldHVybmAoPzoke0N9JHtnbG9ic3RhcihyKX0ke3B9KT8ke2N9JHtmfSR7Yn1gO2RlZmF1bHQ6e2NvbnN0IHQ9L14oLio/KVxcLihcXHcrKSQvLmV4ZWMoZSk7aWYoIXQpcmV0dXJuO2NvbnN0IHI9Y3JlYXRlKHRbMV0pO2lmKCFyKXJldHVybjtyZXR1cm4gcitjK3RbMl19fX07Y29uc3QgUz11LnJlbW92ZVByZWZpeChlLHgpO2xldCBIPWNyZWF0ZShTKTtpZihIJiZyLnN0cmljdFNsYXNoZXMhPT10cnVlKXtIKz1gJHtwfT9gfXJldHVybiBIfTtlLmV4cG9ydHM9cGFyc2V9LDY4MzooZSx0LHIpPT57Y29uc3Qgbj1yKDE3KTtjb25zdCB1PXIoNzAwKTtjb25zdCBzPXIoNzU0KTtjb25zdCBvPXIoNTEzKTtjb25zdCBpPXIoMzU2KTtjb25zdCBpc09iamVjdD1lPT5lJiZ0eXBlb2YgZT09PVwib2JqZWN0XCImJiFBcnJheS5pc0FycmF5KGUpO2NvbnN0IHBpY29tYXRjaD0oZSx0LHI9ZmFsc2UpPT57aWYoQXJyYXkuaXNBcnJheShlKSl7Y29uc3Qgbj1lLm1hcCgoZT0+cGljb21hdGNoKGUsdCxyKSkpO2NvbnN0IGFycmF5TWF0Y2hlcj1lPT57Zm9yKGNvbnN0IHQgb2Ygbil7Y29uc3Qgcj10KGUpO2lmKHIpcmV0dXJuIHJ9cmV0dXJuIGZhbHNlfTtyZXR1cm4gYXJyYXlNYXRjaGVyfWNvbnN0IG49aXNPYmplY3QoZSkmJmUudG9rZW5zJiZlLmlucHV0O2lmKGU9PT1cIlwifHx0eXBlb2YgZSE9PVwic3RyaW5nXCImJiFuKXt0aHJvdyBuZXcgVHlwZUVycm9yKFwiRXhwZWN0ZWQgcGF0dGVybiB0byBiZSBhIG5vbi1lbXB0eSBzdHJpbmdcIil9Y29uc3QgdT10fHx7fTtjb25zdCBzPW8uaXNXaW5kb3dzKHQpO2NvbnN0IGk9bj9waWNvbWF0Y2guY29tcGlsZVJlKGUsdCk6cGljb21hdGNoLm1ha2VSZShlLHQsZmFsc2UsdHJ1ZSk7Y29uc3QgYT1pLnN0YXRlO2RlbGV0ZSBpLnN0YXRlO2xldCBpc0lnbm9yZWQ9KCk9PmZhbHNlO2lmKHUuaWdub3JlKXtjb25zdCBlPXsuLi50LGlnbm9yZTpudWxsLG9uTWF0Y2g6bnVsbCxvblJlc3VsdDpudWxsfTtpc0lnbm9yZWQ9cGljb21hdGNoKHUuaWdub3JlLGUscil9Y29uc3QgbWF0Y2hlcj0ocixuPWZhbHNlKT0+e2NvbnN0e2lzTWF0Y2g6byxtYXRjaDpsLG91dHB1dDpjfT1waWNvbWF0Y2gudGVzdChyLGksdCx7Z2xvYjplLHBvc2l4OnN9KTtjb25zdCBwPXtnbG9iOmUsc3RhdGU6YSxyZWdleDppLHBvc2l4OnMsaW5wdXQ6cixvdXRwdXQ6YyxtYXRjaDpsLGlzTWF0Y2g6b307aWYodHlwZW9mIHUub25SZXN1bHQ9PT1cImZ1bmN0aW9uXCIpe3Uub25SZXN1bHQocCl9aWYobz09PWZhbHNlKXtwLmlzTWF0Y2g9ZmFsc2U7cmV0dXJuIG4/cDpmYWxzZX1pZihpc0lnbm9yZWQocikpe2lmKHR5cGVvZiB1Lm9uSWdub3JlPT09XCJmdW5jdGlvblwiKXt1Lm9uSWdub3JlKHApfXAuaXNNYXRjaD1mYWxzZTtyZXR1cm4gbj9wOmZhbHNlfWlmKHR5cGVvZiB1Lm9uTWF0Y2g9PT1cImZ1bmN0aW9uXCIpe3Uub25NYXRjaChwKX1yZXR1cm4gbj9wOnRydWV9O2lmKHIpe21hdGNoZXIuc3RhdGU9YX1yZXR1cm4gbWF0Y2hlcn07cGljb21hdGNoLnRlc3Q9KGUsdCxyLHtnbG9iOm4scG9zaXg6dX09e30pPT57aWYodHlwZW9mIGUhPT1cInN0cmluZ1wiKXt0aHJvdyBuZXcgVHlwZUVycm9yKFwiRXhwZWN0ZWQgaW5wdXQgdG8gYmUgYSBzdHJpbmdcIil9aWYoZT09PVwiXCIpe3JldHVybntpc01hdGNoOmZhbHNlLG91dHB1dDpcIlwifX1jb25zdCBzPXJ8fHt9O2NvbnN0IGk9cy5mb3JtYXR8fCh1P28udG9Qb3NpeFNsYXNoZXM6bnVsbCk7bGV0IGE9ZT09PW47bGV0IGw9YSYmaT9pKGUpOmU7aWYoYT09PWZhbHNlKXtsPWk/aShlKTplO2E9bD09PW59aWYoYT09PWZhbHNlfHxzLmNhcHR1cmU9PT10cnVlKXtpZihzLm1hdGNoQmFzZT09PXRydWV8fHMuYmFzZW5hbWU9PT10cnVlKXthPXBpY29tYXRjaC5tYXRjaEJhc2UoZSx0LHIsdSl9ZWxzZXthPXQuZXhlYyhsKX19cmV0dXJue2lzTWF0Y2g6Qm9vbGVhbihhKSxtYXRjaDphLG91dHB1dDpsfX07cGljb21hdGNoLm1hdGNoQmFzZT0oZSx0LHIsdT1vLmlzV2luZG93cyhyKSk9Pntjb25zdCBzPXQgaW5zdGFuY2VvZiBSZWdFeHA/dDpwaWNvbWF0Y2gubWFrZVJlKHQscik7cmV0dXJuIHMudGVzdChuLmJhc2VuYW1lKGUpKX07cGljb21hdGNoLmlzTWF0Y2g9KGUsdCxyKT0+cGljb21hdGNoKHQscikoZSk7cGljb21hdGNoLnBhcnNlPShlLHQpPT57aWYoQXJyYXkuaXNBcnJheShlKSlyZXR1cm4gZS5tYXAoKGU9PnBpY29tYXRjaC5wYXJzZShlLHQpKSk7cmV0dXJuIHMoZSx7Li4udCxmYXN0cGF0aHM6ZmFsc2V9KX07cGljb21hdGNoLnNjYW49KGUsdCk9PnUoZSx0KTtwaWNvbWF0Y2guY29tcGlsZVJlPShlLHQscj1mYWxzZSxuPWZhbHNlKT0+e2lmKHI9PT10cnVlKXtyZXR1cm4gZS5vdXRwdXR9Y29uc3QgdT10fHx7fTtjb25zdCBzPXUuY29udGFpbnM/XCJcIjpcIl5cIjtjb25zdCBvPXUuY29udGFpbnM/XCJcIjpcIiRcIjtsZXQgaT1gJHtzfSg/OiR7ZS5vdXRwdXR9KSR7b31gO2lmKGUmJmUubmVnYXRlZD09PXRydWUpe2k9YF4oPyEke2l9KS4qJGB9Y29uc3QgYT1waWNvbWF0Y2gudG9SZWdleChpLHQpO2lmKG49PT10cnVlKXthLnN0YXRlPWV9cmV0dXJuIGF9O3BpY29tYXRjaC5tYWtlUmU9KGUsdCxyPWZhbHNlLG49ZmFsc2UpPT57aWYoIWV8fHR5cGVvZiBlIT09XCJzdHJpbmdcIil7dGhyb3cgbmV3IFR5cGVFcnJvcihcIkV4cGVjdGVkIGEgbm9uLWVtcHR5IHN0cmluZ1wiKX1jb25zdCB1PXR8fHt9O2xldCBvPXtuZWdhdGVkOmZhbHNlLGZhc3RwYXRoczp0cnVlfTtsZXQgaT1cIlwiO2xldCBhO2lmKGUuc3RhcnRzV2l0aChcIi4vXCIpKXtlPWUuc2xpY2UoMik7aT1vLnByZWZpeD1cIi4vXCJ9aWYodS5mYXN0cGF0aHMhPT1mYWxzZSYmKGVbMF09PT1cIi5cInx8ZVswXT09PVwiKlwiKSl7YT1zLmZhc3RwYXRocyhlLHQpfWlmKGE9PT11bmRlZmluZWQpe289cyhlLHQpO28ucHJlZml4PWkrKG8ucHJlZml4fHxcIlwiKX1lbHNle28ub3V0cHV0PWF9cmV0dXJuIHBpY29tYXRjaC5jb21waWxlUmUobyx0LHIsbil9O3BpY29tYXRjaC50b1JlZ2V4PShlLHQpPT57dHJ5e2NvbnN0IHI9dHx8e307cmV0dXJuIG5ldyBSZWdFeHAoZSxyLmZsYWdzfHwoci5ub2Nhc2U/XCJpXCI6XCJcIikpfWNhdGNoKGUpe2lmKHQmJnQuZGVidWc9PT10cnVlKXRocm93IGU7cmV0dXJuLyReL319O3BpY29tYXRjaC5jb25zdGFudHM9aTtlLmV4cG9ydHM9cGljb21hdGNofSw3MDA6KGUsdCxyKT0+e2NvbnN0IG49cig1MTMpO2NvbnN0e0NIQVJfQVNURVJJU0s6dSxDSEFSX0FUOnMsQ0hBUl9CQUNLV0FSRF9TTEFTSDpvLENIQVJfQ09NTUE6aSxDSEFSX0RPVDphLENIQVJfRVhDTEFNQVRJT05fTUFSSzpsLENIQVJfRk9SV0FSRF9TTEFTSDpjLENIQVJfTEVGVF9DVVJMWV9CUkFDRTpwLENIQVJfTEVGVF9QQVJFTlRIRVNFUzpmLENIQVJfTEVGVF9TUVVBUkVfQlJBQ0tFVDpBLENIQVJfUExVUzpSLENIQVJfUVVFU1RJT05fTUFSSzpfLENIQVJfUklHSFRfQ1VSTFlfQlJBQ0U6aCxDSEFSX1JJR0hUX1BBUkVOVEhFU0VTOmcsQ0hBUl9SSUdIVF9TUVVBUkVfQlJBQ0tFVDpFfT1yKDM1Nik7Y29uc3QgaXNQYXRoU2VwYXJhdG9yPWU9PmU9PT1jfHxlPT09bztjb25zdCBkZXB0aD1lPT57aWYoZS5pc1ByZWZpeCE9PXRydWUpe2UuZGVwdGg9ZS5pc0dsb2JzdGFyP0luZmluaXR5OjF9fTtjb25zdCBzY2FuPShlLHQpPT57Y29uc3Qgcj10fHx7fTtjb25zdCBDPWUubGVuZ3RoLTE7Y29uc3QgeT1yLnBhcnRzPT09dHJ1ZXx8ci5zY2FuVG9FbmQ9PT10cnVlO2NvbnN0IGQ9W107Y29uc3QgeD1bXTtjb25zdCBiPVtdO2xldCBTPWU7bGV0IEg9LTE7bGV0IHY9MDtsZXQgJD0wO2xldCBtPWZhbHNlO2xldCBUPWZhbHNlO2xldCBMPWZhbHNlO2xldCBPPWZhbHNlO2xldCB3PWZhbHNlO2xldCBOPWZhbHNlO2xldCBrPWZhbHNlO2xldCBJPWZhbHNlO2xldCBNPWZhbHNlO2xldCBQPTA7bGV0IEI7bGV0IEc7bGV0IEQ9e3ZhbHVlOlwiXCIsZGVwdGg6MCxpc0dsb2I6ZmFsc2V9O2NvbnN0IGVvcz0oKT0+SD49Qztjb25zdCBwZWVrPSgpPT5TLmNoYXJDb2RlQXQoSCsxKTtjb25zdCBhZHZhbmNlPSgpPT57Qj1HO3JldHVybiBTLmNoYXJDb2RlQXQoKytIKX07d2hpbGUoSDxDKXtHPWFkdmFuY2UoKTtsZXQgZTtpZihHPT09byl7az1ELmJhY2tzbGFzaGVzPXRydWU7Rz1hZHZhbmNlKCk7aWYoRz09PXApe049dHJ1ZX1jb250aW51ZX1pZihOPT09dHJ1ZXx8Rz09PXApe1ArKzt3aGlsZShlb3MoKSE9PXRydWUmJihHPWFkdmFuY2UoKSkpe2lmKEc9PT1vKXtrPUQuYmFja3NsYXNoZXM9dHJ1ZTthZHZhbmNlKCk7Y29udGludWV9aWYoRz09PXApe1ArKztjb250aW51ZX1pZihOIT09dHJ1ZSYmRz09PWEmJihHPWFkdmFuY2UoKSk9PT1hKXttPUQuaXNCcmFjZT10cnVlO0w9RC5pc0dsb2I9dHJ1ZTtNPXRydWU7aWYoeT09PXRydWUpe2NvbnRpbnVlfWJyZWFrfWlmKE4hPT10cnVlJiZHPT09aSl7bT1ELmlzQnJhY2U9dHJ1ZTtMPUQuaXNHbG9iPXRydWU7TT10cnVlO2lmKHk9PT10cnVlKXtjb250aW51ZX1icmVha31pZihHPT09aCl7UC0tO2lmKFA9PT0wKXtOPWZhbHNlO209RC5pc0JyYWNlPXRydWU7TT10cnVlO2JyZWFrfX19aWYoeT09PXRydWUpe2NvbnRpbnVlfWJyZWFrfWlmKEc9PT1jKXtkLnB1c2goSCk7eC5wdXNoKEQpO0Q9e3ZhbHVlOlwiXCIsZGVwdGg6MCxpc0dsb2I6ZmFsc2V9O2lmKE09PT10cnVlKWNvbnRpbnVlO2lmKEI9PT1hJiZIPT09disxKXt2Kz0yO2NvbnRpbnVlfSQ9SCsxO2NvbnRpbnVlfWlmKHIubm9leHQhPT10cnVlKXtjb25zdCBlPUc9PT1SfHxHPT09c3x8Rz09PXV8fEc9PT1ffHxHPT09bDtpZihlPT09dHJ1ZSYmcGVlaygpPT09Zil7TD1ELmlzR2xvYj10cnVlO089RC5pc0V4dGdsb2I9dHJ1ZTtNPXRydWU7aWYoeT09PXRydWUpe3doaWxlKGVvcygpIT09dHJ1ZSYmKEc9YWR2YW5jZSgpKSl7aWYoRz09PW8pe2s9RC5iYWNrc2xhc2hlcz10cnVlO0c9YWR2YW5jZSgpO2NvbnRpbnVlfWlmKEc9PT1nKXtMPUQuaXNHbG9iPXRydWU7TT10cnVlO2JyZWFrfX1jb250aW51ZX1icmVha319aWYoRz09PXUpe2lmKEI9PT11KXc9RC5pc0dsb2JzdGFyPXRydWU7TD1ELmlzR2xvYj10cnVlO009dHJ1ZTtpZih5PT09dHJ1ZSl7Y29udGludWV9YnJlYWt9aWYoRz09PV8pe0w9RC5pc0dsb2I9dHJ1ZTtNPXRydWU7aWYoeT09PXRydWUpe2NvbnRpbnVlfWJyZWFrfWlmKEc9PT1BKXt3aGlsZShlb3MoKSE9PXRydWUmJihlPWFkdmFuY2UoKSkpe2lmKGU9PT1vKXtrPUQuYmFja3NsYXNoZXM9dHJ1ZTthZHZhbmNlKCk7Y29udGludWV9aWYoZT09PUUpe1Q9RC5pc0JyYWNrZXQ9dHJ1ZTtMPUQuaXNHbG9iPXRydWU7TT10cnVlO2JyZWFrfX1pZih5PT09dHJ1ZSl7Y29udGludWV9YnJlYWt9aWYoci5ub25lZ2F0ZSE9PXRydWUmJkc9PT1sJiZIPT09dil7ST1ELm5lZ2F0ZWQ9dHJ1ZTt2Kys7Y29udGludWV9aWYoci5ub3BhcmVuIT09dHJ1ZSYmRz09PWYpe0w9RC5pc0dsb2I9dHJ1ZTtpZih5PT09dHJ1ZSl7d2hpbGUoZW9zKCkhPT10cnVlJiYoRz1hZHZhbmNlKCkpKXtpZihHPT09Zil7az1ELmJhY2tzbGFzaGVzPXRydWU7Rz1hZHZhbmNlKCk7Y29udGludWV9aWYoRz09PWcpe009dHJ1ZTticmVha319Y29udGludWV9YnJlYWt9aWYoTD09PXRydWUpe009dHJ1ZTtpZih5PT09dHJ1ZSl7Y29udGludWV9YnJlYWt9fWlmKHIubm9leHQ9PT10cnVlKXtPPWZhbHNlO0w9ZmFsc2V9bGV0IFU9UztsZXQgSz1cIlwiO2xldCBGPVwiXCI7aWYodj4wKXtLPVMuc2xpY2UoMCx2KTtTPVMuc2xpY2Uodik7JC09dn1pZihVJiZMPT09dHJ1ZSYmJD4wKXtVPVMuc2xpY2UoMCwkKTtGPVMuc2xpY2UoJCl9ZWxzZSBpZihMPT09dHJ1ZSl7VT1cIlwiO0Y9U31lbHNle1U9U31pZihVJiZVIT09XCJcIiYmVSE9PVwiL1wiJiZVIT09Uyl7aWYoaXNQYXRoU2VwYXJhdG9yKFUuY2hhckNvZGVBdChVLmxlbmd0aC0xKSkpe1U9VS5zbGljZSgwLC0xKX19aWYoci51bmVzY2FwZT09PXRydWUpe2lmKEYpRj1uLnJlbW92ZUJhY2tzbGFzaGVzKEYpO2lmKFUmJms9PT10cnVlKXtVPW4ucmVtb3ZlQmFja3NsYXNoZXMoVSl9fWNvbnN0IFE9e3ByZWZpeDpLLGlucHV0OmUsc3RhcnQ6dixiYXNlOlUsZ2xvYjpGLGlzQnJhY2U6bSxpc0JyYWNrZXQ6VCxpc0dsb2I6TCxpc0V4dGdsb2I6Tyxpc0dsb2JzdGFyOncsbmVnYXRlZDpJfTtpZihyLnRva2Vucz09PXRydWUpe1EubWF4RGVwdGg9MDtpZighaXNQYXRoU2VwYXJhdG9yKEcpKXt4LnB1c2goRCl9US50b2tlbnM9eH1pZihyLnBhcnRzPT09dHJ1ZXx8ci50b2tlbnM9PT10cnVlKXtsZXQgdDtmb3IobGV0IG49MDtuPGQubGVuZ3RoO24rKyl7Y29uc3QgdT10P3QrMTp2O2NvbnN0IHM9ZFtuXTtjb25zdCBvPWUuc2xpY2UodSxzKTtpZihyLnRva2Vucyl7aWYobj09PTAmJnYhPT0wKXt4W25dLmlzUHJlZml4PXRydWU7eFtuXS52YWx1ZT1LfWVsc2V7eFtuXS52YWx1ZT1vfWRlcHRoKHhbbl0pO1EubWF4RGVwdGgrPXhbbl0uZGVwdGh9aWYobiE9PTB8fG8hPT1cIlwiKXtiLnB1c2gobyl9dD1zfWlmKHQmJnQrMTxlLmxlbmd0aCl7Y29uc3Qgbj1lLnNsaWNlKHQrMSk7Yi5wdXNoKG4pO2lmKHIudG9rZW5zKXt4W3gubGVuZ3RoLTFdLnZhbHVlPW47ZGVwdGgoeFt4Lmxlbmd0aC0xXSk7US5tYXhEZXB0aCs9eFt4Lmxlbmd0aC0xXS5kZXB0aH19US5zbGFzaGVzPWQ7US5wYXJ0cz1ifXJldHVybiBRfTtlLmV4cG9ydHM9c2Nhbn0sNTEzOihlLHQscik9Pntjb25zdCBuPXIoMTcpO2NvbnN0IHU9cHJvY2Vzcy5wbGF0Zm9ybT09PVwid2luMzJcIjtjb25zdHtSRUdFWF9CQUNLU0xBU0g6cyxSRUdFWF9SRU1PVkVfQkFDS1NMQVNIOm8sUkVHRVhfU1BFQ0lBTF9DSEFSUzppLFJFR0VYX1NQRUNJQUxfQ0hBUlNfR0xPQkFMOmF9PXIoMzU2KTt0LmlzT2JqZWN0PWU9PmUhPT1udWxsJiZ0eXBlb2YgZT09PVwib2JqZWN0XCImJiFBcnJheS5pc0FycmF5KGUpO3QuaGFzUmVnZXhDaGFycz1lPT5pLnRlc3QoZSk7dC5pc1JlZ2V4Q2hhcj1lPT5lLmxlbmd0aD09PTEmJnQuaGFzUmVnZXhDaGFycyhlKTt0LmVzY2FwZVJlZ2V4PWU9PmUucmVwbGFjZShhLFwiXFxcXCQxXCIpO3QudG9Qb3NpeFNsYXNoZXM9ZT0+ZS5yZXBsYWNlKHMsXCIvXCIpO3QucmVtb3ZlQmFja3NsYXNoZXM9ZT0+ZS5yZXBsYWNlKG8sKGU9PmU9PT1cIlxcXFxcIj9cIlwiOmUpKTt0LnN1cHBvcnRzTG9va2JlaGluZHM9KCk9Pntjb25zdCBlPXByb2Nlc3MudmVyc2lvbi5zbGljZSgxKS5zcGxpdChcIi5cIikubWFwKE51bWJlcik7aWYoZS5sZW5ndGg9PT0zJiZlWzBdPj05fHxlWzBdPT09OCYmZVsxXT49MTApe3JldHVybiB0cnVlfXJldHVybiBmYWxzZX07dC5pc1dpbmRvd3M9ZT0+e2lmKGUmJnR5cGVvZiBlLndpbmRvd3M9PT1cImJvb2xlYW5cIil7cmV0dXJuIGUud2luZG93c31yZXR1cm4gdT09PXRydWV8fG4uc2VwPT09XCJcXFxcXCJ9O3QuZXNjYXBlTGFzdD0oZSxyLG4pPT57Y29uc3QgdT1lLmxhc3RJbmRleE9mKHIsbik7aWYodT09PS0xKXJldHVybiBlO2lmKGVbdS0xXT09PVwiXFxcXFwiKXJldHVybiB0LmVzY2FwZUxhc3QoZSxyLHUtMSk7cmV0dXJuYCR7ZS5zbGljZSgwLHUpfVxcXFwke2Uuc2xpY2UodSl9YH07dC5yZW1vdmVQcmVmaXg9KGUsdD17fSk9PntsZXQgcj1lO2lmKHIuc3RhcnRzV2l0aChcIi4vXCIpKXtyPXIuc2xpY2UoMik7dC5wcmVmaXg9XCIuL1wifXJldHVybiByfTt0LndyYXBPdXRwdXQ9KGUsdD17fSxyPXt9KT0+e2NvbnN0IG49ci5jb250YWlucz9cIlwiOlwiXlwiO2NvbnN0IHU9ci5jb250YWlucz9cIlwiOlwiJFwiO2xldCBzPWAke259KD86JHtlfSkke3V9YDtpZih0Lm5lZ2F0ZWQ9PT10cnVlKXtzPWAoPzpeKD8hJHtzfSkuKiQpYH1yZXR1cm4gc319LDQ5MjooZSx0LHIpPT57XG4vKiFcbiAqIHRvLXJlZ2V4LXJhbmdlIDxodHRwczovL2dpdGh1Yi5jb20vbWljcm9tYXRjaC90by1yZWdleC1yYW5nZT5cbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUtcHJlc2VudCwgSm9uIFNjaGxpbmtlcnQuXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKi9cbmNvbnN0IG49cigzNTcpO2NvbnN0IHRvUmVnZXhSYW5nZT0oZSx0LHIpPT57aWYobihlKT09PWZhbHNlKXt0aHJvdyBuZXcgVHlwZUVycm9yKFwidG9SZWdleFJhbmdlOiBleHBlY3RlZCB0aGUgZmlyc3QgYXJndW1lbnQgdG8gYmUgYSBudW1iZXJcIil9aWYodD09PXZvaWQgMHx8ZT09PXQpe3JldHVybiBTdHJpbmcoZSl9aWYobih0KT09PWZhbHNlKXt0aHJvdyBuZXcgVHlwZUVycm9yKFwidG9SZWdleFJhbmdlOiBleHBlY3RlZCB0aGUgc2Vjb25kIGFyZ3VtZW50IHRvIGJlIGEgbnVtYmVyLlwiKX1sZXQgdT17cmVsYXhaZXJvczp0cnVlLC4uLnJ9O2lmKHR5cGVvZiB1LnN0cmljdFplcm9zPT09XCJib29sZWFuXCIpe3UucmVsYXhaZXJvcz11LnN0cmljdFplcm9zPT09ZmFsc2V9bGV0IHM9U3RyaW5nKHUucmVsYXhaZXJvcyk7bGV0IG89U3RyaW5nKHUuc2hvcnRoYW5kKTtsZXQgaT1TdHJpbmcodS5jYXB0dXJlKTtsZXQgYT1TdHJpbmcodS53cmFwKTtsZXQgbD1lK1wiOlwiK3QrXCI9XCIrcytvK2krYTtpZih0b1JlZ2V4UmFuZ2UuY2FjaGUuaGFzT3duUHJvcGVydHkobCkpe3JldHVybiB0b1JlZ2V4UmFuZ2UuY2FjaGVbbF0ucmVzdWx0fWxldCBjPU1hdGgubWluKGUsdCk7bGV0IHA9TWF0aC5tYXgoZSx0KTtpZihNYXRoLmFicyhjLXApPT09MSl7bGV0IHI9ZStcInxcIit0O2lmKHUuY2FwdHVyZSl7cmV0dXJuYCgke3J9KWB9aWYodS53cmFwPT09ZmFsc2Upe3JldHVybiByfXJldHVybmAoPzoke3J9KWB9bGV0IGY9aGFzUGFkZGluZyhlKXx8aGFzUGFkZGluZyh0KTtsZXQgQT17bWluOmUsbWF4OnQsYTpjLGI6cH07bGV0IFI9W107bGV0IF89W107aWYoZil7QS5pc1BhZGRlZD1mO0EubWF4TGVuPVN0cmluZyhBLm1heCkubGVuZ3RofWlmKGM8MCl7bGV0IGU9cDwwP01hdGguYWJzKHApOjE7Xz1zcGxpdFRvUGF0dGVybnMoZSxNYXRoLmFicyhjKSxBLHUpO2M9QS5hPTB9aWYocD49MCl7Uj1zcGxpdFRvUGF0dGVybnMoYyxwLEEsdSl9QS5uZWdhdGl2ZXM9XztBLnBvc2l0aXZlcz1SO0EucmVzdWx0PWNvbGxhdGVQYXR0ZXJucyhfLFIsdSk7aWYodS5jYXB0dXJlPT09dHJ1ZSl7QS5yZXN1bHQ9YCgke0EucmVzdWx0fSlgfWVsc2UgaWYodS53cmFwIT09ZmFsc2UmJlIubGVuZ3RoK18ubGVuZ3RoPjEpe0EucmVzdWx0PWAoPzoke0EucmVzdWx0fSlgfXRvUmVnZXhSYW5nZS5jYWNoZVtsXT1BO3JldHVybiBBLnJlc3VsdH07ZnVuY3Rpb24gY29sbGF0ZVBhdHRlcm5zKGUsdCxyKXtsZXQgbj1maWx0ZXJQYXR0ZXJucyhlLHQsXCItXCIsZmFsc2Uscil8fFtdO2xldCB1PWZpbHRlclBhdHRlcm5zKHQsZSxcIlwiLGZhbHNlLHIpfHxbXTtsZXQgcz1maWx0ZXJQYXR0ZXJucyhlLHQsXCItP1wiLHRydWUscil8fFtdO2xldCBvPW4uY29uY2F0KHMpLmNvbmNhdCh1KTtyZXR1cm4gby5qb2luKFwifFwiKX1mdW5jdGlvbiBzcGxpdFRvUmFuZ2VzKGUsdCl7bGV0IHI9MTtsZXQgbj0xO2xldCB1PWNvdW50TmluZXMoZSxyKTtsZXQgcz1uZXcgU2V0KFt0XSk7d2hpbGUoZTw9dSYmdTw9dCl7cy5hZGQodSk7cis9MTt1PWNvdW50TmluZXMoZSxyKX11PWNvdW50WmVyb3ModCsxLG4pLTE7d2hpbGUoZTx1JiZ1PD10KXtzLmFkZCh1KTtuKz0xO3U9Y291bnRaZXJvcyh0KzEsbiktMX1zPVsuLi5zXTtzLnNvcnQoY29tcGFyZSk7cmV0dXJuIHN9ZnVuY3Rpb24gcmFuZ2VUb1BhdHRlcm4oZSx0LHIpe2lmKGU9PT10KXtyZXR1cm57cGF0dGVybjplLGNvdW50OltdLGRpZ2l0czowfX1sZXQgbj16aXAoZSx0KTtsZXQgdT1uLmxlbmd0aDtsZXQgcz1cIlwiO2xldCBvPTA7Zm9yKGxldCBlPTA7ZTx1O2UrKyl7bGV0W3QsdV09bltlXTtpZih0PT09dSl7cys9dH1lbHNlIGlmKHQhPT1cIjBcInx8dSE9PVwiOVwiKXtzKz10b0NoYXJhY3RlckNsYXNzKHQsdSxyKX1lbHNle28rK319aWYobyl7cys9ci5zaG9ydGhhbmQ9PT10cnVlP1wiXFxcXGRcIjpcIlswLTldXCJ9cmV0dXJue3BhdHRlcm46cyxjb3VudDpbb10sZGlnaXRzOnV9fWZ1bmN0aW9uIHNwbGl0VG9QYXR0ZXJucyhlLHQscixuKXtsZXQgdT1zcGxpdFRvUmFuZ2VzKGUsdCk7bGV0IHM9W107bGV0IG89ZTtsZXQgaTtmb3IobGV0IGU9MDtlPHUubGVuZ3RoO2UrKyl7bGV0IHQ9dVtlXTtsZXQgYT1yYW5nZVRvUGF0dGVybihTdHJpbmcobyksU3RyaW5nKHQpLG4pO2xldCBsPVwiXCI7aWYoIXIuaXNQYWRkZWQmJmkmJmkucGF0dGVybj09PWEucGF0dGVybil7aWYoaS5jb3VudC5sZW5ndGg+MSl7aS5jb3VudC5wb3AoKX1pLmNvdW50LnB1c2goYS5jb3VudFswXSk7aS5zdHJpbmc9aS5wYXR0ZXJuK3RvUXVhbnRpZmllcihpLmNvdW50KTtvPXQrMTtjb250aW51ZX1pZihyLmlzUGFkZGVkKXtsPXBhZFplcm9zKHQscixuKX1hLnN0cmluZz1sK2EucGF0dGVybit0b1F1YW50aWZpZXIoYS5jb3VudCk7cy5wdXNoKGEpO289dCsxO2k9YX1yZXR1cm4gc31mdW5jdGlvbiBmaWx0ZXJQYXR0ZXJucyhlLHQscixuLHUpe2xldCBzPVtdO2ZvcihsZXQgdSBvZiBlKXtsZXR7c3RyaW5nOmV9PXU7aWYoIW4mJiFjb250YWlucyh0LFwic3RyaW5nXCIsZSkpe3MucHVzaChyK2UpfWlmKG4mJmNvbnRhaW5zKHQsXCJzdHJpbmdcIixlKSl7cy5wdXNoKHIrZSl9fXJldHVybiBzfWZ1bmN0aW9uIHppcChlLHQpe2xldCByPVtdO2ZvcihsZXQgbj0wO248ZS5sZW5ndGg7bisrKXIucHVzaChbZVtuXSx0W25dXSk7cmV0dXJuIHJ9ZnVuY3Rpb24gY29tcGFyZShlLHQpe3JldHVybiBlPnQ/MTp0PmU/LTE6MH1mdW5jdGlvbiBjb250YWlucyhlLHQscil7cmV0dXJuIGUuc29tZSgoZT0+ZVt0XT09PXIpKX1mdW5jdGlvbiBjb3VudE5pbmVzKGUsdCl7cmV0dXJuIE51bWJlcihTdHJpbmcoZSkuc2xpY2UoMCwtdCkrXCI5XCIucmVwZWF0KHQpKX1mdW5jdGlvbiBjb3VudFplcm9zKGUsdCl7cmV0dXJuIGUtZSVNYXRoLnBvdygxMCx0KX1mdW5jdGlvbiB0b1F1YW50aWZpZXIoZSl7bGV0W3Q9MCxyPVwiXCJdPWU7aWYocnx8dD4xKXtyZXR1cm5geyR7dCsocj9cIixcIityOlwiXCIpfX1gfXJldHVyblwiXCJ9ZnVuY3Rpb24gdG9DaGFyYWN0ZXJDbGFzcyhlLHQscil7cmV0dXJuYFske2V9JHt0LWU9PT0xP1wiXCI6XCItXCJ9JHt0fV1gfWZ1bmN0aW9uIGhhc1BhZGRpbmcoZSl7cmV0dXJuL14tPygwKylcXGQvLnRlc3QoZSl9ZnVuY3Rpb24gcGFkWmVyb3MoZSx0LHIpe2lmKCF0LmlzUGFkZGVkKXtyZXR1cm4gZX1sZXQgbj1NYXRoLmFicyh0Lm1heExlbi1TdHJpbmcoZSkubGVuZ3RoKTtsZXQgdT1yLnJlbGF4WmVyb3MhPT1mYWxzZTtzd2l0Y2gobil7Y2FzZSAwOnJldHVyblwiXCI7Y2FzZSAxOnJldHVybiB1P1wiMD9cIjpcIjBcIjtjYXNlIDI6cmV0dXJuIHU/XCIwezAsMn1cIjpcIjAwXCI7ZGVmYXVsdDp7cmV0dXJuIHU/YDB7MCwke259fWA6YDB7JHtufX1gfX19dG9SZWdleFJhbmdlLmNhY2hlPXt9O3RvUmVnZXhSYW5nZS5jbGVhckNhY2hlPSgpPT50b1JlZ2V4UmFuZ2UuY2FjaGU9e307ZS5leHBvcnRzPXRvUmVnZXhSYW5nZX0sMTc6ZT0+e2UuZXhwb3J0cz1yZXF1aXJlKFwicGF0aFwiKX0sODM3OmU9PntlLmV4cG9ydHM9cmVxdWlyZShcInV0aWxcIil9fTt2YXIgdD17fTtmdW5jdGlvbiBfX25jY3dwY2tfcmVxdWlyZV9fKHIpe3ZhciBuPXRbcl07aWYobiE9PXVuZGVmaW5lZCl7cmV0dXJuIG4uZXhwb3J0c312YXIgdT10W3JdPXtleHBvcnRzOnt9fTt2YXIgcz10cnVlO3RyeXtlW3JdKHUsdS5leHBvcnRzLF9fbmNjd3Bja19yZXF1aXJlX18pO3M9ZmFsc2V9ZmluYWxseXtpZihzKWRlbGV0ZSB0W3JdfXJldHVybiB1LmV4cG9ydHN9aWYodHlwZW9mIF9fbmNjd3Bja19yZXF1aXJlX18hPT1cInVuZGVmaW5lZFwiKV9fbmNjd3Bja19yZXF1aXJlX18uYWI9X19kaXJuYW1lK1wiL1wiO3ZhciByPV9fbmNjd3Bja19yZXF1aXJlX18oOTcxKTttb2R1bGUuZXhwb3J0cz1yfSkoKTsiXSwibmFtZXMiOlsiZSIsInQiLCJyIiwibiIsInUiLCJzIiwibyIsImJyYWNlcyIsIkFycmF5IiwiaXNBcnJheSIsImNyZWF0ZSIsInB1c2giLCJjb25jYXQiLCJleHBhbmQiLCJub2R1cGVzIiwiU2V0IiwicGFyc2UiLCJzdHJpbmdpZnkiLCJjb21waWxlIiwibm9lbXB0eSIsImZpbHRlciIsIkJvb2xlYW4iLCJsZW5ndGgiLCJleHBvcnRzIiwid2FsayIsImlzSW52YWxpZEJyYWNlIiwiaW52YWxpZCIsImVzY2FwZUludmFsaWQiLCJpIiwiYSIsImwiLCJpc09wZW4iLCJ2YWx1ZSIsImlzQ2xvc2UiLCJ0eXBlIiwicHJldiIsIm5vZGVzIiwicmFuZ2VzIiwicmVkdWNlIiwid3JhcCIsInRvUmVnZXgiLCJNQVhfTEVOR1RIIiwiQ0hBUl8wIiwiQ0hBUl85IiwiQ0hBUl9VUFBFUkNBU0VfQSIsIkNIQVJfTE9XRVJDQVNFX0EiLCJDSEFSX1VQUEVSQ0FTRV9aIiwiQ0hBUl9MT1dFUkNBU0VfWiIsIkNIQVJfTEVGVF9QQVJFTlRIRVNFUyIsIkNIQVJfUklHSFRfUEFSRU5USEVTRVMiLCJDSEFSX0FTVEVSSVNLIiwiQ0hBUl9BTVBFUlNBTkQiLCJDSEFSX0FUIiwiQ0hBUl9CQUNLU0xBU0giLCJDSEFSX0JBQ0tUSUNLIiwiQ0hBUl9DQVJSSUFHRV9SRVRVUk4iLCJDSEFSX0NJUkNVTUZMRVhfQUNDRU5UIiwiQ0hBUl9DT0xPTiIsIkNIQVJfQ09NTUEiLCJDSEFSX0RPTExBUiIsIkNIQVJfRE9UIiwiQ0hBUl9ET1VCTEVfUVVPVEUiLCJDSEFSX0VRVUFMIiwiQ0hBUl9FWENMQU1BVElPTl9NQVJLIiwiQ0hBUl9GT1JNX0ZFRUQiLCJDSEFSX0ZPUldBUkRfU0xBU0giLCJDSEFSX0hBU0giLCJDSEFSX0hZUEhFTl9NSU5VUyIsIkNIQVJfTEVGVF9BTkdMRV9CUkFDS0VUIiwiQ0hBUl9MRUZUX0NVUkxZX0JSQUNFIiwiQ0hBUl9MRUZUX1NRVUFSRV9CUkFDS0VUIiwiQ0hBUl9MSU5FX0ZFRUQiLCJDSEFSX05PX0JSRUFLX1NQQUNFIiwiQ0hBUl9QRVJDRU5UIiwiQ0hBUl9QTFVTIiwiQ0hBUl9RVUVTVElPTl9NQVJLIiwiQ0hBUl9SSUdIVF9BTkdMRV9CUkFDS0VUIiwiQ0hBUl9SSUdIVF9DVVJMWV9CUkFDRSIsIkNIQVJfUklHSFRfU1FVQVJFX0JSQUNLRVQiLCJDSEFSX1NFTUlDT0xPTiIsIkNIQVJfU0lOR0xFX1FVT1RFIiwiQ0hBUl9TUEFDRSIsIkNIQVJfVEFCIiwiQ0hBUl9VTkRFUlNDT1JFIiwiQ0hBUl9WRVJUSUNBTF9MSU5FIiwiQ0hBUl9aRVJPX1dJRFRIX05PQlJFQUtfU1BBQ0UiLCJhcHBlbmQiLCJmbGF0dGVuIiwibWFwIiwicmFuZ2VMaW1pdCIsInF1ZXVlIiwicGFyZW50IiwiZG9sbGFyIiwicG9wIiwiZXhjZWVkc0xpbWl0Iiwic3RlcCIsIlJhbmdlRXJyb3IiLCJlbmNsb3NlQnJhY2UiLCJjIiwicCIsImYiLCJBIiwiUiIsIl8iLCJoIiwiZyIsIkUiLCJUeXBlRXJyb3IiLCJDIiwibWF4TGVuZ3RoIiwiTWF0aCIsIm1pbiIsIlN5bnRheEVycm9yIiwieSIsImlucHV0IiwiZCIsIngiLCJiIiwiUyIsIkgiLCJ2IiwiJCIsIm0iLCJUIiwiYWR2YW5jZSIsImtlZXBFc2NhcGluZyIsImtlZXBRdW90ZXMiLCJzbGljZSIsIm9wZW4iLCJjbG9zZSIsImRlcHRoIiwiY29tbWFzIiwic2hpZnQiLCJyYW5nZSIsImFyZ3MiLCJmb3JFYWNoIiwiaW5kZXhPZiIsInNwbGljZSIsImlzT3Blbk9yQ2xvc2UiLCJpc0ludGVnZXIiLCJOdW1iZXIiLCJ0cmltIiwiZmluZCIsImVzY2FwZU5vZGUiLCJlc2NhcGVkIiwiZmxhdCIsImlzT2JqZWN0IiwidHJhbnNmb3JtIiwiU3RyaW5nIiwiaXNWYWxpZFZhbHVlIiwiaXNOdW1iZXIiLCJ6ZXJvcyIsInBhZCIsInBhZFN0YXJ0IiwidG9NYXhMZW4iLCJ0b1NlcXVlbmNlIiwibmVnYXRpdmVzIiwic29ydCIsInBvc2l0aXZlcyIsImNhcHR1cmUiLCJqb2luIiwidG9SYW5nZSIsImZyb21DaGFyQ29kZSIsInJhbmdlRXJyb3IiLCJpbnNwZWN0IiwiaW52YWxpZFJhbmdlIiwic3RyaWN0UmFuZ2VzIiwiaW52YWxpZFN0ZXAiLCJmaWxsTnVtYmVycyIsIm1heCIsImFicyIsImZpbGxMZXR0ZXJzIiwiY2hhckNvZGVBdCIsIm9wdGlvbnMiLCJmaWxsIiwiaXNGaW5pdGUiLCJpc0VtcHR5U3RyaW5nIiwibWljcm9tYXRjaCIsIm9uUmVzdWx0IiwiYWRkIiwib3V0cHV0Iiwic3RhdGUiLCJuZWdhdGVkIiwibmVnYXRlZEV4dGdsb2IiLCJpc01hdGNoIiwiZGVsZXRlIiwiaGFzIiwiZmFpbGdsb2IiLCJFcnJvciIsIm5vbnVsbCIsIm51bGxnbG9iIiwidW5lc2NhcGUiLCJyZXBsYWNlIiwibWF0Y2giLCJtYXRjaGVyIiwiYW55Iiwibm90IiwiaW5jbHVkZXMiLCJjb250YWlucyIsInNvbWUiLCJzdGFydHNXaXRoIiwibWF0Y2hLZXlzIiwiT2JqZWN0Iiwia2V5cyIsImV2ZXJ5IiwiYWxsIiwiaXNXaW5kb3dzIiwibWFrZVJlIiwiZXhlYyIsInRvUG9zaXhTbGFzaGVzIiwic2NhbiIsIm5vYnJhY2UiLCJ0ZXN0IiwiYnJhY2VFeHBhbmQiLCJET1RfTElURVJBTCIsIlBMVVNfTElURVJBTCIsIlFNQVJLX0xJVEVSQUwiLCJTTEFTSF9MSVRFUkFMIiwiT05FX0NIQVIiLCJRTUFSSyIsIkVORF9BTkNIT1IiLCJET1RTX1NMQVNIIiwiTk9fRE9UIiwiTk9fRE9UUyIsIk5PX0RPVF9TTEFTSCIsIk5PX0RPVFNfU0xBU0giLCJRTUFSS19OT19ET1QiLCJTVEFSIiwiU1RBUlRfQU5DSE9SIiwiYWxudW0iLCJhbHBoYSIsImFzY2lpIiwiYmxhbmsiLCJjbnRybCIsImRpZ2l0IiwiZ3JhcGgiLCJsb3dlciIsInByaW50IiwicHVuY3QiLCJzcGFjZSIsInVwcGVyIiwid29yZCIsInhkaWdpdCIsIlBPU0lYX1JFR0VYX1NPVVJDRSIsIlJFR0VYX0JBQ0tTTEFTSCIsIlJFR0VYX05PTl9TUEVDSUFMX0NIQVJTIiwiUkVHRVhfU1BFQ0lBTF9DSEFSUyIsIlJFR0VYX1NQRUNJQUxfQ0hBUlNfQkFDS1JFRiIsIlJFR0VYX1NQRUNJQUxfQ0hBUlNfR0xPQkFMIiwiUkVHRVhfUkVNT1ZFX0JBQ0tTTEFTSCIsIlJFUExBQ0VNRU5UUyIsIkNIQVJfQkFDS1dBUkRfU0xBU0giLCJDSEFSX0dSQVZFX0FDQ0VOVCIsIlNFUCIsInNlcCIsImV4dGdsb2JDaGFycyIsImdsb2JDaGFycyIsImV4cGFuZFJhbmdlIiwiUmVnRXhwIiwiZXNjYXBlUmVnZXgiLCJzeW50YXhFcnJvciIsInByZXBlbmQiLCJnbG9ic3RhciIsImRvdCIsIkwiLCJPIiwidyIsImJhc2giLCJub2V4dCIsIm5vZXh0Z2xvYiIsIk4iLCJpbmRleCIsInN0YXJ0IiwiY29uc3VtZWQiLCJwcmVmaXgiLCJiYWNrdHJhY2siLCJicmFja2V0cyIsInBhcmVucyIsInF1b3RlcyIsInRva2VucyIsInJlbW92ZVByZWZpeCIsImsiLCJJIiwiTSIsIlAiLCJCIiwiZW9zIiwiRyIsInBlZWsiLCJEIiwicmVtYWluaW5nIiwiY29uc3VtZSIsIm5lZ2F0ZSIsImluY3JlbWVudCIsImRlY3JlbWVudCIsImV4dGdsb2IiLCJpbm5lciIsImV4dGdsb2JPcGVuIiwiY29uZGl0aW9ucyIsImV4dGdsb2JDbG9zZSIsImZhc3RwYXRocyIsInJlcGVhdCIsIndyYXBPdXRwdXQiLCJwb3NpeCIsImxhc3RJbmRleE9mIiwic3RyaWN0QnJhY2tldHMiLCJub2JyYWNrZXQiLCJsaXRlcmFsQnJhY2tldHMiLCJoYXNSZWdleENoYXJzIiwib3V0cHV0SW5kZXgiLCJ0b2tlbnNJbmRleCIsImRvdHMiLCJ1bnNoaWZ0IiwiY29tbWEiLCJzdXBwb3J0c0xvb2tiZWhpbmRzIiwibm9uZWdhdGUiLCJyZWdleCIsInN0YXIiLCJub2dsb2JzdGFyIiwic3RyaWN0U2xhc2hlcyIsImVzY2FwZUxhc3QiLCJzdWZmaXgiLCJwaWNvbWF0Y2giLCJhcnJheU1hdGNoZXIiLCJjb21waWxlUmUiLCJpc0lnbm9yZWQiLCJpZ25vcmUiLCJvbk1hdGNoIiwiZ2xvYiIsIm9uSWdub3JlIiwiZm9ybWF0IiwibWF0Y2hCYXNlIiwiYmFzZW5hbWUiLCJ1bmRlZmluZWQiLCJmbGFncyIsIm5vY2FzZSIsImRlYnVnIiwiY29uc3RhbnRzIiwiaXNQYXRoU2VwYXJhdG9yIiwiaXNQcmVmaXgiLCJpc0dsb2JzdGFyIiwiSW5maW5pdHkiLCJwYXJ0cyIsInNjYW5Ub0VuZCIsImlzR2xvYiIsImJhY2tzbGFzaGVzIiwiaXNCcmFjZSIsImlzRXh0Z2xvYiIsImlzQnJhY2tldCIsIm5vcGFyZW4iLCJVIiwiSyIsIkYiLCJyZW1vdmVCYWNrc2xhc2hlcyIsIlEiLCJiYXNlIiwibWF4RGVwdGgiLCJzbGFzaGVzIiwicHJvY2VzcyIsInBsYXRmb3JtIiwiaXNSZWdleENoYXIiLCJ2ZXJzaW9uIiwic3BsaXQiLCJ3aW5kb3dzIiwidG9SZWdleFJhbmdlIiwicmVsYXhaZXJvcyIsInN0cmljdFplcm9zIiwic2hvcnRoYW5kIiwiY2FjaGUiLCJoYXNPd25Qcm9wZXJ0eSIsInJlc3VsdCIsImhhc1BhZGRpbmciLCJpc1BhZGRlZCIsIm1heExlbiIsInNwbGl0VG9QYXR0ZXJucyIsImNvbGxhdGVQYXR0ZXJucyIsImZpbHRlclBhdHRlcm5zIiwic3BsaXRUb1JhbmdlcyIsImNvdW50TmluZXMiLCJjb3VudFplcm9zIiwiY29tcGFyZSIsInJhbmdlVG9QYXR0ZXJuIiwicGF0dGVybiIsImNvdW50IiwiZGlnaXRzIiwiemlwIiwidG9DaGFyYWN0ZXJDbGFzcyIsInN0cmluZyIsInRvUXVhbnRpZmllciIsInBhZFplcm9zIiwicG93IiwiY2xlYXJDYWNoZSIsInJlcXVpcmUiLCJfX25jY3dwY2tfcmVxdWlyZV9fIiwiYWIiLCJfX2Rpcm5hbWUiLCJtb2R1bGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/micromatch/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/path-browserify/index.js":
/*!******************************************************************!*\
  !*** ./node_modules/next/dist/compiled/path-browserify/index.js ***!
  \******************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var __dirname = \"/\";\n\n(function() {\n    \"use strict\";\n    var e = {\n        114: function(e) {\n            function assertPath(e) {\n                if (typeof e !== \"string\") {\n                    throw new TypeError(\"Path must be a string. Received \" + JSON.stringify(e));\n                }\n            }\n            function normalizeStringPosix(e, r) {\n                var t = \"\";\n                var i = 0;\n                var n = -1;\n                var a = 0;\n                var f;\n                for(var l = 0; l <= e.length; ++l){\n                    if (l < e.length) f = e.charCodeAt(l);\n                    else if (f === 47) break;\n                    else f = 47;\n                    if (f === 47) {\n                        if (n === l - 1 || a === 1) {} else if (n !== l - 1 && a === 2) {\n                            if (t.length < 2 || i !== 2 || t.charCodeAt(t.length - 1) !== 46 || t.charCodeAt(t.length - 2) !== 46) {\n                                if (t.length > 2) {\n                                    var s = t.lastIndexOf(\"/\");\n                                    if (s !== t.length - 1) {\n                                        if (s === -1) {\n                                            t = \"\";\n                                            i = 0;\n                                        } else {\n                                            t = t.slice(0, s);\n                                            i = t.length - 1 - t.lastIndexOf(\"/\");\n                                        }\n                                        n = l;\n                                        a = 0;\n                                        continue;\n                                    }\n                                } else if (t.length === 2 || t.length === 1) {\n                                    t = \"\";\n                                    i = 0;\n                                    n = l;\n                                    a = 0;\n                                    continue;\n                                }\n                            }\n                            if (r) {\n                                if (t.length > 0) t += \"/..\";\n                                else t = \"..\";\n                                i = 2;\n                            }\n                        } else {\n                            if (t.length > 0) t += \"/\" + e.slice(n + 1, l);\n                            else t = e.slice(n + 1, l);\n                            i = l - n - 1;\n                        }\n                        n = l;\n                        a = 0;\n                    } else if (f === 46 && a !== -1) {\n                        ++a;\n                    } else {\n                        a = -1;\n                    }\n                }\n                return t;\n            }\n            function _format(e, r) {\n                var t = r.dir || r.root;\n                var i = r.base || (r.name || \"\") + (r.ext || \"\");\n                if (!t) {\n                    return i;\n                }\n                if (t === r.root) {\n                    return t + i;\n                }\n                return t + e + i;\n            }\n            var r = {\n                resolve: function resolve() {\n                    var e = \"\";\n                    var r = false;\n                    var t;\n                    for(var i = arguments.length - 1; i >= -1 && !r; i--){\n                        var n;\n                        if (i >= 0) n = arguments[i];\n                        else {\n                            if (t === undefined) t = \"\";\n                            n = t;\n                        }\n                        assertPath(n);\n                        if (n.length === 0) {\n                            continue;\n                        }\n                        e = n + \"/\" + e;\n                        r = n.charCodeAt(0) === 47;\n                    }\n                    e = normalizeStringPosix(e, !r);\n                    if (r) {\n                        if (e.length > 0) return \"/\" + e;\n                        else return \"/\";\n                    } else if (e.length > 0) {\n                        return e;\n                    } else {\n                        return \".\";\n                    }\n                },\n                normalize: function normalize(e) {\n                    assertPath(e);\n                    if (e.length === 0) return \".\";\n                    var r = e.charCodeAt(0) === 47;\n                    var t = e.charCodeAt(e.length - 1) === 47;\n                    e = normalizeStringPosix(e, !r);\n                    if (e.length === 0 && !r) e = \".\";\n                    if (e.length > 0 && t) e += \"/\";\n                    if (r) return \"/\" + e;\n                    return e;\n                },\n                isAbsolute: function isAbsolute(e) {\n                    assertPath(e);\n                    return e.length > 0 && e.charCodeAt(0) === 47;\n                },\n                join: function join() {\n                    if (arguments.length === 0) return \".\";\n                    var e;\n                    for(var t = 0; t < arguments.length; ++t){\n                        var i = arguments[t];\n                        assertPath(i);\n                        if (i.length > 0) {\n                            if (e === undefined) e = i;\n                            else e += \"/\" + i;\n                        }\n                    }\n                    if (e === undefined) return \".\";\n                    return r.normalize(e);\n                },\n                relative: function relative(e, t) {\n                    assertPath(e);\n                    assertPath(t);\n                    if (e === t) return \"\";\n                    e = r.resolve(e);\n                    t = r.resolve(t);\n                    if (e === t) return \"\";\n                    var i = 1;\n                    for(; i < e.length; ++i){\n                        if (e.charCodeAt(i) !== 47) break;\n                    }\n                    var n = e.length;\n                    var a = n - i;\n                    var f = 1;\n                    for(; f < t.length; ++f){\n                        if (t.charCodeAt(f) !== 47) break;\n                    }\n                    var l = t.length;\n                    var s = l - f;\n                    var o = a < s ? a : s;\n                    var u = -1;\n                    var h = 0;\n                    for(; h <= o; ++h){\n                        if (h === o) {\n                            if (s > o) {\n                                if (t.charCodeAt(f + h) === 47) {\n                                    return t.slice(f + h + 1);\n                                } else if (h === 0) {\n                                    return t.slice(f + h);\n                                }\n                            } else if (a > o) {\n                                if (e.charCodeAt(i + h) === 47) {\n                                    u = h;\n                                } else if (h === 0) {\n                                    u = 0;\n                                }\n                            }\n                            break;\n                        }\n                        var c = e.charCodeAt(i + h);\n                        var v = t.charCodeAt(f + h);\n                        if (c !== v) break;\n                        else if (c === 47) u = h;\n                    }\n                    var g = \"\";\n                    for(h = i + u + 1; h <= n; ++h){\n                        if (h === n || e.charCodeAt(h) === 47) {\n                            if (g.length === 0) g += \"..\";\n                            else g += \"/..\";\n                        }\n                    }\n                    if (g.length > 0) return g + t.slice(f + u);\n                    else {\n                        f += u;\n                        if (t.charCodeAt(f) === 47) ++f;\n                        return t.slice(f);\n                    }\n                },\n                _makeLong: function _makeLong(e) {\n                    return e;\n                },\n                dirname: function dirname(e) {\n                    assertPath(e);\n                    if (e.length === 0) return \".\";\n                    var r = e.charCodeAt(0);\n                    var t = r === 47;\n                    var i = -1;\n                    var n = true;\n                    for(var a = e.length - 1; a >= 1; --a){\n                        r = e.charCodeAt(a);\n                        if (r === 47) {\n                            if (!n) {\n                                i = a;\n                                break;\n                            }\n                        } else {\n                            n = false;\n                        }\n                    }\n                    if (i === -1) return t ? \"/\" : \".\";\n                    if (t && i === 1) return \"//\";\n                    return e.slice(0, i);\n                },\n                basename: function basename(e, r) {\n                    if (r !== undefined && typeof r !== \"string\") throw new TypeError('\"ext\" argument must be a string');\n                    assertPath(e);\n                    var t = 0;\n                    var i = -1;\n                    var n = true;\n                    var a;\n                    if (r !== undefined && r.length > 0 && r.length <= e.length) {\n                        if (r.length === e.length && r === e) return \"\";\n                        var f = r.length - 1;\n                        var l = -1;\n                        for(a = e.length - 1; a >= 0; --a){\n                            var s = e.charCodeAt(a);\n                            if (s === 47) {\n                                if (!n) {\n                                    t = a + 1;\n                                    break;\n                                }\n                            } else {\n                                if (l === -1) {\n                                    n = false;\n                                    l = a + 1;\n                                }\n                                if (f >= 0) {\n                                    if (s === r.charCodeAt(f)) {\n                                        if (--f === -1) {\n                                            i = a;\n                                        }\n                                    } else {\n                                        f = -1;\n                                        i = l;\n                                    }\n                                }\n                            }\n                        }\n                        if (t === i) i = l;\n                        else if (i === -1) i = e.length;\n                        return e.slice(t, i);\n                    } else {\n                        for(a = e.length - 1; a >= 0; --a){\n                            if (e.charCodeAt(a) === 47) {\n                                if (!n) {\n                                    t = a + 1;\n                                    break;\n                                }\n                            } else if (i === -1) {\n                                n = false;\n                                i = a + 1;\n                            }\n                        }\n                        if (i === -1) return \"\";\n                        return e.slice(t, i);\n                    }\n                },\n                extname: function extname(e) {\n                    assertPath(e);\n                    var r = -1;\n                    var t = 0;\n                    var i = -1;\n                    var n = true;\n                    var a = 0;\n                    for(var f = e.length - 1; f >= 0; --f){\n                        var l = e.charCodeAt(f);\n                        if (l === 47) {\n                            if (!n) {\n                                t = f + 1;\n                                break;\n                            }\n                            continue;\n                        }\n                        if (i === -1) {\n                            n = false;\n                            i = f + 1;\n                        }\n                        if (l === 46) {\n                            if (r === -1) r = f;\n                            else if (a !== 1) a = 1;\n                        } else if (r !== -1) {\n                            a = -1;\n                        }\n                    }\n                    if (r === -1 || i === -1 || a === 0 || a === 1 && r === i - 1 && r === t + 1) {\n                        return \"\";\n                    }\n                    return e.slice(r, i);\n                },\n                format: function format(e) {\n                    if (e === null || typeof e !== \"object\") {\n                        throw new TypeError('The \"pathObject\" argument must be of type Object. Received type ' + typeof e);\n                    }\n                    return _format(\"/\", e);\n                },\n                parse: function parse(e) {\n                    assertPath(e);\n                    var r = {\n                        root: \"\",\n                        dir: \"\",\n                        base: \"\",\n                        ext: \"\",\n                        name: \"\"\n                    };\n                    if (e.length === 0) return r;\n                    var t = e.charCodeAt(0);\n                    var i = t === 47;\n                    var n;\n                    if (i) {\n                        r.root = \"/\";\n                        n = 1;\n                    } else {\n                        n = 0;\n                    }\n                    var a = -1;\n                    var f = 0;\n                    var l = -1;\n                    var s = true;\n                    var o = e.length - 1;\n                    var u = 0;\n                    for(; o >= n; --o){\n                        t = e.charCodeAt(o);\n                        if (t === 47) {\n                            if (!s) {\n                                f = o + 1;\n                                break;\n                            }\n                            continue;\n                        }\n                        if (l === -1) {\n                            s = false;\n                            l = o + 1;\n                        }\n                        if (t === 46) {\n                            if (a === -1) a = o;\n                            else if (u !== 1) u = 1;\n                        } else if (a !== -1) {\n                            u = -1;\n                        }\n                    }\n                    if (a === -1 || l === -1 || u === 0 || u === 1 && a === l - 1 && a === f + 1) {\n                        if (l !== -1) {\n                            if (f === 0 && i) r.base = r.name = e.slice(1, l);\n                            else r.base = r.name = e.slice(f, l);\n                        }\n                    } else {\n                        if (f === 0 && i) {\n                            r.name = e.slice(1, a);\n                            r.base = e.slice(1, l);\n                        } else {\n                            r.name = e.slice(f, a);\n                            r.base = e.slice(f, l);\n                        }\n                        r.ext = e.slice(a, l);\n                    }\n                    if (f > 0) r.dir = e.slice(0, f - 1);\n                    else if (i) r.dir = \"/\";\n                    return r;\n                },\n                sep: \"/\",\n                delimiter: \":\",\n                win32: null,\n                posix: null\n            };\n            r.posix = r;\n            e.exports = r;\n        }\n    };\n    var r = {};\n    function __nccwpck_require__(t) {\n        var i = r[t];\n        if (i !== undefined) {\n            return i.exports;\n        }\n        var n = r[t] = {\n            exports: {}\n        };\n        var a = true;\n        try {\n            e[t](n, n.exports, __nccwpck_require__);\n            a = false;\n        } finally{\n            if (a) delete r[t];\n        }\n        return n.exports;\n    }\n    if (typeof __nccwpck_require__ !== \"undefined\") __nccwpck_require__.ab = __dirname + \"/\";\n    var t = __nccwpck_require__(114);\n    module.exports = t;\n})();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcGF0aC1icm93c2VyaWZ5L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7O0FBQUM7SUFBVztJQUFhLElBQUlBLElBQUU7UUFBQyxLQUFJLFNBQVNBLENBQUM7WUFBRSxTQUFTQyxXQUFXRCxDQUFDO2dCQUFFLElBQUcsT0FBT0EsTUFBSSxVQUFTO29CQUFDLE1BQU0sSUFBSUUsVUFBVSxxQ0FBbUNDLEtBQUtDLFNBQVMsQ0FBQ0o7Z0JBQUc7WUFBQztZQUFDLFNBQVNLLHFCQUFxQkwsQ0FBQyxFQUFDTSxDQUFDO2dCQUFFLElBQUlDLElBQUU7Z0JBQUcsSUFBSUMsSUFBRTtnQkFBRSxJQUFJQyxJQUFFLENBQUM7Z0JBQUUsSUFBSUMsSUFBRTtnQkFBRSxJQUFJQztnQkFBRSxJQUFJLElBQUlDLElBQUUsR0FBRUEsS0FBR1osRUFBRWEsTUFBTSxFQUFDLEVBQUVELEVBQUU7b0JBQUMsSUFBR0EsSUFBRVosRUFBRWEsTUFBTSxFQUFDRixJQUFFWCxFQUFFYyxVQUFVLENBQUNGO3lCQUFRLElBQUdELE1BQUksSUFBRzt5QkFBV0EsSUFBRTtvQkFBRyxJQUFHQSxNQUFJLElBQUc7d0JBQUMsSUFBR0YsTUFBSUcsSUFBRSxLQUFHRixNQUFJLEdBQUUsQ0FBQyxPQUFNLElBQUdELE1BQUlHLElBQUUsS0FBR0YsTUFBSSxHQUFFOzRCQUFDLElBQUdILEVBQUVNLE1BQU0sR0FBQyxLQUFHTCxNQUFJLEtBQUdELEVBQUVPLFVBQVUsQ0FBQ1AsRUFBRU0sTUFBTSxHQUFDLE9BQUssTUFBSU4sRUFBRU8sVUFBVSxDQUFDUCxFQUFFTSxNQUFNLEdBQUMsT0FBSyxJQUFHO2dDQUFDLElBQUdOLEVBQUVNLE1BQU0sR0FBQyxHQUFFO29DQUFDLElBQUlFLElBQUVSLEVBQUVTLFdBQVcsQ0FBQztvQ0FBSyxJQUFHRCxNQUFJUixFQUFFTSxNQUFNLEdBQUMsR0FBRTt3Q0FBQyxJQUFHRSxNQUFJ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QUFFK0MsT0FBTyxHQUFDekM7UUFBQztJQUFDO0lBQUUsSUFBSUEsSUFBRSxDQUFDO0lBQUUsU0FBUzBDLG9CQUFvQnpDLENBQUM7UUFBRSxJQUFJQyxJQUFFRixDQUFDLENBQUNDLEVBQUU7UUFBQyxJQUFHQyxNQUFJa0IsV0FBVTtZQUFDLE9BQU9sQixFQUFFdUMsT0FBTztRQUFBO1FBQUMsSUFBSXRDLElBQUVILENBQUMsQ0FBQ0MsRUFBRSxHQUFDO1lBQUN3QyxTQUFRLENBQUM7UUFBQztRQUFFLElBQUlyQyxJQUFFO1FBQUssSUFBRztZQUFDVixDQUFDLENBQUNPLEVBQUUsQ0FBQ0UsR0FBRUEsRUFBRXNDLE9BQU8sRUFBQ0M7WUFBcUJ0QyxJQUFFO1FBQUssU0FBUTtZQUFDLElBQUdBLEdBQUUsT0FBT0osQ0FBQyxDQUFDQyxFQUFFO1FBQUE7UUFBQyxPQUFPRSxFQUFFc0MsT0FBTztJQUFBO0lBQUMsSUFBRyxPQUFPQyx3QkFBc0IsYUFBWUEsb0JBQW9CQyxFQUFFLEdBQUNDLFNBQVNBLEdBQUM7SUFBSSxJQUFJM0MsSUFBRXlDLG9CQUFvQjtJQUFLRyxPQUFPSixPQUFPLEdBQUN4QztBQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcGF0aC1icm93c2VyaWZ5L2luZGV4LmpzPzNjZDEiXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uKCl7XCJ1c2Ugc3RyaWN0XCI7dmFyIGU9ezExNDpmdW5jdGlvbihlKXtmdW5jdGlvbiBhc3NlcnRQYXRoKGUpe2lmKHR5cGVvZiBlIT09XCJzdHJpbmdcIil7dGhyb3cgbmV3IFR5cGVFcnJvcihcIlBhdGggbXVzdCBiZSBhIHN0cmluZy4gUmVjZWl2ZWQgXCIrSlNPTi5zdHJpbmdpZnkoZSkpfX1mdW5jdGlvbiBub3JtYWxpemVTdHJpbmdQb3NpeChlLHIpe3ZhciB0PVwiXCI7dmFyIGk9MDt2YXIgbj0tMTt2YXIgYT0wO3ZhciBmO2Zvcih2YXIgbD0wO2w8PWUubGVuZ3RoOysrbCl7aWYobDxlLmxlbmd0aClmPWUuY2hhckNvZGVBdChsKTtlbHNlIGlmKGY9PT00NylicmVhaztlbHNlIGY9NDc7aWYoZj09PTQ3KXtpZihuPT09bC0xfHxhPT09MSl7fWVsc2UgaWYobiE9PWwtMSYmYT09PTIpe2lmKHQubGVuZ3RoPDJ8fGkhPT0yfHx0LmNoYXJDb2RlQXQodC5sZW5ndGgtMSkhPT00Nnx8dC5jaGFyQ29kZUF0KHQubGVuZ3RoLTIpIT09NDYpe2lmKHQubGVuZ3RoPjIpe3ZhciBzPXQubGFzdEluZGV4T2YoXCIvXCIpO2lmKHMhPT10Lmxlbmd0aC0xKXtpZihzPT09LTEpe3Q9XCJcIjtpPTB9ZWxzZXt0PXQuc2xpY2UoMCxzKTtpPXQubGVuZ3RoLTEtdC5sYXN0SW5kZXhPZihcIi9cIil9bj1sO2E9MDtjb250aW51ZX19ZWxzZSBpZih0Lmxlbmd0aD09PTJ8fHQubGVuZ3RoPT09MSl7dD1cIlwiO2k9MDtuPWw7YT0wO2NvbnRpbnVlfX1pZihyKXtpZih0Lmxlbmd0aD4wKXQrPVwiLy4uXCI7ZWxzZSB0PVwiLi5cIjtpPTJ9fWVsc2V7aWYodC5sZW5ndGg+MCl0Kz1cIi9cIitlLnNsaWNlKG4rMSxsKTtlbHNlIHQ9ZS5zbGljZShuKzEsbCk7aT1sLW4tMX1uPWw7YT0wfWVsc2UgaWYoZj09PTQ2JiZhIT09LTEpeysrYX1lbHNle2E9LTF9fXJldHVybiB0fWZ1bmN0aW9uIF9mb3JtYXQoZSxyKXt2YXIgdD1yLmRpcnx8ci5yb290O3ZhciBpPXIuYmFzZXx8KHIubmFtZXx8XCJcIikrKHIuZXh0fHxcIlwiKTtpZighdCl7cmV0dXJuIGl9aWYodD09PXIucm9vdCl7cmV0dXJuIHQraX1yZXR1cm4gdCtlK2l9dmFyIHI9e3Jlc29sdmU6ZnVuY3Rpb24gcmVzb2x2ZSgpe3ZhciBlPVwiXCI7dmFyIHI9ZmFsc2U7dmFyIHQ7Zm9yKHZhciBpPWFyZ3VtZW50cy5sZW5ndGgtMTtpPj0tMSYmIXI7aS0tKXt2YXIgbjtpZihpPj0wKW49YXJndW1lbnRzW2ldO2Vsc2V7aWYodD09PXVuZGVmaW5lZCl0PVwiXCI7bj10fWFzc2VydFBhdGgobik7aWYobi5sZW5ndGg9PT0wKXtjb250aW51ZX1lPW4rXCIvXCIrZTtyPW4uY2hhckNvZGVBdCgwKT09PTQ3fWU9bm9ybWFsaXplU3RyaW5nUG9zaXgoZSwhcik7aWYocil7aWYoZS5sZW5ndGg+MClyZXR1cm5cIi9cIitlO2Vsc2UgcmV0dXJuXCIvXCJ9ZWxzZSBpZihlLmxlbmd0aD4wKXtyZXR1cm4gZX1lbHNle3JldHVyblwiLlwifX0sbm9ybWFsaXplOmZ1bmN0aW9uIG5vcm1hbGl6ZShlKXthc3NlcnRQYXRoKGUpO2lmKGUubGVuZ3RoPT09MClyZXR1cm5cIi5cIjt2YXIgcj1lLmNoYXJDb2RlQXQoMCk9PT00Nzt2YXIgdD1lLmNoYXJDb2RlQXQoZS5sZW5ndGgtMSk9PT00NztlPW5vcm1hbGl6ZVN0cmluZ1Bvc2l4KGUsIXIpO2lmKGUubGVuZ3RoPT09MCYmIXIpZT1cIi5cIjtpZihlLmxlbmd0aD4wJiZ0KWUrPVwiL1wiO2lmKHIpcmV0dXJuXCIvXCIrZTtyZXR1cm4gZX0saXNBYnNvbHV0ZTpmdW5jdGlvbiBpc0Fic29sdXRlKGUpe2Fzc2VydFBhdGgoZSk7cmV0dXJuIGUubGVuZ3RoPjAmJmUuY2hhckNvZGVBdCgwKT09PTQ3fSxqb2luOmZ1bmN0aW9uIGpvaW4oKXtpZihhcmd1bWVudHMubGVuZ3RoPT09MClyZXR1cm5cIi5cIjt2YXIgZTtmb3IodmFyIHQ9MDt0PGFyZ3VtZW50cy5sZW5ndGg7Kyt0KXt2YXIgaT1hcmd1bWVudHNbdF07YXNzZXJ0UGF0aChpKTtpZihpLmxlbmd0aD4wKXtpZihlPT09dW5kZWZpbmVkKWU9aTtlbHNlIGUrPVwiL1wiK2l9fWlmKGU9PT11bmRlZmluZWQpcmV0dXJuXCIuXCI7cmV0dXJuIHIubm9ybWFsaXplKGUpfSxyZWxhdGl2ZTpmdW5jdGlvbiByZWxhdGl2ZShlLHQpe2Fzc2VydFBhdGgoZSk7YXNzZXJ0UGF0aCh0KTtpZihlPT09dClyZXR1cm5cIlwiO2U9ci5yZXNvbHZlKGUpO3Q9ci5yZXNvbHZlKHQpO2lmKGU9PT10KXJldHVyblwiXCI7dmFyIGk9MTtmb3IoO2k8ZS5sZW5ndGg7KytpKXtpZihlLmNoYXJDb2RlQXQoaSkhPT00NylicmVha312YXIgbj1lLmxlbmd0aDt2YXIgYT1uLWk7dmFyIGY9MTtmb3IoO2Y8dC5sZW5ndGg7KytmKXtpZih0LmNoYXJDb2RlQXQoZikhPT00NylicmVha312YXIgbD10Lmxlbmd0aDt2YXIgcz1sLWY7dmFyIG89YTxzP2E6czt2YXIgdT0tMTt2YXIgaD0wO2Zvcig7aDw9bzsrK2gpe2lmKGg9PT1vKXtpZihzPm8pe2lmKHQuY2hhckNvZGVBdChmK2gpPT09NDcpe3JldHVybiB0LnNsaWNlKGYraCsxKX1lbHNlIGlmKGg9PT0wKXtyZXR1cm4gdC5zbGljZShmK2gpfX1lbHNlIGlmKGE+byl7aWYoZS5jaGFyQ29kZUF0KGkraCk9PT00Nyl7dT1ofWVsc2UgaWYoaD09PTApe3U9MH19YnJlYWt9dmFyIGM9ZS5jaGFyQ29kZUF0KGkraCk7dmFyIHY9dC5jaGFyQ29kZUF0KGYraCk7aWYoYyE9PXYpYnJlYWs7ZWxzZSBpZihjPT09NDcpdT1ofXZhciBnPVwiXCI7Zm9yKGg9aSt1KzE7aDw9bjsrK2gpe2lmKGg9PT1ufHxlLmNoYXJDb2RlQXQoaCk9PT00Nyl7aWYoZy5sZW5ndGg9PT0wKWcrPVwiLi5cIjtlbHNlIGcrPVwiLy4uXCJ9fWlmKGcubGVuZ3RoPjApcmV0dXJuIGcrdC5zbGljZShmK3UpO2Vsc2V7Zis9dTtpZih0LmNoYXJDb2RlQXQoZik9PT00NykrK2Y7cmV0dXJuIHQuc2xpY2UoZil9fSxfbWFrZUxvbmc6ZnVuY3Rpb24gX21ha2VMb25nKGUpe3JldHVybiBlfSxkaXJuYW1lOmZ1bmN0aW9uIGRpcm5hbWUoZSl7YXNzZXJ0UGF0aChlKTtpZihlLmxlbmd0aD09PTApcmV0dXJuXCIuXCI7dmFyIHI9ZS5jaGFyQ29kZUF0KDApO3ZhciB0PXI9PT00Nzt2YXIgaT0tMTt2YXIgbj10cnVlO2Zvcih2YXIgYT1lLmxlbmd0aC0xO2E+PTE7LS1hKXtyPWUuY2hhckNvZGVBdChhKTtpZihyPT09NDcpe2lmKCFuKXtpPWE7YnJlYWt9fWVsc2V7bj1mYWxzZX19aWYoaT09PS0xKXJldHVybiB0P1wiL1wiOlwiLlwiO2lmKHQmJmk9PT0xKXJldHVyblwiLy9cIjtyZXR1cm4gZS5zbGljZSgwLGkpfSxiYXNlbmFtZTpmdW5jdGlvbiBiYXNlbmFtZShlLHIpe2lmKHIhPT11bmRlZmluZWQmJnR5cGVvZiByIT09XCJzdHJpbmdcIil0aHJvdyBuZXcgVHlwZUVycm9yKCdcImV4dFwiIGFyZ3VtZW50IG11c3QgYmUgYSBzdHJpbmcnKTthc3NlcnRQYXRoKGUpO3ZhciB0PTA7dmFyIGk9LTE7dmFyIG49dHJ1ZTt2YXIgYTtpZihyIT09dW5kZWZpbmVkJiZyLmxlbmd0aD4wJiZyLmxlbmd0aDw9ZS5sZW5ndGgpe2lmKHIubGVuZ3RoPT09ZS5sZW5ndGgmJnI9PT1lKXJldHVyblwiXCI7dmFyIGY9ci5sZW5ndGgtMTt2YXIgbD0tMTtmb3IoYT1lLmxlbmd0aC0xO2E+PTA7LS1hKXt2YXIgcz1lLmNoYXJDb2RlQXQoYSk7aWYocz09PTQ3KXtpZighbil7dD1hKzE7YnJlYWt9fWVsc2V7aWYobD09PS0xKXtuPWZhbHNlO2w9YSsxfWlmKGY+PTApe2lmKHM9PT1yLmNoYXJDb2RlQXQoZikpe2lmKC0tZj09PS0xKXtpPWF9fWVsc2V7Zj0tMTtpPWx9fX19aWYodD09PWkpaT1sO2Vsc2UgaWYoaT09PS0xKWk9ZS5sZW5ndGg7cmV0dXJuIGUuc2xpY2UodCxpKX1lbHNle2ZvcihhPWUubGVuZ3RoLTE7YT49MDstLWEpe2lmKGUuY2hhckNvZGVBdChhKT09PTQ3KXtpZighbil7dD1hKzE7YnJlYWt9fWVsc2UgaWYoaT09PS0xKXtuPWZhbHNlO2k9YSsxfX1pZihpPT09LTEpcmV0dXJuXCJcIjtyZXR1cm4gZS5zbGljZSh0LGkpfX0sZXh0bmFtZTpmdW5jdGlvbiBleHRuYW1lKGUpe2Fzc2VydFBhdGgoZSk7dmFyIHI9LTE7dmFyIHQ9MDt2YXIgaT0tMTt2YXIgbj10cnVlO3ZhciBhPTA7Zm9yKHZhciBmPWUubGVuZ3RoLTE7Zj49MDstLWYpe3ZhciBsPWUuY2hhckNvZGVBdChmKTtpZihsPT09NDcpe2lmKCFuKXt0PWYrMTticmVha31jb250aW51ZX1pZihpPT09LTEpe249ZmFsc2U7aT1mKzF9aWYobD09PTQ2KXtpZihyPT09LTEpcj1mO2Vsc2UgaWYoYSE9PTEpYT0xfWVsc2UgaWYociE9PS0xKXthPS0xfX1pZihyPT09LTF8fGk9PT0tMXx8YT09PTB8fGE9PT0xJiZyPT09aS0xJiZyPT09dCsxKXtyZXR1cm5cIlwifXJldHVybiBlLnNsaWNlKHIsaSl9LGZvcm1hdDpmdW5jdGlvbiBmb3JtYXQoZSl7aWYoZT09PW51bGx8fHR5cGVvZiBlIT09XCJvYmplY3RcIil7dGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwicGF0aE9iamVjdFwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBPYmplY3QuIFJlY2VpdmVkIHR5cGUgJyt0eXBlb2YgZSl9cmV0dXJuIF9mb3JtYXQoXCIvXCIsZSl9LHBhcnNlOmZ1bmN0aW9uIHBhcnNlKGUpe2Fzc2VydFBhdGgoZSk7dmFyIHI9e3Jvb3Q6XCJcIixkaXI6XCJcIixiYXNlOlwiXCIsZXh0OlwiXCIsbmFtZTpcIlwifTtpZihlLmxlbmd0aD09PTApcmV0dXJuIHI7dmFyIHQ9ZS5jaGFyQ29kZUF0KDApO3ZhciBpPXQ9PT00Nzt2YXIgbjtpZihpKXtyLnJvb3Q9XCIvXCI7bj0xfWVsc2V7bj0wfXZhciBhPS0xO3ZhciBmPTA7dmFyIGw9LTE7dmFyIHM9dHJ1ZTt2YXIgbz1lLmxlbmd0aC0xO3ZhciB1PTA7Zm9yKDtvPj1uOy0tbyl7dD1lLmNoYXJDb2RlQXQobyk7aWYodD09PTQ3KXtpZighcyl7Zj1vKzE7YnJlYWt9Y29udGludWV9aWYobD09PS0xKXtzPWZhbHNlO2w9bysxfWlmKHQ9PT00Nil7aWYoYT09PS0xKWE9bztlbHNlIGlmKHUhPT0xKXU9MX1lbHNlIGlmKGEhPT0tMSl7dT0tMX19aWYoYT09PS0xfHxsPT09LTF8fHU9PT0wfHx1PT09MSYmYT09PWwtMSYmYT09PWYrMSl7aWYobCE9PS0xKXtpZihmPT09MCYmaSlyLmJhc2U9ci5uYW1lPWUuc2xpY2UoMSxsKTtlbHNlIHIuYmFzZT1yLm5hbWU9ZS5zbGljZShmLGwpfX1lbHNle2lmKGY9PT0wJiZpKXtyLm5hbWU9ZS5zbGljZSgxLGEpO3IuYmFzZT1lLnNsaWNlKDEsbCl9ZWxzZXtyLm5hbWU9ZS5zbGljZShmLGEpO3IuYmFzZT1lLnNsaWNlKGYsbCl9ci5leHQ9ZS5zbGljZShhLGwpfWlmKGY+MClyLmRpcj1lLnNsaWNlKDAsZi0xKTtlbHNlIGlmKGkpci5kaXI9XCIvXCI7cmV0dXJuIHJ9LHNlcDpcIi9cIixkZWxpbWl0ZXI6XCI6XCIsd2luMzI6bnVsbCxwb3NpeDpudWxsfTtyLnBvc2l4PXI7ZS5leHBvcnRzPXJ9fTt2YXIgcj17fTtmdW5jdGlvbiBfX25jY3dwY2tfcmVxdWlyZV9fKHQpe3ZhciBpPXJbdF07aWYoaSE9PXVuZGVmaW5lZCl7cmV0dXJuIGkuZXhwb3J0c312YXIgbj1yW3RdPXtleHBvcnRzOnt9fTt2YXIgYT10cnVlO3RyeXtlW3RdKG4sbi5leHBvcnRzLF9fbmNjd3Bja19yZXF1aXJlX18pO2E9ZmFsc2V9ZmluYWxseXtpZihhKWRlbGV0ZSByW3RdfXJldHVybiBuLmV4cG9ydHN9aWYodHlwZW9mIF9fbmNjd3Bja19yZXF1aXJlX18hPT1cInVuZGVmaW5lZFwiKV9fbmNjd3Bja19yZXF1aXJlX18uYWI9X19kaXJuYW1lK1wiL1wiO3ZhciB0PV9fbmNjd3Bja19yZXF1aXJlX18oMTE0KTttb2R1bGUuZXhwb3J0cz10fSkoKTsiXSwibmFtZXMiOlsiZSIsImFzc2VydFBhdGgiLCJUeXBlRXJyb3IiLCJKU09OIiwic3RyaW5naWZ5Iiwibm9ybWFsaXplU3RyaW5nUG9zaXgiLCJyIiwidCIsImkiLCJuIiwiYSIsImYiLCJsIiwibGVuZ3RoIiwiY2hhckNvZGVBdCIsInMiLCJsYXN0SW5kZXhPZiIsInNsaWNlIiwiX2Zvcm1hdCIsImRpciIsInJvb3QiLCJiYXNlIiwibmFtZSIsImV4dCIsInJlc29sdmUiLCJhcmd1bWVudHMiLCJ1bmRlZmluZWQiLCJub3JtYWxpemUiLCJpc0Fic29sdXRlIiwiam9pbiIsInJlbGF0aXZlIiwibyIsInUiLCJoIiwiYyIsInYiLCJnIiwiX21ha2VMb25nIiwiZGlybmFtZSIsImJhc2VuYW1lIiwiZXh0bmFtZSIsImZvcm1hdCIsInBhcnNlIiwic2VwIiwiZGVsaW1pdGVyIiwid2luMzIiLCJwb3NpeCIsImV4cG9ydHMiLCJfX25jY3dwY2tfcmVxdWlyZV9fIiwiYWIiLCJfX2Rpcm5hbWUiLCJtb2R1bGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/path-browserify/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/util/util.js":
/*!******************************************************!*\
  !*** ./node_modules/next/dist/compiled/util/util.js ***!
  \******************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var __dirname = \"/\";\n/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"(app-pages-browser)/../../../../node_modules/buffer/index.js\")[\"Buffer\"];\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js\");\n\n(function() {\n    var r = {\n        992: function(r) {\n            r.exports = function(r, t, o) {\n                if (r.filter) return r.filter(t, o);\n                if (void 0 === r || null === r) throw new TypeError;\n                if (\"function\" != typeof t) throw new TypeError;\n                var n = [];\n                for(var i = 0; i < r.length; i++){\n                    if (!e.call(r, i)) continue;\n                    var a = r[i];\n                    if (t.call(o, a, i, r)) n.push(a);\n                }\n                return n;\n            };\n            var e = Object.prototype.hasOwnProperty;\n        },\n        256: function(r, e, t) {\n            \"use strict\";\n            var o = t(925);\n            var n = t(139);\n            var i = n(o(\"String.prototype.indexOf\"));\n            r.exports = function callBoundIntrinsic(r, e) {\n                var t = o(r, !!e);\n                if (typeof t === \"function\" && i(r, \".prototype.\") > -1) {\n                    return n(t);\n                }\n                return t;\n            };\n        },\n        139: function(r, e, t) {\n            \"use strict\";\n            var o = t(174);\n            var n = t(925);\n            var i = n(\"%Function.prototype.apply%\");\n            var a = n(\"%Function.prototype.call%\");\n            var y = n(\"%Reflect.apply%\", true) || o.call(a, i);\n            var f = n(\"%Object.getOwnPropertyDescriptor%\", true);\n            var p = n(\"%Object.defineProperty%\", true);\n            var u = n(\"%Math.max%\");\n            if (p) {\n                try {\n                    p({}, \"a\", {\n                        value: 1\n                    });\n                } catch (r) {\n                    p = null;\n                }\n            }\n            r.exports = function callBind(r) {\n                var e = y(o, a, arguments);\n                if (f && p) {\n                    var t = f(e, \"length\");\n                    if (t.configurable) {\n                        p(e, \"length\", {\n                            value: 1 + u(0, r.length - (arguments.length - 1))\n                        });\n                    }\n                }\n                return e;\n            };\n            var s = function applyBind() {\n                return y(o, i, arguments);\n            };\n            if (p) {\n                p(r.exports, \"apply\", {\n                    value: s\n                });\n            } else {\n                r.exports.apply = s;\n            }\n        },\n        144: function(r) {\n            var e = Object.prototype.hasOwnProperty;\n            var t = Object.prototype.toString;\n            r.exports = function forEach(r, o, n) {\n                if (t.call(o) !== \"[object Function]\") {\n                    throw new TypeError(\"iterator must be a function\");\n                }\n                var i = r.length;\n                if (i === +i) {\n                    for(var a = 0; a < i; a++){\n                        o.call(n, r[a], a, r);\n                    }\n                } else {\n                    for(var y in r){\n                        if (e.call(r, y)) {\n                            o.call(n, r[y], y, r);\n                        }\n                    }\n                }\n            };\n        },\n        426: function(r) {\n            \"use strict\";\n            var e = \"Function.prototype.bind called on incompatible \";\n            var t = Array.prototype.slice;\n            var o = Object.prototype.toString;\n            var n = \"[object Function]\";\n            r.exports = function bind(r) {\n                var i = this;\n                if (typeof i !== \"function\" || o.call(i) !== n) {\n                    throw new TypeError(e + i);\n                }\n                var a = t.call(arguments, 1);\n                var y;\n                var binder = function() {\n                    if (this instanceof y) {\n                        var e = i.apply(this, a.concat(t.call(arguments)));\n                        if (Object(e) === e) {\n                            return e;\n                        }\n                        return this;\n                    } else {\n                        return i.apply(r, a.concat(t.call(arguments)));\n                    }\n                };\n                var f = Math.max(0, i.length - a.length);\n                var p = [];\n                for(var u = 0; u < f; u++){\n                    p.push(\"$\" + u);\n                }\n                y = Function(\"binder\", \"return function (\" + p.join(\",\") + \"){ return binder.apply(this,arguments); }\")(binder);\n                if (i.prototype) {\n                    var s = function Empty() {};\n                    s.prototype = i.prototype;\n                    y.prototype = new s;\n                    s.prototype = null;\n                }\n                return y;\n            };\n        },\n        174: function(r, e, t) {\n            \"use strict\";\n            var o = t(426);\n            r.exports = Function.prototype.bind || o;\n        },\n        500: function(r, e, t) {\n            \"use strict\";\n            var o;\n            var n = SyntaxError;\n            var i = Function;\n            var a = TypeError;\n            var getEvalledConstructor = function(r) {\n                try {\n                    return i('\"use strict\"; return (' + r + \").constructor;\")();\n                } catch (r) {}\n            };\n            var y = Object.getOwnPropertyDescriptor;\n            if (y) {\n                try {\n                    y({}, \"\");\n                } catch (r) {\n                    y = null;\n                }\n            }\n            var throwTypeError = function() {\n                throw new a;\n            };\n            var f = y ? function() {\n                try {\n                    arguments.callee;\n                    return throwTypeError;\n                } catch (r) {\n                    try {\n                        return y(arguments, \"callee\").get;\n                    } catch (r) {\n                        return throwTypeError;\n                    }\n                }\n            }() : throwTypeError;\n            var p = t(115)();\n            var u = Object.getPrototypeOf || function(r) {\n                return r.__proto__;\n            };\n            var s = {};\n            var c = typeof Uint8Array === \"undefined\" ? o : u(Uint8Array);\n            var l = {\n                \"%AggregateError%\": typeof AggregateError === \"undefined\" ? o : AggregateError,\n                \"%Array%\": Array,\n                \"%ArrayBuffer%\": typeof ArrayBuffer === \"undefined\" ? o : ArrayBuffer,\n                \"%ArrayIteratorPrototype%\": p ? u([][Symbol.iterator]()) : o,\n                \"%AsyncFromSyncIteratorPrototype%\": o,\n                \"%AsyncFunction%\": s,\n                \"%AsyncGenerator%\": s,\n                \"%AsyncGeneratorFunction%\": s,\n                \"%AsyncIteratorPrototype%\": s,\n                \"%Atomics%\": typeof Atomics === \"undefined\" ? o : Atomics,\n                \"%BigInt%\": typeof BigInt === \"undefined\" ? o : BigInt,\n                \"%Boolean%\": Boolean,\n                \"%DataView%\": typeof DataView === \"undefined\" ? o : DataView,\n                \"%Date%\": Date,\n                \"%decodeURI%\": decodeURI,\n                \"%decodeURIComponent%\": decodeURIComponent,\n                \"%encodeURI%\": encodeURI,\n                \"%encodeURIComponent%\": encodeURIComponent,\n                \"%Error%\": Error,\n                \"%eval%\": eval,\n                \"%EvalError%\": EvalError,\n                \"%Float32Array%\": typeof Float32Array === \"undefined\" ? o : Float32Array,\n                \"%Float64Array%\": typeof Float64Array === \"undefined\" ? o : Float64Array,\n                \"%FinalizationRegistry%\": typeof FinalizationRegistry === \"undefined\" ? o : FinalizationRegistry,\n                \"%Function%\": i,\n                \"%GeneratorFunction%\": s,\n                \"%Int8Array%\": typeof Int8Array === \"undefined\" ? o : Int8Array,\n                \"%Int16Array%\": typeof Int16Array === \"undefined\" ? o : Int16Array,\n                \"%Int32Array%\": typeof Int32Array === \"undefined\" ? o : Int32Array,\n                \"%isFinite%\": isFinite,\n                \"%isNaN%\": isNaN,\n                \"%IteratorPrototype%\": p ? u(u([][Symbol.iterator]())) : o,\n                \"%JSON%\": typeof JSON === \"object\" ? JSON : o,\n                \"%Map%\": typeof Map === \"undefined\" ? o : Map,\n                \"%MapIteratorPrototype%\": typeof Map === \"undefined\" || !p ? o : u((new Map)[Symbol.iterator]()),\n                \"%Math%\": Math,\n                \"%Number%\": Number,\n                \"%Object%\": Object,\n                \"%parseFloat%\": parseFloat,\n                \"%parseInt%\": parseInt,\n                \"%Promise%\": typeof Promise === \"undefined\" ? o : Promise,\n                \"%Proxy%\": typeof Proxy === \"undefined\" ? o : Proxy,\n                \"%RangeError%\": RangeError,\n                \"%ReferenceError%\": ReferenceError,\n                \"%Reflect%\": typeof Reflect === \"undefined\" ? o : Reflect,\n                \"%RegExp%\": RegExp,\n                \"%Set%\": typeof Set === \"undefined\" ? o : Set,\n                \"%SetIteratorPrototype%\": typeof Set === \"undefined\" || !p ? o : u((new Set)[Symbol.iterator]()),\n                \"%SharedArrayBuffer%\": typeof SharedArrayBuffer === \"undefined\" ? o : SharedArrayBuffer,\n                \"%String%\": String,\n                \"%StringIteratorPrototype%\": p ? u(\"\"[Symbol.iterator]()) : o,\n                \"%Symbol%\": p ? Symbol : o,\n                \"%SyntaxError%\": n,\n                \"%ThrowTypeError%\": f,\n                \"%TypedArray%\": c,\n                \"%TypeError%\": a,\n                \"%Uint8Array%\": typeof Uint8Array === \"undefined\" ? o : Uint8Array,\n                \"%Uint8ClampedArray%\": typeof Uint8ClampedArray === \"undefined\" ? o : Uint8ClampedArray,\n                \"%Uint16Array%\": typeof Uint16Array === \"undefined\" ? o : Uint16Array,\n                \"%Uint32Array%\": typeof Uint32Array === \"undefined\" ? o : Uint32Array,\n                \"%URIError%\": URIError,\n                \"%WeakMap%\": typeof WeakMap === \"undefined\" ? o : WeakMap,\n                \"%WeakRef%\": typeof WeakRef === \"undefined\" ? o : WeakRef,\n                \"%WeakSet%\": typeof WeakSet === \"undefined\" ? o : WeakSet\n            };\n            var d = function doEval(r) {\n                var e;\n                if (r === \"%AsyncFunction%\") {\n                    e = getEvalledConstructor(\"async function () {}\");\n                } else if (r === \"%GeneratorFunction%\") {\n                    e = getEvalledConstructor(\"function* () {}\");\n                } else if (r === \"%AsyncGeneratorFunction%\") {\n                    e = getEvalledConstructor(\"async function* () {}\");\n                } else if (r === \"%AsyncGenerator%\") {\n                    var t = doEval(\"%AsyncGeneratorFunction%\");\n                    if (t) {\n                        e = t.prototype;\n                    }\n                } else if (r === \"%AsyncIteratorPrototype%\") {\n                    var o = doEval(\"%AsyncGenerator%\");\n                    if (o) {\n                        e = u(o.prototype);\n                    }\n                }\n                l[r] = e;\n                return e;\n            };\n            var g = {\n                \"%ArrayBufferPrototype%\": [\n                    \"ArrayBuffer\",\n                    \"prototype\"\n                ],\n                \"%ArrayPrototype%\": [\n                    \"Array\",\n                    \"prototype\"\n                ],\n                \"%ArrayProto_entries%\": [\n                    \"Array\",\n                    \"prototype\",\n                    \"entries\"\n                ],\n                \"%ArrayProto_forEach%\": [\n                    \"Array\",\n                    \"prototype\",\n                    \"forEach\"\n                ],\n                \"%ArrayProto_keys%\": [\n                    \"Array\",\n                    \"prototype\",\n                    \"keys\"\n                ],\n                \"%ArrayProto_values%\": [\n                    \"Array\",\n                    \"prototype\",\n                    \"values\"\n                ],\n                \"%AsyncFunctionPrototype%\": [\n                    \"AsyncFunction\",\n                    \"prototype\"\n                ],\n                \"%AsyncGenerator%\": [\n                    \"AsyncGeneratorFunction\",\n                    \"prototype\"\n                ],\n                \"%AsyncGeneratorPrototype%\": [\n                    \"AsyncGeneratorFunction\",\n                    \"prototype\",\n                    \"prototype\"\n                ],\n                \"%BooleanPrototype%\": [\n                    \"Boolean\",\n                    \"prototype\"\n                ],\n                \"%DataViewPrototype%\": [\n                    \"DataView\",\n                    \"prototype\"\n                ],\n                \"%DatePrototype%\": [\n                    \"Date\",\n                    \"prototype\"\n                ],\n                \"%ErrorPrototype%\": [\n                    \"Error\",\n                    \"prototype\"\n                ],\n                \"%EvalErrorPrototype%\": [\n                    \"EvalError\",\n                    \"prototype\"\n                ],\n                \"%Float32ArrayPrototype%\": [\n                    \"Float32Array\",\n                    \"prototype\"\n                ],\n                \"%Float64ArrayPrototype%\": [\n                    \"Float64Array\",\n                    \"prototype\"\n                ],\n                \"%FunctionPrototype%\": [\n                    \"Function\",\n                    \"prototype\"\n                ],\n                \"%Generator%\": [\n                    \"GeneratorFunction\",\n                    \"prototype\"\n                ],\n                \"%GeneratorPrototype%\": [\n                    \"GeneratorFunction\",\n                    \"prototype\",\n                    \"prototype\"\n                ],\n                \"%Int8ArrayPrototype%\": [\n                    \"Int8Array\",\n                    \"prototype\"\n                ],\n                \"%Int16ArrayPrototype%\": [\n                    \"Int16Array\",\n                    \"prototype\"\n                ],\n                \"%Int32ArrayPrototype%\": [\n                    \"Int32Array\",\n                    \"prototype\"\n                ],\n                \"%JSONParse%\": [\n                    \"JSON\",\n                    \"parse\"\n                ],\n                \"%JSONStringify%\": [\n                    \"JSON\",\n                    \"stringify\"\n                ],\n                \"%MapPrototype%\": [\n                    \"Map\",\n                    \"prototype\"\n                ],\n                \"%NumberPrototype%\": [\n                    \"Number\",\n                    \"prototype\"\n                ],\n                \"%ObjectPrototype%\": [\n                    \"Object\",\n                    \"prototype\"\n                ],\n                \"%ObjProto_toString%\": [\n                    \"Object\",\n                    \"prototype\",\n                    \"toString\"\n                ],\n                \"%ObjProto_valueOf%\": [\n                    \"Object\",\n                    \"prototype\",\n                    \"valueOf\"\n                ],\n                \"%PromisePrototype%\": [\n                    \"Promise\",\n                    \"prototype\"\n                ],\n                \"%PromiseProto_then%\": [\n                    \"Promise\",\n                    \"prototype\",\n                    \"then\"\n                ],\n                \"%Promise_all%\": [\n                    \"Promise\",\n                    \"all\"\n                ],\n                \"%Promise_reject%\": [\n                    \"Promise\",\n                    \"reject\"\n                ],\n                \"%Promise_resolve%\": [\n                    \"Promise\",\n                    \"resolve\"\n                ],\n                \"%RangeErrorPrototype%\": [\n                    \"RangeError\",\n                    \"prototype\"\n                ],\n                \"%ReferenceErrorPrototype%\": [\n                    \"ReferenceError\",\n                    \"prototype\"\n                ],\n                \"%RegExpPrototype%\": [\n                    \"RegExp\",\n                    \"prototype\"\n                ],\n                \"%SetPrototype%\": [\n                    \"Set\",\n                    \"prototype\"\n                ],\n                \"%SharedArrayBufferPrototype%\": [\n                    \"SharedArrayBuffer\",\n                    \"prototype\"\n                ],\n                \"%StringPrototype%\": [\n                    \"String\",\n                    \"prototype\"\n                ],\n                \"%SymbolPrototype%\": [\n                    \"Symbol\",\n                    \"prototype\"\n                ],\n                \"%SyntaxErrorPrototype%\": [\n                    \"SyntaxError\",\n                    \"prototype\"\n                ],\n                \"%TypedArrayPrototype%\": [\n                    \"TypedArray\",\n                    \"prototype\"\n                ],\n                \"%TypeErrorPrototype%\": [\n                    \"TypeError\",\n                    \"prototype\"\n                ],\n                \"%Uint8ArrayPrototype%\": [\n                    \"Uint8Array\",\n                    \"prototype\"\n                ],\n                \"%Uint8ClampedArrayPrototype%\": [\n                    \"Uint8ClampedArray\",\n                    \"prototype\"\n                ],\n                \"%Uint16ArrayPrototype%\": [\n                    \"Uint16Array\",\n                    \"prototype\"\n                ],\n                \"%Uint32ArrayPrototype%\": [\n                    \"Uint32Array\",\n                    \"prototype\"\n                ],\n                \"%URIErrorPrototype%\": [\n                    \"URIError\",\n                    \"prototype\"\n                ],\n                \"%WeakMapPrototype%\": [\n                    \"WeakMap\",\n                    \"prototype\"\n                ],\n                \"%WeakSetPrototype%\": [\n                    \"WeakSet\",\n                    \"prototype\"\n                ]\n            };\n            var v = t(174);\n            var b = t(101);\n            var A = v.call(Function.call, Array.prototype.concat);\n            var m = v.call(Function.apply, Array.prototype.splice);\n            var S = v.call(Function.call, String.prototype.replace);\n            var h = v.call(Function.call, String.prototype.slice);\n            var P = v.call(Function.call, RegExp.prototype.exec);\n            var O = /[^%.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|%$))/g;\n            var w = /\\\\(\\\\)?/g;\n            var j = function stringToPath(r) {\n                var e = h(r, 0, 1);\n                var t = h(r, -1);\n                if (e === \"%\" && t !== \"%\") {\n                    throw new n(\"invalid intrinsic syntax, expected closing `%`\");\n                } else if (t === \"%\" && e !== \"%\") {\n                    throw new n(\"invalid intrinsic syntax, expected opening `%`\");\n                }\n                var o = [];\n                S(r, O, function(r, e, t, n) {\n                    o[o.length] = t ? S(n, w, \"$1\") : e || r;\n                });\n                return o;\n            };\n            var E = function getBaseIntrinsic(r, e) {\n                var t = r;\n                var o;\n                if (b(g, t)) {\n                    o = g[t];\n                    t = \"%\" + o[0] + \"%\";\n                }\n                if (b(l, t)) {\n                    var i = l[t];\n                    if (i === s) {\n                        i = d(t);\n                    }\n                    if (typeof i === \"undefined\" && !e) {\n                        throw new a(\"intrinsic \" + r + \" exists, but is not available. Please file an issue!\");\n                    }\n                    return {\n                        alias: o,\n                        name: t,\n                        value: i\n                    };\n                }\n                throw new n(\"intrinsic \" + r + \" does not exist!\");\n            };\n            r.exports = function GetIntrinsic(r, e) {\n                if (typeof r !== \"string\" || r.length === 0) {\n                    throw new a(\"intrinsic name must be a non-empty string\");\n                }\n                if (arguments.length > 1 && typeof e !== \"boolean\") {\n                    throw new a('\"allowMissing\" argument must be a boolean');\n                }\n                if (P(/^%?[^%]*%?$/g, r) === null) {\n                    throw new n(\"`%` may not be present anywhere but at the beginning and end of the intrinsic name\");\n                }\n                var t = j(r);\n                var i = t.length > 0 ? t[0] : \"\";\n                var f = E(\"%\" + i + \"%\", e);\n                var p = f.name;\n                var u = f.value;\n                var s = false;\n                var c = f.alias;\n                if (c) {\n                    i = c[0];\n                    m(t, A([\n                        0,\n                        1\n                    ], c));\n                }\n                for(var d = 1, g = true; d < t.length; d += 1){\n                    var v = t[d];\n                    var S = h(v, 0, 1);\n                    var O = h(v, -1);\n                    if ((S === '\"' || S === \"'\" || S === \"`\" || O === '\"' || O === \"'\" || O === \"`\") && S !== O) {\n                        throw new n(\"property names with quotes must have matching quotes\");\n                    }\n                    if (v === \"constructor\" || !g) {\n                        s = true;\n                    }\n                    i += \".\" + v;\n                    p = \"%\" + i + \"%\";\n                    if (b(l, p)) {\n                        u = l[p];\n                    } else if (u != null) {\n                        if (!(v in u)) {\n                            if (!e) {\n                                throw new a(\"base intrinsic for \" + r + \" exists, but the property is not available.\");\n                            }\n                            return void o;\n                        }\n                        if (y && d + 1 >= t.length) {\n                            var w = y(u, v);\n                            g = !!w;\n                            if (g && \"get\" in w && !(\"originalValue\" in w.get)) {\n                                u = w.get;\n                            } else {\n                                u = u[v];\n                            }\n                        } else {\n                            g = b(u, v);\n                            u = u[v];\n                        }\n                        if (g && !s) {\n                            l[p] = u;\n                        }\n                    }\n                }\n                return u;\n            };\n        },\n        925: function(r, e, t) {\n            \"use strict\";\n            var o;\n            var n = SyntaxError;\n            var i = Function;\n            var a = TypeError;\n            var getEvalledConstructor = function(r) {\n                try {\n                    return i('\"use strict\"; return (' + r + \").constructor;\")();\n                } catch (r) {}\n            };\n            var y = Object.getOwnPropertyDescriptor;\n            if (y) {\n                try {\n                    y({}, \"\");\n                } catch (r) {\n                    y = null;\n                }\n            }\n            var throwTypeError = function() {\n                throw new a;\n            };\n            var f = y ? function() {\n                try {\n                    arguments.callee;\n                    return throwTypeError;\n                } catch (r) {\n                    try {\n                        return y(arguments, \"callee\").get;\n                    } catch (r) {\n                        return throwTypeError;\n                    }\n                }\n            }() : throwTypeError;\n            var p = t(115)();\n            var u = t(504)();\n            var s = Object.getPrototypeOf || (u ? function(r) {\n                return r.__proto__;\n            } : null);\n            var c = {};\n            var l = typeof Uint8Array === \"undefined\" || !s ? o : s(Uint8Array);\n            var d = {\n                \"%AggregateError%\": typeof AggregateError === \"undefined\" ? o : AggregateError,\n                \"%Array%\": Array,\n                \"%ArrayBuffer%\": typeof ArrayBuffer === \"undefined\" ? o : ArrayBuffer,\n                \"%ArrayIteratorPrototype%\": p && s ? s([][Symbol.iterator]()) : o,\n                \"%AsyncFromSyncIteratorPrototype%\": o,\n                \"%AsyncFunction%\": c,\n                \"%AsyncGenerator%\": c,\n                \"%AsyncGeneratorFunction%\": c,\n                \"%AsyncIteratorPrototype%\": c,\n                \"%Atomics%\": typeof Atomics === \"undefined\" ? o : Atomics,\n                \"%BigInt%\": typeof BigInt === \"undefined\" ? o : BigInt,\n                \"%BigInt64Array%\": typeof BigInt64Array === \"undefined\" ? o : BigInt64Array,\n                \"%BigUint64Array%\": typeof BigUint64Array === \"undefined\" ? o : BigUint64Array,\n                \"%Boolean%\": Boolean,\n                \"%DataView%\": typeof DataView === \"undefined\" ? o : DataView,\n                \"%Date%\": Date,\n                \"%decodeURI%\": decodeURI,\n                \"%decodeURIComponent%\": decodeURIComponent,\n                \"%encodeURI%\": encodeURI,\n                \"%encodeURIComponent%\": encodeURIComponent,\n                \"%Error%\": Error,\n                \"%eval%\": eval,\n                \"%EvalError%\": EvalError,\n                \"%Float32Array%\": typeof Float32Array === \"undefined\" ? o : Float32Array,\n                \"%Float64Array%\": typeof Float64Array === \"undefined\" ? o : Float64Array,\n                \"%FinalizationRegistry%\": typeof FinalizationRegistry === \"undefined\" ? o : FinalizationRegistry,\n                \"%Function%\": i,\n                \"%GeneratorFunction%\": c,\n                \"%Int8Array%\": typeof Int8Array === \"undefined\" ? o : Int8Array,\n                \"%Int16Array%\": typeof Int16Array === \"undefined\" ? o : Int16Array,\n                \"%Int32Array%\": typeof Int32Array === \"undefined\" ? o : Int32Array,\n                \"%isFinite%\": isFinite,\n                \"%isNaN%\": isNaN,\n                \"%IteratorPrototype%\": p && s ? s(s([][Symbol.iterator]())) : o,\n                \"%JSON%\": typeof JSON === \"object\" ? JSON : o,\n                \"%Map%\": typeof Map === \"undefined\" ? o : Map,\n                \"%MapIteratorPrototype%\": typeof Map === \"undefined\" || !p || !s ? o : s((new Map)[Symbol.iterator]()),\n                \"%Math%\": Math,\n                \"%Number%\": Number,\n                \"%Object%\": Object,\n                \"%parseFloat%\": parseFloat,\n                \"%parseInt%\": parseInt,\n                \"%Promise%\": typeof Promise === \"undefined\" ? o : Promise,\n                \"%Proxy%\": typeof Proxy === \"undefined\" ? o : Proxy,\n                \"%RangeError%\": RangeError,\n                \"%ReferenceError%\": ReferenceError,\n                \"%Reflect%\": typeof Reflect === \"undefined\" ? o : Reflect,\n                \"%RegExp%\": RegExp,\n                \"%Set%\": typeof Set === \"undefined\" ? o : Set,\n                \"%SetIteratorPrototype%\": typeof Set === \"undefined\" || !p || !s ? o : s((new Set)[Symbol.iterator]()),\n                \"%SharedArrayBuffer%\": typeof SharedArrayBuffer === \"undefined\" ? o : SharedArrayBuffer,\n                \"%String%\": String,\n                \"%StringIteratorPrototype%\": p && s ? s(\"\"[Symbol.iterator]()) : o,\n                \"%Symbol%\": p ? Symbol : o,\n                \"%SyntaxError%\": n,\n                \"%ThrowTypeError%\": f,\n                \"%TypedArray%\": l,\n                \"%TypeError%\": a,\n                \"%Uint8Array%\": typeof Uint8Array === \"undefined\" ? o : Uint8Array,\n                \"%Uint8ClampedArray%\": typeof Uint8ClampedArray === \"undefined\" ? o : Uint8ClampedArray,\n                \"%Uint16Array%\": typeof Uint16Array === \"undefined\" ? o : Uint16Array,\n                \"%Uint32Array%\": typeof Uint32Array === \"undefined\" ? o : Uint32Array,\n                \"%URIError%\": URIError,\n                \"%WeakMap%\": typeof WeakMap === \"undefined\" ? o : WeakMap,\n                \"%WeakRef%\": typeof WeakRef === \"undefined\" ? o : WeakRef,\n                \"%WeakSet%\": typeof WeakSet === \"undefined\" ? o : WeakSet\n            };\n            if (s) {\n                try {\n                    null.error;\n                } catch (r) {\n                    var g = s(s(r));\n                    d[\"%Error.prototype%\"] = g;\n                }\n            }\n            var v = function doEval(r) {\n                var e;\n                if (r === \"%AsyncFunction%\") {\n                    e = getEvalledConstructor(\"async function () {}\");\n                } else if (r === \"%GeneratorFunction%\") {\n                    e = getEvalledConstructor(\"function* () {}\");\n                } else if (r === \"%AsyncGeneratorFunction%\") {\n                    e = getEvalledConstructor(\"async function* () {}\");\n                } else if (r === \"%AsyncGenerator%\") {\n                    var t = doEval(\"%AsyncGeneratorFunction%\");\n                    if (t) {\n                        e = t.prototype;\n                    }\n                } else if (r === \"%AsyncIteratorPrototype%\") {\n                    var o = doEval(\"%AsyncGenerator%\");\n                    if (o && s) {\n                        e = s(o.prototype);\n                    }\n                }\n                d[r] = e;\n                return e;\n            };\n            var b = {\n                \"%ArrayBufferPrototype%\": [\n                    \"ArrayBuffer\",\n                    \"prototype\"\n                ],\n                \"%ArrayPrototype%\": [\n                    \"Array\",\n                    \"prototype\"\n                ],\n                \"%ArrayProto_entries%\": [\n                    \"Array\",\n                    \"prototype\",\n                    \"entries\"\n                ],\n                \"%ArrayProto_forEach%\": [\n                    \"Array\",\n                    \"prototype\",\n                    \"forEach\"\n                ],\n                \"%ArrayProto_keys%\": [\n                    \"Array\",\n                    \"prototype\",\n                    \"keys\"\n                ],\n                \"%ArrayProto_values%\": [\n                    \"Array\",\n                    \"prototype\",\n                    \"values\"\n                ],\n                \"%AsyncFunctionPrototype%\": [\n                    \"AsyncFunction\",\n                    \"prototype\"\n                ],\n                \"%AsyncGenerator%\": [\n                    \"AsyncGeneratorFunction\",\n                    \"prototype\"\n                ],\n                \"%AsyncGeneratorPrototype%\": [\n                    \"AsyncGeneratorFunction\",\n                    \"prototype\",\n                    \"prototype\"\n                ],\n                \"%BooleanPrototype%\": [\n                    \"Boolean\",\n                    \"prototype\"\n                ],\n                \"%DataViewPrototype%\": [\n                    \"DataView\",\n                    \"prototype\"\n                ],\n                \"%DatePrototype%\": [\n                    \"Date\",\n                    \"prototype\"\n                ],\n                \"%ErrorPrototype%\": [\n                    \"Error\",\n                    \"prototype\"\n                ],\n                \"%EvalErrorPrototype%\": [\n                    \"EvalError\",\n                    \"prototype\"\n                ],\n                \"%Float32ArrayPrototype%\": [\n                    \"Float32Array\",\n                    \"prototype\"\n                ],\n                \"%Float64ArrayPrototype%\": [\n                    \"Float64Array\",\n                    \"prototype\"\n                ],\n                \"%FunctionPrototype%\": [\n                    \"Function\",\n                    \"prototype\"\n                ],\n                \"%Generator%\": [\n                    \"GeneratorFunction\",\n                    \"prototype\"\n                ],\n                \"%GeneratorPrototype%\": [\n                    \"GeneratorFunction\",\n                    \"prototype\",\n                    \"prototype\"\n                ],\n                \"%Int8ArrayPrototype%\": [\n                    \"Int8Array\",\n                    \"prototype\"\n                ],\n                \"%Int16ArrayPrototype%\": [\n                    \"Int16Array\",\n                    \"prototype\"\n                ],\n                \"%Int32ArrayPrototype%\": [\n                    \"Int32Array\",\n                    \"prototype\"\n                ],\n                \"%JSONParse%\": [\n                    \"JSON\",\n                    \"parse\"\n                ],\n                \"%JSONStringify%\": [\n                    \"JSON\",\n                    \"stringify\"\n                ],\n                \"%MapPrototype%\": [\n                    \"Map\",\n                    \"prototype\"\n                ],\n                \"%NumberPrototype%\": [\n                    \"Number\",\n                    \"prototype\"\n                ],\n                \"%ObjectPrototype%\": [\n                    \"Object\",\n                    \"prototype\"\n                ],\n                \"%ObjProto_toString%\": [\n                    \"Object\",\n                    \"prototype\",\n                    \"toString\"\n                ],\n                \"%ObjProto_valueOf%\": [\n                    \"Object\",\n                    \"prototype\",\n                    \"valueOf\"\n                ],\n                \"%PromisePrototype%\": [\n                    \"Promise\",\n                    \"prototype\"\n                ],\n                \"%PromiseProto_then%\": [\n                    \"Promise\",\n                    \"prototype\",\n                    \"then\"\n                ],\n                \"%Promise_all%\": [\n                    \"Promise\",\n                    \"all\"\n                ],\n                \"%Promise_reject%\": [\n                    \"Promise\",\n                    \"reject\"\n                ],\n                \"%Promise_resolve%\": [\n                    \"Promise\",\n                    \"resolve\"\n                ],\n                \"%RangeErrorPrototype%\": [\n                    \"RangeError\",\n                    \"prototype\"\n                ],\n                \"%ReferenceErrorPrototype%\": [\n                    \"ReferenceError\",\n                    \"prototype\"\n                ],\n                \"%RegExpPrototype%\": [\n                    \"RegExp\",\n                    \"prototype\"\n                ],\n                \"%SetPrototype%\": [\n                    \"Set\",\n                    \"prototype\"\n                ],\n                \"%SharedArrayBufferPrototype%\": [\n                    \"SharedArrayBuffer\",\n                    \"prototype\"\n                ],\n                \"%StringPrototype%\": [\n                    \"String\",\n                    \"prototype\"\n                ],\n                \"%SymbolPrototype%\": [\n                    \"Symbol\",\n                    \"prototype\"\n                ],\n                \"%SyntaxErrorPrototype%\": [\n                    \"SyntaxError\",\n                    \"prototype\"\n                ],\n                \"%TypedArrayPrototype%\": [\n                    \"TypedArray\",\n                    \"prototype\"\n                ],\n                \"%TypeErrorPrototype%\": [\n                    \"TypeError\",\n                    \"prototype\"\n                ],\n                \"%Uint8ArrayPrototype%\": [\n                    \"Uint8Array\",\n                    \"prototype\"\n                ],\n                \"%Uint8ClampedArrayPrototype%\": [\n                    \"Uint8ClampedArray\",\n                    \"prototype\"\n                ],\n                \"%Uint16ArrayPrototype%\": [\n                    \"Uint16Array\",\n                    \"prototype\"\n                ],\n                \"%Uint32ArrayPrototype%\": [\n                    \"Uint32Array\",\n                    \"prototype\"\n                ],\n                \"%URIErrorPrototype%\": [\n                    \"URIError\",\n                    \"prototype\"\n                ],\n                \"%WeakMapPrototype%\": [\n                    \"WeakMap\",\n                    \"prototype\"\n                ],\n                \"%WeakSetPrototype%\": [\n                    \"WeakSet\",\n                    \"prototype\"\n                ]\n            };\n            var A = t(174);\n            var m = t(101);\n            var S = A.call(Function.call, Array.prototype.concat);\n            var h = A.call(Function.apply, Array.prototype.splice);\n            var P = A.call(Function.call, String.prototype.replace);\n            var O = A.call(Function.call, String.prototype.slice);\n            var w = A.call(Function.call, RegExp.prototype.exec);\n            var j = /[^%.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|%$))/g;\n            var E = /\\\\(\\\\)?/g;\n            var I = function stringToPath(r) {\n                var e = O(r, 0, 1);\n                var t = O(r, -1);\n                if (e === \"%\" && t !== \"%\") {\n                    throw new n(\"invalid intrinsic syntax, expected closing `%`\");\n                } else if (t === \"%\" && e !== \"%\") {\n                    throw new n(\"invalid intrinsic syntax, expected opening `%`\");\n                }\n                var o = [];\n                P(r, j, function(r, e, t, n) {\n                    o[o.length] = t ? P(n, E, \"$1\") : e || r;\n                });\n                return o;\n            };\n            var B = function getBaseIntrinsic(r, e) {\n                var t = r;\n                var o;\n                if (m(b, t)) {\n                    o = b[t];\n                    t = \"%\" + o[0] + \"%\";\n                }\n                if (m(d, t)) {\n                    var i = d[t];\n                    if (i === c) {\n                        i = v(t);\n                    }\n                    if (typeof i === \"undefined\" && !e) {\n                        throw new a(\"intrinsic \" + r + \" exists, but is not available. Please file an issue!\");\n                    }\n                    return {\n                        alias: o,\n                        name: t,\n                        value: i\n                    };\n                }\n                throw new n(\"intrinsic \" + r + \" does not exist!\");\n            };\n            r.exports = function GetIntrinsic(r, e) {\n                if (typeof r !== \"string\" || r.length === 0) {\n                    throw new a(\"intrinsic name must be a non-empty string\");\n                }\n                if (arguments.length > 1 && typeof e !== \"boolean\") {\n                    throw new a('\"allowMissing\" argument must be a boolean');\n                }\n                if (w(/^%?[^%]*%?$/, r) === null) {\n                    throw new n(\"`%` may not be present anywhere but at the beginning and end of the intrinsic name\");\n                }\n                var t = I(r);\n                var i = t.length > 0 ? t[0] : \"\";\n                var f = B(\"%\" + i + \"%\", e);\n                var p = f.name;\n                var u = f.value;\n                var s = false;\n                var c = f.alias;\n                if (c) {\n                    i = c[0];\n                    h(t, S([\n                        0,\n                        1\n                    ], c));\n                }\n                for(var l = 1, g = true; l < t.length; l += 1){\n                    var v = t[l];\n                    var b = O(v, 0, 1);\n                    var A = O(v, -1);\n                    if ((b === '\"' || b === \"'\" || b === \"`\" || A === '\"' || A === \"'\" || A === \"`\") && b !== A) {\n                        throw new n(\"property names with quotes must have matching quotes\");\n                    }\n                    if (v === \"constructor\" || !g) {\n                        s = true;\n                    }\n                    i += \".\" + v;\n                    p = \"%\" + i + \"%\";\n                    if (m(d, p)) {\n                        u = d[p];\n                    } else if (u != null) {\n                        if (!(v in u)) {\n                            if (!e) {\n                                throw new a(\"base intrinsic for \" + r + \" exists, but the property is not available.\");\n                            }\n                            return void o;\n                        }\n                        if (y && l + 1 >= t.length) {\n                            var P = y(u, v);\n                            g = !!P;\n                            if (g && \"get\" in P && !(\"originalValue\" in P.get)) {\n                                u = P.get;\n                            } else {\n                                u = u[v];\n                            }\n                        } else {\n                            g = m(u, v);\n                            u = u[v];\n                        }\n                        if (g && !s) {\n                            d[p] = u;\n                        }\n                    }\n                }\n                return u;\n            };\n        },\n        504: function(r) {\n            \"use strict\";\n            var e = {\n                foo: {}\n            };\n            var t = Object;\n            r.exports = function hasProto() {\n                return ({\n                    __proto__: e\n                }).foo === e.foo && !(({\n                    __proto__: null\n                }) instanceof t);\n            };\n        },\n        942: function(r, e, t) {\n            \"use strict\";\n            var o = typeof Symbol !== \"undefined\" && Symbol;\n            var n = t(773);\n            r.exports = function hasNativeSymbols() {\n                if (typeof o !== \"function\") {\n                    return false;\n                }\n                if (typeof Symbol !== \"function\") {\n                    return false;\n                }\n                if (typeof o(\"foo\") !== \"symbol\") {\n                    return false;\n                }\n                if (typeof Symbol(\"bar\") !== \"symbol\") {\n                    return false;\n                }\n                return n();\n            };\n        },\n        773: function(r) {\n            \"use strict\";\n            r.exports = function hasSymbols() {\n                if (typeof Symbol !== \"function\" || typeof Object.getOwnPropertySymbols !== \"function\") {\n                    return false;\n                }\n                if (typeof Symbol.iterator === \"symbol\") {\n                    return true;\n                }\n                var r = {};\n                var e = Symbol(\"test\");\n                var t = Object(e);\n                if (typeof e === \"string\") {\n                    return false;\n                }\n                if (Object.prototype.toString.call(e) !== \"[object Symbol]\") {\n                    return false;\n                }\n                if (Object.prototype.toString.call(t) !== \"[object Symbol]\") {\n                    return false;\n                }\n                var o = 42;\n                r[e] = o;\n                for(e in r){\n                    return false;\n                }\n                if (typeof Object.keys === \"function\" && Object.keys(r).length !== 0) {\n                    return false;\n                }\n                if (typeof Object.getOwnPropertyNames === \"function\" && Object.getOwnPropertyNames(r).length !== 0) {\n                    return false;\n                }\n                var n = Object.getOwnPropertySymbols(r);\n                if (n.length !== 1 || n[0] !== e) {\n                    return false;\n                }\n                if (!Object.prototype.propertyIsEnumerable.call(r, e)) {\n                    return false;\n                }\n                if (typeof Object.getOwnPropertyDescriptor === \"function\") {\n                    var i = Object.getOwnPropertyDescriptor(r, e);\n                    if (i.value !== o || i.enumerable !== true) {\n                        return false;\n                    }\n                }\n                return true;\n            };\n        },\n        115: function(r, e, t) {\n            \"use strict\";\n            var o = typeof Symbol !== \"undefined\" && Symbol;\n            var n = t(832);\n            r.exports = function hasNativeSymbols() {\n                if (typeof o !== \"function\") {\n                    return false;\n                }\n                if (typeof Symbol !== \"function\") {\n                    return false;\n                }\n                if (typeof o(\"foo\") !== \"symbol\") {\n                    return false;\n                }\n                if (typeof Symbol(\"bar\") !== \"symbol\") {\n                    return false;\n                }\n                return n();\n            };\n        },\n        832: function(r) {\n            \"use strict\";\n            r.exports = function hasSymbols() {\n                if (typeof Symbol !== \"function\" || typeof Object.getOwnPropertySymbols !== \"function\") {\n                    return false;\n                }\n                if (typeof Symbol.iterator === \"symbol\") {\n                    return true;\n                }\n                var r = {};\n                var e = Symbol(\"test\");\n                var t = Object(e);\n                if (typeof e === \"string\") {\n                    return false;\n                }\n                if (Object.prototype.toString.call(e) !== \"[object Symbol]\") {\n                    return false;\n                }\n                if (Object.prototype.toString.call(t) !== \"[object Symbol]\") {\n                    return false;\n                }\n                var o = 42;\n                r[e] = o;\n                for(e in r){\n                    return false;\n                }\n                if (typeof Object.keys === \"function\" && Object.keys(r).length !== 0) {\n                    return false;\n                }\n                if (typeof Object.getOwnPropertyNames === \"function\" && Object.getOwnPropertyNames(r).length !== 0) {\n                    return false;\n                }\n                var n = Object.getOwnPropertySymbols(r);\n                if (n.length !== 1 || n[0] !== e) {\n                    return false;\n                }\n                if (!Object.prototype.propertyIsEnumerable.call(r, e)) {\n                    return false;\n                }\n                if (typeof Object.getOwnPropertyDescriptor === \"function\") {\n                    var i = Object.getOwnPropertyDescriptor(r, e);\n                    if (i.value !== o || i.enumerable !== true) {\n                        return false;\n                    }\n                }\n                return true;\n            };\n        },\n        101: function(r, e, t) {\n            \"use strict\";\n            var o = t(174);\n            r.exports = o.call(Function.call, Object.prototype.hasOwnProperty);\n        },\n        782: function(r) {\n            if (typeof Object.create === \"function\") {\n                r.exports = function inherits(r, e) {\n                    if (e) {\n                        r.super_ = e;\n                        r.prototype = Object.create(e.prototype, {\n                            constructor: {\n                                value: r,\n                                enumerable: false,\n                                writable: true,\n                                configurable: true\n                            }\n                        });\n                    }\n                };\n            } else {\n                r.exports = function inherits(r, e) {\n                    if (e) {\n                        r.super_ = e;\n                        var TempCtor = function() {};\n                        TempCtor.prototype = e.prototype;\n                        r.prototype = new TempCtor;\n                        r.prototype.constructor = r;\n                    }\n                };\n            }\n        },\n        157: function(r) {\n            \"use strict\";\n            var e = typeof Symbol === \"function\" && typeof Symbol.toStringTag === \"symbol\";\n            var t = Object.prototype.toString;\n            var o = function isArguments(r) {\n                if (e && r && typeof r === \"object\" && Symbol.toStringTag in r) {\n                    return false;\n                }\n                return t.call(r) === \"[object Arguments]\";\n            };\n            var n = function isArguments(r) {\n                if (o(r)) {\n                    return true;\n                }\n                return r !== null && typeof r === \"object\" && typeof r.length === \"number\" && r.length >= 0 && t.call(r) !== \"[object Array]\" && t.call(r.callee) === \"[object Function]\";\n            };\n            var i = function() {\n                return o(arguments);\n            }();\n            o.isLegacyArguments = n;\n            r.exports = i ? o : n;\n        },\n        391: function(r) {\n            \"use strict\";\n            var e = Object.prototype.toString;\n            var t = Function.prototype.toString;\n            var o = /^\\s*(?:function)?\\*/;\n            var n = typeof Symbol === \"function\" && typeof Symbol.toStringTag === \"symbol\";\n            var i = Object.getPrototypeOf;\n            var getGeneratorFunc = function() {\n                if (!n) {\n                    return false;\n                }\n                try {\n                    return Function(\"return function*() {}\")();\n                } catch (r) {}\n            };\n            var a = getGeneratorFunc();\n            var y = a ? i(a) : {};\n            r.exports = function isGeneratorFunction(r) {\n                if (typeof r !== \"function\") {\n                    return false;\n                }\n                if (o.test(t.call(r))) {\n                    return true;\n                }\n                if (!n) {\n                    var a = e.call(r);\n                    return a === \"[object GeneratorFunction]\";\n                }\n                return i(r) === y;\n            };\n        },\n        994: function(r, e, t) {\n            \"use strict\";\n            var o = t(144);\n            var n = t(349);\n            var i = t(256);\n            var a = i(\"Object.prototype.toString\");\n            var y = t(942)();\n            var f = y && typeof Symbol.toStringTag === \"symbol\";\n            var p = n();\n            var u = i(\"Array.prototype.indexOf\", true) || function indexOf(r, e) {\n                for(var t = 0; t < r.length; t += 1){\n                    if (r[t] === e) {\n                        return t;\n                    }\n                }\n                return -1;\n            };\n            var s = i(\"String.prototype.slice\");\n            var c = {};\n            var l = t(24);\n            var d = Object.getPrototypeOf;\n            if (f && l && d) {\n                o(p, function(r) {\n                    var e = new __webpack_require__.g[r];\n                    if (!(Symbol.toStringTag in e)) {\n                        throw new EvalError(\"this engine has support for Symbol.toStringTag, but \" + r + \" does not have the property! Please report this.\");\n                    }\n                    var t = d(e);\n                    var o = l(t, Symbol.toStringTag);\n                    if (!o) {\n                        var n = d(t);\n                        o = l(n, Symbol.toStringTag);\n                    }\n                    c[r] = o.get;\n                });\n            }\n            var g = function tryAllTypedArrays(r) {\n                var e = false;\n                o(c, function(t, o) {\n                    if (!e) {\n                        try {\n                            e = t.call(r) === o;\n                        } catch (r) {}\n                    }\n                });\n                return e;\n            };\n            r.exports = function isTypedArray(r) {\n                if (!r || typeof r !== \"object\") {\n                    return false;\n                }\n                if (!f) {\n                    var e = s(a(r), 8, -1);\n                    return u(p, e) > -1;\n                }\n                if (!l) {\n                    return false;\n                }\n                return g(r);\n            };\n        },\n        369: function(r) {\n            r.exports = function isBuffer(r) {\n                return r instanceof Buffer;\n            };\n        },\n        584: function(r, e, t) {\n            \"use strict\";\n            var o = t(157);\n            var n = t(391);\n            var i = t(490);\n            var a = t(994);\n            function uncurryThis(r) {\n                return r.call.bind(r);\n            }\n            var y = typeof BigInt !== \"undefined\";\n            var f = typeof Symbol !== \"undefined\";\n            var p = uncurryThis(Object.prototype.toString);\n            var u = uncurryThis(Number.prototype.valueOf);\n            var s = uncurryThis(String.prototype.valueOf);\n            var c = uncurryThis(Boolean.prototype.valueOf);\n            if (y) {\n                var l = uncurryThis(BigInt.prototype.valueOf);\n            }\n            if (f) {\n                var d = uncurryThis(Symbol.prototype.valueOf);\n            }\n            function checkBoxedPrimitive(r, e) {\n                if (typeof r !== \"object\") {\n                    return false;\n                }\n                try {\n                    e(r);\n                    return true;\n                } catch (r) {\n                    return false;\n                }\n            }\n            e.isArgumentsObject = o;\n            e.isGeneratorFunction = n;\n            e.isTypedArray = a;\n            function isPromise(r) {\n                return typeof Promise !== \"undefined\" && r instanceof Promise || r !== null && typeof r === \"object\" && typeof r.then === \"function\" && typeof r.catch === \"function\";\n            }\n            e.isPromise = isPromise;\n            function isArrayBufferView(r) {\n                if (typeof ArrayBuffer !== \"undefined\" && ArrayBuffer.isView) {\n                    return ArrayBuffer.isView(r);\n                }\n                return a(r) || isDataView(r);\n            }\n            e.isArrayBufferView = isArrayBufferView;\n            function isUint8Array(r) {\n                return i(r) === \"Uint8Array\";\n            }\n            e.isUint8Array = isUint8Array;\n            function isUint8ClampedArray(r) {\n                return i(r) === \"Uint8ClampedArray\";\n            }\n            e.isUint8ClampedArray = isUint8ClampedArray;\n            function isUint16Array(r) {\n                return i(r) === \"Uint16Array\";\n            }\n            e.isUint16Array = isUint16Array;\n            function isUint32Array(r) {\n                return i(r) === \"Uint32Array\";\n            }\n            e.isUint32Array = isUint32Array;\n            function isInt8Array(r) {\n                return i(r) === \"Int8Array\";\n            }\n            e.isInt8Array = isInt8Array;\n            function isInt16Array(r) {\n                return i(r) === \"Int16Array\";\n            }\n            e.isInt16Array = isInt16Array;\n            function isInt32Array(r) {\n                return i(r) === \"Int32Array\";\n            }\n            e.isInt32Array = isInt32Array;\n            function isFloat32Array(r) {\n                return i(r) === \"Float32Array\";\n            }\n            e.isFloat32Array = isFloat32Array;\n            function isFloat64Array(r) {\n                return i(r) === \"Float64Array\";\n            }\n            e.isFloat64Array = isFloat64Array;\n            function isBigInt64Array(r) {\n                return i(r) === \"BigInt64Array\";\n            }\n            e.isBigInt64Array = isBigInt64Array;\n            function isBigUint64Array(r) {\n                return i(r) === \"BigUint64Array\";\n            }\n            e.isBigUint64Array = isBigUint64Array;\n            function isMapToString(r) {\n                return p(r) === \"[object Map]\";\n            }\n            isMapToString.working = typeof Map !== \"undefined\" && isMapToString(new Map);\n            function isMap(r) {\n                if (typeof Map === \"undefined\") {\n                    return false;\n                }\n                return isMapToString.working ? isMapToString(r) : r instanceof Map;\n            }\n            e.isMap = isMap;\n            function isSetToString(r) {\n                return p(r) === \"[object Set]\";\n            }\n            isSetToString.working = typeof Set !== \"undefined\" && isSetToString(new Set);\n            function isSet(r) {\n                if (typeof Set === \"undefined\") {\n                    return false;\n                }\n                return isSetToString.working ? isSetToString(r) : r instanceof Set;\n            }\n            e.isSet = isSet;\n            function isWeakMapToString(r) {\n                return p(r) === \"[object WeakMap]\";\n            }\n            isWeakMapToString.working = typeof WeakMap !== \"undefined\" && isWeakMapToString(new WeakMap);\n            function isWeakMap(r) {\n                if (typeof WeakMap === \"undefined\") {\n                    return false;\n                }\n                return isWeakMapToString.working ? isWeakMapToString(r) : r instanceof WeakMap;\n            }\n            e.isWeakMap = isWeakMap;\n            function isWeakSetToString(r) {\n                return p(r) === \"[object WeakSet]\";\n            }\n            isWeakSetToString.working = typeof WeakSet !== \"undefined\" && isWeakSetToString(new WeakSet);\n            function isWeakSet(r) {\n                return isWeakSetToString(r);\n            }\n            e.isWeakSet = isWeakSet;\n            function isArrayBufferToString(r) {\n                return p(r) === \"[object ArrayBuffer]\";\n            }\n            isArrayBufferToString.working = typeof ArrayBuffer !== \"undefined\" && isArrayBufferToString(new ArrayBuffer);\n            function isArrayBuffer(r) {\n                if (typeof ArrayBuffer === \"undefined\") {\n                    return false;\n                }\n                return isArrayBufferToString.working ? isArrayBufferToString(r) : r instanceof ArrayBuffer;\n            }\n            e.isArrayBuffer = isArrayBuffer;\n            function isDataViewToString(r) {\n                return p(r) === \"[object DataView]\";\n            }\n            isDataViewToString.working = typeof ArrayBuffer !== \"undefined\" && typeof DataView !== \"undefined\" && isDataViewToString(new DataView(new ArrayBuffer(1), 0, 1));\n            function isDataView(r) {\n                if (typeof DataView === \"undefined\") {\n                    return false;\n                }\n                return isDataViewToString.working ? isDataViewToString(r) : r instanceof DataView;\n            }\n            e.isDataView = isDataView;\n            var g = typeof SharedArrayBuffer !== \"undefined\" ? SharedArrayBuffer : undefined;\n            function isSharedArrayBufferToString(r) {\n                return p(r) === \"[object SharedArrayBuffer]\";\n            }\n            function isSharedArrayBuffer(r) {\n                if (typeof g === \"undefined\") {\n                    return false;\n                }\n                if (typeof isSharedArrayBufferToString.working === \"undefined\") {\n                    isSharedArrayBufferToString.working = isSharedArrayBufferToString(new g);\n                }\n                return isSharedArrayBufferToString.working ? isSharedArrayBufferToString(r) : r instanceof g;\n            }\n            e.isSharedArrayBuffer = isSharedArrayBuffer;\n            function isAsyncFunction(r) {\n                return p(r) === \"[object AsyncFunction]\";\n            }\n            e.isAsyncFunction = isAsyncFunction;\n            function isMapIterator(r) {\n                return p(r) === \"[object Map Iterator]\";\n            }\n            e.isMapIterator = isMapIterator;\n            function isSetIterator(r) {\n                return p(r) === \"[object Set Iterator]\";\n            }\n            e.isSetIterator = isSetIterator;\n            function isGeneratorObject(r) {\n                return p(r) === \"[object Generator]\";\n            }\n            e.isGeneratorObject = isGeneratorObject;\n            function isWebAssemblyCompiledModule(r) {\n                return p(r) === \"[object WebAssembly.Module]\";\n            }\n            e.isWebAssemblyCompiledModule = isWebAssemblyCompiledModule;\n            function isNumberObject(r) {\n                return checkBoxedPrimitive(r, u);\n            }\n            e.isNumberObject = isNumberObject;\n            function isStringObject(r) {\n                return checkBoxedPrimitive(r, s);\n            }\n            e.isStringObject = isStringObject;\n            function isBooleanObject(r) {\n                return checkBoxedPrimitive(r, c);\n            }\n            e.isBooleanObject = isBooleanObject;\n            function isBigIntObject(r) {\n                return y && checkBoxedPrimitive(r, l);\n            }\n            e.isBigIntObject = isBigIntObject;\n            function isSymbolObject(r) {\n                return f && checkBoxedPrimitive(r, d);\n            }\n            e.isSymbolObject = isSymbolObject;\n            function isBoxedPrimitive(r) {\n                return isNumberObject(r) || isStringObject(r) || isBooleanObject(r) || isBigIntObject(r) || isSymbolObject(r);\n            }\n            e.isBoxedPrimitive = isBoxedPrimitive;\n            function isAnyArrayBuffer(r) {\n                return typeof Uint8Array !== \"undefined\" && (isArrayBuffer(r) || isSharedArrayBuffer(r));\n            }\n            e.isAnyArrayBuffer = isAnyArrayBuffer;\n            [\n                \"isProxy\",\n                \"isExternal\",\n                \"isModuleNamespaceObject\"\n            ].forEach(function(r) {\n                Object.defineProperty(e, r, {\n                    enumerable: false,\n                    value: function() {\n                        throw new Error(r + \" is not supported in userland\");\n                    }\n                });\n            });\n        },\n        177: function(r, e, t) {\n            var o = Object.getOwnPropertyDescriptors || function getOwnPropertyDescriptors(r) {\n                var e = Object.keys(r);\n                var t = {};\n                for(var o = 0; o < e.length; o++){\n                    t[e[o]] = Object.getOwnPropertyDescriptor(r, e[o]);\n                }\n                return t;\n            };\n            var n = /%[sdj%]/g;\n            e.format = function(r) {\n                if (!isString(r)) {\n                    var e = [];\n                    for(var t = 0; t < arguments.length; t++){\n                        e.push(inspect(arguments[t]));\n                    }\n                    return e.join(\" \");\n                }\n                var t = 1;\n                var o = arguments;\n                var i = o.length;\n                var a = String(r).replace(n, function(r) {\n                    if (r === \"%%\") return \"%\";\n                    if (t >= i) return r;\n                    switch(r){\n                        case \"%s\":\n                            return String(o[t++]);\n                        case \"%d\":\n                            return Number(o[t++]);\n                        case \"%j\":\n                            try {\n                                return JSON.stringify(o[t++]);\n                            } catch (r) {\n                                return \"[Circular]\";\n                            }\n                        default:\n                            return r;\n                    }\n                });\n                for(var y = o[t]; t < i; y = o[++t]){\n                    if (isNull(y) || !isObject(y)) {\n                        a += \" \" + y;\n                    } else {\n                        a += \" \" + inspect(y);\n                    }\n                }\n                return a;\n            };\n            e.deprecate = function(r, t) {\n                if (typeof process !== \"undefined\" && process.noDeprecation === true) {\n                    return r;\n                }\n                if (typeof process === \"undefined\") {\n                    return function() {\n                        return e.deprecate(r, t).apply(this, arguments);\n                    };\n                }\n                var o = false;\n                function deprecated() {\n                    if (!o) {\n                        if (process.throwDeprecation) {\n                            throw new Error(t);\n                        } else if (process.traceDeprecation) {\n                            console.trace(t);\n                        } else {\n                            console.error(t);\n                        }\n                        o = true;\n                    }\n                    return r.apply(this, arguments);\n                }\n                return deprecated;\n            };\n            var i = {};\n            var a = /^$/;\n            if (process.env.NODE_DEBUG) {\n                var y = process.env.NODE_DEBUG;\n                y = y.replace(/[|\\\\{}()[\\]^$+?.]/g, \"\\\\$&\").replace(/\\*/g, \".*\").replace(/,/g, \"$|^\").toUpperCase();\n                a = new RegExp(\"^\" + y + \"$\", \"i\");\n            }\n            e.debuglog = function(r) {\n                r = r.toUpperCase();\n                if (!i[r]) {\n                    if (a.test(r)) {\n                        var t = process.pid;\n                        i[r] = function() {\n                            var o = e.format.apply(e, arguments);\n                            console.error(\"%s %d: %s\", r, t, o);\n                        };\n                    } else {\n                        i[r] = function() {};\n                    }\n                }\n                return i[r];\n            };\n            function inspect(r, t) {\n                var o = {\n                    seen: [],\n                    stylize: stylizeNoColor\n                };\n                if (arguments.length >= 3) o.depth = arguments[2];\n                if (arguments.length >= 4) o.colors = arguments[3];\n                if (isBoolean(t)) {\n                    o.showHidden = t;\n                } else if (t) {\n                    e._extend(o, t);\n                }\n                if (isUndefined(o.showHidden)) o.showHidden = false;\n                if (isUndefined(o.depth)) o.depth = 2;\n                if (isUndefined(o.colors)) o.colors = false;\n                if (isUndefined(o.customInspect)) o.customInspect = true;\n                if (o.colors) o.stylize = stylizeWithColor;\n                return formatValue(o, r, o.depth);\n            }\n            e.inspect = inspect;\n            inspect.colors = {\n                bold: [\n                    1,\n                    22\n                ],\n                italic: [\n                    3,\n                    23\n                ],\n                underline: [\n                    4,\n                    24\n                ],\n                inverse: [\n                    7,\n                    27\n                ],\n                white: [\n                    37,\n                    39\n                ],\n                grey: [\n                    90,\n                    39\n                ],\n                black: [\n                    30,\n                    39\n                ],\n                blue: [\n                    34,\n                    39\n                ],\n                cyan: [\n                    36,\n                    39\n                ],\n                green: [\n                    32,\n                    39\n                ],\n                magenta: [\n                    35,\n                    39\n                ],\n                red: [\n                    31,\n                    39\n                ],\n                yellow: [\n                    33,\n                    39\n                ]\n            };\n            inspect.styles = {\n                special: \"cyan\",\n                number: \"yellow\",\n                boolean: \"yellow\",\n                undefined: \"grey\",\n                null: \"bold\",\n                string: \"green\",\n                date: \"magenta\",\n                regexp: \"red\"\n            };\n            function stylizeWithColor(r, e) {\n                var t = inspect.styles[e];\n                if (t) {\n                    return \"\\x1b[\" + inspect.colors[t][0] + \"m\" + r + \"\\x1b[\" + inspect.colors[t][1] + \"m\";\n                } else {\n                    return r;\n                }\n            }\n            function stylizeNoColor(r, e) {\n                return r;\n            }\n            function arrayToHash(r) {\n                var e = {};\n                r.forEach(function(r, t) {\n                    e[r] = true;\n                });\n                return e;\n            }\n            function formatValue(r, t, o) {\n                if (r.customInspect && t && isFunction(t.inspect) && t.inspect !== e.inspect && !(t.constructor && t.constructor.prototype === t)) {\n                    var n = t.inspect(o, r);\n                    if (!isString(n)) {\n                        n = formatValue(r, n, o);\n                    }\n                    return n;\n                }\n                var i = formatPrimitive(r, t);\n                if (i) {\n                    return i;\n                }\n                var a = Object.keys(t);\n                var y = arrayToHash(a);\n                if (r.showHidden) {\n                    a = Object.getOwnPropertyNames(t);\n                }\n                if (isError(t) && (a.indexOf(\"message\") >= 0 || a.indexOf(\"description\") >= 0)) {\n                    return formatError(t);\n                }\n                if (a.length === 0) {\n                    if (isFunction(t)) {\n                        var f = t.name ? \": \" + t.name : \"\";\n                        return r.stylize(\"[Function\" + f + \"]\", \"special\");\n                    }\n                    if (isRegExp(t)) {\n                        return r.stylize(RegExp.prototype.toString.call(t), \"regexp\");\n                    }\n                    if (isDate(t)) {\n                        return r.stylize(Date.prototype.toString.call(t), \"date\");\n                    }\n                    if (isError(t)) {\n                        return formatError(t);\n                    }\n                }\n                var p = \"\", u = false, s = [\n                    \"{\",\n                    \"}\"\n                ];\n                if (isArray(t)) {\n                    u = true;\n                    s = [\n                        \"[\",\n                        \"]\"\n                    ];\n                }\n                if (isFunction(t)) {\n                    var c = t.name ? \": \" + t.name : \"\";\n                    p = \" [Function\" + c + \"]\";\n                }\n                if (isRegExp(t)) {\n                    p = \" \" + RegExp.prototype.toString.call(t);\n                }\n                if (isDate(t)) {\n                    p = \" \" + Date.prototype.toUTCString.call(t);\n                }\n                if (isError(t)) {\n                    p = \" \" + formatError(t);\n                }\n                if (a.length === 0 && (!u || t.length == 0)) {\n                    return s[0] + p + s[1];\n                }\n                if (o < 0) {\n                    if (isRegExp(t)) {\n                        return r.stylize(RegExp.prototype.toString.call(t), \"regexp\");\n                    } else {\n                        return r.stylize(\"[Object]\", \"special\");\n                    }\n                }\n                r.seen.push(t);\n                var l;\n                if (u) {\n                    l = formatArray(r, t, o, y, a);\n                } else {\n                    l = a.map(function(e) {\n                        return formatProperty(r, t, o, y, e, u);\n                    });\n                }\n                r.seen.pop();\n                return reduceToSingleString(l, p, s);\n            }\n            function formatPrimitive(r, e) {\n                if (isUndefined(e)) return r.stylize(\"undefined\", \"undefined\");\n                if (isString(e)) {\n                    var t = \"'\" + JSON.stringify(e).replace(/^\"|\"$/g, \"\").replace(/'/g, \"\\\\'\").replace(/\\\\\"/g, '\"') + \"'\";\n                    return r.stylize(t, \"string\");\n                }\n                if (isNumber(e)) return r.stylize(\"\" + e, \"number\");\n                if (isBoolean(e)) return r.stylize(\"\" + e, \"boolean\");\n                if (isNull(e)) return r.stylize(\"null\", \"null\");\n            }\n            function formatError(r) {\n                return \"[\" + Error.prototype.toString.call(r) + \"]\";\n            }\n            function formatArray(r, e, t, o, n) {\n                var i = [];\n                for(var a = 0, y = e.length; a < y; ++a){\n                    if (hasOwnProperty(e, String(a))) {\n                        i.push(formatProperty(r, e, t, o, String(a), true));\n                    } else {\n                        i.push(\"\");\n                    }\n                }\n                n.forEach(function(n) {\n                    if (!n.match(/^\\d+$/)) {\n                        i.push(formatProperty(r, e, t, o, n, true));\n                    }\n                });\n                return i;\n            }\n            function formatProperty(r, e, t, o, n, i) {\n                var a, y, f;\n                f = Object.getOwnPropertyDescriptor(e, n) || {\n                    value: e[n]\n                };\n                if (f.get) {\n                    if (f.set) {\n                        y = r.stylize(\"[Getter/Setter]\", \"special\");\n                    } else {\n                        y = r.stylize(\"[Getter]\", \"special\");\n                    }\n                } else {\n                    if (f.set) {\n                        y = r.stylize(\"[Setter]\", \"special\");\n                    }\n                }\n                if (!hasOwnProperty(o, n)) {\n                    a = \"[\" + n + \"]\";\n                }\n                if (!y) {\n                    if (r.seen.indexOf(f.value) < 0) {\n                        if (isNull(t)) {\n                            y = formatValue(r, f.value, null);\n                        } else {\n                            y = formatValue(r, f.value, t - 1);\n                        }\n                        if (y.indexOf(\"\\n\") > -1) {\n                            if (i) {\n                                y = y.split(\"\\n\").map(function(r) {\n                                    return \"  \" + r;\n                                }).join(\"\\n\").substr(2);\n                            } else {\n                                y = \"\\n\" + y.split(\"\\n\").map(function(r) {\n                                    return \"   \" + r;\n                                }).join(\"\\n\");\n                            }\n                        }\n                    } else {\n                        y = r.stylize(\"[Circular]\", \"special\");\n                    }\n                }\n                if (isUndefined(a)) {\n                    if (i && n.match(/^\\d+$/)) {\n                        return y;\n                    }\n                    a = JSON.stringify(\"\" + n);\n                    if (a.match(/^\"([a-zA-Z_][a-zA-Z_0-9]*)\"$/)) {\n                        a = a.substr(1, a.length - 2);\n                        a = r.stylize(a, \"name\");\n                    } else {\n                        a = a.replace(/'/g, \"\\\\'\").replace(/\\\\\"/g, '\"').replace(/(^\"|\"$)/g, \"'\");\n                        a = r.stylize(a, \"string\");\n                    }\n                }\n                return a + \": \" + y;\n            }\n            function reduceToSingleString(r, e, t) {\n                var o = 0;\n                var n = r.reduce(function(r, e) {\n                    o++;\n                    if (e.indexOf(\"\\n\") >= 0) o++;\n                    return r + e.replace(/\\u001b\\[\\d\\d?m/g, \"\").length + 1;\n                }, 0);\n                if (n > 60) {\n                    return t[0] + (e === \"\" ? \"\" : e + \"\\n \") + \" \" + r.join(\",\\n  \") + \" \" + t[1];\n                }\n                return t[0] + e + \" \" + r.join(\", \") + \" \" + t[1];\n            }\n            e.types = t(584);\n            function isArray(r) {\n                return Array.isArray(r);\n            }\n            e.isArray = isArray;\n            function isBoolean(r) {\n                return typeof r === \"boolean\";\n            }\n            e.isBoolean = isBoolean;\n            function isNull(r) {\n                return r === null;\n            }\n            e.isNull = isNull;\n            function isNullOrUndefined(r) {\n                return r == null;\n            }\n            e.isNullOrUndefined = isNullOrUndefined;\n            function isNumber(r) {\n                return typeof r === \"number\";\n            }\n            e.isNumber = isNumber;\n            function isString(r) {\n                return typeof r === \"string\";\n            }\n            e.isString = isString;\n            function isSymbol(r) {\n                return typeof r === \"symbol\";\n            }\n            e.isSymbol = isSymbol;\n            function isUndefined(r) {\n                return r === void 0;\n            }\n            e.isUndefined = isUndefined;\n            function isRegExp(r) {\n                return isObject(r) && objectToString(r) === \"[object RegExp]\";\n            }\n            e.isRegExp = isRegExp;\n            e.types.isRegExp = isRegExp;\n            function isObject(r) {\n                return typeof r === \"object\" && r !== null;\n            }\n            e.isObject = isObject;\n            function isDate(r) {\n                return isObject(r) && objectToString(r) === \"[object Date]\";\n            }\n            e.isDate = isDate;\n            e.types.isDate = isDate;\n            function isError(r) {\n                return isObject(r) && (objectToString(r) === \"[object Error]\" || r instanceof Error);\n            }\n            e.isError = isError;\n            e.types.isNativeError = isError;\n            function isFunction(r) {\n                return typeof r === \"function\";\n            }\n            e.isFunction = isFunction;\n            function isPrimitive(r) {\n                return r === null || typeof r === \"boolean\" || typeof r === \"number\" || typeof r === \"string\" || typeof r === \"symbol\" || typeof r === \"undefined\";\n            }\n            e.isPrimitive = isPrimitive;\n            e.isBuffer = t(369);\n            function objectToString(r) {\n                return Object.prototype.toString.call(r);\n            }\n            function pad(r) {\n                return r < 10 ? \"0\" + r.toString(10) : r.toString(10);\n            }\n            var f = [\n                \"Jan\",\n                \"Feb\",\n                \"Mar\",\n                \"Apr\",\n                \"May\",\n                \"Jun\",\n                \"Jul\",\n                \"Aug\",\n                \"Sep\",\n                \"Oct\",\n                \"Nov\",\n                \"Dec\"\n            ];\n            function timestamp() {\n                var r = new Date;\n                var e = [\n                    pad(r.getHours()),\n                    pad(r.getMinutes()),\n                    pad(r.getSeconds())\n                ].join(\":\");\n                return [\n                    r.getDate(),\n                    f[r.getMonth()],\n                    e\n                ].join(\" \");\n            }\n            e.log = function() {\n                console.log(\"%s - %s\", timestamp(), e.format.apply(e, arguments));\n            };\n            e.inherits = t(782);\n            e._extend = function(r, e) {\n                if (!e || !isObject(e)) return r;\n                var t = Object.keys(e);\n                var o = t.length;\n                while(o--){\n                    r[t[o]] = e[t[o]];\n                }\n                return r;\n            };\n            function hasOwnProperty(r, e) {\n                return Object.prototype.hasOwnProperty.call(r, e);\n            }\n            var p = typeof Symbol !== \"undefined\" ? Symbol(\"util.promisify.custom\") : undefined;\n            e.promisify = function promisify(r) {\n                if (typeof r !== \"function\") throw new TypeError('The \"original\" argument must be of type Function');\n                if (p && r[p]) {\n                    var e = r[p];\n                    if (typeof e !== \"function\") {\n                        throw new TypeError('The \"util.promisify.custom\" argument must be of type Function');\n                    }\n                    Object.defineProperty(e, p, {\n                        value: e,\n                        enumerable: false,\n                        writable: false,\n                        configurable: true\n                    });\n                    return e;\n                }\n                function e() {\n                    var e, t;\n                    var o = new Promise(function(r, o) {\n                        e = r;\n                        t = o;\n                    });\n                    var n = [];\n                    for(var i = 0; i < arguments.length; i++){\n                        n.push(arguments[i]);\n                    }\n                    n.push(function(r, o) {\n                        if (r) {\n                            t(r);\n                        } else {\n                            e(o);\n                        }\n                    });\n                    try {\n                        r.apply(this, n);\n                    } catch (r) {\n                        t(r);\n                    }\n                    return o;\n                }\n                Object.setPrototypeOf(e, Object.getPrototypeOf(r));\n                if (p) Object.defineProperty(e, p, {\n                    value: e,\n                    enumerable: false,\n                    writable: false,\n                    configurable: true\n                });\n                return Object.defineProperties(e, o(r));\n            };\n            e.promisify.custom = p;\n            function callbackifyOnRejected(r, e) {\n                if (!r) {\n                    var t = new Error(\"Promise was rejected with a falsy value\");\n                    t.reason = r;\n                    r = t;\n                }\n                return e(r);\n            }\n            function callbackify(r) {\n                if (typeof r !== \"function\") {\n                    throw new TypeError('The \"original\" argument must be of type Function');\n                }\n                function callbackified() {\n                    var e = [];\n                    for(var t = 0; t < arguments.length; t++){\n                        e.push(arguments[t]);\n                    }\n                    var o = e.pop();\n                    if (typeof o !== \"function\") {\n                        throw new TypeError(\"The last argument must be of type Function\");\n                    }\n                    var n = this;\n                    var cb = function() {\n                        return o.apply(n, arguments);\n                    };\n                    r.apply(this, e).then(function(r) {\n                        process.nextTick(cb.bind(null, null, r));\n                    }, function(r) {\n                        process.nextTick(callbackifyOnRejected.bind(null, r, cb));\n                    });\n                }\n                Object.setPrototypeOf(callbackified, Object.getPrototypeOf(r));\n                Object.defineProperties(callbackified, o(r));\n                return callbackified;\n            }\n            e.callbackify = callbackify;\n        },\n        490: function(r, e, t) {\n            \"use strict\";\n            var o = t(144);\n            var n = t(349);\n            var i = t(256);\n            var a = i(\"Object.prototype.toString\");\n            var y = t(942)();\n            var f = y && typeof Symbol.toStringTag === \"symbol\";\n            var p = n();\n            var u = i(\"String.prototype.slice\");\n            var s = {};\n            var c = t(24);\n            var l = Object.getPrototypeOf;\n            if (f && c && l) {\n                o(p, function(r) {\n                    if (typeof __webpack_require__.g[r] === \"function\") {\n                        var e = new __webpack_require__.g[r];\n                        if (!(Symbol.toStringTag in e)) {\n                            throw new EvalError(\"this engine has support for Symbol.toStringTag, but \" + r + \" does not have the property! Please report this.\");\n                        }\n                        var t = l(e);\n                        var o = c(t, Symbol.toStringTag);\n                        if (!o) {\n                            var n = l(t);\n                            o = c(n, Symbol.toStringTag);\n                        }\n                        s[r] = o.get;\n                    }\n                });\n            }\n            var d = function tryAllTypedArrays(r) {\n                var e = false;\n                o(s, function(t, o) {\n                    if (!e) {\n                        try {\n                            var n = t.call(r);\n                            if (n === o) {\n                                e = n;\n                            }\n                        } catch (r) {}\n                    }\n                });\n                return e;\n            };\n            var g = t(994);\n            r.exports = function whichTypedArray(r) {\n                if (!g(r)) {\n                    return false;\n                }\n                if (!f) {\n                    return u(a(r), 8, -1);\n                }\n                return d(r);\n            };\n        },\n        349: function(r, e, t) {\n            \"use strict\";\n            var o = t(992);\n            r.exports = function availableTypedArrays() {\n                return o([\n                    \"BigInt64Array\",\n                    \"BigUint64Array\",\n                    \"Float32Array\",\n                    \"Float64Array\",\n                    \"Int16Array\",\n                    \"Int32Array\",\n                    \"Int8Array\",\n                    \"Uint16Array\",\n                    \"Uint32Array\",\n                    \"Uint8Array\",\n                    \"Uint8ClampedArray\"\n                ], function(r) {\n                    return typeof __webpack_require__.g[r] === \"function\";\n                });\n            };\n        },\n        24: function(r, e, t) {\n            \"use strict\";\n            var o = t(500);\n            var n = o(\"%Object.getOwnPropertyDescriptor%\", true);\n            if (n) {\n                try {\n                    n([], \"length\");\n                } catch (r) {\n                    n = null;\n                }\n            }\n            r.exports = n;\n        }\n    };\n    var e = {};\n    function __nccwpck_require__(t) {\n        var o = e[t];\n        if (o !== undefined) {\n            return o.exports;\n        }\n        var n = e[t] = {\n            exports: {}\n        };\n        var i = true;\n        try {\n            r[t](n, n.exports, __nccwpck_require__);\n            i = false;\n        } finally{\n            if (i) delete e[t];\n        }\n        return n.exports;\n    }\n    if (typeof __nccwpck_require__ !== \"undefined\") __nccwpck_require__.ab = __dirname + \"/\";\n    var t = __nccwpck_require__(177);\n    module.exports = t;\n})();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvdXRpbC91dGlsLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQztJQUFXLElBQUlBLElBQUU7UUFBQyxLQUFJLFNBQVNBLENBQUM7WUFBRUEsRUFBRUMsT0FBTyxHQUFDLFNBQVNELENBQUMsRUFBQ0UsQ0FBQyxFQUFDQyxDQUFDO2dCQUFFLElBQUdILEVBQUVJLE1BQU0sRUFBQyxPQUFPSixFQUFFSSxNQUFNLENBQUNGLEdBQUVDO2dCQUFHLElBQUcsS0FBSyxNQUFJSCxLQUFHLFNBQU9BLEdBQUUsTUFBTSxJQUFJSztnQkFBVSxJQUFHLGNBQVksT0FBT0gsR0FBRSxNQUFNLElBQUlHO2dCQUFVLElBQUlDLElBQUUsRUFBRTtnQkFBQyxJQUFJLElBQUlDLElBQUUsR0FBRUEsSUFBRVAsRUFBRVEsTUFBTSxFQUFDRCxJQUFJO29CQUFDLElBQUcsQ0FBQ0UsRUFBRUMsSUFBSSxDQUFDVixHQUFFTyxJQUFHO29CQUFTLElBQUlJLElBQUVYLENBQUMsQ0FBQ08sRUFBRTtvQkFBQyxJQUFHTCxFQUFFUSxJQUFJLENBQUNQLEdBQUVRLEdBQUVKLEdBQUVQLElBQUdNLEVBQUVNLElBQUksQ0FBQ0Q7Z0JBQUU7Z0JBQUMsT0FBT0w7WUFBQztZQUFFLElBQUlHLElBQUVJLE9BQU9DLFNBQVMsQ0FBQ0MsY0FBYztRQUFBO1FBQUUsS0FBSSxTQUFTZixDQUFDLEVBQUNTLENBQUMsRUFBQ1AsQ0FBQztZQUFFO1lBQWEsSUFBSUMsSUFBRUQsRUFBRTtZQUFLLElBQUlJLElBQUVKLEVBQUU7WUFBSyxJQUFJSyxJQUFFRCxFQUFFSCxFQUFFO1lBQTZCSCxFQUFFQyxPQUFPLEdBQUMsU0FBU2UsbUJBQW1CaEIsQ0FBQyxFQUFDUyxDQUFDO2dCQUFFLElBQUlQLElBQUVDLEVBQUVILEdBQUUsQ0FBQyxDQUFDUztnQkFBRyxJQUFHLE9BQU9QLE1BQUksY0FBWUssRUFBRVAsR0FBRSxpQkFBZSxD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O1lBQUM7WUFBQ04sRUFBRUMsT0FBTyxHQUFDSztRQUFDO0lBQUM7SUFBRSxJQUFJRyxJQUFFLENBQUM7SUFBRSxTQUFTaVMsb0JBQW9CeFMsQ0FBQztRQUFFLElBQUlDLElBQUVNLENBQUMsQ0FBQ1AsRUFBRTtRQUFDLElBQUdDLE1BQUlvTCxXQUFVO1lBQUMsT0FBT3BMLEVBQUVGLE9BQU87UUFBQTtRQUFDLElBQUlLLElBQUVHLENBQUMsQ0FBQ1AsRUFBRSxHQUFDO1lBQUNELFNBQVEsQ0FBQztRQUFDO1FBQUUsSUFBSU0sSUFBRTtRQUFLLElBQUc7WUFBQ1AsQ0FBQyxDQUFDRSxFQUFFLENBQUNJLEdBQUVBLEVBQUVMLE9BQU8sRUFBQ3lTO1lBQXFCblMsSUFBRTtRQUFLLFNBQVE7WUFBQyxJQUFHQSxHQUFFLE9BQU9FLENBQUMsQ0FBQ1AsRUFBRTtRQUFBO1FBQUMsT0FBT0ksRUFBRUwsT0FBTztJQUFBO0lBQUMsSUFBRyxPQUFPeVMsd0JBQXNCLGFBQVlBLG9CQUFvQkMsRUFBRSxHQUFDQyxTQUFTQSxHQUFDO0lBQUksSUFBSTFTLElBQUV3UyxvQkFBb0I7SUFBS0csT0FBTzVTLE9BQU8sR0FBQ0M7QUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3V0aWwvdXRpbC5qcz9hYzE0Il0sInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbigpe3ZhciByPXs5OTI6ZnVuY3Rpb24ocil7ci5leHBvcnRzPWZ1bmN0aW9uKHIsdCxvKXtpZihyLmZpbHRlcilyZXR1cm4gci5maWx0ZXIodCxvKTtpZih2b2lkIDA9PT1yfHxudWxsPT09cil0aHJvdyBuZXcgVHlwZUVycm9yO2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIHQpdGhyb3cgbmV3IFR5cGVFcnJvcjt2YXIgbj1bXTtmb3IodmFyIGk9MDtpPHIubGVuZ3RoO2krKyl7aWYoIWUuY2FsbChyLGkpKWNvbnRpbnVlO3ZhciBhPXJbaV07aWYodC5jYWxsKG8sYSxpLHIpKW4ucHVzaChhKX1yZXR1cm4gbn07dmFyIGU9T2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eX0sMjU2OmZ1bmN0aW9uKHIsZSx0KXtcInVzZSBzdHJpY3RcIjt2YXIgbz10KDkyNSk7dmFyIG49dCgxMzkpO3ZhciBpPW4obyhcIlN0cmluZy5wcm90b3R5cGUuaW5kZXhPZlwiKSk7ci5leHBvcnRzPWZ1bmN0aW9uIGNhbGxCb3VuZEludHJpbnNpYyhyLGUpe3ZhciB0PW8ociwhIWUpO2lmKHR5cGVvZiB0PT09XCJmdW5jdGlvblwiJiZpKHIsXCIucHJvdG90eXBlLlwiKT4tMSl7cmV0dXJuIG4odCl9cmV0dXJuIHR9fSwxMzk6ZnVuY3Rpb24ocixlLHQpe1widXNlIHN0cmljdFwiO3ZhciBvPXQoMTc0KTt2YXIgbj10KDkyNSk7dmFyIGk9bihcIiVGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHklXCIpO3ZhciBhPW4oXCIlRnVuY3Rpb24ucHJvdG90eXBlLmNhbGwlXCIpO3ZhciB5PW4oXCIlUmVmbGVjdC5hcHBseSVcIix0cnVlKXx8by5jYWxsKGEsaSk7dmFyIGY9bihcIiVPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJVwiLHRydWUpO3ZhciBwPW4oXCIlT2JqZWN0LmRlZmluZVByb3BlcnR5JVwiLHRydWUpO3ZhciB1PW4oXCIlTWF0aC5tYXglXCIpO2lmKHApe3RyeXtwKHt9LFwiYVwiLHt2YWx1ZToxfSl9Y2F0Y2gocil7cD1udWxsfX1yLmV4cG9ydHM9ZnVuY3Rpb24gY2FsbEJpbmQocil7dmFyIGU9eShvLGEsYXJndW1lbnRzKTtpZihmJiZwKXt2YXIgdD1mKGUsXCJsZW5ndGhcIik7aWYodC5jb25maWd1cmFibGUpe3AoZSxcImxlbmd0aFwiLHt2YWx1ZToxK3UoMCxyLmxlbmd0aC0oYXJndW1lbnRzLmxlbmd0aC0xKSl9KX19cmV0dXJuIGV9O3ZhciBzPWZ1bmN0aW9uIGFwcGx5QmluZCgpe3JldHVybiB5KG8saSxhcmd1bWVudHMpfTtpZihwKXtwKHIuZXhwb3J0cyxcImFwcGx5XCIse3ZhbHVlOnN9KX1lbHNle3IuZXhwb3J0cy5hcHBseT1zfX0sMTQ0OmZ1bmN0aW9uKHIpe3ZhciBlPU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7dmFyIHQ9T2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztyLmV4cG9ydHM9ZnVuY3Rpb24gZm9yRWFjaChyLG8sbil7aWYodC5jYWxsKG8pIT09XCJbb2JqZWN0IEZ1bmN0aW9uXVwiKXt0aHJvdyBuZXcgVHlwZUVycm9yKFwiaXRlcmF0b3IgbXVzdCBiZSBhIGZ1bmN0aW9uXCIpfXZhciBpPXIubGVuZ3RoO2lmKGk9PT0raSl7Zm9yKHZhciBhPTA7YTxpO2ErKyl7by5jYWxsKG4sclthXSxhLHIpfX1lbHNle2Zvcih2YXIgeSBpbiByKXtpZihlLmNhbGwocix5KSl7by5jYWxsKG4sclt5XSx5LHIpfX19fX0sNDI2OmZ1bmN0aW9uKHIpe1widXNlIHN0cmljdFwiO3ZhciBlPVwiRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQgY2FsbGVkIG9uIGluY29tcGF0aWJsZSBcIjt2YXIgdD1BcnJheS5wcm90b3R5cGUuc2xpY2U7dmFyIG89T2JqZWN0LnByb3RvdHlwZS50b1N0cmluZzt2YXIgbj1cIltvYmplY3QgRnVuY3Rpb25dXCI7ci5leHBvcnRzPWZ1bmN0aW9uIGJpbmQocil7dmFyIGk9dGhpcztpZih0eXBlb2YgaSE9PVwiZnVuY3Rpb25cInx8by5jYWxsKGkpIT09bil7dGhyb3cgbmV3IFR5cGVFcnJvcihlK2kpfXZhciBhPXQuY2FsbChhcmd1bWVudHMsMSk7dmFyIHk7dmFyIGJpbmRlcj1mdW5jdGlvbigpe2lmKHRoaXMgaW5zdGFuY2VvZiB5KXt2YXIgZT1pLmFwcGx5KHRoaXMsYS5jb25jYXQodC5jYWxsKGFyZ3VtZW50cykpKTtpZihPYmplY3QoZSk9PT1lKXtyZXR1cm4gZX1yZXR1cm4gdGhpc31lbHNle3JldHVybiBpLmFwcGx5KHIsYS5jb25jYXQodC5jYWxsKGFyZ3VtZW50cykpKX19O3ZhciBmPU1hdGgubWF4KDAsaS5sZW5ndGgtYS5sZW5ndGgpO3ZhciBwPVtdO2Zvcih2YXIgdT0wO3U8Zjt1Kyspe3AucHVzaChcIiRcIit1KX15PUZ1bmN0aW9uKFwiYmluZGVyXCIsXCJyZXR1cm4gZnVuY3Rpb24gKFwiK3Auam9pbihcIixcIikrXCIpeyByZXR1cm4gYmluZGVyLmFwcGx5KHRoaXMsYXJndW1lbnRzKTsgfVwiKShiaW5kZXIpO2lmKGkucHJvdG90eXBlKXt2YXIgcz1mdW5jdGlvbiBFbXB0eSgpe307cy5wcm90b3R5cGU9aS5wcm90b3R5cGU7eS5wcm90b3R5cGU9bmV3IHM7cy5wcm90b3R5cGU9bnVsbH1yZXR1cm4geX19LDE3NDpmdW5jdGlvbihyLGUsdCl7XCJ1c2Ugc3RyaWN0XCI7dmFyIG89dCg0MjYpO3IuZXhwb3J0cz1GdW5jdGlvbi5wcm90b3R5cGUuYmluZHx8b30sNTAwOmZ1bmN0aW9uKHIsZSx0KXtcInVzZSBzdHJpY3RcIjt2YXIgbzt2YXIgbj1TeW50YXhFcnJvcjt2YXIgaT1GdW5jdGlvbjt2YXIgYT1UeXBlRXJyb3I7dmFyIGdldEV2YWxsZWRDb25zdHJ1Y3Rvcj1mdW5jdGlvbihyKXt0cnl7cmV0dXJuIGkoJ1widXNlIHN0cmljdFwiOyByZXR1cm4gKCcrcitcIikuY29uc3RydWN0b3I7XCIpKCl9Y2F0Y2gocil7fX07dmFyIHk9T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtpZih5KXt0cnl7eSh7fSxcIlwiKX1jYXRjaChyKXt5PW51bGx9fXZhciB0aHJvd1R5cGVFcnJvcj1mdW5jdGlvbigpe3Rocm93IG5ldyBhfTt2YXIgZj15P2Z1bmN0aW9uKCl7dHJ5e2FyZ3VtZW50cy5jYWxsZWU7cmV0dXJuIHRocm93VHlwZUVycm9yfWNhdGNoKHIpe3RyeXtyZXR1cm4geShhcmd1bWVudHMsXCJjYWxsZWVcIikuZ2V0fWNhdGNoKHIpe3JldHVybiB0aHJvd1R5cGVFcnJvcn19fSgpOnRocm93VHlwZUVycm9yO3ZhciBwPXQoMTE1KSgpO3ZhciB1PU9iamVjdC5nZXRQcm90b3R5cGVPZnx8ZnVuY3Rpb24ocil7cmV0dXJuIHIuX19wcm90b19ffTt2YXIgcz17fTt2YXIgYz10eXBlb2YgVWludDhBcnJheT09PVwidW5kZWZpbmVkXCI/bzp1KFVpbnQ4QXJyYXkpO3ZhciBsPXtcIiVBZ2dyZWdhdGVFcnJvciVcIjp0eXBlb2YgQWdncmVnYXRlRXJyb3I9PT1cInVuZGVmaW5lZFwiP286QWdncmVnYXRlRXJyb3IsXCIlQXJyYXklXCI6QXJyYXksXCIlQXJyYXlCdWZmZXIlXCI6dHlwZW9mIEFycmF5QnVmZmVyPT09XCJ1bmRlZmluZWRcIj9vOkFycmF5QnVmZmVyLFwiJUFycmF5SXRlcmF0b3JQcm90b3R5cGUlXCI6cD91KFtdW1N5bWJvbC5pdGVyYXRvcl0oKSk6byxcIiVBc3luY0Zyb21TeW5jSXRlcmF0b3JQcm90b3R5cGUlXCI6byxcIiVBc3luY0Z1bmN0aW9uJVwiOnMsXCIlQXN5bmNHZW5lcmF0b3IlXCI6cyxcIiVBc3luY0dlbmVyYXRvckZ1bmN0aW9uJVwiOnMsXCIlQXN5bmNJdGVyYXRvclByb3RvdHlwZSVcIjpzLFwiJUF0b21pY3MlXCI6dHlwZW9mIEF0b21pY3M9PT1cInVuZGVmaW5lZFwiP286QXRvbWljcyxcIiVCaWdJbnQlXCI6dHlwZW9mIEJpZ0ludD09PVwidW5kZWZpbmVkXCI/bzpCaWdJbnQsXCIlQm9vbGVhbiVcIjpCb29sZWFuLFwiJURhdGFWaWV3JVwiOnR5cGVvZiBEYXRhVmlldz09PVwidW5kZWZpbmVkXCI/bzpEYXRhVmlldyxcIiVEYXRlJVwiOkRhdGUsXCIlZGVjb2RlVVJJJVwiOmRlY29kZVVSSSxcIiVkZWNvZGVVUklDb21wb25lbnQlXCI6ZGVjb2RlVVJJQ29tcG9uZW50LFwiJWVuY29kZVVSSSVcIjplbmNvZGVVUkksXCIlZW5jb2RlVVJJQ29tcG9uZW50JVwiOmVuY29kZVVSSUNvbXBvbmVudCxcIiVFcnJvciVcIjpFcnJvcixcIiVldmFsJVwiOmV2YWwsXCIlRXZhbEVycm9yJVwiOkV2YWxFcnJvcixcIiVGbG9hdDMyQXJyYXklXCI6dHlwZW9mIEZsb2F0MzJBcnJheT09PVwidW5kZWZpbmVkXCI/bzpGbG9hdDMyQXJyYXksXCIlRmxvYXQ2NEFycmF5JVwiOnR5cGVvZiBGbG9hdDY0QXJyYXk9PT1cInVuZGVmaW5lZFwiP286RmxvYXQ2NEFycmF5LFwiJUZpbmFsaXphdGlvblJlZ2lzdHJ5JVwiOnR5cGVvZiBGaW5hbGl6YXRpb25SZWdpc3RyeT09PVwidW5kZWZpbmVkXCI/bzpGaW5hbGl6YXRpb25SZWdpc3RyeSxcIiVGdW5jdGlvbiVcIjppLFwiJUdlbmVyYXRvckZ1bmN0aW9uJVwiOnMsXCIlSW50OEFycmF5JVwiOnR5cGVvZiBJbnQ4QXJyYXk9PT1cInVuZGVmaW5lZFwiP286SW50OEFycmF5LFwiJUludDE2QXJyYXklXCI6dHlwZW9mIEludDE2QXJyYXk9PT1cInVuZGVmaW5lZFwiP286SW50MTZBcnJheSxcIiVJbnQzMkFycmF5JVwiOnR5cGVvZiBJbnQzMkFycmF5PT09XCJ1bmRlZmluZWRcIj9vOkludDMyQXJyYXksXCIlaXNGaW5pdGUlXCI6aXNGaW5pdGUsXCIlaXNOYU4lXCI6aXNOYU4sXCIlSXRlcmF0b3JQcm90b3R5cGUlXCI6cD91KHUoW11bU3ltYm9sLml0ZXJhdG9yXSgpKSk6byxcIiVKU09OJVwiOnR5cGVvZiBKU09OPT09XCJvYmplY3RcIj9KU09OOm8sXCIlTWFwJVwiOnR5cGVvZiBNYXA9PT1cInVuZGVmaW5lZFwiP286TWFwLFwiJU1hcEl0ZXJhdG9yUHJvdG90eXBlJVwiOnR5cGVvZiBNYXA9PT1cInVuZGVmaW5lZFwifHwhcD9vOnUoKG5ldyBNYXApW1N5bWJvbC5pdGVyYXRvcl0oKSksXCIlTWF0aCVcIjpNYXRoLFwiJU51bWJlciVcIjpOdW1iZXIsXCIlT2JqZWN0JVwiOk9iamVjdCxcIiVwYXJzZUZsb2F0JVwiOnBhcnNlRmxvYXQsXCIlcGFyc2VJbnQlXCI6cGFyc2VJbnQsXCIlUHJvbWlzZSVcIjp0eXBlb2YgUHJvbWlzZT09PVwidW5kZWZpbmVkXCI/bzpQcm9taXNlLFwiJVByb3h5JVwiOnR5cGVvZiBQcm94eT09PVwidW5kZWZpbmVkXCI/bzpQcm94eSxcIiVSYW5nZUVycm9yJVwiOlJhbmdlRXJyb3IsXCIlUmVmZXJlbmNlRXJyb3IlXCI6UmVmZXJlbmNlRXJyb3IsXCIlUmVmbGVjdCVcIjp0eXBlb2YgUmVmbGVjdD09PVwidW5kZWZpbmVkXCI/bzpSZWZsZWN0LFwiJVJlZ0V4cCVcIjpSZWdFeHAsXCIlU2V0JVwiOnR5cGVvZiBTZXQ9PT1cInVuZGVmaW5lZFwiP286U2V0LFwiJVNldEl0ZXJhdG9yUHJvdG90eXBlJVwiOnR5cGVvZiBTZXQ9PT1cInVuZGVmaW5lZFwifHwhcD9vOnUoKG5ldyBTZXQpW1N5bWJvbC5pdGVyYXRvcl0oKSksXCIlU2hhcmVkQXJyYXlCdWZmZXIlXCI6dHlwZW9mIFNoYXJlZEFycmF5QnVmZmVyPT09XCJ1bmRlZmluZWRcIj9vOlNoYXJlZEFycmF5QnVmZmVyLFwiJVN0cmluZyVcIjpTdHJpbmcsXCIlU3RyaW5nSXRlcmF0b3JQcm90b3R5cGUlXCI6cD91KFwiXCJbU3ltYm9sLml0ZXJhdG9yXSgpKTpvLFwiJVN5bWJvbCVcIjpwP1N5bWJvbDpvLFwiJVN5bnRheEVycm9yJVwiOm4sXCIlVGhyb3dUeXBlRXJyb3IlXCI6ZixcIiVUeXBlZEFycmF5JVwiOmMsXCIlVHlwZUVycm9yJVwiOmEsXCIlVWludDhBcnJheSVcIjp0eXBlb2YgVWludDhBcnJheT09PVwidW5kZWZpbmVkXCI/bzpVaW50OEFycmF5LFwiJVVpbnQ4Q2xhbXBlZEFycmF5JVwiOnR5cGVvZiBVaW50OENsYW1wZWRBcnJheT09PVwidW5kZWZpbmVkXCI/bzpVaW50OENsYW1wZWRBcnJheSxcIiVVaW50MTZBcnJheSVcIjp0eXBlb2YgVWludDE2QXJyYXk9PT1cInVuZGVmaW5lZFwiP286VWludDE2QXJyYXksXCIlVWludDMyQXJyYXklXCI6dHlwZW9mIFVpbnQzMkFycmF5PT09XCJ1bmRlZmluZWRcIj9vOlVpbnQzMkFycmF5LFwiJVVSSUVycm9yJVwiOlVSSUVycm9yLFwiJVdlYWtNYXAlXCI6dHlwZW9mIFdlYWtNYXA9PT1cInVuZGVmaW5lZFwiP286V2Vha01hcCxcIiVXZWFrUmVmJVwiOnR5cGVvZiBXZWFrUmVmPT09XCJ1bmRlZmluZWRcIj9vOldlYWtSZWYsXCIlV2Vha1NldCVcIjp0eXBlb2YgV2Vha1NldD09PVwidW5kZWZpbmVkXCI/bzpXZWFrU2V0fTt2YXIgZD1mdW5jdGlvbiBkb0V2YWwocil7dmFyIGU7aWYocj09PVwiJUFzeW5jRnVuY3Rpb24lXCIpe2U9Z2V0RXZhbGxlZENvbnN0cnVjdG9yKFwiYXN5bmMgZnVuY3Rpb24gKCkge31cIil9ZWxzZSBpZihyPT09XCIlR2VuZXJhdG9yRnVuY3Rpb24lXCIpe2U9Z2V0RXZhbGxlZENvbnN0cnVjdG9yKFwiZnVuY3Rpb24qICgpIHt9XCIpfWVsc2UgaWYocj09PVwiJUFzeW5jR2VuZXJhdG9yRnVuY3Rpb24lXCIpe2U9Z2V0RXZhbGxlZENvbnN0cnVjdG9yKFwiYXN5bmMgZnVuY3Rpb24qICgpIHt9XCIpfWVsc2UgaWYocj09PVwiJUFzeW5jR2VuZXJhdG9yJVwiKXt2YXIgdD1kb0V2YWwoXCIlQXN5bmNHZW5lcmF0b3JGdW5jdGlvbiVcIik7aWYodCl7ZT10LnByb3RvdHlwZX19ZWxzZSBpZihyPT09XCIlQXN5bmNJdGVyYXRvclByb3RvdHlwZSVcIil7dmFyIG89ZG9FdmFsKFwiJUFzeW5jR2VuZXJhdG9yJVwiKTtpZihvKXtlPXUoby5wcm90b3R5cGUpfX1sW3JdPWU7cmV0dXJuIGV9O3ZhciBnPXtcIiVBcnJheUJ1ZmZlclByb3RvdHlwZSVcIjpbXCJBcnJheUJ1ZmZlclwiLFwicHJvdG90eXBlXCJdLFwiJUFycmF5UHJvdG90eXBlJVwiOltcIkFycmF5XCIsXCJwcm90b3R5cGVcIl0sXCIlQXJyYXlQcm90b19lbnRyaWVzJVwiOltcIkFycmF5XCIsXCJwcm90b3R5cGVcIixcImVudHJpZXNcIl0sXCIlQXJyYXlQcm90b19mb3JFYWNoJVwiOltcIkFycmF5XCIsXCJwcm90b3R5cGVcIixcImZvckVhY2hcIl0sXCIlQXJyYXlQcm90b19rZXlzJVwiOltcIkFycmF5XCIsXCJwcm90b3R5cGVcIixcImtleXNcIl0sXCIlQXJyYXlQcm90b192YWx1ZXMlXCI6W1wiQXJyYXlcIixcInByb3RvdHlwZVwiLFwidmFsdWVzXCJdLFwiJUFzeW5jRnVuY3Rpb25Qcm90b3R5cGUlXCI6W1wiQXN5bmNGdW5jdGlvblwiLFwicHJvdG90eXBlXCJdLFwiJUFzeW5jR2VuZXJhdG9yJVwiOltcIkFzeW5jR2VuZXJhdG9yRnVuY3Rpb25cIixcInByb3RvdHlwZVwiXSxcIiVBc3luY0dlbmVyYXRvclByb3RvdHlwZSVcIjpbXCJBc3luY0dlbmVyYXRvckZ1bmN0aW9uXCIsXCJwcm90b3R5cGVcIixcInByb3RvdHlwZVwiXSxcIiVCb29sZWFuUHJvdG90eXBlJVwiOltcIkJvb2xlYW5cIixcInByb3RvdHlwZVwiXSxcIiVEYXRhVmlld1Byb3RvdHlwZSVcIjpbXCJEYXRhVmlld1wiLFwicHJvdG90eXBlXCJdLFwiJURhdGVQcm90b3R5cGUlXCI6W1wiRGF0ZVwiLFwicHJvdG90eXBlXCJdLFwiJUVycm9yUHJvdG90eXBlJVwiOltcIkVycm9yXCIsXCJwcm90b3R5cGVcIl0sXCIlRXZhbEVycm9yUHJvdG90eXBlJVwiOltcIkV2YWxFcnJvclwiLFwicHJvdG90eXBlXCJdLFwiJUZsb2F0MzJBcnJheVByb3RvdHlwZSVcIjpbXCJGbG9hdDMyQXJyYXlcIixcInByb3RvdHlwZVwiXSxcIiVGbG9hdDY0QXJyYXlQcm90b3R5cGUlXCI6W1wiRmxvYXQ2NEFycmF5XCIsXCJwcm90b3R5cGVcIl0sXCIlRnVuY3Rpb25Qcm90b3R5cGUlXCI6W1wiRnVuY3Rpb25cIixcInByb3RvdHlwZVwiXSxcIiVHZW5lcmF0b3IlXCI6W1wiR2VuZXJhdG9yRnVuY3Rpb25cIixcInByb3RvdHlwZVwiXSxcIiVHZW5lcmF0b3JQcm90b3R5cGUlXCI6W1wiR2VuZXJhdG9yRnVuY3Rpb25cIixcInByb3RvdHlwZVwiLFwicHJvdG90eXBlXCJdLFwiJUludDhBcnJheVByb3RvdHlwZSVcIjpbXCJJbnQ4QXJyYXlcIixcInByb3RvdHlwZVwiXSxcIiVJbnQxNkFycmF5UHJvdG90eXBlJVwiOltcIkludDE2QXJyYXlcIixcInByb3RvdHlwZVwiXSxcIiVJbnQzMkFycmF5UHJvdG90eXBlJVwiOltcIkludDMyQXJyYXlcIixcInByb3RvdHlwZVwiXSxcIiVKU09OUGFyc2UlXCI6W1wiSlNPTlwiLFwicGFyc2VcIl0sXCIlSlNPTlN0cmluZ2lmeSVcIjpbXCJKU09OXCIsXCJzdHJpbmdpZnlcIl0sXCIlTWFwUHJvdG90eXBlJVwiOltcIk1hcFwiLFwicHJvdG90eXBlXCJdLFwiJU51bWJlclByb3RvdHlwZSVcIjpbXCJOdW1iZXJcIixcInByb3RvdHlwZVwiXSxcIiVPYmplY3RQcm90b3R5cGUlXCI6W1wiT2JqZWN0XCIsXCJwcm90b3R5cGVcIl0sXCIlT2JqUHJvdG9fdG9TdHJpbmclXCI6W1wiT2JqZWN0XCIsXCJwcm90b3R5cGVcIixcInRvU3RyaW5nXCJdLFwiJU9ialByb3RvX3ZhbHVlT2YlXCI6W1wiT2JqZWN0XCIsXCJwcm90b3R5cGVcIixcInZhbHVlT2ZcIl0sXCIlUHJvbWlzZVByb3RvdHlwZSVcIjpbXCJQcm9taXNlXCIsXCJwcm90b3R5cGVcIl0sXCIlUHJvbWlzZVByb3RvX3RoZW4lXCI6W1wiUHJvbWlzZVwiLFwicHJvdG90eXBlXCIsXCJ0aGVuXCJdLFwiJVByb21pc2VfYWxsJVwiOltcIlByb21pc2VcIixcImFsbFwiXSxcIiVQcm9taXNlX3JlamVjdCVcIjpbXCJQcm9taXNlXCIsXCJyZWplY3RcIl0sXCIlUHJvbWlzZV9yZXNvbHZlJVwiOltcIlByb21pc2VcIixcInJlc29sdmVcIl0sXCIlUmFuZ2VFcnJvclByb3RvdHlwZSVcIjpbXCJSYW5nZUVycm9yXCIsXCJwcm90b3R5cGVcIl0sXCIlUmVmZXJlbmNlRXJyb3JQcm90b3R5cGUlXCI6W1wiUmVmZXJlbmNlRXJyb3JcIixcInByb3RvdHlwZVwiXSxcIiVSZWdFeHBQcm90b3R5cGUlXCI6W1wiUmVnRXhwXCIsXCJwcm90b3R5cGVcIl0sXCIlU2V0UHJvdG90eXBlJVwiOltcIlNldFwiLFwicHJvdG90eXBlXCJdLFwiJVNoYXJlZEFycmF5QnVmZmVyUHJvdG90eXBlJVwiOltcIlNoYXJlZEFycmF5QnVmZmVyXCIsXCJwcm90b3R5cGVcIl0sXCIlU3RyaW5nUHJvdG90eXBlJVwiOltcIlN0cmluZ1wiLFwicHJvdG90eXBlXCJdLFwiJVN5bWJvbFByb3RvdHlwZSVcIjpbXCJTeW1ib2xcIixcInByb3RvdHlwZVwiXSxcIiVTeW50YXhFcnJvclByb3RvdHlwZSVcIjpbXCJTeW50YXhFcnJvclwiLFwicHJvdG90eXBlXCJdLFwiJVR5cGVkQXJyYXlQcm90b3R5cGUlXCI6W1wiVHlwZWRBcnJheVwiLFwicHJvdG90eXBlXCJdLFwiJVR5cGVFcnJvclByb3RvdHlwZSVcIjpbXCJUeXBlRXJyb3JcIixcInByb3RvdHlwZVwiXSxcIiVVaW50OEFycmF5UHJvdG90eXBlJVwiOltcIlVpbnQ4QXJyYXlcIixcInByb3RvdHlwZVwiXSxcIiVVaW50OENsYW1wZWRBcnJheVByb3RvdHlwZSVcIjpbXCJVaW50OENsYW1wZWRBcnJheVwiLFwicHJvdG90eXBlXCJdLFwiJVVpbnQxNkFycmF5UHJvdG90eXBlJVwiOltcIlVpbnQxNkFycmF5XCIsXCJwcm90b3R5cGVcIl0sXCIlVWludDMyQXJyYXlQcm90b3R5cGUlXCI6W1wiVWludDMyQXJyYXlcIixcInByb3RvdHlwZVwiXSxcIiVVUklFcnJvclByb3RvdHlwZSVcIjpbXCJVUklFcnJvclwiLFwicHJvdG90eXBlXCJdLFwiJVdlYWtNYXBQcm90b3R5cGUlXCI6W1wiV2Vha01hcFwiLFwicHJvdG90eXBlXCJdLFwiJVdlYWtTZXRQcm90b3R5cGUlXCI6W1wiV2Vha1NldFwiLFwicHJvdG90eXBlXCJdfTt2YXIgdj10KDE3NCk7dmFyIGI9dCgxMDEpO3ZhciBBPXYuY2FsbChGdW5jdGlvbi5jYWxsLEFycmF5LnByb3RvdHlwZS5jb25jYXQpO3ZhciBtPXYuY2FsbChGdW5jdGlvbi5hcHBseSxBcnJheS5wcm90b3R5cGUuc3BsaWNlKTt2YXIgUz12LmNhbGwoRnVuY3Rpb24uY2FsbCxTdHJpbmcucHJvdG90eXBlLnJlcGxhY2UpO3ZhciBoPXYuY2FsbChGdW5jdGlvbi5jYWxsLFN0cmluZy5wcm90b3R5cGUuc2xpY2UpO3ZhciBQPXYuY2FsbChGdW5jdGlvbi5jYWxsLFJlZ0V4cC5wcm90b3R5cGUuZXhlYyk7dmFyIE89L1teJS5bXFxdXSt8XFxbKD86KC0/XFxkKyg/OlxcLlxcZCspPyl8KFtcIiddKSgoPzooPyFcXDIpW15cXFxcXXxcXFxcLikqPylcXDIpXFxdfCg/PSg/OlxcLnxcXFtcXF0pKD86XFwufFxcW1xcXXwlJCkpL2c7dmFyIHc9L1xcXFwoXFxcXCk/L2c7dmFyIGo9ZnVuY3Rpb24gc3RyaW5nVG9QYXRoKHIpe3ZhciBlPWgociwwLDEpO3ZhciB0PWgociwtMSk7aWYoZT09PVwiJVwiJiZ0IT09XCIlXCIpe3Rocm93IG5ldyBuKFwiaW52YWxpZCBpbnRyaW5zaWMgc3ludGF4LCBleHBlY3RlZCBjbG9zaW5nIGAlYFwiKX1lbHNlIGlmKHQ9PT1cIiVcIiYmZSE9PVwiJVwiKXt0aHJvdyBuZXcgbihcImludmFsaWQgaW50cmluc2ljIHN5bnRheCwgZXhwZWN0ZWQgb3BlbmluZyBgJWBcIil9dmFyIG89W107UyhyLE8sKGZ1bmN0aW9uKHIsZSx0LG4pe29bby5sZW5ndGhdPXQ/UyhuLHcsXCIkMVwiKTplfHxyfSkpO3JldHVybiBvfTt2YXIgRT1mdW5jdGlvbiBnZXRCYXNlSW50cmluc2ljKHIsZSl7dmFyIHQ9cjt2YXIgbztpZihiKGcsdCkpe289Z1t0XTt0PVwiJVwiK29bMF0rXCIlXCJ9aWYoYihsLHQpKXt2YXIgaT1sW3RdO2lmKGk9PT1zKXtpPWQodCl9aWYodHlwZW9mIGk9PT1cInVuZGVmaW5lZFwiJiYhZSl7dGhyb3cgbmV3IGEoXCJpbnRyaW5zaWMgXCIrcitcIiBleGlzdHMsIGJ1dCBpcyBub3QgYXZhaWxhYmxlLiBQbGVhc2UgZmlsZSBhbiBpc3N1ZSFcIil9cmV0dXJue2FsaWFzOm8sbmFtZTp0LHZhbHVlOml9fXRocm93IG5ldyBuKFwiaW50cmluc2ljIFwiK3IrXCIgZG9lcyBub3QgZXhpc3QhXCIpfTtyLmV4cG9ydHM9ZnVuY3Rpb24gR2V0SW50cmluc2ljKHIsZSl7aWYodHlwZW9mIHIhPT1cInN0cmluZ1wifHxyLmxlbmd0aD09PTApe3Rocm93IG5ldyBhKFwiaW50cmluc2ljIG5hbWUgbXVzdCBiZSBhIG5vbi1lbXB0eSBzdHJpbmdcIil9aWYoYXJndW1lbnRzLmxlbmd0aD4xJiZ0eXBlb2YgZSE9PVwiYm9vbGVhblwiKXt0aHJvdyBuZXcgYSgnXCJhbGxvd01pc3NpbmdcIiBhcmd1bWVudCBtdXN0IGJlIGEgYm9vbGVhbicpfWlmKFAoL14lP1teJV0qJT8kL2cscik9PT1udWxsKXt0aHJvdyBuZXcgbihcImAlYCBtYXkgbm90IGJlIHByZXNlbnQgYW55d2hlcmUgYnV0IGF0IHRoZSBiZWdpbm5pbmcgYW5kIGVuZCBvZiB0aGUgaW50cmluc2ljIG5hbWVcIil9dmFyIHQ9aihyKTt2YXIgaT10Lmxlbmd0aD4wP3RbMF06XCJcIjt2YXIgZj1FKFwiJVwiK2krXCIlXCIsZSk7dmFyIHA9Zi5uYW1lO3ZhciB1PWYudmFsdWU7dmFyIHM9ZmFsc2U7dmFyIGM9Zi5hbGlhcztpZihjKXtpPWNbMF07bSh0LEEoWzAsMV0sYykpfWZvcih2YXIgZD0xLGc9dHJ1ZTtkPHQubGVuZ3RoO2QrPTEpe3ZhciB2PXRbZF07dmFyIFM9aCh2LDAsMSk7dmFyIE89aCh2LC0xKTtpZigoUz09PSdcIid8fFM9PT1cIidcInx8Uz09PVwiYFwifHwoTz09PSdcIid8fE89PT1cIidcInx8Tz09PVwiYFwiKSkmJlMhPT1PKXt0aHJvdyBuZXcgbihcInByb3BlcnR5IG5hbWVzIHdpdGggcXVvdGVzIG11c3QgaGF2ZSBtYXRjaGluZyBxdW90ZXNcIil9aWYodj09PVwiY29uc3RydWN0b3JcInx8IWcpe3M9dHJ1ZX1pKz1cIi5cIit2O3A9XCIlXCIraStcIiVcIjtpZihiKGwscCkpe3U9bFtwXX1lbHNlIGlmKHUhPW51bGwpe2lmKCEodiBpbiB1KSl7aWYoIWUpe3Rocm93IG5ldyBhKFwiYmFzZSBpbnRyaW5zaWMgZm9yIFwiK3IrXCIgZXhpc3RzLCBidXQgdGhlIHByb3BlcnR5IGlzIG5vdCBhdmFpbGFibGUuXCIpfXJldHVybiB2b2lkIG99aWYoeSYmZCsxPj10Lmxlbmd0aCl7dmFyIHc9eSh1LHYpO2c9ISF3O2lmKGcmJlwiZ2V0XCJpbiB3JiYhKFwib3JpZ2luYWxWYWx1ZVwiaW4gdy5nZXQpKXt1PXcuZ2V0fWVsc2V7dT11W3ZdfX1lbHNle2c9Yih1LHYpO3U9dVt2XX1pZihnJiYhcyl7bFtwXT11fX19cmV0dXJuIHV9fSw5MjU6ZnVuY3Rpb24ocixlLHQpe1widXNlIHN0cmljdFwiO3ZhciBvO3ZhciBuPVN5bnRheEVycm9yO3ZhciBpPUZ1bmN0aW9uO3ZhciBhPVR5cGVFcnJvcjt2YXIgZ2V0RXZhbGxlZENvbnN0cnVjdG9yPWZ1bmN0aW9uKHIpe3RyeXtyZXR1cm4gaSgnXCJ1c2Ugc3RyaWN0XCI7IHJldHVybiAoJytyK1wiKS5jb25zdHJ1Y3RvcjtcIikoKX1jYXRjaChyKXt9fTt2YXIgeT1PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO2lmKHkpe3RyeXt5KHt9LFwiXCIpfWNhdGNoKHIpe3k9bnVsbH19dmFyIHRocm93VHlwZUVycm9yPWZ1bmN0aW9uKCl7dGhyb3cgbmV3IGF9O3ZhciBmPXk/ZnVuY3Rpb24oKXt0cnl7YXJndW1lbnRzLmNhbGxlZTtyZXR1cm4gdGhyb3dUeXBlRXJyb3J9Y2F0Y2gocil7dHJ5e3JldHVybiB5KGFyZ3VtZW50cyxcImNhbGxlZVwiKS5nZXR9Y2F0Y2gocil7cmV0dXJuIHRocm93VHlwZUVycm9yfX19KCk6dGhyb3dUeXBlRXJyb3I7dmFyIHA9dCgxMTUpKCk7dmFyIHU9dCg1MDQpKCk7dmFyIHM9T2JqZWN0LmdldFByb3RvdHlwZU9mfHwodT9mdW5jdGlvbihyKXtyZXR1cm4gci5fX3Byb3RvX199Om51bGwpO3ZhciBjPXt9O3ZhciBsPXR5cGVvZiBVaW50OEFycmF5PT09XCJ1bmRlZmluZWRcInx8IXM/bzpzKFVpbnQ4QXJyYXkpO3ZhciBkPXtcIiVBZ2dyZWdhdGVFcnJvciVcIjp0eXBlb2YgQWdncmVnYXRlRXJyb3I9PT1cInVuZGVmaW5lZFwiP286QWdncmVnYXRlRXJyb3IsXCIlQXJyYXklXCI6QXJyYXksXCIlQXJyYXlCdWZmZXIlXCI6dHlwZW9mIEFycmF5QnVmZmVyPT09XCJ1bmRlZmluZWRcIj9vOkFycmF5QnVmZmVyLFwiJUFycmF5SXRlcmF0b3JQcm90b3R5cGUlXCI6cCYmcz9zKFtdW1N5bWJvbC5pdGVyYXRvcl0oKSk6byxcIiVBc3luY0Zyb21TeW5jSXRlcmF0b3JQcm90b3R5cGUlXCI6byxcIiVBc3luY0Z1bmN0aW9uJVwiOmMsXCIlQXN5bmNHZW5lcmF0b3IlXCI6YyxcIiVBc3luY0dlbmVyYXRvckZ1bmN0aW9uJVwiOmMsXCIlQXN5bmNJdGVyYXRvclByb3RvdHlwZSVcIjpjLFwiJUF0b21pY3MlXCI6dHlwZW9mIEF0b21pY3M9PT1cInVuZGVmaW5lZFwiP286QXRvbWljcyxcIiVCaWdJbnQlXCI6dHlwZW9mIEJpZ0ludD09PVwidW5kZWZpbmVkXCI/bzpCaWdJbnQsXCIlQmlnSW50NjRBcnJheSVcIjp0eXBlb2YgQmlnSW50NjRBcnJheT09PVwidW5kZWZpbmVkXCI/bzpCaWdJbnQ2NEFycmF5LFwiJUJpZ1VpbnQ2NEFycmF5JVwiOnR5cGVvZiBCaWdVaW50NjRBcnJheT09PVwidW5kZWZpbmVkXCI/bzpCaWdVaW50NjRBcnJheSxcIiVCb29sZWFuJVwiOkJvb2xlYW4sXCIlRGF0YVZpZXclXCI6dHlwZW9mIERhdGFWaWV3PT09XCJ1bmRlZmluZWRcIj9vOkRhdGFWaWV3LFwiJURhdGUlXCI6RGF0ZSxcIiVkZWNvZGVVUkklXCI6ZGVjb2RlVVJJLFwiJWRlY29kZVVSSUNvbXBvbmVudCVcIjpkZWNvZGVVUklDb21wb25lbnQsXCIlZW5jb2RlVVJJJVwiOmVuY29kZVVSSSxcIiVlbmNvZGVVUklDb21wb25lbnQlXCI6ZW5jb2RlVVJJQ29tcG9uZW50LFwiJUVycm9yJVwiOkVycm9yLFwiJWV2YWwlXCI6ZXZhbCxcIiVFdmFsRXJyb3IlXCI6RXZhbEVycm9yLFwiJUZsb2F0MzJBcnJheSVcIjp0eXBlb2YgRmxvYXQzMkFycmF5PT09XCJ1bmRlZmluZWRcIj9vOkZsb2F0MzJBcnJheSxcIiVGbG9hdDY0QXJyYXklXCI6dHlwZW9mIEZsb2F0NjRBcnJheT09PVwidW5kZWZpbmVkXCI/bzpGbG9hdDY0QXJyYXksXCIlRmluYWxpemF0aW9uUmVnaXN0cnklXCI6dHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5PT09XCJ1bmRlZmluZWRcIj9vOkZpbmFsaXphdGlvblJlZ2lzdHJ5LFwiJUZ1bmN0aW9uJVwiOmksXCIlR2VuZXJhdG9yRnVuY3Rpb24lXCI6YyxcIiVJbnQ4QXJyYXklXCI6dHlwZW9mIEludDhBcnJheT09PVwidW5kZWZpbmVkXCI/bzpJbnQ4QXJyYXksXCIlSW50MTZBcnJheSVcIjp0eXBlb2YgSW50MTZBcnJheT09PVwidW5kZWZpbmVkXCI/bzpJbnQxNkFycmF5LFwiJUludDMyQXJyYXklXCI6dHlwZW9mIEludDMyQXJyYXk9PT1cInVuZGVmaW5lZFwiP286SW50MzJBcnJheSxcIiVpc0Zpbml0ZSVcIjppc0Zpbml0ZSxcIiVpc05hTiVcIjppc05hTixcIiVJdGVyYXRvclByb3RvdHlwZSVcIjpwJiZzP3MocyhbXVtTeW1ib2wuaXRlcmF0b3JdKCkpKTpvLFwiJUpTT04lXCI6dHlwZW9mIEpTT049PT1cIm9iamVjdFwiP0pTT046byxcIiVNYXAlXCI6dHlwZW9mIE1hcD09PVwidW5kZWZpbmVkXCI/bzpNYXAsXCIlTWFwSXRlcmF0b3JQcm90b3R5cGUlXCI6dHlwZW9mIE1hcD09PVwidW5kZWZpbmVkXCJ8fCFwfHwhcz9vOnMoKG5ldyBNYXApW1N5bWJvbC5pdGVyYXRvcl0oKSksXCIlTWF0aCVcIjpNYXRoLFwiJU51bWJlciVcIjpOdW1iZXIsXCIlT2JqZWN0JVwiOk9iamVjdCxcIiVwYXJzZUZsb2F0JVwiOnBhcnNlRmxvYXQsXCIlcGFyc2VJbnQlXCI6cGFyc2VJbnQsXCIlUHJvbWlzZSVcIjp0eXBlb2YgUHJvbWlzZT09PVwidW5kZWZpbmVkXCI/bzpQcm9taXNlLFwiJVByb3h5JVwiOnR5cGVvZiBQcm94eT09PVwidW5kZWZpbmVkXCI/bzpQcm94eSxcIiVSYW5nZUVycm9yJVwiOlJhbmdlRXJyb3IsXCIlUmVmZXJlbmNlRXJyb3IlXCI6UmVmZXJlbmNlRXJyb3IsXCIlUmVmbGVjdCVcIjp0eXBlb2YgUmVmbGVjdD09PVwidW5kZWZpbmVkXCI/bzpSZWZsZWN0LFwiJVJlZ0V4cCVcIjpSZWdFeHAsXCIlU2V0JVwiOnR5cGVvZiBTZXQ9PT1cInVuZGVmaW5lZFwiP286U2V0LFwiJVNldEl0ZXJhdG9yUHJvdG90eXBlJVwiOnR5cGVvZiBTZXQ9PT1cInVuZGVmaW5lZFwifHwhcHx8IXM/bzpzKChuZXcgU2V0KVtTeW1ib2wuaXRlcmF0b3JdKCkpLFwiJVNoYXJlZEFycmF5QnVmZmVyJVwiOnR5cGVvZiBTaGFyZWRBcnJheUJ1ZmZlcj09PVwidW5kZWZpbmVkXCI/bzpTaGFyZWRBcnJheUJ1ZmZlcixcIiVTdHJpbmclXCI6U3RyaW5nLFwiJVN0cmluZ0l0ZXJhdG9yUHJvdG90eXBlJVwiOnAmJnM/cyhcIlwiW1N5bWJvbC5pdGVyYXRvcl0oKSk6byxcIiVTeW1ib2wlXCI6cD9TeW1ib2w6byxcIiVTeW50YXhFcnJvciVcIjpuLFwiJVRocm93VHlwZUVycm9yJVwiOmYsXCIlVHlwZWRBcnJheSVcIjpsLFwiJVR5cGVFcnJvciVcIjphLFwiJVVpbnQ4QXJyYXklXCI6dHlwZW9mIFVpbnQ4QXJyYXk9PT1cInVuZGVmaW5lZFwiP286VWludDhBcnJheSxcIiVVaW50OENsYW1wZWRBcnJheSVcIjp0eXBlb2YgVWludDhDbGFtcGVkQXJyYXk9PT1cInVuZGVmaW5lZFwiP286VWludDhDbGFtcGVkQXJyYXksXCIlVWludDE2QXJyYXklXCI6dHlwZW9mIFVpbnQxNkFycmF5PT09XCJ1bmRlZmluZWRcIj9vOlVpbnQxNkFycmF5LFwiJVVpbnQzMkFycmF5JVwiOnR5cGVvZiBVaW50MzJBcnJheT09PVwidW5kZWZpbmVkXCI/bzpVaW50MzJBcnJheSxcIiVVUklFcnJvciVcIjpVUklFcnJvcixcIiVXZWFrTWFwJVwiOnR5cGVvZiBXZWFrTWFwPT09XCJ1bmRlZmluZWRcIj9vOldlYWtNYXAsXCIlV2Vha1JlZiVcIjp0eXBlb2YgV2Vha1JlZj09PVwidW5kZWZpbmVkXCI/bzpXZWFrUmVmLFwiJVdlYWtTZXQlXCI6dHlwZW9mIFdlYWtTZXQ9PT1cInVuZGVmaW5lZFwiP286V2Vha1NldH07aWYocyl7dHJ5e251bGwuZXJyb3J9Y2F0Y2gocil7dmFyIGc9cyhzKHIpKTtkW1wiJUVycm9yLnByb3RvdHlwZSVcIl09Z319dmFyIHY9ZnVuY3Rpb24gZG9FdmFsKHIpe3ZhciBlO2lmKHI9PT1cIiVBc3luY0Z1bmN0aW9uJVwiKXtlPWdldEV2YWxsZWRDb25zdHJ1Y3RvcihcImFzeW5jIGZ1bmN0aW9uICgpIHt9XCIpfWVsc2UgaWYocj09PVwiJUdlbmVyYXRvckZ1bmN0aW9uJVwiKXtlPWdldEV2YWxsZWRDb25zdHJ1Y3RvcihcImZ1bmN0aW9uKiAoKSB7fVwiKX1lbHNlIGlmKHI9PT1cIiVBc3luY0dlbmVyYXRvckZ1bmN0aW9uJVwiKXtlPWdldEV2YWxsZWRDb25zdHJ1Y3RvcihcImFzeW5jIGZ1bmN0aW9uKiAoKSB7fVwiKX1lbHNlIGlmKHI9PT1cIiVBc3luY0dlbmVyYXRvciVcIil7dmFyIHQ9ZG9FdmFsKFwiJUFzeW5jR2VuZXJhdG9yRnVuY3Rpb24lXCIpO2lmKHQpe2U9dC5wcm90b3R5cGV9fWVsc2UgaWYocj09PVwiJUFzeW5jSXRlcmF0b3JQcm90b3R5cGUlXCIpe3ZhciBvPWRvRXZhbChcIiVBc3luY0dlbmVyYXRvciVcIik7aWYobyYmcyl7ZT1zKG8ucHJvdG90eXBlKX19ZFtyXT1lO3JldHVybiBlfTt2YXIgYj17XCIlQXJyYXlCdWZmZXJQcm90b3R5cGUlXCI6W1wiQXJyYXlCdWZmZXJcIixcInByb3RvdHlwZVwiXSxcIiVBcnJheVByb3RvdHlwZSVcIjpbXCJBcnJheVwiLFwicHJvdG90eXBlXCJdLFwiJUFycmF5UHJvdG9fZW50cmllcyVcIjpbXCJBcnJheVwiLFwicHJvdG90eXBlXCIsXCJlbnRyaWVzXCJdLFwiJUFycmF5UHJvdG9fZm9yRWFjaCVcIjpbXCJBcnJheVwiLFwicHJvdG90eXBlXCIsXCJmb3JFYWNoXCJdLFwiJUFycmF5UHJvdG9fa2V5cyVcIjpbXCJBcnJheVwiLFwicHJvdG90eXBlXCIsXCJrZXlzXCJdLFwiJUFycmF5UHJvdG9fdmFsdWVzJVwiOltcIkFycmF5XCIsXCJwcm90b3R5cGVcIixcInZhbHVlc1wiXSxcIiVBc3luY0Z1bmN0aW9uUHJvdG90eXBlJVwiOltcIkFzeW5jRnVuY3Rpb25cIixcInByb3RvdHlwZVwiXSxcIiVBc3luY0dlbmVyYXRvciVcIjpbXCJBc3luY0dlbmVyYXRvckZ1bmN0aW9uXCIsXCJwcm90b3R5cGVcIl0sXCIlQXN5bmNHZW5lcmF0b3JQcm90b3R5cGUlXCI6W1wiQXN5bmNHZW5lcmF0b3JGdW5jdGlvblwiLFwicHJvdG90eXBlXCIsXCJwcm90b3R5cGVcIl0sXCIlQm9vbGVhblByb3RvdHlwZSVcIjpbXCJCb29sZWFuXCIsXCJwcm90b3R5cGVcIl0sXCIlRGF0YVZpZXdQcm90b3R5cGUlXCI6W1wiRGF0YVZpZXdcIixcInByb3RvdHlwZVwiXSxcIiVEYXRlUHJvdG90eXBlJVwiOltcIkRhdGVcIixcInByb3RvdHlwZVwiXSxcIiVFcnJvclByb3RvdHlwZSVcIjpbXCJFcnJvclwiLFwicHJvdG90eXBlXCJdLFwiJUV2YWxFcnJvclByb3RvdHlwZSVcIjpbXCJFdmFsRXJyb3JcIixcInByb3RvdHlwZVwiXSxcIiVGbG9hdDMyQXJyYXlQcm90b3R5cGUlXCI6W1wiRmxvYXQzMkFycmF5XCIsXCJwcm90b3R5cGVcIl0sXCIlRmxvYXQ2NEFycmF5UHJvdG90eXBlJVwiOltcIkZsb2F0NjRBcnJheVwiLFwicHJvdG90eXBlXCJdLFwiJUZ1bmN0aW9uUHJvdG90eXBlJVwiOltcIkZ1bmN0aW9uXCIsXCJwcm90b3R5cGVcIl0sXCIlR2VuZXJhdG9yJVwiOltcIkdlbmVyYXRvckZ1bmN0aW9uXCIsXCJwcm90b3R5cGVcIl0sXCIlR2VuZXJhdG9yUHJvdG90eXBlJVwiOltcIkdlbmVyYXRvckZ1bmN0aW9uXCIsXCJwcm90b3R5cGVcIixcInByb3RvdHlwZVwiXSxcIiVJbnQ4QXJyYXlQcm90b3R5cGUlXCI6W1wiSW50OEFycmF5XCIsXCJwcm90b3R5cGVcIl0sXCIlSW50MTZBcnJheVByb3RvdHlwZSVcIjpbXCJJbnQxNkFycmF5XCIsXCJwcm90b3R5cGVcIl0sXCIlSW50MzJBcnJheVByb3RvdHlwZSVcIjpbXCJJbnQzMkFycmF5XCIsXCJwcm90b3R5cGVcIl0sXCIlSlNPTlBhcnNlJVwiOltcIkpTT05cIixcInBhcnNlXCJdLFwiJUpTT05TdHJpbmdpZnklXCI6W1wiSlNPTlwiLFwic3RyaW5naWZ5XCJdLFwiJU1hcFByb3RvdHlwZSVcIjpbXCJNYXBcIixcInByb3RvdHlwZVwiXSxcIiVOdW1iZXJQcm90b3R5cGUlXCI6W1wiTnVtYmVyXCIsXCJwcm90b3R5cGVcIl0sXCIlT2JqZWN0UHJvdG90eXBlJVwiOltcIk9iamVjdFwiLFwicHJvdG90eXBlXCJdLFwiJU9ialByb3RvX3RvU3RyaW5nJVwiOltcIk9iamVjdFwiLFwicHJvdG90eXBlXCIsXCJ0b1N0cmluZ1wiXSxcIiVPYmpQcm90b192YWx1ZU9mJVwiOltcIk9iamVjdFwiLFwicHJvdG90eXBlXCIsXCJ2YWx1ZU9mXCJdLFwiJVByb21pc2VQcm90b3R5cGUlXCI6W1wiUHJvbWlzZVwiLFwicHJvdG90eXBlXCJdLFwiJVByb21pc2VQcm90b190aGVuJVwiOltcIlByb21pc2VcIixcInByb3RvdHlwZVwiLFwidGhlblwiXSxcIiVQcm9taXNlX2FsbCVcIjpbXCJQcm9taXNlXCIsXCJhbGxcIl0sXCIlUHJvbWlzZV9yZWplY3QlXCI6W1wiUHJvbWlzZVwiLFwicmVqZWN0XCJdLFwiJVByb21pc2VfcmVzb2x2ZSVcIjpbXCJQcm9taXNlXCIsXCJyZXNvbHZlXCJdLFwiJVJhbmdlRXJyb3JQcm90b3R5cGUlXCI6W1wiUmFuZ2VFcnJvclwiLFwicHJvdG90eXBlXCJdLFwiJVJlZmVyZW5jZUVycm9yUHJvdG90eXBlJVwiOltcIlJlZmVyZW5jZUVycm9yXCIsXCJwcm90b3R5cGVcIl0sXCIlUmVnRXhwUHJvdG90eXBlJVwiOltcIlJlZ0V4cFwiLFwicHJvdG90eXBlXCJdLFwiJVNldFByb3RvdHlwZSVcIjpbXCJTZXRcIixcInByb3RvdHlwZVwiXSxcIiVTaGFyZWRBcnJheUJ1ZmZlclByb3RvdHlwZSVcIjpbXCJTaGFyZWRBcnJheUJ1ZmZlclwiLFwicHJvdG90eXBlXCJdLFwiJVN0cmluZ1Byb3RvdHlwZSVcIjpbXCJTdHJpbmdcIixcInByb3RvdHlwZVwiXSxcIiVTeW1ib2xQcm90b3R5cGUlXCI6W1wiU3ltYm9sXCIsXCJwcm90b3R5cGVcIl0sXCIlU3ludGF4RXJyb3JQcm90b3R5cGUlXCI6W1wiU3ludGF4RXJyb3JcIixcInByb3RvdHlwZVwiXSxcIiVUeXBlZEFycmF5UHJvdG90eXBlJVwiOltcIlR5cGVkQXJyYXlcIixcInByb3RvdHlwZVwiXSxcIiVUeXBlRXJyb3JQcm90b3R5cGUlXCI6W1wiVHlwZUVycm9yXCIsXCJwcm90b3R5cGVcIl0sXCIlVWludDhBcnJheVByb3RvdHlwZSVcIjpbXCJVaW50OEFycmF5XCIsXCJwcm90b3R5cGVcIl0sXCIlVWludDhDbGFtcGVkQXJyYXlQcm90b3R5cGUlXCI6W1wiVWludDhDbGFtcGVkQXJyYXlcIixcInByb3RvdHlwZVwiXSxcIiVVaW50MTZBcnJheVByb3RvdHlwZSVcIjpbXCJVaW50MTZBcnJheVwiLFwicHJvdG90eXBlXCJdLFwiJVVpbnQzMkFycmF5UHJvdG90eXBlJVwiOltcIlVpbnQzMkFycmF5XCIsXCJwcm90b3R5cGVcIl0sXCIlVVJJRXJyb3JQcm90b3R5cGUlXCI6W1wiVVJJRXJyb3JcIixcInByb3RvdHlwZVwiXSxcIiVXZWFrTWFwUHJvdG90eXBlJVwiOltcIldlYWtNYXBcIixcInByb3RvdHlwZVwiXSxcIiVXZWFrU2V0UHJvdG90eXBlJVwiOltcIldlYWtTZXRcIixcInByb3RvdHlwZVwiXX07dmFyIEE9dCgxNzQpO3ZhciBtPXQoMTAxKTt2YXIgUz1BLmNhbGwoRnVuY3Rpb24uY2FsbCxBcnJheS5wcm90b3R5cGUuY29uY2F0KTt2YXIgaD1BLmNhbGwoRnVuY3Rpb24uYXBwbHksQXJyYXkucHJvdG90eXBlLnNwbGljZSk7dmFyIFA9QS5jYWxsKEZ1bmN0aW9uLmNhbGwsU3RyaW5nLnByb3RvdHlwZS5yZXBsYWNlKTt2YXIgTz1BLmNhbGwoRnVuY3Rpb24uY2FsbCxTdHJpbmcucHJvdG90eXBlLnNsaWNlKTt2YXIgdz1BLmNhbGwoRnVuY3Rpb24uY2FsbCxSZWdFeHAucHJvdG90eXBlLmV4ZWMpO3ZhciBqPS9bXiUuW1xcXV0rfFxcWyg/OigtP1xcZCsoPzpcXC5cXGQrKT8pfChbXCInXSkoKD86KD8hXFwyKVteXFxcXF18XFxcXC4pKj8pXFwyKVxcXXwoPz0oPzpcXC58XFxbXFxdKSg/OlxcLnxcXFtcXF18JSQpKS9nO3ZhciBFPS9cXFxcKFxcXFwpPy9nO3ZhciBJPWZ1bmN0aW9uIHN0cmluZ1RvUGF0aChyKXt2YXIgZT1PKHIsMCwxKTt2YXIgdD1PKHIsLTEpO2lmKGU9PT1cIiVcIiYmdCE9PVwiJVwiKXt0aHJvdyBuZXcgbihcImludmFsaWQgaW50cmluc2ljIHN5bnRheCwgZXhwZWN0ZWQgY2xvc2luZyBgJWBcIil9ZWxzZSBpZih0PT09XCIlXCImJmUhPT1cIiVcIil7dGhyb3cgbmV3IG4oXCJpbnZhbGlkIGludHJpbnNpYyBzeW50YXgsIGV4cGVjdGVkIG9wZW5pbmcgYCVgXCIpfXZhciBvPVtdO1AocixqLChmdW5jdGlvbihyLGUsdCxuKXtvW28ubGVuZ3RoXT10P1AobixFLFwiJDFcIik6ZXx8cn0pKTtyZXR1cm4gb307dmFyIEI9ZnVuY3Rpb24gZ2V0QmFzZUludHJpbnNpYyhyLGUpe3ZhciB0PXI7dmFyIG87aWYobShiLHQpKXtvPWJbdF07dD1cIiVcIitvWzBdK1wiJVwifWlmKG0oZCx0KSl7dmFyIGk9ZFt0XTtpZihpPT09Yyl7aT12KHQpfWlmKHR5cGVvZiBpPT09XCJ1bmRlZmluZWRcIiYmIWUpe3Rocm93IG5ldyBhKFwiaW50cmluc2ljIFwiK3IrXCIgZXhpc3RzLCBidXQgaXMgbm90IGF2YWlsYWJsZS4gUGxlYXNlIGZpbGUgYW4gaXNzdWUhXCIpfXJldHVybnthbGlhczpvLG5hbWU6dCx2YWx1ZTppfX10aHJvdyBuZXcgbihcImludHJpbnNpYyBcIityK1wiIGRvZXMgbm90IGV4aXN0IVwiKX07ci5leHBvcnRzPWZ1bmN0aW9uIEdldEludHJpbnNpYyhyLGUpe2lmKHR5cGVvZiByIT09XCJzdHJpbmdcInx8ci5sZW5ndGg9PT0wKXt0aHJvdyBuZXcgYShcImludHJpbnNpYyBuYW1lIG11c3QgYmUgYSBub24tZW1wdHkgc3RyaW5nXCIpfWlmKGFyZ3VtZW50cy5sZW5ndGg+MSYmdHlwZW9mIGUhPT1cImJvb2xlYW5cIil7dGhyb3cgbmV3IGEoJ1wiYWxsb3dNaXNzaW5nXCIgYXJndW1lbnQgbXVzdCBiZSBhIGJvb2xlYW4nKX1pZih3KC9eJT9bXiVdKiU/JC8scik9PT1udWxsKXt0aHJvdyBuZXcgbihcImAlYCBtYXkgbm90IGJlIHByZXNlbnQgYW55d2hlcmUgYnV0IGF0IHRoZSBiZWdpbm5pbmcgYW5kIGVuZCBvZiB0aGUgaW50cmluc2ljIG5hbWVcIil9dmFyIHQ9SShyKTt2YXIgaT10Lmxlbmd0aD4wP3RbMF06XCJcIjt2YXIgZj1CKFwiJVwiK2krXCIlXCIsZSk7dmFyIHA9Zi5uYW1lO3ZhciB1PWYudmFsdWU7dmFyIHM9ZmFsc2U7dmFyIGM9Zi5hbGlhcztpZihjKXtpPWNbMF07aCh0LFMoWzAsMV0sYykpfWZvcih2YXIgbD0xLGc9dHJ1ZTtsPHQubGVuZ3RoO2wrPTEpe3ZhciB2PXRbbF07dmFyIGI9Tyh2LDAsMSk7dmFyIEE9Tyh2LC0xKTtpZigoYj09PSdcIid8fGI9PT1cIidcInx8Yj09PVwiYFwifHwoQT09PSdcIid8fEE9PT1cIidcInx8QT09PVwiYFwiKSkmJmIhPT1BKXt0aHJvdyBuZXcgbihcInByb3BlcnR5IG5hbWVzIHdpdGggcXVvdGVzIG11c3QgaGF2ZSBtYXRjaGluZyBxdW90ZXNcIil9aWYodj09PVwiY29uc3RydWN0b3JcInx8IWcpe3M9dHJ1ZX1pKz1cIi5cIit2O3A9XCIlXCIraStcIiVcIjtpZihtKGQscCkpe3U9ZFtwXX1lbHNlIGlmKHUhPW51bGwpe2lmKCEodiBpbiB1KSl7aWYoIWUpe3Rocm93IG5ldyBhKFwiYmFzZSBpbnRyaW5zaWMgZm9yIFwiK3IrXCIgZXhpc3RzLCBidXQgdGhlIHByb3BlcnR5IGlzIG5vdCBhdmFpbGFibGUuXCIpfXJldHVybiB2b2lkIG99aWYoeSYmbCsxPj10Lmxlbmd0aCl7dmFyIFA9eSh1LHYpO2c9ISFQO2lmKGcmJlwiZ2V0XCJpbiBQJiYhKFwib3JpZ2luYWxWYWx1ZVwiaW4gUC5nZXQpKXt1PVAuZ2V0fWVsc2V7dT11W3ZdfX1lbHNle2c9bSh1LHYpO3U9dVt2XX1pZihnJiYhcyl7ZFtwXT11fX19cmV0dXJuIHV9fSw1MDQ6ZnVuY3Rpb24ocil7XCJ1c2Ugc3RyaWN0XCI7dmFyIGU9e2Zvbzp7fX07dmFyIHQ9T2JqZWN0O3IuZXhwb3J0cz1mdW5jdGlvbiBoYXNQcm90bygpe3JldHVybntfX3Byb3RvX186ZX0uZm9vPT09ZS5mb28mJiEoe19fcHJvdG9fXzpudWxsfWluc3RhbmNlb2YgdCl9fSw5NDI6ZnVuY3Rpb24ocixlLHQpe1widXNlIHN0cmljdFwiO3ZhciBvPXR5cGVvZiBTeW1ib2whPT1cInVuZGVmaW5lZFwiJiZTeW1ib2w7dmFyIG49dCg3NzMpO3IuZXhwb3J0cz1mdW5jdGlvbiBoYXNOYXRpdmVTeW1ib2xzKCl7aWYodHlwZW9mIG8hPT1cImZ1bmN0aW9uXCIpe3JldHVybiBmYWxzZX1pZih0eXBlb2YgU3ltYm9sIT09XCJmdW5jdGlvblwiKXtyZXR1cm4gZmFsc2V9aWYodHlwZW9mIG8oXCJmb29cIikhPT1cInN5bWJvbFwiKXtyZXR1cm4gZmFsc2V9aWYodHlwZW9mIFN5bWJvbChcImJhclwiKSE9PVwic3ltYm9sXCIpe3JldHVybiBmYWxzZX1yZXR1cm4gbigpfX0sNzczOmZ1bmN0aW9uKHIpe1widXNlIHN0cmljdFwiO3IuZXhwb3J0cz1mdW5jdGlvbiBoYXNTeW1ib2xzKCl7aWYodHlwZW9mIFN5bWJvbCE9PVwiZnVuY3Rpb25cInx8dHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMhPT1cImZ1bmN0aW9uXCIpe3JldHVybiBmYWxzZX1pZih0eXBlb2YgU3ltYm9sLml0ZXJhdG9yPT09XCJzeW1ib2xcIil7cmV0dXJuIHRydWV9dmFyIHI9e307dmFyIGU9U3ltYm9sKFwidGVzdFwiKTt2YXIgdD1PYmplY3QoZSk7aWYodHlwZW9mIGU9PT1cInN0cmluZ1wiKXtyZXR1cm4gZmFsc2V9aWYoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGUpIT09XCJbb2JqZWN0IFN5bWJvbF1cIil7cmV0dXJuIGZhbHNlfWlmKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh0KSE9PVwiW29iamVjdCBTeW1ib2xdXCIpe3JldHVybiBmYWxzZX12YXIgbz00MjtyW2VdPW87Zm9yKGUgaW4gcil7cmV0dXJuIGZhbHNlfWlmKHR5cGVvZiBPYmplY3Qua2V5cz09PVwiZnVuY3Rpb25cIiYmT2JqZWN0LmtleXMocikubGVuZ3RoIT09MCl7cmV0dXJuIGZhbHNlfWlmKHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcz09PVwiZnVuY3Rpb25cIiYmT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMocikubGVuZ3RoIT09MCl7cmV0dXJuIGZhbHNlfXZhciBuPU9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMocik7aWYobi5sZW5ndGghPT0xfHxuWzBdIT09ZSl7cmV0dXJuIGZhbHNlfWlmKCFPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwocixlKSl7cmV0dXJuIGZhbHNlfWlmKHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yPT09XCJmdW5jdGlvblwiKXt2YXIgaT1PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHIsZSk7aWYoaS52YWx1ZSE9PW98fGkuZW51bWVyYWJsZSE9PXRydWUpe3JldHVybiBmYWxzZX19cmV0dXJuIHRydWV9fSwxMTU6ZnVuY3Rpb24ocixlLHQpe1widXNlIHN0cmljdFwiO3ZhciBvPXR5cGVvZiBTeW1ib2whPT1cInVuZGVmaW5lZFwiJiZTeW1ib2w7dmFyIG49dCg4MzIpO3IuZXhwb3J0cz1mdW5jdGlvbiBoYXNOYXRpdmVTeW1ib2xzKCl7aWYodHlwZW9mIG8hPT1cImZ1bmN0aW9uXCIpe3JldHVybiBmYWxzZX1pZih0eXBlb2YgU3ltYm9sIT09XCJmdW5jdGlvblwiKXtyZXR1cm4gZmFsc2V9aWYodHlwZW9mIG8oXCJmb29cIikhPT1cInN5bWJvbFwiKXtyZXR1cm4gZmFsc2V9aWYodHlwZW9mIFN5bWJvbChcImJhclwiKSE9PVwic3ltYm9sXCIpe3JldHVybiBmYWxzZX1yZXR1cm4gbigpfX0sODMyOmZ1bmN0aW9uKHIpe1widXNlIHN0cmljdFwiO3IuZXhwb3J0cz1mdW5jdGlvbiBoYXNTeW1ib2xzKCl7aWYodHlwZW9mIFN5bWJvbCE9PVwiZnVuY3Rpb25cInx8dHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMhPT1cImZ1bmN0aW9uXCIpe3JldHVybiBmYWxzZX1pZih0eXBlb2YgU3ltYm9sLml0ZXJhdG9yPT09XCJzeW1ib2xcIil7cmV0dXJuIHRydWV9dmFyIHI9e307dmFyIGU9U3ltYm9sKFwidGVzdFwiKTt2YXIgdD1PYmplY3QoZSk7aWYodHlwZW9mIGU9PT1cInN0cmluZ1wiKXtyZXR1cm4gZmFsc2V9aWYoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGUpIT09XCJbb2JqZWN0IFN5bWJvbF1cIil7cmV0dXJuIGZhbHNlfWlmKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh0KSE9PVwiW29iamVjdCBTeW1ib2xdXCIpe3JldHVybiBmYWxzZX12YXIgbz00MjtyW2VdPW87Zm9yKGUgaW4gcil7cmV0dXJuIGZhbHNlfWlmKHR5cGVvZiBPYmplY3Qua2V5cz09PVwiZnVuY3Rpb25cIiYmT2JqZWN0LmtleXMocikubGVuZ3RoIT09MCl7cmV0dXJuIGZhbHNlfWlmKHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcz09PVwiZnVuY3Rpb25cIiYmT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMocikubGVuZ3RoIT09MCl7cmV0dXJuIGZhbHNlfXZhciBuPU9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMocik7aWYobi5sZW5ndGghPT0xfHxuWzBdIT09ZSl7cmV0dXJuIGZhbHNlfWlmKCFPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwocixlKSl7cmV0dXJuIGZhbHNlfWlmKHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yPT09XCJmdW5jdGlvblwiKXt2YXIgaT1PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHIsZSk7aWYoaS52YWx1ZSE9PW98fGkuZW51bWVyYWJsZSE9PXRydWUpe3JldHVybiBmYWxzZX19cmV0dXJuIHRydWV9fSwxMDE6ZnVuY3Rpb24ocixlLHQpe1widXNlIHN0cmljdFwiO3ZhciBvPXQoMTc0KTtyLmV4cG9ydHM9by5jYWxsKEZ1bmN0aW9uLmNhbGwsT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSl9LDc4MjpmdW5jdGlvbihyKXtpZih0eXBlb2YgT2JqZWN0LmNyZWF0ZT09PVwiZnVuY3Rpb25cIil7ci5leHBvcnRzPWZ1bmN0aW9uIGluaGVyaXRzKHIsZSl7aWYoZSl7ci5zdXBlcl89ZTtyLnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKGUucHJvdG90eXBlLHtjb25zdHJ1Y3Rvcjp7dmFsdWU6cixlbnVtZXJhYmxlOmZhbHNlLHdyaXRhYmxlOnRydWUsY29uZmlndXJhYmxlOnRydWV9fSl9fX1lbHNle3IuZXhwb3J0cz1mdW5jdGlvbiBpbmhlcml0cyhyLGUpe2lmKGUpe3Iuc3VwZXJfPWU7dmFyIFRlbXBDdG9yPWZ1bmN0aW9uKCl7fTtUZW1wQ3Rvci5wcm90b3R5cGU9ZS5wcm90b3R5cGU7ci5wcm90b3R5cGU9bmV3IFRlbXBDdG9yO3IucHJvdG90eXBlLmNvbnN0cnVjdG9yPXJ9fX19LDE1NzpmdW5jdGlvbihyKXtcInVzZSBzdHJpY3RcIjt2YXIgZT10eXBlb2YgU3ltYm9sPT09XCJmdW5jdGlvblwiJiZ0eXBlb2YgU3ltYm9sLnRvU3RyaW5nVGFnPT09XCJzeW1ib2xcIjt2YXIgdD1PYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO3ZhciBvPWZ1bmN0aW9uIGlzQXJndW1lbnRzKHIpe2lmKGUmJnImJnR5cGVvZiByPT09XCJvYmplY3RcIiYmU3ltYm9sLnRvU3RyaW5nVGFnIGluIHIpe3JldHVybiBmYWxzZX1yZXR1cm4gdC5jYWxsKHIpPT09XCJbb2JqZWN0IEFyZ3VtZW50c11cIn07dmFyIG49ZnVuY3Rpb24gaXNBcmd1bWVudHMocil7aWYobyhyKSl7cmV0dXJuIHRydWV9cmV0dXJuIHIhPT1udWxsJiZ0eXBlb2Ygcj09PVwib2JqZWN0XCImJnR5cGVvZiByLmxlbmd0aD09PVwibnVtYmVyXCImJnIubGVuZ3RoPj0wJiZ0LmNhbGwocikhPT1cIltvYmplY3QgQXJyYXldXCImJnQuY2FsbChyLmNhbGxlZSk9PT1cIltvYmplY3QgRnVuY3Rpb25dXCJ9O3ZhciBpPWZ1bmN0aW9uKCl7cmV0dXJuIG8oYXJndW1lbnRzKX0oKTtvLmlzTGVnYWN5QXJndW1lbnRzPW47ci5leHBvcnRzPWk/bzpufSwzOTE6ZnVuY3Rpb24ocil7XCJ1c2Ugc3RyaWN0XCI7dmFyIGU9T2JqZWN0LnByb3RvdHlwZS50b1N0cmluZzt2YXIgdD1GdW5jdGlvbi5wcm90b3R5cGUudG9TdHJpbmc7dmFyIG89L15cXHMqKD86ZnVuY3Rpb24pP1xcKi87dmFyIG49dHlwZW9mIFN5bWJvbD09PVwiZnVuY3Rpb25cIiYmdHlwZW9mIFN5bWJvbC50b1N0cmluZ1RhZz09PVwic3ltYm9sXCI7dmFyIGk9T2JqZWN0LmdldFByb3RvdHlwZU9mO3ZhciBnZXRHZW5lcmF0b3JGdW5jPWZ1bmN0aW9uKCl7aWYoIW4pe3JldHVybiBmYWxzZX10cnl7cmV0dXJuIEZ1bmN0aW9uKFwicmV0dXJuIGZ1bmN0aW9uKigpIHt9XCIpKCl9Y2F0Y2gocil7fX07dmFyIGE9Z2V0R2VuZXJhdG9yRnVuYygpO3ZhciB5PWE/aShhKTp7fTtyLmV4cG9ydHM9ZnVuY3Rpb24gaXNHZW5lcmF0b3JGdW5jdGlvbihyKXtpZih0eXBlb2YgciE9PVwiZnVuY3Rpb25cIil7cmV0dXJuIGZhbHNlfWlmKG8udGVzdCh0LmNhbGwocikpKXtyZXR1cm4gdHJ1ZX1pZighbil7dmFyIGE9ZS5jYWxsKHIpO3JldHVybiBhPT09XCJbb2JqZWN0IEdlbmVyYXRvckZ1bmN0aW9uXVwifXJldHVybiBpKHIpPT09eX19LDk5NDpmdW5jdGlvbihyLGUsdCl7XCJ1c2Ugc3RyaWN0XCI7dmFyIG89dCgxNDQpO3ZhciBuPXQoMzQ5KTt2YXIgaT10KDI1Nik7dmFyIGE9aShcIk9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdcIik7dmFyIHk9dCg5NDIpKCk7dmFyIGY9eSYmdHlwZW9mIFN5bWJvbC50b1N0cmluZ1RhZz09PVwic3ltYm9sXCI7dmFyIHA9bigpO3ZhciB1PWkoXCJBcnJheS5wcm90b3R5cGUuaW5kZXhPZlwiLHRydWUpfHxmdW5jdGlvbiBpbmRleE9mKHIsZSl7Zm9yKHZhciB0PTA7dDxyLmxlbmd0aDt0Kz0xKXtpZihyW3RdPT09ZSl7cmV0dXJuIHR9fXJldHVybi0xfTt2YXIgcz1pKFwiU3RyaW5nLnByb3RvdHlwZS5zbGljZVwiKTt2YXIgYz17fTt2YXIgbD10KDI0KTt2YXIgZD1PYmplY3QuZ2V0UHJvdG90eXBlT2Y7aWYoZiYmbCYmZCl7byhwLChmdW5jdGlvbihyKXt2YXIgZT1uZXcgZ2xvYmFsW3JdO2lmKCEoU3ltYm9sLnRvU3RyaW5nVGFnIGluIGUpKXt0aHJvdyBuZXcgRXZhbEVycm9yKFwidGhpcyBlbmdpbmUgaGFzIHN1cHBvcnQgZm9yIFN5bWJvbC50b1N0cmluZ1RhZywgYnV0IFwiK3IrXCIgZG9lcyBub3QgaGF2ZSB0aGUgcHJvcGVydHkhIFBsZWFzZSByZXBvcnQgdGhpcy5cIil9dmFyIHQ9ZChlKTt2YXIgbz1sKHQsU3ltYm9sLnRvU3RyaW5nVGFnKTtpZighbyl7dmFyIG49ZCh0KTtvPWwobixTeW1ib2wudG9TdHJpbmdUYWcpfWNbcl09by5nZXR9KSl9dmFyIGc9ZnVuY3Rpb24gdHJ5QWxsVHlwZWRBcnJheXMocil7dmFyIGU9ZmFsc2U7byhjLChmdW5jdGlvbih0LG8pe2lmKCFlKXt0cnl7ZT10LmNhbGwocik9PT1vfWNhdGNoKHIpe319fSkpO3JldHVybiBlfTtyLmV4cG9ydHM9ZnVuY3Rpb24gaXNUeXBlZEFycmF5KHIpe2lmKCFyfHx0eXBlb2YgciE9PVwib2JqZWN0XCIpe3JldHVybiBmYWxzZX1pZighZil7dmFyIGU9cyhhKHIpLDgsLTEpO3JldHVybiB1KHAsZSk+LTF9aWYoIWwpe3JldHVybiBmYWxzZX1yZXR1cm4gZyhyKX19LDM2OTpmdW5jdGlvbihyKXtyLmV4cG9ydHM9ZnVuY3Rpb24gaXNCdWZmZXIocil7cmV0dXJuIHIgaW5zdGFuY2VvZiBCdWZmZXJ9fSw1ODQ6ZnVuY3Rpb24ocixlLHQpe1widXNlIHN0cmljdFwiO3ZhciBvPXQoMTU3KTt2YXIgbj10KDM5MSk7dmFyIGk9dCg0OTApO3ZhciBhPXQoOTk0KTtmdW5jdGlvbiB1bmN1cnJ5VGhpcyhyKXtyZXR1cm4gci5jYWxsLmJpbmQocil9dmFyIHk9dHlwZW9mIEJpZ0ludCE9PVwidW5kZWZpbmVkXCI7dmFyIGY9dHlwZW9mIFN5bWJvbCE9PVwidW5kZWZpbmVkXCI7dmFyIHA9dW5jdXJyeVRoaXMoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZyk7dmFyIHU9dW5jdXJyeVRoaXMoTnVtYmVyLnByb3RvdHlwZS52YWx1ZU9mKTt2YXIgcz11bmN1cnJ5VGhpcyhTdHJpbmcucHJvdG90eXBlLnZhbHVlT2YpO3ZhciBjPXVuY3VycnlUaGlzKEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YpO2lmKHkpe3ZhciBsPXVuY3VycnlUaGlzKEJpZ0ludC5wcm90b3R5cGUudmFsdWVPZil9aWYoZil7dmFyIGQ9dW5jdXJyeVRoaXMoU3ltYm9sLnByb3RvdHlwZS52YWx1ZU9mKX1mdW5jdGlvbiBjaGVja0JveGVkUHJpbWl0aXZlKHIsZSl7aWYodHlwZW9mIHIhPT1cIm9iamVjdFwiKXtyZXR1cm4gZmFsc2V9dHJ5e2Uocik7cmV0dXJuIHRydWV9Y2F0Y2gocil7cmV0dXJuIGZhbHNlfX1lLmlzQXJndW1lbnRzT2JqZWN0PW87ZS5pc0dlbmVyYXRvckZ1bmN0aW9uPW47ZS5pc1R5cGVkQXJyYXk9YTtmdW5jdGlvbiBpc1Byb21pc2Uocil7cmV0dXJuIHR5cGVvZiBQcm9taXNlIT09XCJ1bmRlZmluZWRcIiYmciBpbnN0YW5jZW9mIFByb21pc2V8fHIhPT1udWxsJiZ0eXBlb2Ygcj09PVwib2JqZWN0XCImJnR5cGVvZiByLnRoZW49PT1cImZ1bmN0aW9uXCImJnR5cGVvZiByLmNhdGNoPT09XCJmdW5jdGlvblwifWUuaXNQcm9taXNlPWlzUHJvbWlzZTtmdW5jdGlvbiBpc0FycmF5QnVmZmVyVmlldyhyKXtpZih0eXBlb2YgQXJyYXlCdWZmZXIhPT1cInVuZGVmaW5lZFwiJiZBcnJheUJ1ZmZlci5pc1ZpZXcpe3JldHVybiBBcnJheUJ1ZmZlci5pc1ZpZXcocil9cmV0dXJuIGEocil8fGlzRGF0YVZpZXcocil9ZS5pc0FycmF5QnVmZmVyVmlldz1pc0FycmF5QnVmZmVyVmlldztmdW5jdGlvbiBpc1VpbnQ4QXJyYXkocil7cmV0dXJuIGkocik9PT1cIlVpbnQ4QXJyYXlcIn1lLmlzVWludDhBcnJheT1pc1VpbnQ4QXJyYXk7ZnVuY3Rpb24gaXNVaW50OENsYW1wZWRBcnJheShyKXtyZXR1cm4gaShyKT09PVwiVWludDhDbGFtcGVkQXJyYXlcIn1lLmlzVWludDhDbGFtcGVkQXJyYXk9aXNVaW50OENsYW1wZWRBcnJheTtmdW5jdGlvbiBpc1VpbnQxNkFycmF5KHIpe3JldHVybiBpKHIpPT09XCJVaW50MTZBcnJheVwifWUuaXNVaW50MTZBcnJheT1pc1VpbnQxNkFycmF5O2Z1bmN0aW9uIGlzVWludDMyQXJyYXkocil7cmV0dXJuIGkocik9PT1cIlVpbnQzMkFycmF5XCJ9ZS5pc1VpbnQzMkFycmF5PWlzVWludDMyQXJyYXk7ZnVuY3Rpb24gaXNJbnQ4QXJyYXkocil7cmV0dXJuIGkocik9PT1cIkludDhBcnJheVwifWUuaXNJbnQ4QXJyYXk9aXNJbnQ4QXJyYXk7ZnVuY3Rpb24gaXNJbnQxNkFycmF5KHIpe3JldHVybiBpKHIpPT09XCJJbnQxNkFycmF5XCJ9ZS5pc0ludDE2QXJyYXk9aXNJbnQxNkFycmF5O2Z1bmN0aW9uIGlzSW50MzJBcnJheShyKXtyZXR1cm4gaShyKT09PVwiSW50MzJBcnJheVwifWUuaXNJbnQzMkFycmF5PWlzSW50MzJBcnJheTtmdW5jdGlvbiBpc0Zsb2F0MzJBcnJheShyKXtyZXR1cm4gaShyKT09PVwiRmxvYXQzMkFycmF5XCJ9ZS5pc0Zsb2F0MzJBcnJheT1pc0Zsb2F0MzJBcnJheTtmdW5jdGlvbiBpc0Zsb2F0NjRBcnJheShyKXtyZXR1cm4gaShyKT09PVwiRmxvYXQ2NEFycmF5XCJ9ZS5pc0Zsb2F0NjRBcnJheT1pc0Zsb2F0NjRBcnJheTtmdW5jdGlvbiBpc0JpZ0ludDY0QXJyYXkocil7cmV0dXJuIGkocik9PT1cIkJpZ0ludDY0QXJyYXlcIn1lLmlzQmlnSW50NjRBcnJheT1pc0JpZ0ludDY0QXJyYXk7ZnVuY3Rpb24gaXNCaWdVaW50NjRBcnJheShyKXtyZXR1cm4gaShyKT09PVwiQmlnVWludDY0QXJyYXlcIn1lLmlzQmlnVWludDY0QXJyYXk9aXNCaWdVaW50NjRBcnJheTtmdW5jdGlvbiBpc01hcFRvU3RyaW5nKHIpe3JldHVybiBwKHIpPT09XCJbb2JqZWN0IE1hcF1cIn1pc01hcFRvU3RyaW5nLndvcmtpbmc9dHlwZW9mIE1hcCE9PVwidW5kZWZpbmVkXCImJmlzTWFwVG9TdHJpbmcobmV3IE1hcCk7ZnVuY3Rpb24gaXNNYXAocil7aWYodHlwZW9mIE1hcD09PVwidW5kZWZpbmVkXCIpe3JldHVybiBmYWxzZX1yZXR1cm4gaXNNYXBUb1N0cmluZy53b3JraW5nP2lzTWFwVG9TdHJpbmcocik6ciBpbnN0YW5jZW9mIE1hcH1lLmlzTWFwPWlzTWFwO2Z1bmN0aW9uIGlzU2V0VG9TdHJpbmcocil7cmV0dXJuIHAocik9PT1cIltvYmplY3QgU2V0XVwifWlzU2V0VG9TdHJpbmcud29ya2luZz10eXBlb2YgU2V0IT09XCJ1bmRlZmluZWRcIiYmaXNTZXRUb1N0cmluZyhuZXcgU2V0KTtmdW5jdGlvbiBpc1NldChyKXtpZih0eXBlb2YgU2V0PT09XCJ1bmRlZmluZWRcIil7cmV0dXJuIGZhbHNlfXJldHVybiBpc1NldFRvU3RyaW5nLndvcmtpbmc/aXNTZXRUb1N0cmluZyhyKTpyIGluc3RhbmNlb2YgU2V0fWUuaXNTZXQ9aXNTZXQ7ZnVuY3Rpb24gaXNXZWFrTWFwVG9TdHJpbmcocil7cmV0dXJuIHAocik9PT1cIltvYmplY3QgV2Vha01hcF1cIn1pc1dlYWtNYXBUb1N0cmluZy53b3JraW5nPXR5cGVvZiBXZWFrTWFwIT09XCJ1bmRlZmluZWRcIiYmaXNXZWFrTWFwVG9TdHJpbmcobmV3IFdlYWtNYXApO2Z1bmN0aW9uIGlzV2Vha01hcChyKXtpZih0eXBlb2YgV2Vha01hcD09PVwidW5kZWZpbmVkXCIpe3JldHVybiBmYWxzZX1yZXR1cm4gaXNXZWFrTWFwVG9TdHJpbmcud29ya2luZz9pc1dlYWtNYXBUb1N0cmluZyhyKTpyIGluc3RhbmNlb2YgV2Vha01hcH1lLmlzV2Vha01hcD1pc1dlYWtNYXA7ZnVuY3Rpb24gaXNXZWFrU2V0VG9TdHJpbmcocil7cmV0dXJuIHAocik9PT1cIltvYmplY3QgV2Vha1NldF1cIn1pc1dlYWtTZXRUb1N0cmluZy53b3JraW5nPXR5cGVvZiBXZWFrU2V0IT09XCJ1bmRlZmluZWRcIiYmaXNXZWFrU2V0VG9TdHJpbmcobmV3IFdlYWtTZXQpO2Z1bmN0aW9uIGlzV2Vha1NldChyKXtyZXR1cm4gaXNXZWFrU2V0VG9TdHJpbmcocil9ZS5pc1dlYWtTZXQ9aXNXZWFrU2V0O2Z1bmN0aW9uIGlzQXJyYXlCdWZmZXJUb1N0cmluZyhyKXtyZXR1cm4gcChyKT09PVwiW29iamVjdCBBcnJheUJ1ZmZlcl1cIn1pc0FycmF5QnVmZmVyVG9TdHJpbmcud29ya2luZz10eXBlb2YgQXJyYXlCdWZmZXIhPT1cInVuZGVmaW5lZFwiJiZpc0FycmF5QnVmZmVyVG9TdHJpbmcobmV3IEFycmF5QnVmZmVyKTtmdW5jdGlvbiBpc0FycmF5QnVmZmVyKHIpe2lmKHR5cGVvZiBBcnJheUJ1ZmZlcj09PVwidW5kZWZpbmVkXCIpe3JldHVybiBmYWxzZX1yZXR1cm4gaXNBcnJheUJ1ZmZlclRvU3RyaW5nLndvcmtpbmc/aXNBcnJheUJ1ZmZlclRvU3RyaW5nKHIpOnIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcn1lLmlzQXJyYXlCdWZmZXI9aXNBcnJheUJ1ZmZlcjtmdW5jdGlvbiBpc0RhdGFWaWV3VG9TdHJpbmcocil7cmV0dXJuIHAocik9PT1cIltvYmplY3QgRGF0YVZpZXddXCJ9aXNEYXRhVmlld1RvU3RyaW5nLndvcmtpbmc9dHlwZW9mIEFycmF5QnVmZmVyIT09XCJ1bmRlZmluZWRcIiYmdHlwZW9mIERhdGFWaWV3IT09XCJ1bmRlZmluZWRcIiYmaXNEYXRhVmlld1RvU3RyaW5nKG5ldyBEYXRhVmlldyhuZXcgQXJyYXlCdWZmZXIoMSksMCwxKSk7ZnVuY3Rpb24gaXNEYXRhVmlldyhyKXtpZih0eXBlb2YgRGF0YVZpZXc9PT1cInVuZGVmaW5lZFwiKXtyZXR1cm4gZmFsc2V9cmV0dXJuIGlzRGF0YVZpZXdUb1N0cmluZy53b3JraW5nP2lzRGF0YVZpZXdUb1N0cmluZyhyKTpyIGluc3RhbmNlb2YgRGF0YVZpZXd9ZS5pc0RhdGFWaWV3PWlzRGF0YVZpZXc7dmFyIGc9dHlwZW9mIFNoYXJlZEFycmF5QnVmZmVyIT09XCJ1bmRlZmluZWRcIj9TaGFyZWRBcnJheUJ1ZmZlcjp1bmRlZmluZWQ7ZnVuY3Rpb24gaXNTaGFyZWRBcnJheUJ1ZmZlclRvU3RyaW5nKHIpe3JldHVybiBwKHIpPT09XCJbb2JqZWN0IFNoYXJlZEFycmF5QnVmZmVyXVwifWZ1bmN0aW9uIGlzU2hhcmVkQXJyYXlCdWZmZXIocil7aWYodHlwZW9mIGc9PT1cInVuZGVmaW5lZFwiKXtyZXR1cm4gZmFsc2V9aWYodHlwZW9mIGlzU2hhcmVkQXJyYXlCdWZmZXJUb1N0cmluZy53b3JraW5nPT09XCJ1bmRlZmluZWRcIil7aXNTaGFyZWRBcnJheUJ1ZmZlclRvU3RyaW5nLndvcmtpbmc9aXNTaGFyZWRBcnJheUJ1ZmZlclRvU3RyaW5nKG5ldyBnKX1yZXR1cm4gaXNTaGFyZWRBcnJheUJ1ZmZlclRvU3RyaW5nLndvcmtpbmc/aXNTaGFyZWRBcnJheUJ1ZmZlclRvU3RyaW5nKHIpOnIgaW5zdGFuY2VvZiBnfWUuaXNTaGFyZWRBcnJheUJ1ZmZlcj1pc1NoYXJlZEFycmF5QnVmZmVyO2Z1bmN0aW9uIGlzQXN5bmNGdW5jdGlvbihyKXtyZXR1cm4gcChyKT09PVwiW29iamVjdCBBc3luY0Z1bmN0aW9uXVwifWUuaXNBc3luY0Z1bmN0aW9uPWlzQXN5bmNGdW5jdGlvbjtmdW5jdGlvbiBpc01hcEl0ZXJhdG9yKHIpe3JldHVybiBwKHIpPT09XCJbb2JqZWN0IE1hcCBJdGVyYXRvcl1cIn1lLmlzTWFwSXRlcmF0b3I9aXNNYXBJdGVyYXRvcjtmdW5jdGlvbiBpc1NldEl0ZXJhdG9yKHIpe3JldHVybiBwKHIpPT09XCJbb2JqZWN0IFNldCBJdGVyYXRvcl1cIn1lLmlzU2V0SXRlcmF0b3I9aXNTZXRJdGVyYXRvcjtmdW5jdGlvbiBpc0dlbmVyYXRvck9iamVjdChyKXtyZXR1cm4gcChyKT09PVwiW29iamVjdCBHZW5lcmF0b3JdXCJ9ZS5pc0dlbmVyYXRvck9iamVjdD1pc0dlbmVyYXRvck9iamVjdDtmdW5jdGlvbiBpc1dlYkFzc2VtYmx5Q29tcGlsZWRNb2R1bGUocil7cmV0dXJuIHAocik9PT1cIltvYmplY3QgV2ViQXNzZW1ibHkuTW9kdWxlXVwifWUuaXNXZWJBc3NlbWJseUNvbXBpbGVkTW9kdWxlPWlzV2ViQXNzZW1ibHlDb21waWxlZE1vZHVsZTtmdW5jdGlvbiBpc051bWJlck9iamVjdChyKXtyZXR1cm4gY2hlY2tCb3hlZFByaW1pdGl2ZShyLHUpfWUuaXNOdW1iZXJPYmplY3Q9aXNOdW1iZXJPYmplY3Q7ZnVuY3Rpb24gaXNTdHJpbmdPYmplY3Qocil7cmV0dXJuIGNoZWNrQm94ZWRQcmltaXRpdmUocixzKX1lLmlzU3RyaW5nT2JqZWN0PWlzU3RyaW5nT2JqZWN0O2Z1bmN0aW9uIGlzQm9vbGVhbk9iamVjdChyKXtyZXR1cm4gY2hlY2tCb3hlZFByaW1pdGl2ZShyLGMpfWUuaXNCb29sZWFuT2JqZWN0PWlzQm9vbGVhbk9iamVjdDtmdW5jdGlvbiBpc0JpZ0ludE9iamVjdChyKXtyZXR1cm4geSYmY2hlY2tCb3hlZFByaW1pdGl2ZShyLGwpfWUuaXNCaWdJbnRPYmplY3Q9aXNCaWdJbnRPYmplY3Q7ZnVuY3Rpb24gaXNTeW1ib2xPYmplY3Qocil7cmV0dXJuIGYmJmNoZWNrQm94ZWRQcmltaXRpdmUocixkKX1lLmlzU3ltYm9sT2JqZWN0PWlzU3ltYm9sT2JqZWN0O2Z1bmN0aW9uIGlzQm94ZWRQcmltaXRpdmUocil7cmV0dXJuIGlzTnVtYmVyT2JqZWN0KHIpfHxpc1N0cmluZ09iamVjdChyKXx8aXNCb29sZWFuT2JqZWN0KHIpfHxpc0JpZ0ludE9iamVjdChyKXx8aXNTeW1ib2xPYmplY3Qocil9ZS5pc0JveGVkUHJpbWl0aXZlPWlzQm94ZWRQcmltaXRpdmU7ZnVuY3Rpb24gaXNBbnlBcnJheUJ1ZmZlcihyKXtyZXR1cm4gdHlwZW9mIFVpbnQ4QXJyYXkhPT1cInVuZGVmaW5lZFwiJiYoaXNBcnJheUJ1ZmZlcihyKXx8aXNTaGFyZWRBcnJheUJ1ZmZlcihyKSl9ZS5pc0FueUFycmF5QnVmZmVyPWlzQW55QXJyYXlCdWZmZXI7W1wiaXNQcm94eVwiLFwiaXNFeHRlcm5hbFwiLFwiaXNNb2R1bGVOYW1lc3BhY2VPYmplY3RcIl0uZm9yRWFjaCgoZnVuY3Rpb24ocil7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUscix7ZW51bWVyYWJsZTpmYWxzZSx2YWx1ZTpmdW5jdGlvbigpe3Rocm93IG5ldyBFcnJvcihyK1wiIGlzIG5vdCBzdXBwb3J0ZWQgaW4gdXNlcmxhbmRcIil9fSl9KSl9LDE3NzpmdW5jdGlvbihyLGUsdCl7dmFyIG89T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnN8fGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcnMocil7dmFyIGU9T2JqZWN0LmtleXMocik7dmFyIHQ9e307Zm9yKHZhciBvPTA7bzxlLmxlbmd0aDtvKyspe3RbZVtvXV09T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihyLGVbb10pfXJldHVybiB0fTt2YXIgbj0vJVtzZGolXS9nO2UuZm9ybWF0PWZ1bmN0aW9uKHIpe2lmKCFpc1N0cmluZyhyKSl7dmFyIGU9W107Zm9yKHZhciB0PTA7dDxhcmd1bWVudHMubGVuZ3RoO3QrKyl7ZS5wdXNoKGluc3BlY3QoYXJndW1lbnRzW3RdKSl9cmV0dXJuIGUuam9pbihcIiBcIil9dmFyIHQ9MTt2YXIgbz1hcmd1bWVudHM7dmFyIGk9by5sZW5ndGg7dmFyIGE9U3RyaW5nKHIpLnJlcGxhY2UobiwoZnVuY3Rpb24ocil7aWYocj09PVwiJSVcIilyZXR1cm5cIiVcIjtpZih0Pj1pKXJldHVybiByO3N3aXRjaChyKXtjYXNlXCIlc1wiOnJldHVybiBTdHJpbmcob1t0KytdKTtjYXNlXCIlZFwiOnJldHVybiBOdW1iZXIob1t0KytdKTtjYXNlXCIlalwiOnRyeXtyZXR1cm4gSlNPTi5zdHJpbmdpZnkob1t0KytdKX1jYXRjaChyKXtyZXR1cm5cIltDaXJjdWxhcl1cIn1kZWZhdWx0OnJldHVybiByfX0pKTtmb3IodmFyIHk9b1t0XTt0PGk7eT1vWysrdF0pe2lmKGlzTnVsbCh5KXx8IWlzT2JqZWN0KHkpKXthKz1cIiBcIit5fWVsc2V7YSs9XCIgXCIraW5zcGVjdCh5KX19cmV0dXJuIGF9O2UuZGVwcmVjYXRlPWZ1bmN0aW9uKHIsdCl7aWYodHlwZW9mIHByb2Nlc3MhPT1cInVuZGVmaW5lZFwiJiZwcm9jZXNzLm5vRGVwcmVjYXRpb249PT10cnVlKXtyZXR1cm4gcn1pZih0eXBlb2YgcHJvY2Vzcz09PVwidW5kZWZpbmVkXCIpe3JldHVybiBmdW5jdGlvbigpe3JldHVybiBlLmRlcHJlY2F0ZShyLHQpLmFwcGx5KHRoaXMsYXJndW1lbnRzKX19dmFyIG89ZmFsc2U7ZnVuY3Rpb24gZGVwcmVjYXRlZCgpe2lmKCFvKXtpZihwcm9jZXNzLnRocm93RGVwcmVjYXRpb24pe3Rocm93IG5ldyBFcnJvcih0KX1lbHNlIGlmKHByb2Nlc3MudHJhY2VEZXByZWNhdGlvbil7Y29uc29sZS50cmFjZSh0KX1lbHNle2NvbnNvbGUuZXJyb3IodCl9bz10cnVlfXJldHVybiByLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1yZXR1cm4gZGVwcmVjYXRlZH07dmFyIGk9e307dmFyIGE9L14kLztpZihwcm9jZXNzLmVudi5OT0RFX0RFQlVHKXt2YXIgeT1wcm9jZXNzLmVudi5OT0RFX0RFQlVHO3k9eS5yZXBsYWNlKC9bfFxcXFx7fSgpW1xcXV4kKz8uXS9nLFwiXFxcXCQmXCIpLnJlcGxhY2UoL1xcKi9nLFwiLipcIikucmVwbGFjZSgvLC9nLFwiJHxeXCIpLnRvVXBwZXJDYXNlKCk7YT1uZXcgUmVnRXhwKFwiXlwiK3krXCIkXCIsXCJpXCIpfWUuZGVidWdsb2c9ZnVuY3Rpb24ocil7cj1yLnRvVXBwZXJDYXNlKCk7aWYoIWlbcl0pe2lmKGEudGVzdChyKSl7dmFyIHQ9cHJvY2Vzcy5waWQ7aVtyXT1mdW5jdGlvbigpe3ZhciBvPWUuZm9ybWF0LmFwcGx5KGUsYXJndW1lbnRzKTtjb25zb2xlLmVycm9yKFwiJXMgJWQ6ICVzXCIscix0LG8pfX1lbHNle2lbcl09ZnVuY3Rpb24oKXt9fX1yZXR1cm4gaVtyXX07ZnVuY3Rpb24gaW5zcGVjdChyLHQpe3ZhciBvPXtzZWVuOltdLHN0eWxpemU6c3R5bGl6ZU5vQ29sb3J9O2lmKGFyZ3VtZW50cy5sZW5ndGg+PTMpby5kZXB0aD1hcmd1bWVudHNbMl07aWYoYXJndW1lbnRzLmxlbmd0aD49NClvLmNvbG9ycz1hcmd1bWVudHNbM107aWYoaXNCb29sZWFuKHQpKXtvLnNob3dIaWRkZW49dH1lbHNlIGlmKHQpe2UuX2V4dGVuZChvLHQpfWlmKGlzVW5kZWZpbmVkKG8uc2hvd0hpZGRlbikpby5zaG93SGlkZGVuPWZhbHNlO2lmKGlzVW5kZWZpbmVkKG8uZGVwdGgpKW8uZGVwdGg9MjtpZihpc1VuZGVmaW5lZChvLmNvbG9ycykpby5jb2xvcnM9ZmFsc2U7aWYoaXNVbmRlZmluZWQoby5jdXN0b21JbnNwZWN0KSlvLmN1c3RvbUluc3BlY3Q9dHJ1ZTtpZihvLmNvbG9ycylvLnN0eWxpemU9c3R5bGl6ZVdpdGhDb2xvcjtyZXR1cm4gZm9ybWF0VmFsdWUobyxyLG8uZGVwdGgpfWUuaW5zcGVjdD1pbnNwZWN0O2luc3BlY3QuY29sb3JzPXtib2xkOlsxLDIyXSxpdGFsaWM6WzMsMjNdLHVuZGVybGluZTpbNCwyNF0saW52ZXJzZTpbNywyN10sd2hpdGU6WzM3LDM5XSxncmV5Ols5MCwzOV0sYmxhY2s6WzMwLDM5XSxibHVlOlszNCwzOV0sY3lhbjpbMzYsMzldLGdyZWVuOlszMiwzOV0sbWFnZW50YTpbMzUsMzldLHJlZDpbMzEsMzldLHllbGxvdzpbMzMsMzldfTtpbnNwZWN0LnN0eWxlcz17c3BlY2lhbDpcImN5YW5cIixudW1iZXI6XCJ5ZWxsb3dcIixib29sZWFuOlwieWVsbG93XCIsdW5kZWZpbmVkOlwiZ3JleVwiLG51bGw6XCJib2xkXCIsc3RyaW5nOlwiZ3JlZW5cIixkYXRlOlwibWFnZW50YVwiLHJlZ2V4cDpcInJlZFwifTtmdW5jdGlvbiBzdHlsaXplV2l0aENvbG9yKHIsZSl7dmFyIHQ9aW5zcGVjdC5zdHlsZXNbZV07aWYodCl7cmV0dXJuXCJcdTAwMWJbXCIraW5zcGVjdC5jb2xvcnNbdF1bMF0rXCJtXCIrcitcIlx1MDAxYltcIitpbnNwZWN0LmNvbG9yc1t0XVsxXStcIm1cIn1lbHNle3JldHVybiByfX1mdW5jdGlvbiBzdHlsaXplTm9Db2xvcihyLGUpe3JldHVybiByfWZ1bmN0aW9uIGFycmF5VG9IYXNoKHIpe3ZhciBlPXt9O3IuZm9yRWFjaCgoZnVuY3Rpb24ocix0KXtlW3JdPXRydWV9KSk7cmV0dXJuIGV9ZnVuY3Rpb24gZm9ybWF0VmFsdWUocix0LG8pe2lmKHIuY3VzdG9tSW5zcGVjdCYmdCYmaXNGdW5jdGlvbih0Lmluc3BlY3QpJiZ0Lmluc3BlY3QhPT1lLmluc3BlY3QmJiEodC5jb25zdHJ1Y3RvciYmdC5jb25zdHJ1Y3Rvci5wcm90b3R5cGU9PT10KSl7dmFyIG49dC5pbnNwZWN0KG8scik7aWYoIWlzU3RyaW5nKG4pKXtuPWZvcm1hdFZhbHVlKHIsbixvKX1yZXR1cm4gbn12YXIgaT1mb3JtYXRQcmltaXRpdmUocix0KTtpZihpKXtyZXR1cm4gaX12YXIgYT1PYmplY3Qua2V5cyh0KTt2YXIgeT1hcnJheVRvSGFzaChhKTtpZihyLnNob3dIaWRkZW4pe2E9T2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModCl9aWYoaXNFcnJvcih0KSYmKGEuaW5kZXhPZihcIm1lc3NhZ2VcIik+PTB8fGEuaW5kZXhPZihcImRlc2NyaXB0aW9uXCIpPj0wKSl7cmV0dXJuIGZvcm1hdEVycm9yKHQpfWlmKGEubGVuZ3RoPT09MCl7aWYoaXNGdW5jdGlvbih0KSl7dmFyIGY9dC5uYW1lP1wiOiBcIit0Lm5hbWU6XCJcIjtyZXR1cm4gci5zdHlsaXplKFwiW0Z1bmN0aW9uXCIrZitcIl1cIixcInNwZWNpYWxcIil9aWYoaXNSZWdFeHAodCkpe3JldHVybiByLnN0eWxpemUoUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHQpLFwicmVnZXhwXCIpfWlmKGlzRGF0ZSh0KSl7cmV0dXJuIHIuc3R5bGl6ZShEYXRlLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHQpLFwiZGF0ZVwiKX1pZihpc0Vycm9yKHQpKXtyZXR1cm4gZm9ybWF0RXJyb3IodCl9fXZhciBwPVwiXCIsdT1mYWxzZSxzPVtcIntcIixcIn1cIl07aWYoaXNBcnJheSh0KSl7dT10cnVlO3M9W1wiW1wiLFwiXVwiXX1pZihpc0Z1bmN0aW9uKHQpKXt2YXIgYz10Lm5hbWU/XCI6IFwiK3QubmFtZTpcIlwiO3A9XCIgW0Z1bmN0aW9uXCIrYytcIl1cIn1pZihpc1JlZ0V4cCh0KSl7cD1cIiBcIitSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodCl9aWYoaXNEYXRlKHQpKXtwPVwiIFwiK0RhdGUucHJvdG90eXBlLnRvVVRDU3RyaW5nLmNhbGwodCl9aWYoaXNFcnJvcih0KSl7cD1cIiBcIitmb3JtYXRFcnJvcih0KX1pZihhLmxlbmd0aD09PTAmJighdXx8dC5sZW5ndGg9PTApKXtyZXR1cm4gc1swXStwK3NbMV19aWYobzwwKXtpZihpc1JlZ0V4cCh0KSl7cmV0dXJuIHIuc3R5bGl6ZShSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodCksXCJyZWdleHBcIil9ZWxzZXtyZXR1cm4gci5zdHlsaXplKFwiW09iamVjdF1cIixcInNwZWNpYWxcIil9fXIuc2Vlbi5wdXNoKHQpO3ZhciBsO2lmKHUpe2w9Zm9ybWF0QXJyYXkocix0LG8seSxhKX1lbHNle2w9YS5tYXAoKGZ1bmN0aW9uKGUpe3JldHVybiBmb3JtYXRQcm9wZXJ0eShyLHQsbyx5LGUsdSl9KSl9ci5zZWVuLnBvcCgpO3JldHVybiByZWR1Y2VUb1NpbmdsZVN0cmluZyhsLHAscyl9ZnVuY3Rpb24gZm9ybWF0UHJpbWl0aXZlKHIsZSl7aWYoaXNVbmRlZmluZWQoZSkpcmV0dXJuIHIuc3R5bGl6ZShcInVuZGVmaW5lZFwiLFwidW5kZWZpbmVkXCIpO2lmKGlzU3RyaW5nKGUpKXt2YXIgdD1cIidcIitKU09OLnN0cmluZ2lmeShlKS5yZXBsYWNlKC9eXCJ8XCIkL2csXCJcIikucmVwbGFjZSgvJy9nLFwiXFxcXCdcIikucmVwbGFjZSgvXFxcXFwiL2csJ1wiJykrXCInXCI7cmV0dXJuIHIuc3R5bGl6ZSh0LFwic3RyaW5nXCIpfWlmKGlzTnVtYmVyKGUpKXJldHVybiByLnN0eWxpemUoXCJcIitlLFwibnVtYmVyXCIpO2lmKGlzQm9vbGVhbihlKSlyZXR1cm4gci5zdHlsaXplKFwiXCIrZSxcImJvb2xlYW5cIik7aWYoaXNOdWxsKGUpKXJldHVybiByLnN0eWxpemUoXCJudWxsXCIsXCJudWxsXCIpfWZ1bmN0aW9uIGZvcm1hdEVycm9yKHIpe3JldHVyblwiW1wiK0Vycm9yLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHIpK1wiXVwifWZ1bmN0aW9uIGZvcm1hdEFycmF5KHIsZSx0LG8sbil7dmFyIGk9W107Zm9yKHZhciBhPTAseT1lLmxlbmd0aDthPHk7KythKXtpZihoYXNPd25Qcm9wZXJ0eShlLFN0cmluZyhhKSkpe2kucHVzaChmb3JtYXRQcm9wZXJ0eShyLGUsdCxvLFN0cmluZyhhKSx0cnVlKSl9ZWxzZXtpLnB1c2goXCJcIil9fW4uZm9yRWFjaCgoZnVuY3Rpb24obil7aWYoIW4ubWF0Y2goL15cXGQrJC8pKXtpLnB1c2goZm9ybWF0UHJvcGVydHkocixlLHQsbyxuLHRydWUpKX19KSk7cmV0dXJuIGl9ZnVuY3Rpb24gZm9ybWF0UHJvcGVydHkocixlLHQsbyxuLGkpe3ZhciBhLHksZjtmPU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSxuKXx8e3ZhbHVlOmVbbl19O2lmKGYuZ2V0KXtpZihmLnNldCl7eT1yLnN0eWxpemUoXCJbR2V0dGVyL1NldHRlcl1cIixcInNwZWNpYWxcIil9ZWxzZXt5PXIuc3R5bGl6ZShcIltHZXR0ZXJdXCIsXCJzcGVjaWFsXCIpfX1lbHNle2lmKGYuc2V0KXt5PXIuc3R5bGl6ZShcIltTZXR0ZXJdXCIsXCJzcGVjaWFsXCIpfX1pZighaGFzT3duUHJvcGVydHkobyxuKSl7YT1cIltcIituK1wiXVwifWlmKCF5KXtpZihyLnNlZW4uaW5kZXhPZihmLnZhbHVlKTwwKXtpZihpc051bGwodCkpe3k9Zm9ybWF0VmFsdWUocixmLnZhbHVlLG51bGwpfWVsc2V7eT1mb3JtYXRWYWx1ZShyLGYudmFsdWUsdC0xKX1pZih5LmluZGV4T2YoXCJcXG5cIik+LTEpe2lmKGkpe3k9eS5zcGxpdChcIlxcblwiKS5tYXAoKGZ1bmN0aW9uKHIpe3JldHVyblwiICBcIityfSkpLmpvaW4oXCJcXG5cIikuc3Vic3RyKDIpfWVsc2V7eT1cIlxcblwiK3kuc3BsaXQoXCJcXG5cIikubWFwKChmdW5jdGlvbihyKXtyZXR1cm5cIiAgIFwiK3J9KSkuam9pbihcIlxcblwiKX19fWVsc2V7eT1yLnN0eWxpemUoXCJbQ2lyY3VsYXJdXCIsXCJzcGVjaWFsXCIpfX1pZihpc1VuZGVmaW5lZChhKSl7aWYoaSYmbi5tYXRjaCgvXlxcZCskLykpe3JldHVybiB5fWE9SlNPTi5zdHJpbmdpZnkoXCJcIituKTtpZihhLm1hdGNoKC9eXCIoW2EtekEtWl9dW2EtekEtWl8wLTldKilcIiQvKSl7YT1hLnN1YnN0cigxLGEubGVuZ3RoLTIpO2E9ci5zdHlsaXplKGEsXCJuYW1lXCIpfWVsc2V7YT1hLnJlcGxhY2UoLycvZyxcIlxcXFwnXCIpLnJlcGxhY2UoL1xcXFxcIi9nLCdcIicpLnJlcGxhY2UoLyheXCJ8XCIkKS9nLFwiJ1wiKTthPXIuc3R5bGl6ZShhLFwic3RyaW5nXCIpfX1yZXR1cm4gYStcIjogXCIreX1mdW5jdGlvbiByZWR1Y2VUb1NpbmdsZVN0cmluZyhyLGUsdCl7dmFyIG89MDt2YXIgbj1yLnJlZHVjZSgoZnVuY3Rpb24ocixlKXtvKys7aWYoZS5pbmRleE9mKFwiXFxuXCIpPj0wKW8rKztyZXR1cm4gcitlLnJlcGxhY2UoL1xcdTAwMWJcXFtcXGRcXGQ/bS9nLFwiXCIpLmxlbmd0aCsxfSksMCk7aWYobj42MCl7cmV0dXJuIHRbMF0rKGU9PT1cIlwiP1wiXCI6ZStcIlxcbiBcIikrXCIgXCIrci5qb2luKFwiLFxcbiAgXCIpK1wiIFwiK3RbMV19cmV0dXJuIHRbMF0rZStcIiBcIityLmpvaW4oXCIsIFwiKStcIiBcIit0WzFdfWUudHlwZXM9dCg1ODQpO2Z1bmN0aW9uIGlzQXJyYXkocil7cmV0dXJuIEFycmF5LmlzQXJyYXkocil9ZS5pc0FycmF5PWlzQXJyYXk7ZnVuY3Rpb24gaXNCb29sZWFuKHIpe3JldHVybiB0eXBlb2Ygcj09PVwiYm9vbGVhblwifWUuaXNCb29sZWFuPWlzQm9vbGVhbjtmdW5jdGlvbiBpc051bGwocil7cmV0dXJuIHI9PT1udWxsfWUuaXNOdWxsPWlzTnVsbDtmdW5jdGlvbiBpc051bGxPclVuZGVmaW5lZChyKXtyZXR1cm4gcj09bnVsbH1lLmlzTnVsbE9yVW5kZWZpbmVkPWlzTnVsbE9yVW5kZWZpbmVkO2Z1bmN0aW9uIGlzTnVtYmVyKHIpe3JldHVybiB0eXBlb2Ygcj09PVwibnVtYmVyXCJ9ZS5pc051bWJlcj1pc051bWJlcjtmdW5jdGlvbiBpc1N0cmluZyhyKXtyZXR1cm4gdHlwZW9mIHI9PT1cInN0cmluZ1wifWUuaXNTdHJpbmc9aXNTdHJpbmc7ZnVuY3Rpb24gaXNTeW1ib2wocil7cmV0dXJuIHR5cGVvZiByPT09XCJzeW1ib2xcIn1lLmlzU3ltYm9sPWlzU3ltYm9sO2Z1bmN0aW9uIGlzVW5kZWZpbmVkKHIpe3JldHVybiByPT09dm9pZCAwfWUuaXNVbmRlZmluZWQ9aXNVbmRlZmluZWQ7ZnVuY3Rpb24gaXNSZWdFeHAocil7cmV0dXJuIGlzT2JqZWN0KHIpJiZvYmplY3RUb1N0cmluZyhyKT09PVwiW29iamVjdCBSZWdFeHBdXCJ9ZS5pc1JlZ0V4cD1pc1JlZ0V4cDtlLnR5cGVzLmlzUmVnRXhwPWlzUmVnRXhwO2Z1bmN0aW9uIGlzT2JqZWN0KHIpe3JldHVybiB0eXBlb2Ygcj09PVwib2JqZWN0XCImJnIhPT1udWxsfWUuaXNPYmplY3Q9aXNPYmplY3Q7ZnVuY3Rpb24gaXNEYXRlKHIpe3JldHVybiBpc09iamVjdChyKSYmb2JqZWN0VG9TdHJpbmcocik9PT1cIltvYmplY3QgRGF0ZV1cIn1lLmlzRGF0ZT1pc0RhdGU7ZS50eXBlcy5pc0RhdGU9aXNEYXRlO2Z1bmN0aW9uIGlzRXJyb3Iocil7cmV0dXJuIGlzT2JqZWN0KHIpJiYob2JqZWN0VG9TdHJpbmcocik9PT1cIltvYmplY3QgRXJyb3JdXCJ8fHIgaW5zdGFuY2VvZiBFcnJvcil9ZS5pc0Vycm9yPWlzRXJyb3I7ZS50eXBlcy5pc05hdGl2ZUVycm9yPWlzRXJyb3I7ZnVuY3Rpb24gaXNGdW5jdGlvbihyKXtyZXR1cm4gdHlwZW9mIHI9PT1cImZ1bmN0aW9uXCJ9ZS5pc0Z1bmN0aW9uPWlzRnVuY3Rpb247ZnVuY3Rpb24gaXNQcmltaXRpdmUocil7cmV0dXJuIHI9PT1udWxsfHx0eXBlb2Ygcj09PVwiYm9vbGVhblwifHx0eXBlb2Ygcj09PVwibnVtYmVyXCJ8fHR5cGVvZiByPT09XCJzdHJpbmdcInx8dHlwZW9mIHI9PT1cInN5bWJvbFwifHx0eXBlb2Ygcj09PVwidW5kZWZpbmVkXCJ9ZS5pc1ByaW1pdGl2ZT1pc1ByaW1pdGl2ZTtlLmlzQnVmZmVyPXQoMzY5KTtmdW5jdGlvbiBvYmplY3RUb1N0cmluZyhyKXtyZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHIpfWZ1bmN0aW9uIHBhZChyKXtyZXR1cm4gcjwxMD9cIjBcIityLnRvU3RyaW5nKDEwKTpyLnRvU3RyaW5nKDEwKX12YXIgZj1bXCJKYW5cIixcIkZlYlwiLFwiTWFyXCIsXCJBcHJcIixcIk1heVwiLFwiSnVuXCIsXCJKdWxcIixcIkF1Z1wiLFwiU2VwXCIsXCJPY3RcIixcIk5vdlwiLFwiRGVjXCJdO2Z1bmN0aW9uIHRpbWVzdGFtcCgpe3ZhciByPW5ldyBEYXRlO3ZhciBlPVtwYWQoci5nZXRIb3VycygpKSxwYWQoci5nZXRNaW51dGVzKCkpLHBhZChyLmdldFNlY29uZHMoKSldLmpvaW4oXCI6XCIpO3JldHVybltyLmdldERhdGUoKSxmW3IuZ2V0TW9udGgoKV0sZV0uam9pbihcIiBcIil9ZS5sb2c9ZnVuY3Rpb24oKXtjb25zb2xlLmxvZyhcIiVzIC0gJXNcIix0aW1lc3RhbXAoKSxlLmZvcm1hdC5hcHBseShlLGFyZ3VtZW50cykpfTtlLmluaGVyaXRzPXQoNzgyKTtlLl9leHRlbmQ9ZnVuY3Rpb24ocixlKXtpZighZXx8IWlzT2JqZWN0KGUpKXJldHVybiByO3ZhciB0PU9iamVjdC5rZXlzKGUpO3ZhciBvPXQubGVuZ3RoO3doaWxlKG8tLSl7clt0W29dXT1lW3Rbb11dfXJldHVybiByfTtmdW5jdGlvbiBoYXNPd25Qcm9wZXJ0eShyLGUpe3JldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocixlKX12YXIgcD10eXBlb2YgU3ltYm9sIT09XCJ1bmRlZmluZWRcIj9TeW1ib2woXCJ1dGlsLnByb21pc2lmeS5jdXN0b21cIik6dW5kZWZpbmVkO2UucHJvbWlzaWZ5PWZ1bmN0aW9uIHByb21pc2lmeShyKXtpZih0eXBlb2YgciE9PVwiZnVuY3Rpb25cIil0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJvcmlnaW5hbFwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBGdW5jdGlvbicpO2lmKHAmJnJbcF0pe3ZhciBlPXJbcF07aWYodHlwZW9mIGUhPT1cImZ1bmN0aW9uXCIpe3Rocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcInV0aWwucHJvbWlzaWZ5LmN1c3RvbVwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBGdW5jdGlvbicpfU9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLHAse3ZhbHVlOmUsZW51bWVyYWJsZTpmYWxzZSx3cml0YWJsZTpmYWxzZSxjb25maWd1cmFibGU6dHJ1ZX0pO3JldHVybiBlfWZ1bmN0aW9uIGUoKXt2YXIgZSx0O3ZhciBvPW5ldyBQcm9taXNlKChmdW5jdGlvbihyLG8pe2U9cjt0PW99KSk7dmFyIG49W107Zm9yKHZhciBpPTA7aTxhcmd1bWVudHMubGVuZ3RoO2krKyl7bi5wdXNoKGFyZ3VtZW50c1tpXSl9bi5wdXNoKChmdW5jdGlvbihyLG8pe2lmKHIpe3Qocil9ZWxzZXtlKG8pfX0pKTt0cnl7ci5hcHBseSh0aGlzLG4pfWNhdGNoKHIpe3Qocil9cmV0dXJuIG99T2JqZWN0LnNldFByb3RvdHlwZU9mKGUsT2JqZWN0LmdldFByb3RvdHlwZU9mKHIpKTtpZihwKU9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLHAse3ZhbHVlOmUsZW51bWVyYWJsZTpmYWxzZSx3cml0YWJsZTpmYWxzZSxjb25maWd1cmFibGU6dHJ1ZX0pO3JldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhlLG8ocikpfTtlLnByb21pc2lmeS5jdXN0b209cDtmdW5jdGlvbiBjYWxsYmFja2lmeU9uUmVqZWN0ZWQocixlKXtpZighcil7dmFyIHQ9bmV3IEVycm9yKFwiUHJvbWlzZSB3YXMgcmVqZWN0ZWQgd2l0aCBhIGZhbHN5IHZhbHVlXCIpO3QucmVhc29uPXI7cj10fXJldHVybiBlKHIpfWZ1bmN0aW9uIGNhbGxiYWNraWZ5KHIpe2lmKHR5cGVvZiByIT09XCJmdW5jdGlvblwiKXt0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJvcmlnaW5hbFwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBGdW5jdGlvbicpfWZ1bmN0aW9uIGNhbGxiYWNraWZpZWQoKXt2YXIgZT1bXTtmb3IodmFyIHQ9MDt0PGFyZ3VtZW50cy5sZW5ndGg7dCsrKXtlLnB1c2goYXJndW1lbnRzW3RdKX12YXIgbz1lLnBvcCgpO2lmKHR5cGVvZiBvIT09XCJmdW5jdGlvblwiKXt0aHJvdyBuZXcgVHlwZUVycm9yKFwiVGhlIGxhc3QgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIEZ1bmN0aW9uXCIpfXZhciBuPXRoaXM7dmFyIGNiPWZ1bmN0aW9uKCl7cmV0dXJuIG8uYXBwbHkobixhcmd1bWVudHMpfTtyLmFwcGx5KHRoaXMsZSkudGhlbigoZnVuY3Rpb24ocil7cHJvY2Vzcy5uZXh0VGljayhjYi5iaW5kKG51bGwsbnVsbCxyKSl9KSwoZnVuY3Rpb24ocil7cHJvY2Vzcy5uZXh0VGljayhjYWxsYmFja2lmeU9uUmVqZWN0ZWQuYmluZChudWxsLHIsY2IpKX0pKX1PYmplY3Quc2V0UHJvdG90eXBlT2YoY2FsbGJhY2tpZmllZCxPYmplY3QuZ2V0UHJvdG90eXBlT2YocikpO09iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGNhbGxiYWNraWZpZWQsbyhyKSk7cmV0dXJuIGNhbGxiYWNraWZpZWR9ZS5jYWxsYmFja2lmeT1jYWxsYmFja2lmeX0sNDkwOmZ1bmN0aW9uKHIsZSx0KXtcInVzZSBzdHJpY3RcIjt2YXIgbz10KDE0NCk7dmFyIG49dCgzNDkpO3ZhciBpPXQoMjU2KTt2YXIgYT1pKFwiT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ1wiKTt2YXIgeT10KDk0MikoKTt2YXIgZj15JiZ0eXBlb2YgU3ltYm9sLnRvU3RyaW5nVGFnPT09XCJzeW1ib2xcIjt2YXIgcD1uKCk7dmFyIHU9aShcIlN0cmluZy5wcm90b3R5cGUuc2xpY2VcIik7dmFyIHM9e307dmFyIGM9dCgyNCk7dmFyIGw9T2JqZWN0LmdldFByb3RvdHlwZU9mO2lmKGYmJmMmJmwpe28ocCwoZnVuY3Rpb24ocil7aWYodHlwZW9mIGdsb2JhbFtyXT09PVwiZnVuY3Rpb25cIil7dmFyIGU9bmV3IGdsb2JhbFtyXTtpZighKFN5bWJvbC50b1N0cmluZ1RhZyBpbiBlKSl7dGhyb3cgbmV3IEV2YWxFcnJvcihcInRoaXMgZW5naW5lIGhhcyBzdXBwb3J0IGZvciBTeW1ib2wudG9TdHJpbmdUYWcsIGJ1dCBcIityK1wiIGRvZXMgbm90IGhhdmUgdGhlIHByb3BlcnR5ISBQbGVhc2UgcmVwb3J0IHRoaXMuXCIpfXZhciB0PWwoZSk7dmFyIG89Yyh0LFN5bWJvbC50b1N0cmluZ1RhZyk7aWYoIW8pe3ZhciBuPWwodCk7bz1jKG4sU3ltYm9sLnRvU3RyaW5nVGFnKX1zW3JdPW8uZ2V0fX0pKX12YXIgZD1mdW5jdGlvbiB0cnlBbGxUeXBlZEFycmF5cyhyKXt2YXIgZT1mYWxzZTtvKHMsKGZ1bmN0aW9uKHQsbyl7aWYoIWUpe3RyeXt2YXIgbj10LmNhbGwocik7aWYobj09PW8pe2U9bn19Y2F0Y2gocil7fX19KSk7cmV0dXJuIGV9O3ZhciBnPXQoOTk0KTtyLmV4cG9ydHM9ZnVuY3Rpb24gd2hpY2hUeXBlZEFycmF5KHIpe2lmKCFnKHIpKXtyZXR1cm4gZmFsc2V9aWYoIWYpe3JldHVybiB1KGEociksOCwtMSl9cmV0dXJuIGQocil9fSwzNDk6ZnVuY3Rpb24ocixlLHQpe1widXNlIHN0cmljdFwiO3ZhciBvPXQoOTkyKTtyLmV4cG9ydHM9ZnVuY3Rpb24gYXZhaWxhYmxlVHlwZWRBcnJheXMoKXtyZXR1cm4gbyhbXCJCaWdJbnQ2NEFycmF5XCIsXCJCaWdVaW50NjRBcnJheVwiLFwiRmxvYXQzMkFycmF5XCIsXCJGbG9hdDY0QXJyYXlcIixcIkludDE2QXJyYXlcIixcIkludDMyQXJyYXlcIixcIkludDhBcnJheVwiLFwiVWludDE2QXJyYXlcIixcIlVpbnQzMkFycmF5XCIsXCJVaW50OEFycmF5XCIsXCJVaW50OENsYW1wZWRBcnJheVwiXSwoZnVuY3Rpb24ocil7cmV0dXJuIHR5cGVvZiBnbG9iYWxbcl09PT1cImZ1bmN0aW9uXCJ9KSl9fSwyNDpmdW5jdGlvbihyLGUsdCl7XCJ1c2Ugc3RyaWN0XCI7dmFyIG89dCg1MDApO3ZhciBuPW8oXCIlT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvciVcIix0cnVlKTtpZihuKXt0cnl7bihbXSxcImxlbmd0aFwiKX1jYXRjaChyKXtuPW51bGx9fXIuZXhwb3J0cz1ufX07dmFyIGU9e307ZnVuY3Rpb24gX19uY2N3cGNrX3JlcXVpcmVfXyh0KXt2YXIgbz1lW3RdO2lmKG8hPT11bmRlZmluZWQpe3JldHVybiBvLmV4cG9ydHN9dmFyIG49ZVt0XT17ZXhwb3J0czp7fX07dmFyIGk9dHJ1ZTt0cnl7clt0XShuLG4uZXhwb3J0cyxfX25jY3dwY2tfcmVxdWlyZV9fKTtpPWZhbHNlfWZpbmFsbHl7aWYoaSlkZWxldGUgZVt0XX1yZXR1cm4gbi5leHBvcnRzfWlmKHR5cGVvZiBfX25jY3dwY2tfcmVxdWlyZV9fIT09XCJ1bmRlZmluZWRcIilfX25jY3dwY2tfcmVxdWlyZV9fLmFiPV9fZGlybmFtZStcIi9cIjt2YXIgdD1fX25jY3dwY2tfcmVxdWlyZV9fKDE3Nyk7bW9kdWxlLmV4cG9ydHM9dH0pKCk7Il0sIm5hbWVzIjpbInIiLCJleHBvcnRzIiwidCIsIm8iLCJmaWx0ZXIiLCJUeXBlRXJyb3IiLCJuIiwiaSIsImxlbmd0aCIsImUiLCJjYWxsIiwiYSIsInB1c2giLCJPYmplY3QiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGxCb3VuZEludHJpbnNpYyIsInkiLCJmIiwicCIsInUiLCJ2YWx1ZSIsImNhbGxCaW5kIiwiYXJndW1lbnRzIiwiY29uZmlndXJhYmxlIiwicyIsImFwcGx5QmluZCIsImFwcGx5IiwidG9TdHJpbmciLCJmb3JFYWNoIiwiQXJyYXkiLCJzbGljZSIsImJpbmQiLCJiaW5kZXIiLCJjb25jYXQiLCJNYXRoIiwibWF4IiwiRnVuY3Rpb24iLCJqb2luIiwiRW1wdHkiLCJTeW50YXhFcnJvciIsImdldEV2YWxsZWRDb25zdHJ1Y3RvciIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsInRocm93VHlwZUVycm9yIiwiY2FsbGVlIiwiZ2V0IiwiZ2V0UHJvdG90eXBlT2YiLCJfX3Byb3RvX18iLCJjIiwiVWludDhBcnJheSIsImwiLCJBZ2dyZWdhdGVFcnJvciIsIkFycmF5QnVmZmVyIiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJBdG9taWNzIiwiQmlnSW50IiwiQm9vbGVhbiIsIkRhdGFWaWV3IiwiRGF0ZSIsImRlY29kZVVSSSIsImRlY29kZVVSSUNvbXBvbmVudCIsImVuY29kZVVSSSIsImVuY29kZVVSSUNvbXBvbmVudCIsIkVycm9yIiwiZXZhbCIsIkV2YWxFcnJvciIsIkZsb2F0MzJBcnJheSIsIkZsb2F0NjRBcnJheSIsIkZpbmFsaXphdGlvblJlZ2lzdHJ5IiwiSW50OEFycmF5IiwiSW50MTZBcnJheSIsIkludDMyQXJyYXkiLCJpc0Zpbml0ZSIsImlzTmFOIiwiSlNPTiIsIk1hcCIsIk51bWJlciIsInBhcnNlRmxvYXQiLCJwYXJzZUludCIsIlByb21pc2UiLCJQcm94eSIsIlJhbmdlRXJyb3IiLCJSZWZlcmVuY2VFcnJvciIsIlJlZmxlY3QiLCJSZWdFeHAiLCJTZXQiLCJTaGFyZWRBcnJheUJ1ZmZlciIsIlN0cmluZyIsIlVpbnQ4Q2xhbXBlZEFycmF5IiwiVWludDE2QXJyYXkiLCJVaW50MzJBcnJheSIsIlVSSUVycm9yIiwiV2Vha01hcCIsIldlYWtSZWYiLCJXZWFrU2V0IiwiZCIsImRvRXZhbCIsImciLCJ2IiwiYiIsIkEiLCJtIiwic3BsaWNlIiwiUyIsInJlcGxhY2UiLCJoIiwiUCIsImV4ZWMiLCJPIiwidyIsImoiLCJzdHJpbmdUb1BhdGgiLCJFIiwiZ2V0QmFzZUludHJpbnNpYyIsImFsaWFzIiwibmFtZSIsIkdldEludHJpbnNpYyIsIkJpZ0ludDY0QXJyYXkiLCJCaWdVaW50NjRBcnJheSIsImVycm9yIiwiSSIsIkIiLCJmb28iLCJoYXNQcm90byIsImhhc05hdGl2ZVN5bWJvbHMiLCJoYXNTeW1ib2xzIiwiZ2V0T3duUHJvcGVydHlTeW1ib2xzIiwia2V5cyIsImdldE93blByb3BlcnR5TmFtZXMiLCJwcm9wZXJ0eUlzRW51bWVyYWJsZSIsImVudW1lcmFibGUiLCJjcmVhdGUiLCJpbmhlcml0cyIsInN1cGVyXyIsImNvbnN0cnVjdG9yIiwid3JpdGFibGUiLCJUZW1wQ3RvciIsInRvU3RyaW5nVGFnIiwiaXNBcmd1bWVudHMiLCJpc0xlZ2FjeUFyZ3VtZW50cyIsImdldEdlbmVyYXRvckZ1bmMiLCJpc0dlbmVyYXRvckZ1bmN0aW9uIiwidGVzdCIsImluZGV4T2YiLCJnbG9iYWwiLCJ0cnlBbGxUeXBlZEFycmF5cyIsImlzVHlwZWRBcnJheSIsImlzQnVmZmVyIiwiQnVmZmVyIiwidW5jdXJyeVRoaXMiLCJ2YWx1ZU9mIiwiY2hlY2tCb3hlZFByaW1pdGl2ZSIsImlzQXJndW1lbnRzT2JqZWN0IiwiaXNQcm9taXNlIiwidGhlbiIsImNhdGNoIiwiaXNBcnJheUJ1ZmZlclZpZXciLCJpc1ZpZXciLCJpc0RhdGFWaWV3IiwiaXNVaW50OEFycmF5IiwiaXNVaW50OENsYW1wZWRBcnJheSIsImlzVWludDE2QXJyYXkiLCJpc1VpbnQzMkFycmF5IiwiaXNJbnQ4QXJyYXkiLCJpc0ludDE2QXJyYXkiLCJpc0ludDMyQXJyYXkiLCJpc0Zsb2F0MzJBcnJheSIsImlzRmxvYXQ2NEFycmF5IiwiaXNCaWdJbnQ2NEFycmF5IiwiaXNCaWdVaW50NjRBcnJheSIsImlzTWFwVG9TdHJpbmciLCJ3b3JraW5nIiwiaXNNYXAiLCJpc1NldFRvU3RyaW5nIiwiaXNTZXQiLCJpc1dlYWtNYXBUb1N0cmluZyIsImlzV2Vha01hcCIsImlzV2Vha1NldFRvU3RyaW5nIiwiaXNXZWFrU2V0IiwiaXNBcnJheUJ1ZmZlclRvU3RyaW5nIiwiaXNBcnJheUJ1ZmZlciIsImlzRGF0YVZpZXdUb1N0cmluZyIsInVuZGVmaW5lZCIsImlzU2hhcmVkQXJyYXlCdWZmZXJUb1N0cmluZyIsImlzU2hhcmVkQXJyYXlCdWZmZXIiLCJpc0FzeW5jRnVuY3Rpb24iLCJpc01hcEl0ZXJhdG9yIiwiaXNTZXRJdGVyYXRvciIsImlzR2VuZXJhdG9yT2JqZWN0IiwiaXNXZWJBc3NlbWJseUNvbXBpbGVkTW9kdWxlIiwiaXNOdW1iZXJPYmplY3QiLCJpc1N0cmluZ09iamVjdCIsImlzQm9vbGVhbk9iamVjdCIsImlzQmlnSW50T2JqZWN0IiwiaXNTeW1ib2xPYmplY3QiLCJpc0JveGVkUHJpbWl0aXZlIiwiaXNBbnlBcnJheUJ1ZmZlciIsImRlZmluZVByb3BlcnR5IiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyIsImZvcm1hdCIsImlzU3RyaW5nIiwiaW5zcGVjdCIsInN0cmluZ2lmeSIsImlzTnVsbCIsImlzT2JqZWN0IiwiZGVwcmVjYXRlIiwicHJvY2VzcyIsIm5vRGVwcmVjYXRpb24iLCJkZXByZWNhdGVkIiwidGhyb3dEZXByZWNhdGlvbiIsInRyYWNlRGVwcmVjYXRpb24iLCJjb25zb2xlIiwidHJhY2UiLCJlbnYiLCJOT0RFX0RFQlVHIiwidG9VcHBlckNhc2UiLCJkZWJ1Z2xvZyIsInBpZCIsInNlZW4iLCJzdHlsaXplIiwic3R5bGl6ZU5vQ29sb3IiLCJkZXB0aCIsImNvbG9ycyIsImlzQm9vbGVhbiIsInNob3dIaWRkZW4iLCJfZXh0ZW5kIiwiaXNVbmRlZmluZWQiLCJjdXN0b21JbnNwZWN0Iiwic3R5bGl6ZVdpdGhDb2xvciIsImZvcm1hdFZhbHVlIiwiYm9sZCIsIml0YWxpYyIsInVuZGVybGluZSIsImludmVyc2UiLCJ3aGl0ZSIsImdyZXkiLCJibGFjayIsImJsdWUiLCJjeWFuIiwiZ3JlZW4iLCJtYWdlbnRhIiwicmVkIiwieWVsbG93Iiwic3R5bGVzIiwic3BlY2lhbCIsIm51bWJlciIsImJvb2xlYW4iLCJudWxsIiwic3RyaW5nIiwiZGF0ZSIsInJlZ2V4cCIsImFycmF5VG9IYXNoIiwiaXNGdW5jdGlvbiIsImZvcm1hdFByaW1pdGl2ZSIsImlzRXJyb3IiLCJmb3JtYXRFcnJvciIsImlzUmVnRXhwIiwiaXNEYXRlIiwiaXNBcnJheSIsInRvVVRDU3RyaW5nIiwiZm9ybWF0QXJyYXkiLCJtYXAiLCJmb3JtYXRQcm9wZXJ0eSIsInBvcCIsInJlZHVjZVRvU2luZ2xlU3RyaW5nIiwiaXNOdW1iZXIiLCJtYXRjaCIsInNldCIsInNwbGl0Iiwic3Vic3RyIiwicmVkdWNlIiwidHlwZXMiLCJpc051bGxPclVuZGVmaW5lZCIsImlzU3ltYm9sIiwib2JqZWN0VG9TdHJpbmciLCJpc05hdGl2ZUVycm9yIiwiaXNQcmltaXRpdmUiLCJwYWQiLCJ0aW1lc3RhbXAiLCJnZXRIb3VycyIsImdldE1pbnV0ZXMiLCJnZXRTZWNvbmRzIiwiZ2V0RGF0ZSIsImdldE1vbnRoIiwibG9nIiwicHJvbWlzaWZ5Iiwic2V0UHJvdG90eXBlT2YiLCJkZWZpbmVQcm9wZXJ0aWVzIiwiY3VzdG9tIiwiY2FsbGJhY2tpZnlPblJlamVjdGVkIiwicmVhc29uIiwiY2FsbGJhY2tpZnkiLCJjYWxsYmFja2lmaWVkIiwiY2IiLCJuZXh0VGljayIsIndoaWNoVHlwZWRBcnJheSIsImF2YWlsYWJsZVR5cGVkQXJyYXlzIiwiX19uY2N3cGNrX3JlcXVpcmVfXyIsImFiIiwiX19kaXJuYW1lIiwibW9kdWxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/util/util.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../../../node_modules/tabbable/dist/index.esm.js":
/*!***********************************************************!*\
  !*** ../../../../node_modules/tabbable/dist/index.esm.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   focusable: function() { return /* binding */ focusable; },\n/* harmony export */   getTabIndex: function() { return /* binding */ getTabIndex; },\n/* harmony export */   isFocusable: function() { return /* binding */ isFocusable; },\n/* harmony export */   isTabbable: function() { return /* binding */ isTabbable; },\n/* harmony export */   tabbable: function() { return /* binding */ tabbable; }\n/* harmony export */ });\n/*!\n* tabbable 6.2.0\n* @license MIT, https://github.com/focus-trap/tabbable/blob/master/LICENSE\n*/ // NOTE: separate `:not()` selectors has broader browser support than the newer\n//  `:not([inert], [inert] *)` (Feb 2023)\n// CAREFUL: JSDom does not support `:not([inert] *)` as a selector; using it causes\n//  the entire query to fail, resulting in no nodes found, which will break a lot\n//  of things... so we have to rely on JS to identify nodes inside an inert container\nvar candidateSelectors = [\n    \"input:not([inert])\",\n    \"select:not([inert])\",\n    \"textarea:not([inert])\",\n    \"a[href]:not([inert])\",\n    \"button:not([inert])\",\n    \"[tabindex]:not(slot):not([inert])\",\n    \"audio[controls]:not([inert])\",\n    \"video[controls]:not([inert])\",\n    '[contenteditable]:not([contenteditable=\"false\"]):not([inert])',\n    \"details>summary:first-of-type:not([inert])\",\n    \"details:not([inert])\"\n];\nvar candidateSelector = /* #__PURE__ */ candidateSelectors.join(\",\");\nvar NoElement = typeof Element === \"undefined\";\nvar matches = NoElement ? function() {} : Element.prototype.matches || Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;\nvar getRootNode = !NoElement && Element.prototype.getRootNode ? function(element) {\n    var _element$getRootNode;\n    return element === null || element === void 0 ? void 0 : (_element$getRootNode = element.getRootNode) === null || _element$getRootNode === void 0 ? void 0 : _element$getRootNode.call(element);\n} : function(element) {\n    return element === null || element === void 0 ? void 0 : element.ownerDocument;\n};\n/**\n * Determines if a node is inert or in an inert ancestor.\n * @param {Element} [node]\n * @param {boolean} [lookUp] If true and `node` is not inert, looks up at ancestors to\n *  see if any of them are inert. If false, only `node` itself is considered.\n * @returns {boolean} True if inert itself or by way of being in an inert ancestor.\n *  False if `node` is falsy.\n */ var isInert = function isInert(node, lookUp) {\n    var _node$getAttribute;\n    if (lookUp === void 0) {\n        lookUp = true;\n    }\n    // CAREFUL: JSDom does not support inert at all, so we can't use the `HTMLElement.inert`\n    //  JS API property; we have to check the attribute, which can either be empty or 'true';\n    //  if it's `null` (not specified) or 'false', it's an active element\n    var inertAtt = node === null || node === void 0 ? void 0 : (_node$getAttribute = node.getAttribute) === null || _node$getAttribute === void 0 ? void 0 : _node$getAttribute.call(node, \"inert\");\n    var inert = inertAtt === \"\" || inertAtt === \"true\";\n    // NOTE: this could also be handled with `node.matches('[inert], :is([inert] *)')`\n    //  if it weren't for `matches()` not being a function on shadow roots; the following\n    //  code works for any kind of node\n    // CAREFUL: JSDom does not appear to support certain selectors like `:not([inert] *)`\n    //  so it likely would not support `:is([inert] *)` either...\n    var result = inert || lookUp && node && isInert(node.parentNode); // recursive\n    return result;\n};\n/**\n * Determines if a node's content is editable.\n * @param {Element} [node]\n * @returns True if it's content-editable; false if it's not or `node` is falsy.\n */ var isContentEditable = function isContentEditable(node) {\n    var _node$getAttribute2;\n    // CAREFUL: JSDom does not support the `HTMLElement.isContentEditable` API so we have\n    //  to use the attribute directly to check for this, which can either be empty or 'true';\n    //  if it's `null` (not specified) or 'false', it's a non-editable element\n    var attValue = node === null || node === void 0 ? void 0 : (_node$getAttribute2 = node.getAttribute) === null || _node$getAttribute2 === void 0 ? void 0 : _node$getAttribute2.call(node, \"contenteditable\");\n    return attValue === \"\" || attValue === \"true\";\n};\n/**\n * @param {Element} el container to check in\n * @param {boolean} includeContainer add container to check\n * @param {(node: Element) => boolean} filter filter candidates\n * @returns {Element[]}\n */ var getCandidates = function getCandidates(el, includeContainer, filter) {\n    // even if `includeContainer=false`, we still have to check it for inertness because\n    //  if it's inert, all its children are inert\n    if (isInert(el)) {\n        return [];\n    }\n    var candidates = Array.prototype.slice.apply(el.querySelectorAll(candidateSelector));\n    if (includeContainer && matches.call(el, candidateSelector)) {\n        candidates.unshift(el);\n    }\n    candidates = candidates.filter(filter);\n    return candidates;\n};\n/**\n * @callback GetShadowRoot\n * @param {Element} element to check for shadow root\n * @returns {ShadowRoot|boolean} ShadowRoot if available or boolean indicating if a shadowRoot is attached but not available.\n */ /**\n * @callback ShadowRootFilter\n * @param {Element} shadowHostNode the element which contains shadow content\n * @returns {boolean} true if a shadow root could potentially contain valid candidates.\n */ /**\n * @typedef {Object} CandidateScope\n * @property {Element} scopeParent contains inner candidates\n * @property {Element[]} candidates list of candidates found in the scope parent\n */ /**\n * @typedef {Object} IterativeOptions\n * @property {GetShadowRoot|boolean} getShadowRoot true if shadow support is enabled; falsy if not;\n *  if a function, implies shadow support is enabled and either returns the shadow root of an element\n *  or a boolean stating if it has an undisclosed shadow root\n * @property {(node: Element) => boolean} filter filter candidates\n * @property {boolean} flatten if true then result will flatten any CandidateScope into the returned list\n * @property {ShadowRootFilter} shadowRootFilter filter shadow roots;\n */ /**\n * @param {Element[]} elements list of element containers to match candidates from\n * @param {boolean} includeContainer add container list to check\n * @param {IterativeOptions} options\n * @returns {Array.<Element|CandidateScope>}\n */ var getCandidatesIteratively = function getCandidatesIteratively(elements, includeContainer, options) {\n    var candidates = [];\n    var elementsToCheck = Array.from(elements);\n    while(elementsToCheck.length){\n        var element = elementsToCheck.shift();\n        if (isInert(element, false)) {\n            continue;\n        }\n        if (element.tagName === \"SLOT\") {\n            // add shadow dom slot scope (slot itself cannot be focusable)\n            var assigned = element.assignedElements();\n            var content = assigned.length ? assigned : element.children;\n            var nestedCandidates = getCandidatesIteratively(content, true, options);\n            if (options.flatten) {\n                candidates.push.apply(candidates, nestedCandidates);\n            } else {\n                candidates.push({\n                    scopeParent: element,\n                    candidates: nestedCandidates\n                });\n            }\n        } else {\n            // check candidate element\n            var validCandidate = matches.call(element, candidateSelector);\n            if (validCandidate && options.filter(element) && (includeContainer || !elements.includes(element))) {\n                candidates.push(element);\n            }\n            // iterate over shadow content if possible\n            var shadowRoot = element.shadowRoot || // check for an undisclosed shadow\n            typeof options.getShadowRoot === \"function\" && options.getShadowRoot(element);\n            // no inert look up because we're already drilling down and checking for inertness\n            //  on the way down, so all containers to this root node should have already been\n            //  vetted as non-inert\n            var validShadowRoot = !isInert(shadowRoot, false) && (!options.shadowRootFilter || options.shadowRootFilter(element));\n            if (shadowRoot && validShadowRoot) {\n                // add shadow dom scope IIF a shadow root node was given; otherwise, an undisclosed\n                //  shadow exists, so look at light dom children as fallback BUT create a scope for any\n                //  child candidates found because they're likely slotted elements (elements that are\n                //  children of the web component element (which has the shadow), in the light dom, but\n                //  slotted somewhere _inside_ the undisclosed shadow) -- the scope is created below,\n                //  _after_ we return from this recursive call\n                var _nestedCandidates = getCandidatesIteratively(shadowRoot === true ? element.children : shadowRoot.children, true, options);\n                if (options.flatten) {\n                    candidates.push.apply(candidates, _nestedCandidates);\n                } else {\n                    candidates.push({\n                        scopeParent: element,\n                        candidates: _nestedCandidates\n                    });\n                }\n            } else {\n                // there's not shadow so just dig into the element's (light dom) children\n                //  __without__ giving the element special scope treatment\n                elementsToCheck.unshift.apply(elementsToCheck, element.children);\n            }\n        }\n    }\n    return candidates;\n};\n/**\n * @private\n * Determines if the node has an explicitly specified `tabindex` attribute.\n * @param {HTMLElement} node\n * @returns {boolean} True if so; false if not.\n */ var hasTabIndex = function hasTabIndex(node) {\n    return !isNaN(parseInt(node.getAttribute(\"tabindex\"), 10));\n};\n/**\n * Determine the tab index of a given node.\n * @param {HTMLElement} node\n * @returns {number} Tab order (negative, 0, or positive number).\n * @throws {Error} If `node` is falsy.\n */ var getTabIndex = function getTabIndex(node) {\n    if (!node) {\n        throw new Error(\"No node provided\");\n    }\n    if (node.tabIndex < 0) {\n        // in Chrome, <details/>, <audio controls/> and <video controls/> elements get a default\n        // `tabIndex` of -1 when the 'tabindex' attribute isn't specified in the DOM,\n        // yet they are still part of the regular tab order; in FF, they get a default\n        // `tabIndex` of 0; since Chrome still puts those elements in the regular tab\n        // order, consider their tab index to be 0.\n        // Also browsers do not return `tabIndex` correctly for contentEditable nodes;\n        // so if they don't have a tabindex attribute specifically set, assume it's 0.\n        if ((/^(AUDIO|VIDEO|DETAILS)$/.test(node.tagName) || isContentEditable(node)) && !hasTabIndex(node)) {\n            return 0;\n        }\n    }\n    return node.tabIndex;\n};\n/**\n * Determine the tab index of a given node __for sort order purposes__.\n * @param {HTMLElement} node\n * @param {boolean} [isScope] True for a custom element with shadow root or slot that, by default,\n *  has tabIndex -1, but needs to be sorted by document order in order for its content to be\n *  inserted into the correct sort position.\n * @returns {number} Tab order (negative, 0, or positive number).\n */ var getSortOrderTabIndex = function getSortOrderTabIndex(node, isScope) {\n    var tabIndex = getTabIndex(node);\n    if (tabIndex < 0 && isScope && !hasTabIndex(node)) {\n        return 0;\n    }\n    return tabIndex;\n};\nvar sortOrderedTabbables = function sortOrderedTabbables(a, b) {\n    return a.tabIndex === b.tabIndex ? a.documentOrder - b.documentOrder : a.tabIndex - b.tabIndex;\n};\nvar isInput = function isInput(node) {\n    return node.tagName === \"INPUT\";\n};\nvar isHiddenInput = function isHiddenInput(node) {\n    return isInput(node) && node.type === \"hidden\";\n};\nvar isDetailsWithSummary = function isDetailsWithSummary(node) {\n    var r = node.tagName === \"DETAILS\" && Array.prototype.slice.apply(node.children).some(function(child) {\n        return child.tagName === \"SUMMARY\";\n    });\n    return r;\n};\nvar getCheckedRadio = function getCheckedRadio(nodes, form) {\n    for(var i = 0; i < nodes.length; i++){\n        if (nodes[i].checked && nodes[i].form === form) {\n            return nodes[i];\n        }\n    }\n};\nvar isTabbableRadio = function isTabbableRadio(node) {\n    if (!node.name) {\n        return true;\n    }\n    var radioScope = node.form || getRootNode(node);\n    var queryRadios = function queryRadios(name) {\n        return radioScope.querySelectorAll('input[type=\"radio\"][name=\"' + name + '\"]');\n    };\n    var radioSet;\n    if ( true && typeof window.CSS !== \"undefined\" && typeof window.CSS.escape === \"function\") {\n        radioSet = queryRadios(window.CSS.escape(node.name));\n    } else {\n        try {\n            radioSet = queryRadios(node.name);\n        } catch (err) {\n            // eslint-disable-next-line no-console\n            console.error(\"Looks like you have a radio button with a name attribute containing invalid CSS selector characters and need the CSS.escape polyfill: %s\", err.message);\n            return false;\n        }\n    }\n    var checked = getCheckedRadio(radioSet, node.form);\n    return !checked || checked === node;\n};\nvar isRadio = function isRadio(node) {\n    return isInput(node) && node.type === \"radio\";\n};\nvar isNonTabbableRadio = function isNonTabbableRadio(node) {\n    return isRadio(node) && !isTabbableRadio(node);\n};\n// determines if a node is ultimately attached to the window's document\nvar isNodeAttached = function isNodeAttached(node) {\n    var _nodeRoot;\n    // The root node is the shadow root if the node is in a shadow DOM; some document otherwise\n    //  (but NOT _the_ document; see second 'If' comment below for more).\n    // If rootNode is shadow root, it'll have a host, which is the element to which the shadow\n    //  is attached, and the one we need to check if it's in the document or not (because the\n    //  shadow, and all nodes it contains, is never considered in the document since shadows\n    //  behave like self-contained DOMs; but if the shadow's HOST, which is part of the document,\n    //  is hidden, or is not in the document itself but is detached, it will affect the shadow's\n    //  visibility, including all the nodes it contains). The host could be any normal node,\n    //  or a custom element (i.e. web component). Either way, that's the one that is considered\n    //  part of the document, not the shadow root, nor any of its children (i.e. the node being\n    //  tested).\n    // To further complicate things, we have to look all the way up until we find a shadow HOST\n    //  that is attached (or find none) because the node might be in nested shadows...\n    // If rootNode is not a shadow root, it won't have a host, and so rootNode should be the\n    //  document (per the docs) and while it's a Document-type object, that document does not\n    //  appear to be the same as the node's `ownerDocument` for some reason, so it's safer\n    //  to ignore the rootNode at this point, and use `node.ownerDocument`. Otherwise,\n    //  using `rootNode.contains(node)` will _always_ be true we'll get false-positives when\n    //  node is actually detached.\n    // NOTE: If `nodeRootHost` or `node` happens to be the `document` itself (which is possible\n    //  if a tabbable/focusable node was quickly added to the DOM, focused, and then removed\n    //  from the DOM as in https://github.com/focus-trap/focus-trap-react/issues/905), then\n    //  `ownerDocument` will be `null`, hence the optional chaining on it.\n    var nodeRoot = node && getRootNode(node);\n    var nodeRootHost = (_nodeRoot = nodeRoot) === null || _nodeRoot === void 0 ? void 0 : _nodeRoot.host;\n    // in some cases, a detached node will return itself as the root instead of a document or\n    //  shadow root object, in which case, we shouldn't try to look further up the host chain\n    var attached = false;\n    if (nodeRoot && nodeRoot !== node) {\n        var _nodeRootHost, _nodeRootHost$ownerDo, _node$ownerDocument;\n        attached = !!((_nodeRootHost = nodeRootHost) !== null && _nodeRootHost !== void 0 && (_nodeRootHost$ownerDo = _nodeRootHost.ownerDocument) !== null && _nodeRootHost$ownerDo !== void 0 && _nodeRootHost$ownerDo.contains(nodeRootHost) || node !== null && node !== void 0 && (_node$ownerDocument = node.ownerDocument) !== null && _node$ownerDocument !== void 0 && _node$ownerDocument.contains(node));\n        while(!attached && nodeRootHost){\n            var _nodeRoot2, _nodeRootHost2, _nodeRootHost2$ownerD;\n            // since it's not attached and we have a root host, the node MUST be in a nested shadow DOM,\n            //  which means we need to get the host's host and check if that parent host is contained\n            //  in (i.e. attached to) the document\n            nodeRoot = getRootNode(nodeRootHost);\n            nodeRootHost = (_nodeRoot2 = nodeRoot) === null || _nodeRoot2 === void 0 ? void 0 : _nodeRoot2.host;\n            attached = !!((_nodeRootHost2 = nodeRootHost) !== null && _nodeRootHost2 !== void 0 && (_nodeRootHost2$ownerD = _nodeRootHost2.ownerDocument) !== null && _nodeRootHost2$ownerD !== void 0 && _nodeRootHost2$ownerD.contains(nodeRootHost));\n        }\n    }\n    return attached;\n};\nvar isZeroArea = function isZeroArea(node) {\n    var _node$getBoundingClie = node.getBoundingClientRect(), width = _node$getBoundingClie.width, height = _node$getBoundingClie.height;\n    return width === 0 && height === 0;\n};\nvar isHidden = function isHidden(node, _ref) {\n    var displayCheck = _ref.displayCheck, getShadowRoot = _ref.getShadowRoot;\n    // NOTE: visibility will be `undefined` if node is detached from the document\n    //  (see notes about this further down), which means we will consider it visible\n    //  (this is legacy behavior from a very long way back)\n    // NOTE: we check this regardless of `displayCheck=\"none\"` because this is a\n    //  _visibility_ check, not a _display_ check\n    if (getComputedStyle(node).visibility === \"hidden\") {\n        return true;\n    }\n    var isDirectSummary = matches.call(node, \"details>summary:first-of-type\");\n    var nodeUnderDetails = isDirectSummary ? node.parentElement : node;\n    if (matches.call(nodeUnderDetails, \"details:not([open]) *\")) {\n        return true;\n    }\n    if (!displayCheck || displayCheck === \"full\" || displayCheck === \"legacy-full\") {\n        if (typeof getShadowRoot === \"function\") {\n            // figure out if we should consider the node to be in an undisclosed shadow and use the\n            //  'non-zero-area' fallback\n            var originalNode = node;\n            while(node){\n                var parentElement = node.parentElement;\n                var rootNode = getRootNode(node);\n                if (parentElement && !parentElement.shadowRoot && getShadowRoot(parentElement) === true // check if there's an undisclosed shadow\n                ) {\n                    // node has an undisclosed shadow which means we can only treat it as a black box, so we\n                    //  fall back to a non-zero-area test\n                    return isZeroArea(node);\n                } else if (node.assignedSlot) {\n                    // iterate up slot\n                    node = node.assignedSlot;\n                } else if (!parentElement && rootNode !== node.ownerDocument) {\n                    // cross shadow boundary\n                    node = rootNode.host;\n                } else {\n                    // iterate up normal dom\n                    node = parentElement;\n                }\n            }\n            node = originalNode;\n        }\n        // else, `getShadowRoot` might be true, but all that does is enable shadow DOM support\n        //  (i.e. it does not also presume that all nodes might have undisclosed shadows); or\n        //  it might be a falsy value, which means shadow DOM support is disabled\n        // Since we didn't find it sitting in an undisclosed shadow (or shadows are disabled)\n        //  now we can just test to see if it would normally be visible or not, provided it's\n        //  attached to the main document.\n        // NOTE: We must consider case where node is inside a shadow DOM and given directly to\n        //  `isTabbable()` or `isFocusable()` -- regardless of `getShadowRoot` option setting.\n        if (isNodeAttached(node)) {\n            // this works wherever the node is: if there's at least one client rect, it's\n            //  somehow displayed; it also covers the CSS 'display: contents' case where the\n            //  node itself is hidden in place of its contents; and there's no need to search\n            //  up the hierarchy either\n            return !node.getClientRects().length;\n        }\n        // Else, the node isn't attached to the document, which means the `getClientRects()`\n        //  API will __always__ return zero rects (this can happen, for example, if React\n        //  is used to render nodes onto a detached tree, as confirmed in this thread:\n        //  https://github.com/facebook/react/issues/9117#issuecomment-284228870)\n        //\n        // It also means that even window.getComputedStyle(node).display will return `undefined`\n        //  because styles are only computed for nodes that are in the document.\n        //\n        // NOTE: THIS HAS BEEN THE CASE FOR YEARS. It is not new, nor is it caused by tabbable\n        //  somehow. Though it was never stated officially, anyone who has ever used tabbable\n        //  APIs on nodes in detached containers has actually implicitly used tabbable in what\n        //  was later (as of v5.2.0 on Apr 9, 2021) called `displayCheck=\"none\"` mode -- essentially\n        //  considering __everything__ to be visible because of the innability to determine styles.\n        //\n        // v6.0.0: As of this major release, the default 'full' option __no longer treats detached\n        //  nodes as visible with the 'none' fallback.__\n        if (displayCheck !== \"legacy-full\") {\n            return true; // hidden\n        }\n    // else, fallback to 'none' mode and consider the node visible\n    } else if (displayCheck === \"non-zero-area\") {\n        // NOTE: Even though this tests that the node's client rect is non-zero to determine\n        //  whether it's displayed, and that a detached node will __always__ have a zero-area\n        //  client rect, we don't special-case for whether the node is attached or not. In\n        //  this mode, we do want to consider nodes that have a zero area to be hidden at all\n        //  times, and that includes attached or not.\n        return isZeroArea(node);\n    }\n    // visible, as far as we can tell, or per current `displayCheck=none` mode, we assume\n    //  it's visible\n    return false;\n};\n// form fields (nested) inside a disabled fieldset are not focusable/tabbable\n//  unless they are in the _first_ <legend> element of the top-most disabled\n//  fieldset\nvar isDisabledFromFieldset = function isDisabledFromFieldset(node) {\n    if (/^(INPUT|BUTTON|SELECT|TEXTAREA)$/.test(node.tagName)) {\n        var parentNode = node.parentElement;\n        // check if `node` is contained in a disabled <fieldset>\n        while(parentNode){\n            if (parentNode.tagName === \"FIELDSET\" && parentNode.disabled) {\n                // look for the first <legend> among the children of the disabled <fieldset>\n                for(var i = 0; i < parentNode.children.length; i++){\n                    var child = parentNode.children.item(i);\n                    // when the first <legend> (in document order) is found\n                    if (child.tagName === \"LEGEND\") {\n                        // if its parent <fieldset> is not nested in another disabled <fieldset>,\n                        // return whether `node` is a descendant of its first <legend>\n                        return matches.call(parentNode, \"fieldset[disabled] *\") ? true : !child.contains(node);\n                    }\n                }\n                // the disabled <fieldset> containing `node` has no <legend>\n                return true;\n            }\n            parentNode = parentNode.parentElement;\n        }\n    }\n    // else, node's tabbable/focusable state should not be affected by a fieldset's\n    //  enabled/disabled state\n    return false;\n};\nvar isNodeMatchingSelectorFocusable = function isNodeMatchingSelectorFocusable(options, node) {\n    if (node.disabled || // we must do an inert look up to filter out any elements inside an inert ancestor\n    //  because we're limited in the type of selectors we can use in JSDom (see related\n    //  note related to `candidateSelectors`)\n    isInert(node) || isHiddenInput(node) || isHidden(node, options) || // For a details element with a summary, the summary element gets the focus\n    isDetailsWithSummary(node) || isDisabledFromFieldset(node)) {\n        return false;\n    }\n    return true;\n};\nvar isNodeMatchingSelectorTabbable = function isNodeMatchingSelectorTabbable(options, node) {\n    if (isNonTabbableRadio(node) || getTabIndex(node) < 0 || !isNodeMatchingSelectorFocusable(options, node)) {\n        return false;\n    }\n    return true;\n};\nvar isValidShadowRootTabbable = function isValidShadowRootTabbable(shadowHostNode) {\n    var tabIndex = parseInt(shadowHostNode.getAttribute(\"tabindex\"), 10);\n    if (isNaN(tabIndex) || tabIndex >= 0) {\n        return true;\n    }\n    // If a custom element has an explicit negative tabindex,\n    // browsers will not allow tab targeting said element's children.\n    return false;\n};\n/**\n * @param {Array.<Element|CandidateScope>} candidates\n * @returns Element[]\n */ var sortByOrder = function sortByOrder(candidates) {\n    var regularTabbables = [];\n    var orderedTabbables = [];\n    candidates.forEach(function(item, i) {\n        var isScope = !!item.scopeParent;\n        var element = isScope ? item.scopeParent : item;\n        var candidateTabindex = getSortOrderTabIndex(element, isScope);\n        var elements = isScope ? sortByOrder(item.candidates) : element;\n        if (candidateTabindex === 0) {\n            isScope ? regularTabbables.push.apply(regularTabbables, elements) : regularTabbables.push(element);\n        } else {\n            orderedTabbables.push({\n                documentOrder: i,\n                tabIndex: candidateTabindex,\n                item: item,\n                isScope: isScope,\n                content: elements\n            });\n        }\n    });\n    return orderedTabbables.sort(sortOrderedTabbables).reduce(function(acc, sortable) {\n        sortable.isScope ? acc.push.apply(acc, sortable.content) : acc.push(sortable.content);\n        return acc;\n    }, []).concat(regularTabbables);\n};\nvar tabbable = function tabbable(container, options) {\n    options = options || {};\n    var candidates;\n    if (options.getShadowRoot) {\n        candidates = getCandidatesIteratively([\n            container\n        ], options.includeContainer, {\n            filter: isNodeMatchingSelectorTabbable.bind(null, options),\n            flatten: false,\n            getShadowRoot: options.getShadowRoot,\n            shadowRootFilter: isValidShadowRootTabbable\n        });\n    } else {\n        candidates = getCandidates(container, options.includeContainer, isNodeMatchingSelectorTabbable.bind(null, options));\n    }\n    return sortByOrder(candidates);\n};\nvar focusable = function focusable(container, options) {\n    options = options || {};\n    var candidates;\n    if (options.getShadowRoot) {\n        candidates = getCandidatesIteratively([\n            container\n        ], options.includeContainer, {\n            filter: isNodeMatchingSelectorFocusable.bind(null, options),\n            flatten: true,\n            getShadowRoot: options.getShadowRoot\n        });\n    } else {\n        candidates = getCandidates(container, options.includeContainer, isNodeMatchingSelectorFocusable.bind(null, options));\n    }\n    return candidates;\n};\nvar isTabbable = function isTabbable(node, options) {\n    options = options || {};\n    if (!node) {\n        throw new Error(\"No node provided\");\n    }\n    if (matches.call(node, candidateSelector) === false) {\n        return false;\n    }\n    return isNodeMatchingSelectorTabbable(options, node);\n};\nvar focusableCandidateSelector = /* #__PURE__ */ candidateSelectors.concat(\"iframe\").join(\",\");\nvar isFocusable = function isFocusable(node, options) {\n    options = options || {};\n    if (!node) {\n        throw new Error(\"No node provided\");\n    }\n    if (matches.call(node, focusableCandidateSelector) === false) {\n        return false;\n    }\n    return isNodeMatchingSelectorFocusable(options, node);\n};\n //# sourceMappingURL=index.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdGFiYmFibGUvZGlzdC9pbmRleC5lc20uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTs7O0FBR0EsR0FDQSwrRUFBK0U7QUFDL0UseUNBQXlDO0FBQ3pDLG1GQUFtRjtBQUNuRixpRkFBaUY7QUFDakYscUZBQXFGO0FBQ3JGLElBQUlBLHFCQUFxQjtJQUFDO0lBQXNCO0lBQXVCO0lBQXlCO0lBQXdCO0lBQXVCO0lBQXFDO0lBQWdDO0lBQWdDO0lBQWlFO0lBQThDO0NBQXVCO0FBQzFYLElBQUlDLG9CQUFvQixhQUFhLEdBQUVELG1CQUFtQkUsSUFBSSxDQUFDO0FBQy9ELElBQUlDLFlBQVksT0FBT0MsWUFBWTtBQUNuQyxJQUFJQyxVQUFVRixZQUFZLFlBQWEsSUFBSUMsUUFBUUUsU0FBUyxDQUFDRCxPQUFPLElBQUlELFFBQVFFLFNBQVMsQ0FBQ0MsaUJBQWlCLElBQUlILFFBQVFFLFNBQVMsQ0FBQ0UscUJBQXFCO0FBQ3RKLElBQUlDLGNBQWMsQ0FBQ04sYUFBYUMsUUFBUUUsU0FBUyxDQUFDRyxXQUFXLEdBQUcsU0FBVUMsT0FBTztJQUMvRSxJQUFJQztJQUNKLE9BQU9ELFlBQVksUUFBUUEsWUFBWSxLQUFLLElBQUksS0FBSyxJQUFJLENBQUNDLHVCQUF1QkQsUUFBUUQsV0FBVyxNQUFNLFFBQVFFLHlCQUF5QixLQUFLLElBQUksS0FBSyxJQUFJQSxxQkFBcUJDLElBQUksQ0FBQ0Y7QUFDekwsSUFBSSxTQUFVQSxPQUFPO0lBQ25CLE9BQU9BLFlBQVksUUFBUUEsWUFBWSxLQUFLLElBQUksS0FBSyxJQUFJQSxRQUFRRyxhQUFhO0FBQ2hGO0FBRUE7Ozs7Ozs7Q0FPQyxHQUNELElBQUlDLFVBQVUsU0FBU0EsUUFBUUMsSUFBSSxFQUFFQyxNQUFNO0lBQ3pDLElBQUlDO0lBQ0osSUFBSUQsV0FBVyxLQUFLLEdBQUc7UUFDckJBLFNBQVM7SUFDWDtJQUNBLHdGQUF3RjtJQUN4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QUFJMUQsUUFBUU8sSUFBSSxDQUFDRyxNQUFNdUksZ0NBQWdDLE9BQU87UUFDNUQsT0FBTztJQUNUO0lBQ0EsT0FBT25CLGdDQUFnQzdGLFNBQVN2QjtBQUNsRDtBQUVxRSxDQUNyRSxxQ0FBcUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy90YWJiYWJsZS9kaXN0L2luZGV4LmVzbS5qcz9iN2EzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuKiB0YWJiYWJsZSA2LjIuMFxuKiBAbGljZW5zZSBNSVQsIGh0dHBzOi8vZ2l0aHViLmNvbS9mb2N1cy10cmFwL3RhYmJhYmxlL2Jsb2IvbWFzdGVyL0xJQ0VOU0VcbiovXG4vLyBOT1RFOiBzZXBhcmF0ZSBgOm5vdCgpYCBzZWxlY3RvcnMgaGFzIGJyb2FkZXIgYnJvd3NlciBzdXBwb3J0IHRoYW4gdGhlIG5ld2VyXG4vLyAgYDpub3QoW2luZXJ0XSwgW2luZXJ0XSAqKWAgKEZlYiAyMDIzKVxuLy8gQ0FSRUZVTDogSlNEb20gZG9lcyBub3Qgc3VwcG9ydCBgOm5vdChbaW5lcnRdICopYCBhcyBhIHNlbGVjdG9yOyB1c2luZyBpdCBjYXVzZXNcbi8vICB0aGUgZW50aXJlIHF1ZXJ5IHRvIGZhaWwsIHJlc3VsdGluZyBpbiBubyBub2RlcyBmb3VuZCwgd2hpY2ggd2lsbCBicmVhayBhIGxvdFxuLy8gIG9mIHRoaW5ncy4uLiBzbyB3ZSBoYXZlIHRvIHJlbHkgb24gSlMgdG8gaWRlbnRpZnkgbm9kZXMgaW5zaWRlIGFuIGluZXJ0IGNvbnRhaW5lclxudmFyIGNhbmRpZGF0ZVNlbGVjdG9ycyA9IFsnaW5wdXQ6bm90KFtpbmVydF0pJywgJ3NlbGVjdDpub3QoW2luZXJ0XSknLCAndGV4dGFyZWE6bm90KFtpbmVydF0pJywgJ2FbaHJlZl06bm90KFtpbmVydF0pJywgJ2J1dHRvbjpub3QoW2luZXJ0XSknLCAnW3RhYmluZGV4XTpub3Qoc2xvdCk6bm90KFtpbmVydF0pJywgJ2F1ZGlvW2NvbnRyb2xzXTpub3QoW2luZXJ0XSknLCAndmlkZW9bY29udHJvbHNdOm5vdChbaW5lcnRdKScsICdbY29udGVudGVkaXRhYmxlXTpub3QoW2NvbnRlbnRlZGl0YWJsZT1cImZhbHNlXCJdKTpub3QoW2luZXJ0XSknLCAnZGV0YWlscz5zdW1tYXJ5OmZpcnN0LW9mLXR5cGU6bm90KFtpbmVydF0pJywgJ2RldGFpbHM6bm90KFtpbmVydF0pJ107XG52YXIgY2FuZGlkYXRlU2VsZWN0b3IgPSAvKiAjX19QVVJFX18gKi9jYW5kaWRhdGVTZWxlY3RvcnMuam9pbignLCcpO1xudmFyIE5vRWxlbWVudCA9IHR5cGVvZiBFbGVtZW50ID09PSAndW5kZWZpbmVkJztcbnZhciBtYXRjaGVzID0gTm9FbGVtZW50ID8gZnVuY3Rpb24gKCkge30gOiBFbGVtZW50LnByb3RvdHlwZS5tYXRjaGVzIHx8IEVsZW1lbnQucHJvdG90eXBlLm1zTWF0Y2hlc1NlbGVjdG9yIHx8IEVsZW1lbnQucHJvdG90eXBlLndlYmtpdE1hdGNoZXNTZWxlY3RvcjtcbnZhciBnZXRSb290Tm9kZSA9ICFOb0VsZW1lbnQgJiYgRWxlbWVudC5wcm90b3R5cGUuZ2V0Um9vdE5vZGUgPyBmdW5jdGlvbiAoZWxlbWVudCkge1xuICB2YXIgX2VsZW1lbnQkZ2V0Um9vdE5vZGU7XG4gIHJldHVybiBlbGVtZW50ID09PSBudWxsIHx8IGVsZW1lbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IChfZWxlbWVudCRnZXRSb290Tm9kZSA9IGVsZW1lbnQuZ2V0Um9vdE5vZGUpID09PSBudWxsIHx8IF9lbGVtZW50JGdldFJvb3ROb2RlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZWxlbWVudCRnZXRSb290Tm9kZS5jYWxsKGVsZW1lbnQpO1xufSA6IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gIHJldHVybiBlbGVtZW50ID09PSBudWxsIHx8IGVsZW1lbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGVsZW1lbnQub3duZXJEb2N1bWVudDtcbn07XG5cbi8qKlxuICogRGV0ZXJtaW5lcyBpZiBhIG5vZGUgaXMgaW5lcnQgb3IgaW4gYW4gaW5lcnQgYW5jZXN0b3IuXG4gKiBAcGFyYW0ge0VsZW1lbnR9IFtub2RlXVxuICogQHBhcmFtIHtib29sZWFufSBbbG9va1VwXSBJZiB0cnVlIGFuZCBgbm9kZWAgaXMgbm90IGluZXJ0LCBsb29rcyB1cCBhdCBhbmNlc3RvcnMgdG9cbiAqICBzZWUgaWYgYW55IG9mIHRoZW0gYXJlIGluZXJ0LiBJZiBmYWxzZSwgb25seSBgbm9kZWAgaXRzZWxmIGlzIGNvbnNpZGVyZWQuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiBpbmVydCBpdHNlbGYgb3IgYnkgd2F5IG9mIGJlaW5nIGluIGFuIGluZXJ0IGFuY2VzdG9yLlxuICogIEZhbHNlIGlmIGBub2RlYCBpcyBmYWxzeS5cbiAqL1xudmFyIGlzSW5lcnQgPSBmdW5jdGlvbiBpc0luZXJ0KG5vZGUsIGxvb2tVcCkge1xuICB2YXIgX25vZGUkZ2V0QXR0cmlidXRlO1xuICBpZiAobG9va1VwID09PSB2b2lkIDApIHtcbiAgICBsb29rVXAgPSB0cnVlO1xuICB9XG4gIC8vIENBUkVGVUw6IEpTRG9tIGRvZXMgbm90IHN1cHBvcnQgaW5lcnQgYXQgYWxsLCBzbyB3ZSBjYW4ndCB1c2UgdGhlIGBIVE1MRWxlbWVudC5pbmVydGBcbiAgLy8gIEpTIEFQSSBwcm9wZXJ0eTsgd2UgaGF2ZSB0byBjaGVjayB0aGUgYXR0cmlidXRlLCB3aGljaCBjYW4gZWl0aGVyIGJlIGVtcHR5IG9yICd0cnVlJztcbiAgLy8gIGlmIGl0J3MgYG51bGxgIChub3Qgc3BlY2lmaWVkKSBvciAnZmFsc2UnLCBpdCdzIGFuIGFjdGl2ZSBlbGVtZW50XG4gIHZhciBpbmVydEF0dCA9IG5vZGUgPT09IG51bGwgfHwgbm9kZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogKF9ub2RlJGdldEF0dHJpYnV0ZSA9IG5vZGUuZ2V0QXR0cmlidXRlKSA9PT0gbnVsbCB8fCBfbm9kZSRnZXRBdHRyaWJ1dGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9ub2RlJGdldEF0dHJpYnV0ZS5jYWxsKG5vZGUsICdpbmVydCcpO1xuICB2YXIgaW5lcnQgPSBpbmVydEF0dCA9PT0gJycgfHwgaW5lcnRBdHQgPT09ICd0cnVlJztcblxuICAvLyBOT1RFOiB0aGlzIGNvdWxkIGFsc28gYmUgaGFuZGxlZCB3aXRoIGBub2RlLm1hdGNoZXMoJ1tpbmVydF0sIDppcyhbaW5lcnRdICopJylgXG4gIC8vICBpZiBpdCB3ZXJlbid0IGZvciBgbWF0Y2hlcygpYCBub3QgYmVpbmcgYSBmdW5jdGlvbiBvbiBzaGFkb3cgcm9vdHM7IHRoZSBmb2xsb3dpbmdcbiAgLy8gIGNvZGUgd29ya3MgZm9yIGFueSBraW5kIG9mIG5vZGVcbiAgLy8gQ0FSRUZVTDogSlNEb20gZG9lcyBub3QgYXBwZWFyIHRvIHN1cHBvcnQgY2VydGFpbiBzZWxlY3RvcnMgbGlrZSBgOm5vdChbaW5lcnRdICopYFxuICAvLyAgc28gaXQgbGlrZWx5IHdvdWxkIG5vdCBzdXBwb3J0IGA6aXMoW2luZXJ0XSAqKWAgZWl0aGVyLi4uXG4gIHZhciByZXN1bHQgPSBpbmVydCB8fCBsb29rVXAgJiYgbm9kZSAmJiBpc0luZXJ0KG5vZGUucGFyZW50Tm9kZSk7IC8vIHJlY3Vyc2l2ZVxuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIERldGVybWluZXMgaWYgYSBub2RlJ3MgY29udGVudCBpcyBlZGl0YWJsZS5cbiAqIEBwYXJhbSB7RWxlbWVudH0gW25vZGVdXG4gKiBAcmV0dXJucyBUcnVlIGlmIGl0J3MgY29udGVudC1lZGl0YWJsZTsgZmFsc2UgaWYgaXQncyBub3Qgb3IgYG5vZGVgIGlzIGZhbHN5LlxuICovXG52YXIgaXNDb250ZW50RWRpdGFibGUgPSBmdW5jdGlvbiBpc0NvbnRlbnRFZGl0YWJsZShub2RlKSB7XG4gIHZhciBfbm9kZSRnZXRBdHRyaWJ1dGUyO1xuICAvLyBDQVJFRlVMOiBKU0RvbSBkb2VzIG5vdCBzdXBwb3J0IHRoZSBgSFRNTEVsZW1lbnQuaXNDb250ZW50RWRpdGFibGVgIEFQSSBzbyB3ZSBoYXZlXG4gIC8vICB0byB1c2UgdGhlIGF0dHJpYnV0ZSBkaXJlY3RseSB0byBjaGVjayBmb3IgdGhpcywgd2hpY2ggY2FuIGVpdGhlciBiZSBlbXB0eSBvciAndHJ1ZSc7XG4gIC8vICBpZiBpdCdzIGBudWxsYCAobm90IHNwZWNpZmllZCkgb3IgJ2ZhbHNlJywgaXQncyBhIG5vbi1lZGl0YWJsZSBlbGVtZW50XG4gIHZhciBhdHRWYWx1ZSA9IG5vZGUgPT09IG51bGwgfHwgbm9kZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogKF9ub2RlJGdldEF0dHJpYnV0ZTIgPSBub2RlLmdldEF0dHJpYnV0ZSkgPT09IG51bGwgfHwgX25vZGUkZ2V0QXR0cmlidXRlMiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX25vZGUkZ2V0QXR0cmlidXRlMi5jYWxsKG5vZGUsICdjb250ZW50ZWRpdGFibGUnKTtcbiAgcmV0dXJuIGF0dFZhbHVlID09PSAnJyB8fCBhdHRWYWx1ZSA9PT0gJ3RydWUnO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsIGNvbnRhaW5lciB0byBjaGVjayBpblxuICogQHBhcmFtIHtib29sZWFufSBpbmNsdWRlQ29udGFpbmVyIGFkZCBjb250YWluZXIgdG8gY2hlY2tcbiAqIEBwYXJhbSB7KG5vZGU6IEVsZW1lbnQpID0+IGJvb2xlYW59IGZpbHRlciBmaWx0ZXIgY2FuZGlkYXRlc1xuICogQHJldHVybnMge0VsZW1lbnRbXX1cbiAqL1xudmFyIGdldENhbmRpZGF0ZXMgPSBmdW5jdGlvbiBnZXRDYW5kaWRhdGVzKGVsLCBpbmNsdWRlQ29udGFpbmVyLCBmaWx0ZXIpIHtcbiAgLy8gZXZlbiBpZiBgaW5jbHVkZUNvbnRhaW5lcj1mYWxzZWAsIHdlIHN0aWxsIGhhdmUgdG8gY2hlY2sgaXQgZm9yIGluZXJ0bmVzcyBiZWNhdXNlXG4gIC8vICBpZiBpdCdzIGluZXJ0LCBhbGwgaXRzIGNoaWxkcmVuIGFyZSBpbmVydFxuICBpZiAoaXNJbmVydChlbCkpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgdmFyIGNhbmRpZGF0ZXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuYXBwbHkoZWwucXVlcnlTZWxlY3RvckFsbChjYW5kaWRhdGVTZWxlY3RvcikpO1xuICBpZiAoaW5jbHVkZUNvbnRhaW5lciAmJiBtYXRjaGVzLmNhbGwoZWwsIGNhbmRpZGF0ZVNlbGVjdG9yKSkge1xuICAgIGNhbmRpZGF0ZXMudW5zaGlmdChlbCk7XG4gIH1cbiAgY2FuZGlkYXRlcyA9IGNhbmRpZGF0ZXMuZmlsdGVyKGZpbHRlcik7XG4gIHJldHVybiBjYW5kaWRhdGVzO1xufTtcblxuLyoqXG4gKiBAY2FsbGJhY2sgR2V0U2hhZG93Um9vdFxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50IHRvIGNoZWNrIGZvciBzaGFkb3cgcm9vdFxuICogQHJldHVybnMge1NoYWRvd1Jvb3R8Ym9vbGVhbn0gU2hhZG93Um9vdCBpZiBhdmFpbGFibGUgb3IgYm9vbGVhbiBpbmRpY2F0aW5nIGlmIGEgc2hhZG93Um9vdCBpcyBhdHRhY2hlZCBidXQgbm90IGF2YWlsYWJsZS5cbiAqL1xuXG4vKipcbiAqIEBjYWxsYmFjayBTaGFkb3dSb290RmlsdGVyXG4gKiBAcGFyYW0ge0VsZW1lbnR9IHNoYWRvd0hvc3ROb2RlIHRoZSBlbGVtZW50IHdoaWNoIGNvbnRhaW5zIHNoYWRvdyBjb250ZW50XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpZiBhIHNoYWRvdyByb290IGNvdWxkIHBvdGVudGlhbGx5IGNvbnRhaW4gdmFsaWQgY2FuZGlkYXRlcy5cbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IENhbmRpZGF0ZVNjb3BlXG4gKiBAcHJvcGVydHkge0VsZW1lbnR9IHNjb3BlUGFyZW50IGNvbnRhaW5zIGlubmVyIGNhbmRpZGF0ZXNcbiAqIEBwcm9wZXJ0eSB7RWxlbWVudFtdfSBjYW5kaWRhdGVzIGxpc3Qgb2YgY2FuZGlkYXRlcyBmb3VuZCBpbiB0aGUgc2NvcGUgcGFyZW50XG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBJdGVyYXRpdmVPcHRpb25zXG4gKiBAcHJvcGVydHkge0dldFNoYWRvd1Jvb3R8Ym9vbGVhbn0gZ2V0U2hhZG93Um9vdCB0cnVlIGlmIHNoYWRvdyBzdXBwb3J0IGlzIGVuYWJsZWQ7IGZhbHN5IGlmIG5vdDtcbiAqICBpZiBhIGZ1bmN0aW9uLCBpbXBsaWVzIHNoYWRvdyBzdXBwb3J0IGlzIGVuYWJsZWQgYW5kIGVpdGhlciByZXR1cm5zIHRoZSBzaGFkb3cgcm9vdCBvZiBhbiBlbGVtZW50XG4gKiAgb3IgYSBib29sZWFuIHN0YXRpbmcgaWYgaXQgaGFzIGFuIHVuZGlzY2xvc2VkIHNoYWRvdyByb290XG4gKiBAcHJvcGVydHkgeyhub2RlOiBFbGVtZW50KSA9PiBib29sZWFufSBmaWx0ZXIgZmlsdGVyIGNhbmRpZGF0ZXNcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gZmxhdHRlbiBpZiB0cnVlIHRoZW4gcmVzdWx0IHdpbGwgZmxhdHRlbiBhbnkgQ2FuZGlkYXRlU2NvcGUgaW50byB0aGUgcmV0dXJuZWQgbGlzdFxuICogQHByb3BlcnR5IHtTaGFkb3dSb290RmlsdGVyfSBzaGFkb3dSb290RmlsdGVyIGZpbHRlciBzaGFkb3cgcm9vdHM7XG4gKi9cblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnRbXX0gZWxlbWVudHMgbGlzdCBvZiBlbGVtZW50IGNvbnRhaW5lcnMgdG8gbWF0Y2ggY2FuZGlkYXRlcyBmcm9tXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGluY2x1ZGVDb250YWluZXIgYWRkIGNvbnRhaW5lciBsaXN0IHRvIGNoZWNrXG4gKiBAcGFyYW0ge0l0ZXJhdGl2ZU9wdGlvbnN9IG9wdGlvbnNcbiAqIEByZXR1cm5zIHtBcnJheS48RWxlbWVudHxDYW5kaWRhdGVTY29wZT59XG4gKi9cbnZhciBnZXRDYW5kaWRhdGVzSXRlcmF0aXZlbHkgPSBmdW5jdGlvbiBnZXRDYW5kaWRhdGVzSXRlcmF0aXZlbHkoZWxlbWVudHMsIGluY2x1ZGVDb250YWluZXIsIG9wdGlvbnMpIHtcbiAgdmFyIGNhbmRpZGF0ZXMgPSBbXTtcbiAgdmFyIGVsZW1lbnRzVG9DaGVjayA9IEFycmF5LmZyb20oZWxlbWVudHMpO1xuICB3aGlsZSAoZWxlbWVudHNUb0NoZWNrLmxlbmd0aCkge1xuICAgIHZhciBlbGVtZW50ID0gZWxlbWVudHNUb0NoZWNrLnNoaWZ0KCk7XG4gICAgaWYgKGlzSW5lcnQoZWxlbWVudCwgZmFsc2UpKSB7XG4gICAgICAvLyBubyBuZWVkIHRvIGxvb2sgdXAgc2luY2Ugd2UncmUgZHJpbGxpbmcgZG93blxuICAgICAgLy8gYW55dGhpbmcgaW5zaWRlIHRoaXMgY29udGFpbmVyIHdpbGwgYWxzbyBiZSBpbmVydFxuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChlbGVtZW50LnRhZ05hbWUgPT09ICdTTE9UJykge1xuICAgICAgLy8gYWRkIHNoYWRvdyBkb20gc2xvdCBzY29wZSAoc2xvdCBpdHNlbGYgY2Fubm90IGJlIGZvY3VzYWJsZSlcbiAgICAgIHZhciBhc3NpZ25lZCA9IGVsZW1lbnQuYXNzaWduZWRFbGVtZW50cygpO1xuICAgICAgdmFyIGNvbnRlbnQgPSBhc3NpZ25lZC5sZW5ndGggPyBhc3NpZ25lZCA6IGVsZW1lbnQuY2hpbGRyZW47XG4gICAgICB2YXIgbmVzdGVkQ2FuZGlkYXRlcyA9IGdldENhbmRpZGF0ZXNJdGVyYXRpdmVseShjb250ZW50LCB0cnVlLCBvcHRpb25zKTtcbiAgICAgIGlmIChvcHRpb25zLmZsYXR0ZW4pIHtcbiAgICAgICAgY2FuZGlkYXRlcy5wdXNoLmFwcGx5KGNhbmRpZGF0ZXMsIG5lc3RlZENhbmRpZGF0ZXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2FuZGlkYXRlcy5wdXNoKHtcbiAgICAgICAgICBzY29wZVBhcmVudDogZWxlbWVudCxcbiAgICAgICAgICBjYW5kaWRhdGVzOiBuZXN0ZWRDYW5kaWRhdGVzXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBjaGVjayBjYW5kaWRhdGUgZWxlbWVudFxuICAgICAgdmFyIHZhbGlkQ2FuZGlkYXRlID0gbWF0Y2hlcy5jYWxsKGVsZW1lbnQsIGNhbmRpZGF0ZVNlbGVjdG9yKTtcbiAgICAgIGlmICh2YWxpZENhbmRpZGF0ZSAmJiBvcHRpb25zLmZpbHRlcihlbGVtZW50KSAmJiAoaW5jbHVkZUNvbnRhaW5lciB8fCAhZWxlbWVudHMuaW5jbHVkZXMoZWxlbWVudCkpKSB7XG4gICAgICAgIGNhbmRpZGF0ZXMucHVzaChlbGVtZW50KTtcbiAgICAgIH1cblxuICAgICAgLy8gaXRlcmF0ZSBvdmVyIHNoYWRvdyBjb250ZW50IGlmIHBvc3NpYmxlXG4gICAgICB2YXIgc2hhZG93Um9vdCA9IGVsZW1lbnQuc2hhZG93Um9vdCB8fFxuICAgICAgLy8gY2hlY2sgZm9yIGFuIHVuZGlzY2xvc2VkIHNoYWRvd1xuICAgICAgdHlwZW9mIG9wdGlvbnMuZ2V0U2hhZG93Um9vdCA9PT0gJ2Z1bmN0aW9uJyAmJiBvcHRpb25zLmdldFNoYWRvd1Jvb3QoZWxlbWVudCk7XG5cbiAgICAgIC8vIG5vIGluZXJ0IGxvb2sgdXAgYmVjYXVzZSB3ZSdyZSBhbHJlYWR5IGRyaWxsaW5nIGRvd24gYW5kIGNoZWNraW5nIGZvciBpbmVydG5lc3NcbiAgICAgIC8vICBvbiB0aGUgd2F5IGRvd24sIHNvIGFsbCBjb250YWluZXJzIHRvIHRoaXMgcm9vdCBub2RlIHNob3VsZCBoYXZlIGFscmVhZHkgYmVlblxuICAgICAgLy8gIHZldHRlZCBhcyBub24taW5lcnRcbiAgICAgIHZhciB2YWxpZFNoYWRvd1Jvb3QgPSAhaXNJbmVydChzaGFkb3dSb290LCBmYWxzZSkgJiYgKCFvcHRpb25zLnNoYWRvd1Jvb3RGaWx0ZXIgfHwgb3B0aW9ucy5zaGFkb3dSb290RmlsdGVyKGVsZW1lbnQpKTtcbiAgICAgIGlmIChzaGFkb3dSb290ICYmIHZhbGlkU2hhZG93Um9vdCkge1xuICAgICAgICAvLyBhZGQgc2hhZG93IGRvbSBzY29wZSBJSUYgYSBzaGFkb3cgcm9vdCBub2RlIHdhcyBnaXZlbjsgb3RoZXJ3aXNlLCBhbiB1bmRpc2Nsb3NlZFxuICAgICAgICAvLyAgc2hhZG93IGV4aXN0cywgc28gbG9vayBhdCBsaWdodCBkb20gY2hpbGRyZW4gYXMgZmFsbGJhY2sgQlVUIGNyZWF0ZSBhIHNjb3BlIGZvciBhbnlcbiAgICAgICAgLy8gIGNoaWxkIGNhbmRpZGF0ZXMgZm91bmQgYmVjYXVzZSB0aGV5J3JlIGxpa2VseSBzbG90dGVkIGVsZW1lbnRzIChlbGVtZW50cyB0aGF0IGFyZVxuICAgICAgICAvLyAgY2hpbGRyZW4gb2YgdGhlIHdlYiBjb21wb25lbnQgZWxlbWVudCAod2hpY2ggaGFzIHRoZSBzaGFkb3cpLCBpbiB0aGUgbGlnaHQgZG9tLCBidXRcbiAgICAgICAgLy8gIHNsb3R0ZWQgc29tZXdoZXJlIF9pbnNpZGVfIHRoZSB1bmRpc2Nsb3NlZCBzaGFkb3cpIC0tIHRoZSBzY29wZSBpcyBjcmVhdGVkIGJlbG93LFxuICAgICAgICAvLyAgX2FmdGVyXyB3ZSByZXR1cm4gZnJvbSB0aGlzIHJlY3Vyc2l2ZSBjYWxsXG4gICAgICAgIHZhciBfbmVzdGVkQ2FuZGlkYXRlcyA9IGdldENhbmRpZGF0ZXNJdGVyYXRpdmVseShzaGFkb3dSb290ID09PSB0cnVlID8gZWxlbWVudC5jaGlsZHJlbiA6IHNoYWRvd1Jvb3QuY2hpbGRyZW4sIHRydWUsIG9wdGlvbnMpO1xuICAgICAgICBpZiAob3B0aW9ucy5mbGF0dGVuKSB7XG4gICAgICAgICAgY2FuZGlkYXRlcy5wdXNoLmFwcGx5KGNhbmRpZGF0ZXMsIF9uZXN0ZWRDYW5kaWRhdGVzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjYW5kaWRhdGVzLnB1c2goe1xuICAgICAgICAgICAgc2NvcGVQYXJlbnQ6IGVsZW1lbnQsXG4gICAgICAgICAgICBjYW5kaWRhdGVzOiBfbmVzdGVkQ2FuZGlkYXRlc1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyB0aGVyZSdzIG5vdCBzaGFkb3cgc28ganVzdCBkaWcgaW50byB0aGUgZWxlbWVudCdzIChsaWdodCBkb20pIGNoaWxkcmVuXG4gICAgICAgIC8vICBfX3dpdGhvdXRfXyBnaXZpbmcgdGhlIGVsZW1lbnQgc3BlY2lhbCBzY29wZSB0cmVhdG1lbnRcbiAgICAgICAgZWxlbWVudHNUb0NoZWNrLnVuc2hpZnQuYXBwbHkoZWxlbWVudHNUb0NoZWNrLCBlbGVtZW50LmNoaWxkcmVuKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNhbmRpZGF0ZXM7XG59O1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBEZXRlcm1pbmVzIGlmIHRoZSBub2RlIGhhcyBhbiBleHBsaWNpdGx5IHNwZWNpZmllZCBgdGFiaW5kZXhgIGF0dHJpYnV0ZS5cbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IG5vZGVcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHNvOyBmYWxzZSBpZiBub3QuXG4gKi9cbnZhciBoYXNUYWJJbmRleCA9IGZ1bmN0aW9uIGhhc1RhYkluZGV4KG5vZGUpIHtcbiAgcmV0dXJuICFpc05hTihwYXJzZUludChub2RlLmdldEF0dHJpYnV0ZSgndGFiaW5kZXgnKSwgMTApKTtcbn07XG5cbi8qKlxuICogRGV0ZXJtaW5lIHRoZSB0YWIgaW5kZXggb2YgYSBnaXZlbiBub2RlLlxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gbm9kZVxuICogQHJldHVybnMge251bWJlcn0gVGFiIG9yZGVyIChuZWdhdGl2ZSwgMCwgb3IgcG9zaXRpdmUgbnVtYmVyKS5cbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiBgbm9kZWAgaXMgZmFsc3kuXG4gKi9cbnZhciBnZXRUYWJJbmRleCA9IGZ1bmN0aW9uIGdldFRhYkluZGV4KG5vZGUpIHtcbiAgaWYgKCFub2RlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdObyBub2RlIHByb3ZpZGVkJyk7XG4gIH1cbiAgaWYgKG5vZGUudGFiSW5kZXggPCAwKSB7XG4gICAgLy8gaW4gQ2hyb21lLCA8ZGV0YWlscy8+LCA8YXVkaW8gY29udHJvbHMvPiBhbmQgPHZpZGVvIGNvbnRyb2xzLz4gZWxlbWVudHMgZ2V0IGEgZGVmYXVsdFxuICAgIC8vIGB0YWJJbmRleGAgb2YgLTEgd2hlbiB0aGUgJ3RhYmluZGV4JyBhdHRyaWJ1dGUgaXNuJ3Qgc3BlY2lmaWVkIGluIHRoZSBET00sXG4gICAgLy8geWV0IHRoZXkgYXJlIHN0aWxsIHBhcnQgb2YgdGhlIHJlZ3VsYXIgdGFiIG9yZGVyOyBpbiBGRiwgdGhleSBnZXQgYSBkZWZhdWx0XG4gICAgLy8gYHRhYkluZGV4YCBvZiAwOyBzaW5jZSBDaHJvbWUgc3RpbGwgcHV0cyB0aG9zZSBlbGVtZW50cyBpbiB0aGUgcmVndWxhciB0YWJcbiAgICAvLyBvcmRlciwgY29uc2lkZXIgdGhlaXIgdGFiIGluZGV4IHRvIGJlIDAuXG4gICAgLy8gQWxzbyBicm93c2VycyBkbyBub3QgcmV0dXJuIGB0YWJJbmRleGAgY29ycmVjdGx5IGZvciBjb250ZW50RWRpdGFibGUgbm9kZXM7XG4gICAgLy8gc28gaWYgdGhleSBkb24ndCBoYXZlIGEgdGFiaW5kZXggYXR0cmlidXRlIHNwZWNpZmljYWxseSBzZXQsIGFzc3VtZSBpdCdzIDAuXG4gICAgaWYgKCgvXihBVURJT3xWSURFT3xERVRBSUxTKSQvLnRlc3Qobm9kZS50YWdOYW1lKSB8fCBpc0NvbnRlbnRFZGl0YWJsZShub2RlKSkgJiYgIWhhc1RhYkluZGV4KG5vZGUpKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5vZGUudGFiSW5kZXg7XG59O1xuXG4vKipcbiAqIERldGVybWluZSB0aGUgdGFiIGluZGV4IG9mIGEgZ2l2ZW4gbm9kZSBfX2ZvciBzb3J0IG9yZGVyIHB1cnBvc2VzX18uXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBub2RlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpc1Njb3BlXSBUcnVlIGZvciBhIGN1c3RvbSBlbGVtZW50IHdpdGggc2hhZG93IHJvb3Qgb3Igc2xvdCB0aGF0LCBieSBkZWZhdWx0LFxuICogIGhhcyB0YWJJbmRleCAtMSwgYnV0IG5lZWRzIHRvIGJlIHNvcnRlZCBieSBkb2N1bWVudCBvcmRlciBpbiBvcmRlciBmb3IgaXRzIGNvbnRlbnQgdG8gYmVcbiAqICBpbnNlcnRlZCBpbnRvIHRoZSBjb3JyZWN0IHNvcnQgcG9zaXRpb24uXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBUYWIgb3JkZXIgKG5lZ2F0aXZlLCAwLCBvciBwb3NpdGl2ZSBudW1iZXIpLlxuICovXG52YXIgZ2V0U29ydE9yZGVyVGFiSW5kZXggPSBmdW5jdGlvbiBnZXRTb3J0T3JkZXJUYWJJbmRleChub2RlLCBpc1Njb3BlKSB7XG4gIHZhciB0YWJJbmRleCA9IGdldFRhYkluZGV4KG5vZGUpO1xuICBpZiAodGFiSW5kZXggPCAwICYmIGlzU2NvcGUgJiYgIWhhc1RhYkluZGV4KG5vZGUpKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgcmV0dXJuIHRhYkluZGV4O1xufTtcbnZhciBzb3J0T3JkZXJlZFRhYmJhYmxlcyA9IGZ1bmN0aW9uIHNvcnRPcmRlcmVkVGFiYmFibGVzKGEsIGIpIHtcbiAgcmV0dXJuIGEudGFiSW5kZXggPT09IGIudGFiSW5kZXggPyBhLmRvY3VtZW50T3JkZXIgLSBiLmRvY3VtZW50T3JkZXIgOiBhLnRhYkluZGV4IC0gYi50YWJJbmRleDtcbn07XG52YXIgaXNJbnB1dCA9IGZ1bmN0aW9uIGlzSW5wdXQobm9kZSkge1xuICByZXR1cm4gbm9kZS50YWdOYW1lID09PSAnSU5QVVQnO1xufTtcbnZhciBpc0hpZGRlbklucHV0ID0gZnVuY3Rpb24gaXNIaWRkZW5JbnB1dChub2RlKSB7XG4gIHJldHVybiBpc0lucHV0KG5vZGUpICYmIG5vZGUudHlwZSA9PT0gJ2hpZGRlbic7XG59O1xudmFyIGlzRGV0YWlsc1dpdGhTdW1tYXJ5ID0gZnVuY3Rpb24gaXNEZXRhaWxzV2l0aFN1bW1hcnkobm9kZSkge1xuICB2YXIgciA9IG5vZGUudGFnTmFtZSA9PT0gJ0RFVEFJTFMnICYmIEFycmF5LnByb3RvdHlwZS5zbGljZS5hcHBseShub2RlLmNoaWxkcmVuKS5zb21lKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgIHJldHVybiBjaGlsZC50YWdOYW1lID09PSAnU1VNTUFSWSc7XG4gIH0pO1xuICByZXR1cm4gcjtcbn07XG52YXIgZ2V0Q2hlY2tlZFJhZGlvID0gZnVuY3Rpb24gZ2V0Q2hlY2tlZFJhZGlvKG5vZGVzLCBmb3JtKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAobm9kZXNbaV0uY2hlY2tlZCAmJiBub2Rlc1tpXS5mb3JtID09PSBmb3JtKSB7XG4gICAgICByZXR1cm4gbm9kZXNbaV07XG4gICAgfVxuICB9XG59O1xudmFyIGlzVGFiYmFibGVSYWRpbyA9IGZ1bmN0aW9uIGlzVGFiYmFibGVSYWRpbyhub2RlKSB7XG4gIGlmICghbm9kZS5uYW1lKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgdmFyIHJhZGlvU2NvcGUgPSBub2RlLmZvcm0gfHwgZ2V0Um9vdE5vZGUobm9kZSk7XG4gIHZhciBxdWVyeVJhZGlvcyA9IGZ1bmN0aW9uIHF1ZXJ5UmFkaW9zKG5hbWUpIHtcbiAgICByZXR1cm4gcmFkaW9TY29wZS5xdWVyeVNlbGVjdG9yQWxsKCdpbnB1dFt0eXBlPVwicmFkaW9cIl1bbmFtZT1cIicgKyBuYW1lICsgJ1wiXScpO1xuICB9O1xuICB2YXIgcmFkaW9TZXQ7XG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd2luZG93LkNTUyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5DU1MuZXNjYXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmFkaW9TZXQgPSBxdWVyeVJhZGlvcyh3aW5kb3cuQ1NTLmVzY2FwZShub2RlLm5hbWUpKTtcbiAgfSBlbHNlIHtcbiAgICB0cnkge1xuICAgICAgcmFkaW9TZXQgPSBxdWVyeVJhZGlvcyhub2RlLm5hbWUpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0xvb2tzIGxpa2UgeW91IGhhdmUgYSByYWRpbyBidXR0b24gd2l0aCBhIG5hbWUgYXR0cmlidXRlIGNvbnRhaW5pbmcgaW52YWxpZCBDU1Mgc2VsZWN0b3IgY2hhcmFjdGVycyBhbmQgbmVlZCB0aGUgQ1NTLmVzY2FwZSBwb2x5ZmlsbDogJXMnLCBlcnIubWVzc2FnZSk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHZhciBjaGVja2VkID0gZ2V0Q2hlY2tlZFJhZGlvKHJhZGlvU2V0LCBub2RlLmZvcm0pO1xuICByZXR1cm4gIWNoZWNrZWQgfHwgY2hlY2tlZCA9PT0gbm9kZTtcbn07XG52YXIgaXNSYWRpbyA9IGZ1bmN0aW9uIGlzUmFkaW8obm9kZSkge1xuICByZXR1cm4gaXNJbnB1dChub2RlKSAmJiBub2RlLnR5cGUgPT09ICdyYWRpbyc7XG59O1xudmFyIGlzTm9uVGFiYmFibGVSYWRpbyA9IGZ1bmN0aW9uIGlzTm9uVGFiYmFibGVSYWRpbyhub2RlKSB7XG4gIHJldHVybiBpc1JhZGlvKG5vZGUpICYmICFpc1RhYmJhYmxlUmFkaW8obm9kZSk7XG59O1xuXG4vLyBkZXRlcm1pbmVzIGlmIGEgbm9kZSBpcyB1bHRpbWF0ZWx5IGF0dGFjaGVkIHRvIHRoZSB3aW5kb3cncyBkb2N1bWVudFxudmFyIGlzTm9kZUF0dGFjaGVkID0gZnVuY3Rpb24gaXNOb2RlQXR0YWNoZWQobm9kZSkge1xuICB2YXIgX25vZGVSb290O1xuICAvLyBUaGUgcm9vdCBub2RlIGlzIHRoZSBzaGFkb3cgcm9vdCBpZiB0aGUgbm9kZSBpcyBpbiBhIHNoYWRvdyBET007IHNvbWUgZG9jdW1lbnQgb3RoZXJ3aXNlXG4gIC8vICAoYnV0IE5PVCBfdGhlXyBkb2N1bWVudDsgc2VlIHNlY29uZCAnSWYnIGNvbW1lbnQgYmVsb3cgZm9yIG1vcmUpLlxuICAvLyBJZiByb290Tm9kZSBpcyBzaGFkb3cgcm9vdCwgaXQnbGwgaGF2ZSBhIGhvc3QsIHdoaWNoIGlzIHRoZSBlbGVtZW50IHRvIHdoaWNoIHRoZSBzaGFkb3dcbiAgLy8gIGlzIGF0dGFjaGVkLCBhbmQgdGhlIG9uZSB3ZSBuZWVkIHRvIGNoZWNrIGlmIGl0J3MgaW4gdGhlIGRvY3VtZW50IG9yIG5vdCAoYmVjYXVzZSB0aGVcbiAgLy8gIHNoYWRvdywgYW5kIGFsbCBub2RlcyBpdCBjb250YWlucywgaXMgbmV2ZXIgY29uc2lkZXJlZCBpbiB0aGUgZG9jdW1lbnQgc2luY2Ugc2hhZG93c1xuICAvLyAgYmVoYXZlIGxpa2Ugc2VsZi1jb250YWluZWQgRE9NczsgYnV0IGlmIHRoZSBzaGFkb3cncyBIT1NULCB3aGljaCBpcyBwYXJ0IG9mIHRoZSBkb2N1bWVudCxcbiAgLy8gIGlzIGhpZGRlbiwgb3IgaXMgbm90IGluIHRoZSBkb2N1bWVudCBpdHNlbGYgYnV0IGlzIGRldGFjaGVkLCBpdCB3aWxsIGFmZmVjdCB0aGUgc2hhZG93J3NcbiAgLy8gIHZpc2liaWxpdHksIGluY2x1ZGluZyBhbGwgdGhlIG5vZGVzIGl0IGNvbnRhaW5zKS4gVGhlIGhvc3QgY291bGQgYmUgYW55IG5vcm1hbCBub2RlLFxuICAvLyAgb3IgYSBjdXN0b20gZWxlbWVudCAoaS5lLiB3ZWIgY29tcG9uZW50KS4gRWl0aGVyIHdheSwgdGhhdCdzIHRoZSBvbmUgdGhhdCBpcyBjb25zaWRlcmVkXG4gIC8vICBwYXJ0IG9mIHRoZSBkb2N1bWVudCwgbm90IHRoZSBzaGFkb3cgcm9vdCwgbm9yIGFueSBvZiBpdHMgY2hpbGRyZW4gKGkuZS4gdGhlIG5vZGUgYmVpbmdcbiAgLy8gIHRlc3RlZCkuXG4gIC8vIFRvIGZ1cnRoZXIgY29tcGxpY2F0ZSB0aGluZ3MsIHdlIGhhdmUgdG8gbG9vayBhbGwgdGhlIHdheSB1cCB1bnRpbCB3ZSBmaW5kIGEgc2hhZG93IEhPU1RcbiAgLy8gIHRoYXQgaXMgYXR0YWNoZWQgKG9yIGZpbmQgbm9uZSkgYmVjYXVzZSB0aGUgbm9kZSBtaWdodCBiZSBpbiBuZXN0ZWQgc2hhZG93cy4uLlxuICAvLyBJZiByb290Tm9kZSBpcyBub3QgYSBzaGFkb3cgcm9vdCwgaXQgd29uJ3QgaGF2ZSBhIGhvc3QsIGFuZCBzbyByb290Tm9kZSBzaG91bGQgYmUgdGhlXG4gIC8vICBkb2N1bWVudCAocGVyIHRoZSBkb2NzKSBhbmQgd2hpbGUgaXQncyBhIERvY3VtZW50LXR5cGUgb2JqZWN0LCB0aGF0IGRvY3VtZW50IGRvZXMgbm90XG4gIC8vICBhcHBlYXIgdG8gYmUgdGhlIHNhbWUgYXMgdGhlIG5vZGUncyBgb3duZXJEb2N1bWVudGAgZm9yIHNvbWUgcmVhc29uLCBzbyBpdCdzIHNhZmVyXG4gIC8vICB0byBpZ25vcmUgdGhlIHJvb3ROb2RlIGF0IHRoaXMgcG9pbnQsIGFuZCB1c2UgYG5vZGUub3duZXJEb2N1bWVudGAuIE90aGVyd2lzZSxcbiAgLy8gIHVzaW5nIGByb290Tm9kZS5jb250YWlucyhub2RlKWAgd2lsbCBfYWx3YXlzXyBiZSB0cnVlIHdlJ2xsIGdldCBmYWxzZS1wb3NpdGl2ZXMgd2hlblxuICAvLyAgbm9kZSBpcyBhY3R1YWxseSBkZXRhY2hlZC5cbiAgLy8gTk9URTogSWYgYG5vZGVSb290SG9zdGAgb3IgYG5vZGVgIGhhcHBlbnMgdG8gYmUgdGhlIGBkb2N1bWVudGAgaXRzZWxmICh3aGljaCBpcyBwb3NzaWJsZVxuICAvLyAgaWYgYSB0YWJiYWJsZS9mb2N1c2FibGUgbm9kZSB3YXMgcXVpY2tseSBhZGRlZCB0byB0aGUgRE9NLCBmb2N1c2VkLCBhbmQgdGhlbiByZW1vdmVkXG4gIC8vICBmcm9tIHRoZSBET00gYXMgaW4gaHR0cHM6Ly9naXRodWIuY29tL2ZvY3VzLXRyYXAvZm9jdXMtdHJhcC1yZWFjdC9pc3N1ZXMvOTA1KSwgdGhlblxuICAvLyAgYG93bmVyRG9jdW1lbnRgIHdpbGwgYmUgYG51bGxgLCBoZW5jZSB0aGUgb3B0aW9uYWwgY2hhaW5pbmcgb24gaXQuXG4gIHZhciBub2RlUm9vdCA9IG5vZGUgJiYgZ2V0Um9vdE5vZGUobm9kZSk7XG4gIHZhciBub2RlUm9vdEhvc3QgPSAoX25vZGVSb290ID0gbm9kZVJvb3QpID09PSBudWxsIHx8IF9ub2RlUm9vdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX25vZGVSb290Lmhvc3Q7XG5cbiAgLy8gaW4gc29tZSBjYXNlcywgYSBkZXRhY2hlZCBub2RlIHdpbGwgcmV0dXJuIGl0c2VsZiBhcyB0aGUgcm9vdCBpbnN0ZWFkIG9mIGEgZG9jdW1lbnQgb3JcbiAgLy8gIHNoYWRvdyByb290IG9iamVjdCwgaW4gd2hpY2ggY2FzZSwgd2Ugc2hvdWxkbid0IHRyeSB0byBsb29rIGZ1cnRoZXIgdXAgdGhlIGhvc3QgY2hhaW5cbiAgdmFyIGF0dGFjaGVkID0gZmFsc2U7XG4gIGlmIChub2RlUm9vdCAmJiBub2RlUm9vdCAhPT0gbm9kZSkge1xuICAgIHZhciBfbm9kZVJvb3RIb3N0LCBfbm9kZVJvb3RIb3N0JG93bmVyRG8sIF9ub2RlJG93bmVyRG9jdW1lbnQ7XG4gICAgYXR0YWNoZWQgPSAhISgoX25vZGVSb290SG9zdCA9IG5vZGVSb290SG9zdCkgIT09IG51bGwgJiYgX25vZGVSb290SG9zdCAhPT0gdm9pZCAwICYmIChfbm9kZVJvb3RIb3N0JG93bmVyRG8gPSBfbm9kZVJvb3RIb3N0Lm93bmVyRG9jdW1lbnQpICE9PSBudWxsICYmIF9ub2RlUm9vdEhvc3Qkb3duZXJEbyAhPT0gdm9pZCAwICYmIF9ub2RlUm9vdEhvc3Qkb3duZXJEby5jb250YWlucyhub2RlUm9vdEhvc3QpIHx8IG5vZGUgIT09IG51bGwgJiYgbm9kZSAhPT0gdm9pZCAwICYmIChfbm9kZSRvd25lckRvY3VtZW50ID0gbm9kZS5vd25lckRvY3VtZW50KSAhPT0gbnVsbCAmJiBfbm9kZSRvd25lckRvY3VtZW50ICE9PSB2b2lkIDAgJiYgX25vZGUkb3duZXJEb2N1bWVudC5jb250YWlucyhub2RlKSk7XG4gICAgd2hpbGUgKCFhdHRhY2hlZCAmJiBub2RlUm9vdEhvc3QpIHtcbiAgICAgIHZhciBfbm9kZVJvb3QyLCBfbm9kZVJvb3RIb3N0MiwgX25vZGVSb290SG9zdDIkb3duZXJEO1xuICAgICAgLy8gc2luY2UgaXQncyBub3QgYXR0YWNoZWQgYW5kIHdlIGhhdmUgYSByb290IGhvc3QsIHRoZSBub2RlIE1VU1QgYmUgaW4gYSBuZXN0ZWQgc2hhZG93IERPTSxcbiAgICAgIC8vICB3aGljaCBtZWFucyB3ZSBuZWVkIHRvIGdldCB0aGUgaG9zdCdzIGhvc3QgYW5kIGNoZWNrIGlmIHRoYXQgcGFyZW50IGhvc3QgaXMgY29udGFpbmVkXG4gICAgICAvLyAgaW4gKGkuZS4gYXR0YWNoZWQgdG8pIHRoZSBkb2N1bWVudFxuICAgICAgbm9kZVJvb3QgPSBnZXRSb290Tm9kZShub2RlUm9vdEhvc3QpO1xuICAgICAgbm9kZVJvb3RIb3N0ID0gKF9ub2RlUm9vdDIgPSBub2RlUm9vdCkgPT09IG51bGwgfHwgX25vZGVSb290MiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX25vZGVSb290Mi5ob3N0O1xuICAgICAgYXR0YWNoZWQgPSAhISgoX25vZGVSb290SG9zdDIgPSBub2RlUm9vdEhvc3QpICE9PSBudWxsICYmIF9ub2RlUm9vdEhvc3QyICE9PSB2b2lkIDAgJiYgKF9ub2RlUm9vdEhvc3QyJG93bmVyRCA9IF9ub2RlUm9vdEhvc3QyLm93bmVyRG9jdW1lbnQpICE9PSBudWxsICYmIF9ub2RlUm9vdEhvc3QyJG93bmVyRCAhPT0gdm9pZCAwICYmIF9ub2RlUm9vdEhvc3QyJG93bmVyRC5jb250YWlucyhub2RlUm9vdEhvc3QpKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGF0dGFjaGVkO1xufTtcbnZhciBpc1plcm9BcmVhID0gZnVuY3Rpb24gaXNaZXJvQXJlYShub2RlKSB7XG4gIHZhciBfbm9kZSRnZXRCb3VuZGluZ0NsaWUgPSBub2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLFxuICAgIHdpZHRoID0gX25vZGUkZ2V0Qm91bmRpbmdDbGllLndpZHRoLFxuICAgIGhlaWdodCA9IF9ub2RlJGdldEJvdW5kaW5nQ2xpZS5oZWlnaHQ7XG4gIHJldHVybiB3aWR0aCA9PT0gMCAmJiBoZWlnaHQgPT09IDA7XG59O1xudmFyIGlzSGlkZGVuID0gZnVuY3Rpb24gaXNIaWRkZW4obm9kZSwgX3JlZikge1xuICB2YXIgZGlzcGxheUNoZWNrID0gX3JlZi5kaXNwbGF5Q2hlY2ssXG4gICAgZ2V0U2hhZG93Um9vdCA9IF9yZWYuZ2V0U2hhZG93Um9vdDtcbiAgLy8gTk9URTogdmlzaWJpbGl0eSB3aWxsIGJlIGB1bmRlZmluZWRgIGlmIG5vZGUgaXMgZGV0YWNoZWQgZnJvbSB0aGUgZG9jdW1lbnRcbiAgLy8gIChzZWUgbm90ZXMgYWJvdXQgdGhpcyBmdXJ0aGVyIGRvd24pLCB3aGljaCBtZWFucyB3ZSB3aWxsIGNvbnNpZGVyIGl0IHZpc2libGVcbiAgLy8gICh0aGlzIGlzIGxlZ2FjeSBiZWhhdmlvciBmcm9tIGEgdmVyeSBsb25nIHdheSBiYWNrKVxuICAvLyBOT1RFOiB3ZSBjaGVjayB0aGlzIHJlZ2FyZGxlc3Mgb2YgYGRpc3BsYXlDaGVjaz1cIm5vbmVcImAgYmVjYXVzZSB0aGlzIGlzIGFcbiAgLy8gIF92aXNpYmlsaXR5XyBjaGVjaywgbm90IGEgX2Rpc3BsYXlfIGNoZWNrXG4gIGlmIChnZXRDb21wdXRlZFN0eWxlKG5vZGUpLnZpc2liaWxpdHkgPT09ICdoaWRkZW4nKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgdmFyIGlzRGlyZWN0U3VtbWFyeSA9IG1hdGNoZXMuY2FsbChub2RlLCAnZGV0YWlscz5zdW1tYXJ5OmZpcnN0LW9mLXR5cGUnKTtcbiAgdmFyIG5vZGVVbmRlckRldGFpbHMgPSBpc0RpcmVjdFN1bW1hcnkgPyBub2RlLnBhcmVudEVsZW1lbnQgOiBub2RlO1xuICBpZiAobWF0Y2hlcy5jYWxsKG5vZGVVbmRlckRldGFpbHMsICdkZXRhaWxzOm5vdChbb3Blbl0pIConKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmICghZGlzcGxheUNoZWNrIHx8IGRpc3BsYXlDaGVjayA9PT0gJ2Z1bGwnIHx8IGRpc3BsYXlDaGVjayA9PT0gJ2xlZ2FjeS1mdWxsJykge1xuICAgIGlmICh0eXBlb2YgZ2V0U2hhZG93Um9vdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgLy8gZmlndXJlIG91dCBpZiB3ZSBzaG91bGQgY29uc2lkZXIgdGhlIG5vZGUgdG8gYmUgaW4gYW4gdW5kaXNjbG9zZWQgc2hhZG93IGFuZCB1c2UgdGhlXG4gICAgICAvLyAgJ25vbi16ZXJvLWFyZWEnIGZhbGxiYWNrXG4gICAgICB2YXIgb3JpZ2luYWxOb2RlID0gbm9kZTtcbiAgICAgIHdoaWxlIChub2RlKSB7XG4gICAgICAgIHZhciBwYXJlbnRFbGVtZW50ID0gbm9kZS5wYXJlbnRFbGVtZW50O1xuICAgICAgICB2YXIgcm9vdE5vZGUgPSBnZXRSb290Tm9kZShub2RlKTtcbiAgICAgICAgaWYgKHBhcmVudEVsZW1lbnQgJiYgIXBhcmVudEVsZW1lbnQuc2hhZG93Um9vdCAmJiBnZXRTaGFkb3dSb290KHBhcmVudEVsZW1lbnQpID09PSB0cnVlIC8vIGNoZWNrIGlmIHRoZXJlJ3MgYW4gdW5kaXNjbG9zZWQgc2hhZG93XG4gICAgICAgICkge1xuICAgICAgICAgIC8vIG5vZGUgaGFzIGFuIHVuZGlzY2xvc2VkIHNoYWRvdyB3aGljaCBtZWFucyB3ZSBjYW4gb25seSB0cmVhdCBpdCBhcyBhIGJsYWNrIGJveCwgc28gd2VcbiAgICAgICAgICAvLyAgZmFsbCBiYWNrIHRvIGEgbm9uLXplcm8tYXJlYSB0ZXN0XG4gICAgICAgICAgcmV0dXJuIGlzWmVyb0FyZWEobm9kZSk7XG4gICAgICAgIH0gZWxzZSBpZiAobm9kZS5hc3NpZ25lZFNsb3QpIHtcbiAgICAgICAgICAvLyBpdGVyYXRlIHVwIHNsb3RcbiAgICAgICAgICBub2RlID0gbm9kZS5hc3NpZ25lZFNsb3Q7XG4gICAgICAgIH0gZWxzZSBpZiAoIXBhcmVudEVsZW1lbnQgJiYgcm9vdE5vZGUgIT09IG5vZGUub3duZXJEb2N1bWVudCkge1xuICAgICAgICAgIC8vIGNyb3NzIHNoYWRvdyBib3VuZGFyeVxuICAgICAgICAgIG5vZGUgPSByb290Tm9kZS5ob3N0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGl0ZXJhdGUgdXAgbm9ybWFsIGRvbVxuICAgICAgICAgIG5vZGUgPSBwYXJlbnRFbGVtZW50O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBub2RlID0gb3JpZ2luYWxOb2RlO1xuICAgIH1cbiAgICAvLyBlbHNlLCBgZ2V0U2hhZG93Um9vdGAgbWlnaHQgYmUgdHJ1ZSwgYnV0IGFsbCB0aGF0IGRvZXMgaXMgZW5hYmxlIHNoYWRvdyBET00gc3VwcG9ydFxuICAgIC8vICAoaS5lLiBpdCBkb2VzIG5vdCBhbHNvIHByZXN1bWUgdGhhdCBhbGwgbm9kZXMgbWlnaHQgaGF2ZSB1bmRpc2Nsb3NlZCBzaGFkb3dzKTsgb3JcbiAgICAvLyAgaXQgbWlnaHQgYmUgYSBmYWxzeSB2YWx1ZSwgd2hpY2ggbWVhbnMgc2hhZG93IERPTSBzdXBwb3J0IGlzIGRpc2FibGVkXG5cbiAgICAvLyBTaW5jZSB3ZSBkaWRuJ3QgZmluZCBpdCBzaXR0aW5nIGluIGFuIHVuZGlzY2xvc2VkIHNoYWRvdyAob3Igc2hhZG93cyBhcmUgZGlzYWJsZWQpXG4gICAgLy8gIG5vdyB3ZSBjYW4ganVzdCB0ZXN0IHRvIHNlZSBpZiBpdCB3b3VsZCBub3JtYWxseSBiZSB2aXNpYmxlIG9yIG5vdCwgcHJvdmlkZWQgaXQnc1xuICAgIC8vICBhdHRhY2hlZCB0byB0aGUgbWFpbiBkb2N1bWVudC5cbiAgICAvLyBOT1RFOiBXZSBtdXN0IGNvbnNpZGVyIGNhc2Ugd2hlcmUgbm9kZSBpcyBpbnNpZGUgYSBzaGFkb3cgRE9NIGFuZCBnaXZlbiBkaXJlY3RseSB0b1xuICAgIC8vICBgaXNUYWJiYWJsZSgpYCBvciBgaXNGb2N1c2FibGUoKWAgLS0gcmVnYXJkbGVzcyBvZiBgZ2V0U2hhZG93Um9vdGAgb3B0aW9uIHNldHRpbmcuXG5cbiAgICBpZiAoaXNOb2RlQXR0YWNoZWQobm9kZSkpIHtcbiAgICAgIC8vIHRoaXMgd29ya3Mgd2hlcmV2ZXIgdGhlIG5vZGUgaXM6IGlmIHRoZXJlJ3MgYXQgbGVhc3Qgb25lIGNsaWVudCByZWN0LCBpdCdzXG4gICAgICAvLyAgc29tZWhvdyBkaXNwbGF5ZWQ7IGl0IGFsc28gY292ZXJzIHRoZSBDU1MgJ2Rpc3BsYXk6IGNvbnRlbnRzJyBjYXNlIHdoZXJlIHRoZVxuICAgICAgLy8gIG5vZGUgaXRzZWxmIGlzIGhpZGRlbiBpbiBwbGFjZSBvZiBpdHMgY29udGVudHM7IGFuZCB0aGVyZSdzIG5vIG5lZWQgdG8gc2VhcmNoXG4gICAgICAvLyAgdXAgdGhlIGhpZXJhcmNoeSBlaXRoZXJcbiAgICAgIHJldHVybiAhbm9kZS5nZXRDbGllbnRSZWN0cygpLmxlbmd0aDtcbiAgICB9XG5cbiAgICAvLyBFbHNlLCB0aGUgbm9kZSBpc24ndCBhdHRhY2hlZCB0byB0aGUgZG9jdW1lbnQsIHdoaWNoIG1lYW5zIHRoZSBgZ2V0Q2xpZW50UmVjdHMoKWBcbiAgICAvLyAgQVBJIHdpbGwgX19hbHdheXNfXyByZXR1cm4gemVybyByZWN0cyAodGhpcyBjYW4gaGFwcGVuLCBmb3IgZXhhbXBsZSwgaWYgUmVhY3RcbiAgICAvLyAgaXMgdXNlZCB0byByZW5kZXIgbm9kZXMgb250byBhIGRldGFjaGVkIHRyZWUsIGFzIGNvbmZpcm1lZCBpbiB0aGlzIHRocmVhZDpcbiAgICAvLyAgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy85MTE3I2lzc3VlY29tbWVudC0yODQyMjg4NzApXG4gICAgLy9cbiAgICAvLyBJdCBhbHNvIG1lYW5zIHRoYXQgZXZlbiB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShub2RlKS5kaXNwbGF5IHdpbGwgcmV0dXJuIGB1bmRlZmluZWRgXG4gICAgLy8gIGJlY2F1c2Ugc3R5bGVzIGFyZSBvbmx5IGNvbXB1dGVkIGZvciBub2RlcyB0aGF0IGFyZSBpbiB0aGUgZG9jdW1lbnQuXG4gICAgLy9cbiAgICAvLyBOT1RFOiBUSElTIEhBUyBCRUVOIFRIRSBDQVNFIEZPUiBZRUFSUy4gSXQgaXMgbm90IG5ldywgbm9yIGlzIGl0IGNhdXNlZCBieSB0YWJiYWJsZVxuICAgIC8vICBzb21laG93LiBUaG91Z2ggaXQgd2FzIG5ldmVyIHN0YXRlZCBvZmZpY2lhbGx5LCBhbnlvbmUgd2hvIGhhcyBldmVyIHVzZWQgdGFiYmFibGVcbiAgICAvLyAgQVBJcyBvbiBub2RlcyBpbiBkZXRhY2hlZCBjb250YWluZXJzIGhhcyBhY3R1YWxseSBpbXBsaWNpdGx5IHVzZWQgdGFiYmFibGUgaW4gd2hhdFxuICAgIC8vICB3YXMgbGF0ZXIgKGFzIG9mIHY1LjIuMCBvbiBBcHIgOSwgMjAyMSkgY2FsbGVkIGBkaXNwbGF5Q2hlY2s9XCJub25lXCJgIG1vZGUgLS0gZXNzZW50aWFsbHlcbiAgICAvLyAgY29uc2lkZXJpbmcgX19ldmVyeXRoaW5nX18gdG8gYmUgdmlzaWJsZSBiZWNhdXNlIG9mIHRoZSBpbm5hYmlsaXR5IHRvIGRldGVybWluZSBzdHlsZXMuXG4gICAgLy9cbiAgICAvLyB2Ni4wLjA6IEFzIG9mIHRoaXMgbWFqb3IgcmVsZWFzZSwgdGhlIGRlZmF1bHQgJ2Z1bGwnIG9wdGlvbiBfX25vIGxvbmdlciB0cmVhdHMgZGV0YWNoZWRcbiAgICAvLyAgbm9kZXMgYXMgdmlzaWJsZSB3aXRoIHRoZSAnbm9uZScgZmFsbGJhY2suX19cbiAgICBpZiAoZGlzcGxheUNoZWNrICE9PSAnbGVnYWN5LWZ1bGwnKSB7XG4gICAgICByZXR1cm4gdHJ1ZTsgLy8gaGlkZGVuXG4gICAgfVxuICAgIC8vIGVsc2UsIGZhbGxiYWNrIHRvICdub25lJyBtb2RlIGFuZCBjb25zaWRlciB0aGUgbm9kZSB2aXNpYmxlXG4gIH0gZWxzZSBpZiAoZGlzcGxheUNoZWNrID09PSAnbm9uLXplcm8tYXJlYScpIHtcbiAgICAvLyBOT1RFOiBFdmVuIHRob3VnaCB0aGlzIHRlc3RzIHRoYXQgdGhlIG5vZGUncyBjbGllbnQgcmVjdCBpcyBub24temVybyB0byBkZXRlcm1pbmVcbiAgICAvLyAgd2hldGhlciBpdCdzIGRpc3BsYXllZCwgYW5kIHRoYXQgYSBkZXRhY2hlZCBub2RlIHdpbGwgX19hbHdheXNfXyBoYXZlIGEgemVyby1hcmVhXG4gICAgLy8gIGNsaWVudCByZWN0LCB3ZSBkb24ndCBzcGVjaWFsLWNhc2UgZm9yIHdoZXRoZXIgdGhlIG5vZGUgaXMgYXR0YWNoZWQgb3Igbm90LiBJblxuICAgIC8vICB0aGlzIG1vZGUsIHdlIGRvIHdhbnQgdG8gY29uc2lkZXIgbm9kZXMgdGhhdCBoYXZlIGEgemVybyBhcmVhIHRvIGJlIGhpZGRlbiBhdCBhbGxcbiAgICAvLyAgdGltZXMsIGFuZCB0aGF0IGluY2x1ZGVzIGF0dGFjaGVkIG9yIG5vdC5cbiAgICByZXR1cm4gaXNaZXJvQXJlYShub2RlKTtcbiAgfVxuXG4gIC8vIHZpc2libGUsIGFzIGZhciBhcyB3ZSBjYW4gdGVsbCwgb3IgcGVyIGN1cnJlbnQgYGRpc3BsYXlDaGVjaz1ub25lYCBtb2RlLCB3ZSBhc3N1bWVcbiAgLy8gIGl0J3MgdmlzaWJsZVxuICByZXR1cm4gZmFsc2U7XG59O1xuXG4vLyBmb3JtIGZpZWxkcyAobmVzdGVkKSBpbnNpZGUgYSBkaXNhYmxlZCBmaWVsZHNldCBhcmUgbm90IGZvY3VzYWJsZS90YWJiYWJsZVxuLy8gIHVubGVzcyB0aGV5IGFyZSBpbiB0aGUgX2ZpcnN0XyA8bGVnZW5kPiBlbGVtZW50IG9mIHRoZSB0b3AtbW9zdCBkaXNhYmxlZFxuLy8gIGZpZWxkc2V0XG52YXIgaXNEaXNhYmxlZEZyb21GaWVsZHNldCA9IGZ1bmN0aW9uIGlzRGlzYWJsZWRGcm9tRmllbGRzZXQobm9kZSkge1xuICBpZiAoL14oSU5QVVR8QlVUVE9OfFNFTEVDVHxURVhUQVJFQSkkLy50ZXN0KG5vZGUudGFnTmFtZSkpIHtcbiAgICB2YXIgcGFyZW50Tm9kZSA9IG5vZGUucGFyZW50RWxlbWVudDtcbiAgICAvLyBjaGVjayBpZiBgbm9kZWAgaXMgY29udGFpbmVkIGluIGEgZGlzYWJsZWQgPGZpZWxkc2V0PlxuICAgIHdoaWxlIChwYXJlbnROb2RlKSB7XG4gICAgICBpZiAocGFyZW50Tm9kZS50YWdOYW1lID09PSAnRklFTERTRVQnICYmIHBhcmVudE5vZGUuZGlzYWJsZWQpIHtcbiAgICAgICAgLy8gbG9vayBmb3IgdGhlIGZpcnN0IDxsZWdlbmQ+IGFtb25nIHRoZSBjaGlsZHJlbiBvZiB0aGUgZGlzYWJsZWQgPGZpZWxkc2V0PlxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhcmVudE5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgY2hpbGQgPSBwYXJlbnROb2RlLmNoaWxkcmVuLml0ZW0oaSk7XG4gICAgICAgICAgLy8gd2hlbiB0aGUgZmlyc3QgPGxlZ2VuZD4gKGluIGRvY3VtZW50IG9yZGVyKSBpcyBmb3VuZFxuICAgICAgICAgIGlmIChjaGlsZC50YWdOYW1lID09PSAnTEVHRU5EJykge1xuICAgICAgICAgICAgLy8gaWYgaXRzIHBhcmVudCA8ZmllbGRzZXQ+IGlzIG5vdCBuZXN0ZWQgaW4gYW5vdGhlciBkaXNhYmxlZCA8ZmllbGRzZXQ+LFxuICAgICAgICAgICAgLy8gcmV0dXJuIHdoZXRoZXIgYG5vZGVgIGlzIGEgZGVzY2VuZGFudCBvZiBpdHMgZmlyc3QgPGxlZ2VuZD5cbiAgICAgICAgICAgIHJldHVybiBtYXRjaGVzLmNhbGwocGFyZW50Tm9kZSwgJ2ZpZWxkc2V0W2Rpc2FibGVkXSAqJykgPyB0cnVlIDogIWNoaWxkLmNvbnRhaW5zKG5vZGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyB0aGUgZGlzYWJsZWQgPGZpZWxkc2V0PiBjb250YWluaW5nIGBub2RlYCBoYXMgbm8gPGxlZ2VuZD5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBwYXJlbnROb2RlID0gcGFyZW50Tm9kZS5wYXJlbnRFbGVtZW50O1xuICAgIH1cbiAgfVxuXG4gIC8vIGVsc2UsIG5vZGUncyB0YWJiYWJsZS9mb2N1c2FibGUgc3RhdGUgc2hvdWxkIG5vdCBiZSBhZmZlY3RlZCBieSBhIGZpZWxkc2V0J3NcbiAgLy8gIGVuYWJsZWQvZGlzYWJsZWQgc3RhdGVcbiAgcmV0dXJuIGZhbHNlO1xufTtcbnZhciBpc05vZGVNYXRjaGluZ1NlbGVjdG9yRm9jdXNhYmxlID0gZnVuY3Rpb24gaXNOb2RlTWF0Y2hpbmdTZWxlY3RvckZvY3VzYWJsZShvcHRpb25zLCBub2RlKSB7XG4gIGlmIChub2RlLmRpc2FibGVkIHx8XG4gIC8vIHdlIG11c3QgZG8gYW4gaW5lcnQgbG9vayB1cCB0byBmaWx0ZXIgb3V0IGFueSBlbGVtZW50cyBpbnNpZGUgYW4gaW5lcnQgYW5jZXN0b3JcbiAgLy8gIGJlY2F1c2Ugd2UncmUgbGltaXRlZCBpbiB0aGUgdHlwZSBvZiBzZWxlY3RvcnMgd2UgY2FuIHVzZSBpbiBKU0RvbSAoc2VlIHJlbGF0ZWRcbiAgLy8gIG5vdGUgcmVsYXRlZCB0byBgY2FuZGlkYXRlU2VsZWN0b3JzYClcbiAgaXNJbmVydChub2RlKSB8fCBpc0hpZGRlbklucHV0KG5vZGUpIHx8IGlzSGlkZGVuKG5vZGUsIG9wdGlvbnMpIHx8XG4gIC8vIEZvciBhIGRldGFpbHMgZWxlbWVudCB3aXRoIGEgc3VtbWFyeSwgdGhlIHN1bW1hcnkgZWxlbWVudCBnZXRzIHRoZSBmb2N1c1xuICBpc0RldGFpbHNXaXRoU3VtbWFyeShub2RlKSB8fCBpc0Rpc2FibGVkRnJvbUZpZWxkc2V0KG5vZGUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufTtcbnZhciBpc05vZGVNYXRjaGluZ1NlbGVjdG9yVGFiYmFibGUgPSBmdW5jdGlvbiBpc05vZGVNYXRjaGluZ1NlbGVjdG9yVGFiYmFibGUob3B0aW9ucywgbm9kZSkge1xuICBpZiAoaXNOb25UYWJiYWJsZVJhZGlvKG5vZGUpIHx8IGdldFRhYkluZGV4KG5vZGUpIDwgMCB8fCAhaXNOb2RlTWF0Y2hpbmdTZWxlY3RvckZvY3VzYWJsZShvcHRpb25zLCBub2RlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn07XG52YXIgaXNWYWxpZFNoYWRvd1Jvb3RUYWJiYWJsZSA9IGZ1bmN0aW9uIGlzVmFsaWRTaGFkb3dSb290VGFiYmFibGUoc2hhZG93SG9zdE5vZGUpIHtcbiAgdmFyIHRhYkluZGV4ID0gcGFyc2VJbnQoc2hhZG93SG9zdE5vZGUuZ2V0QXR0cmlidXRlKCd0YWJpbmRleCcpLCAxMCk7XG4gIGlmIChpc05hTih0YWJJbmRleCkgfHwgdGFiSW5kZXggPj0gMCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIC8vIElmIGEgY3VzdG9tIGVsZW1lbnQgaGFzIGFuIGV4cGxpY2l0IG5lZ2F0aXZlIHRhYmluZGV4LFxuICAvLyBicm93c2VycyB3aWxsIG5vdCBhbGxvdyB0YWIgdGFyZ2V0aW5nIHNhaWQgZWxlbWVudCdzIGNoaWxkcmVuLlxuICByZXR1cm4gZmFsc2U7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXkuPEVsZW1lbnR8Q2FuZGlkYXRlU2NvcGU+fSBjYW5kaWRhdGVzXG4gKiBAcmV0dXJucyBFbGVtZW50W11cbiAqL1xudmFyIHNvcnRCeU9yZGVyID0gZnVuY3Rpb24gc29ydEJ5T3JkZXIoY2FuZGlkYXRlcykge1xuICB2YXIgcmVndWxhclRhYmJhYmxlcyA9IFtdO1xuICB2YXIgb3JkZXJlZFRhYmJhYmxlcyA9IFtdO1xuICBjYW5kaWRhdGVzLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0sIGkpIHtcbiAgICB2YXIgaXNTY29wZSA9ICEhaXRlbS5zY29wZVBhcmVudDtcbiAgICB2YXIgZWxlbWVudCA9IGlzU2NvcGUgPyBpdGVtLnNjb3BlUGFyZW50IDogaXRlbTtcbiAgICB2YXIgY2FuZGlkYXRlVGFiaW5kZXggPSBnZXRTb3J0T3JkZXJUYWJJbmRleChlbGVtZW50LCBpc1Njb3BlKTtcbiAgICB2YXIgZWxlbWVudHMgPSBpc1Njb3BlID8gc29ydEJ5T3JkZXIoaXRlbS5jYW5kaWRhdGVzKSA6IGVsZW1lbnQ7XG4gICAgaWYgKGNhbmRpZGF0ZVRhYmluZGV4ID09PSAwKSB7XG4gICAgICBpc1Njb3BlID8gcmVndWxhclRhYmJhYmxlcy5wdXNoLmFwcGx5KHJlZ3VsYXJUYWJiYWJsZXMsIGVsZW1lbnRzKSA6IHJlZ3VsYXJUYWJiYWJsZXMucHVzaChlbGVtZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3JkZXJlZFRhYmJhYmxlcy5wdXNoKHtcbiAgICAgICAgZG9jdW1lbnRPcmRlcjogaSxcbiAgICAgICAgdGFiSW5kZXg6IGNhbmRpZGF0ZVRhYmluZGV4LFxuICAgICAgICBpdGVtOiBpdGVtLFxuICAgICAgICBpc1Njb3BlOiBpc1Njb3BlLFxuICAgICAgICBjb250ZW50OiBlbGVtZW50c1xuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIG9yZGVyZWRUYWJiYWJsZXMuc29ydChzb3J0T3JkZXJlZFRhYmJhYmxlcykucmVkdWNlKGZ1bmN0aW9uIChhY2MsIHNvcnRhYmxlKSB7XG4gICAgc29ydGFibGUuaXNTY29wZSA/IGFjYy5wdXNoLmFwcGx5KGFjYywgc29ydGFibGUuY29udGVudCkgOiBhY2MucHVzaChzb3J0YWJsZS5jb250ZW50KTtcbiAgICByZXR1cm4gYWNjO1xuICB9LCBbXSkuY29uY2F0KHJlZ3VsYXJUYWJiYWJsZXMpO1xufTtcbnZhciB0YWJiYWJsZSA9IGZ1bmN0aW9uIHRhYmJhYmxlKGNvbnRhaW5lciwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgdmFyIGNhbmRpZGF0ZXM7XG4gIGlmIChvcHRpb25zLmdldFNoYWRvd1Jvb3QpIHtcbiAgICBjYW5kaWRhdGVzID0gZ2V0Q2FuZGlkYXRlc0l0ZXJhdGl2ZWx5KFtjb250YWluZXJdLCBvcHRpb25zLmluY2x1ZGVDb250YWluZXIsIHtcbiAgICAgIGZpbHRlcjogaXNOb2RlTWF0Y2hpbmdTZWxlY3RvclRhYmJhYmxlLmJpbmQobnVsbCwgb3B0aW9ucyksXG4gICAgICBmbGF0dGVuOiBmYWxzZSxcbiAgICAgIGdldFNoYWRvd1Jvb3Q6IG9wdGlvbnMuZ2V0U2hhZG93Um9vdCxcbiAgICAgIHNoYWRvd1Jvb3RGaWx0ZXI6IGlzVmFsaWRTaGFkb3dSb290VGFiYmFibGVcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBjYW5kaWRhdGVzID0gZ2V0Q2FuZGlkYXRlcyhjb250YWluZXIsIG9wdGlvbnMuaW5jbHVkZUNvbnRhaW5lciwgaXNOb2RlTWF0Y2hpbmdTZWxlY3RvclRhYmJhYmxlLmJpbmQobnVsbCwgb3B0aW9ucykpO1xuICB9XG4gIHJldHVybiBzb3J0QnlPcmRlcihjYW5kaWRhdGVzKTtcbn07XG52YXIgZm9jdXNhYmxlID0gZnVuY3Rpb24gZm9jdXNhYmxlKGNvbnRhaW5lciwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgdmFyIGNhbmRpZGF0ZXM7XG4gIGlmIChvcHRpb25zLmdldFNoYWRvd1Jvb3QpIHtcbiAgICBjYW5kaWRhdGVzID0gZ2V0Q2FuZGlkYXRlc0l0ZXJhdGl2ZWx5KFtjb250YWluZXJdLCBvcHRpb25zLmluY2x1ZGVDb250YWluZXIsIHtcbiAgICAgIGZpbHRlcjogaXNOb2RlTWF0Y2hpbmdTZWxlY3RvckZvY3VzYWJsZS5iaW5kKG51bGwsIG9wdGlvbnMpLFxuICAgICAgZmxhdHRlbjogdHJ1ZSxcbiAgICAgIGdldFNoYWRvd1Jvb3Q6IG9wdGlvbnMuZ2V0U2hhZG93Um9vdFxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGNhbmRpZGF0ZXMgPSBnZXRDYW5kaWRhdGVzKGNvbnRhaW5lciwgb3B0aW9ucy5pbmNsdWRlQ29udGFpbmVyLCBpc05vZGVNYXRjaGluZ1NlbGVjdG9yRm9jdXNhYmxlLmJpbmQobnVsbCwgb3B0aW9ucykpO1xuICB9XG4gIHJldHVybiBjYW5kaWRhdGVzO1xufTtcbnZhciBpc1RhYmJhYmxlID0gZnVuY3Rpb24gaXNUYWJiYWJsZShub2RlLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBpZiAoIW5vZGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIG5vZGUgcHJvdmlkZWQnKTtcbiAgfVxuICBpZiAobWF0Y2hlcy5jYWxsKG5vZGUsIGNhbmRpZGF0ZVNlbGVjdG9yKSA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIGlzTm9kZU1hdGNoaW5nU2VsZWN0b3JUYWJiYWJsZShvcHRpb25zLCBub2RlKTtcbn07XG52YXIgZm9jdXNhYmxlQ2FuZGlkYXRlU2VsZWN0b3IgPSAvKiAjX19QVVJFX18gKi9jYW5kaWRhdGVTZWxlY3RvcnMuY29uY2F0KCdpZnJhbWUnKS5qb2luKCcsJyk7XG52YXIgaXNGb2N1c2FibGUgPSBmdW5jdGlvbiBpc0ZvY3VzYWJsZShub2RlLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBpZiAoIW5vZGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIG5vZGUgcHJvdmlkZWQnKTtcbiAgfVxuICBpZiAobWF0Y2hlcy5jYWxsKG5vZGUsIGZvY3VzYWJsZUNhbmRpZGF0ZVNlbGVjdG9yKSA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIGlzTm9kZU1hdGNoaW5nU2VsZWN0b3JGb2N1c2FibGUob3B0aW9ucywgbm9kZSk7XG59O1xuXG5leHBvcnQgeyBmb2N1c2FibGUsIGdldFRhYkluZGV4LCBpc0ZvY3VzYWJsZSwgaXNUYWJiYWJsZSwgdGFiYmFibGUgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmVzbS5qcy5tYXBcbiJdLCJuYW1lcyI6WyJjYW5kaWRhdGVTZWxlY3RvcnMiLCJjYW5kaWRhdGVTZWxlY3RvciIsImpvaW4iLCJOb0VsZW1lbnQiLCJFbGVtZW50IiwibWF0Y2hlcyIsInByb3RvdHlwZSIsIm1zTWF0Y2hlc1NlbGVjdG9yIiwid2Via2l0TWF0Y2hlc1NlbGVjdG9yIiwiZ2V0Um9vdE5vZGUiLCJlbGVtZW50IiwiX2VsZW1lbnQkZ2V0Um9vdE5vZGUiLCJjYWxsIiwib3duZXJEb2N1bWVudCIsImlzSW5lcnQiLCJub2RlIiwibG9va1VwIiwiX25vZGUkZ2V0QXR0cmlidXRlIiwiaW5lcnRBdHQiLCJnZXRBdHRyaWJ1dGUiLCJpbmVydCIsInJlc3VsdCIsInBhcmVudE5vZGUiLCJpc0NvbnRlbnRFZGl0YWJsZSIsIl9ub2RlJGdldEF0dHJpYnV0ZTIiLCJhdHRWYWx1ZSIsImdldENhbmRpZGF0ZXMiLCJlbCIsImluY2x1ZGVDb250YWluZXIiLCJmaWx0ZXIiLCJjYW5kaWRhdGVzIiwiQXJyYXkiLCJzbGljZSIsImFwcGx5IiwicXVlcnlTZWxlY3RvckFsbCIsInVuc2hpZnQiLCJnZXRDYW5kaWRhdGVzSXRlcmF0aXZlbHkiLCJlbGVtZW50cyIsIm9wdGlvbnMiLCJlbGVtZW50c1RvQ2hlY2siLCJmcm9tIiwibGVuZ3RoIiwic2hpZnQiLCJ0YWdOYW1lIiwiYXNzaWduZWQiLCJhc3NpZ25lZEVsZW1lbnRzIiwiY29udGVudCIsImNoaWxkcmVuIiwibmVzdGVkQ2FuZGlkYXRlcyIsImZsYXR0ZW4iLCJwdXNoIiwic2NvcGVQYXJlbnQiLCJ2YWxpZENhbmRpZGF0ZSIsImluY2x1ZGVzIiwic2hhZG93Um9vdCIsImdldFNoYWRvd1Jvb3QiLCJ2YWxpZFNoYWRvd1Jvb3QiLCJzaGFkb3dSb290RmlsdGVyIiwiX25lc3RlZENhbmRpZGF0ZXMiLCJoYXNUYWJJbmRleCIsImlzTmFOIiwicGFyc2VJbnQiLCJnZXRUYWJJbmRleCIsIkVycm9yIiwidGFiSW5kZXgiLCJ0ZXN0IiwiZ2V0U29ydE9yZGVyVGFiSW5kZXgiLCJpc1Njb3BlIiwic29ydE9yZGVyZWRUYWJiYWJsZXMiLCJhIiwiYiIsImRvY3VtZW50T3JkZXIiLCJpc0lucHV0IiwiaXNIaWRkZW5JbnB1dCIsInR5cGUiLCJpc0RldGFpbHNXaXRoU3VtbWFyeSIsInIiLCJzb21lIiwiY2hpbGQiLCJnZXRDaGVja2VkUmFkaW8iLCJub2RlcyIsImZvcm0iLCJpIiwiY2hlY2tlZCIsImlzVGFiYmFibGVSYWRpbyIsIm5hbWUiLCJyYWRpb1Njb3BlIiwicXVlcnlSYWRpb3MiLCJyYWRpb1NldCIsIndpbmRvdyIsIkNTUyIsImVzY2FwZSIsImVyciIsImNvbnNvbGUiLCJlcnJvciIsIm1lc3NhZ2UiLCJpc1JhZGlvIiwiaXNOb25UYWJiYWJsZVJhZGlvIiwiaXNOb2RlQXR0YWNoZWQiLCJfbm9kZVJvb3QiLCJub2RlUm9vdCIsIm5vZGVSb290SG9zdCIsImhvc3QiLCJhdHRhY2hlZCIsIl9ub2RlUm9vdEhvc3QiLCJfbm9kZVJvb3RIb3N0JG93bmVyRG8iLCJfbm9kZSRvd25lckRvY3VtZW50IiwiY29udGFpbnMiLCJfbm9kZVJvb3QyIiwiX25vZGVSb290SG9zdDIiLCJfbm9kZVJvb3RIb3N0MiRvd25lckQiLCJpc1plcm9BcmVhIiwiX25vZGUkZ2V0Qm91bmRpbmdDbGllIiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0Iiwid2lkdGgiLCJoZWlnaHQiLCJpc0hpZGRlbiIsIl9yZWYiLCJkaXNwbGF5Q2hlY2siLCJnZXRDb21wdXRlZFN0eWxlIiwidmlzaWJpbGl0eSIsImlzRGlyZWN0U3VtbWFyeSIsIm5vZGVVbmRlckRldGFpbHMiLCJwYXJlbnRFbGVtZW50Iiwib3JpZ2luYWxOb2RlIiwicm9vdE5vZGUiLCJhc3NpZ25lZFNsb3QiLCJnZXRDbGllbnRSZWN0cyIsImlzRGlzYWJsZWRGcm9tRmllbGRzZXQiLCJkaXNhYmxlZCIsIml0ZW0iLCJpc05vZGVNYXRjaGluZ1NlbGVjdG9yRm9jdXNhYmxlIiwiaXNOb2RlTWF0Y2hpbmdTZWxlY3RvclRhYmJhYmxlIiwiaXNWYWxpZFNoYWRvd1Jvb3RUYWJiYWJsZSIsInNoYWRvd0hvc3ROb2RlIiwic29ydEJ5T3JkZXIiLCJyZWd1bGFyVGFiYmFibGVzIiwib3JkZXJlZFRhYmJhYmxlcyIsImZvckVhY2giLCJjYW5kaWRhdGVUYWJpbmRleCIsInNvcnQiLCJyZWR1Y2UiLCJhY2MiLCJzb3J0YWJsZSIsImNvbmNhdCIsInRhYmJhYmxlIiwiY29udGFpbmVyIiwiYmluZCIsImZvY3VzYWJsZSIsImlzVGFiYmFibGUiLCJmb2N1c2FibGVDYW5kaWRhdGVTZWxlY3RvciIsImlzRm9jdXNhYmxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../../../node_modules/tabbable/dist/index.esm.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../../../node_modules/use-sync-external-store/cjs/use-sync-external-store-with-selector.development.js":
/*!*****************************************************************************************************************!*\
  !*** ../../../../node_modules/use-sync-external-store/cjs/use-sync-external-store-with-selector.development.js ***!
  \*****************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval(__webpack_require__.ts("/**\n * @license React\n * use-sync-external-store-with-selector.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */ \n true && function() {\n    var _s = $RefreshSig$();\n    function is(x, y) {\n        return x === y && (0 !== x || 1 / x === 1 / y) || x !== x && y !== y;\n    }\n    \"undefined\" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && \"function\" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());\n    var React = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\"), objectIs = \"function\" === typeof Object.is ? Object.is : is, useSyncExternalStore = React.useSyncExternalStore, useRef = React.useRef, useEffect = React.useEffect, useMemo = React.useMemo, useDebugValue = React.useDebugValue;\n    exports.useSyncExternalStoreWithSelector = _s(function(subscribe, getSnapshot, getServerSnapshot, selector, isEqual) {\n        _s();\n        var instRef = useRef(null);\n        if (null === instRef.current) {\n            var inst = {\n                hasValue: !1,\n                value: null\n            };\n            instRef.current = inst;\n        } else inst = instRef.current;\n        instRef = useMemo(function() {\n            function memoizedSelector(nextSnapshot) {\n                if (!hasMemo) {\n                    hasMemo = !0;\n                    memoizedSnapshot = nextSnapshot;\n                    nextSnapshot = selector(nextSnapshot);\n                    if (void 0 !== isEqual && inst.hasValue) {\n                        var currentSelection = inst.value;\n                        if (isEqual(currentSelection, nextSnapshot)) return memoizedSelection = currentSelection;\n                    }\n                    return memoizedSelection = nextSnapshot;\n                }\n                currentSelection = memoizedSelection;\n                if (objectIs(memoizedSnapshot, nextSnapshot)) return currentSelection;\n                var nextSelection = selector(nextSnapshot);\n                if (void 0 !== isEqual && isEqual(currentSelection, nextSelection)) return memoizedSnapshot = nextSnapshot, currentSelection;\n                memoizedSnapshot = nextSnapshot;\n                return memoizedSelection = nextSelection;\n            }\n            var hasMemo = !1, memoizedSnapshot, memoizedSelection, maybeGetServerSnapshot = void 0 === getServerSnapshot ? null : getServerSnapshot;\n            return [\n                function() {\n                    return memoizedSelector(getSnapshot());\n                },\n                null === maybeGetServerSnapshot ? void 0 : function() {\n                    return memoizedSelector(maybeGetServerSnapshot());\n                }\n            ];\n        }, [\n            getSnapshot,\n            getServerSnapshot,\n            selector,\n            isEqual\n        ]);\n        var value = useSyncExternalStore(subscribe, instRef[0], instRef[1]);\n        useEffect(function() {\n            inst.hasValue = !0;\n            inst.value = value;\n        }, [\n            value\n        ]);\n        useDebugValue(value);\n        return value;\n    }, \"56MPPqMubdRYjFvuNhAgiSms4oQ=\", false, function() {\n        return [\n            useSyncExternalStore\n        ];\n    });\n    \"undefined\" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && \"function\" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());\n}();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdXNlLXN5bmMtZXh0ZXJuYWwtc3RvcmUvY2pzL3VzZS1zeW5jLWV4dGVybmFsLXN0b3JlLXdpdGgtc2VsZWN0b3IuZGV2ZWxvcG1lbnQuanMiLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7O0NBUUMsR0FFWTtBQUNiLEtBWEEsSUFZRTs7SUFDRSxTQUFTQSxHQUFHQyxDQUFDLEVBQUVDLENBQUM7UUFDZCxPQUFPLE1BQU9BLEtBQU0sT0FBTUQsS0FBSyxJQUFJQSxNQUFNLElBQUlDLENBQUFBLEtBQVFELE1BQU1BLEtBQUtDLE1BQU1BO0lBQ3hFO0lBQ0EsZ0JBQWdCLE9BQU9DLGtDQUNyQixlQUNFLE9BQU9BLCtCQUErQkMsMkJBQTJCLElBQ25FRCwrQkFBK0JDLDJCQUEyQixDQUFDQztJQUM3RCxJQUFJQyxRQUFRQyxtQkFBT0EsQ0FBQyxtRkFBTyxHQUN6QkMsV0FBVyxlQUFlLE9BQU9DLE9BQU9ULEVBQUUsR0FBR1MsT0FBT1QsRUFBRSxHQUFHQSxJQUN6RFUsdUJBQXVCSixNQUFNSSxvQkFBb0IsRUFDakRDLFNBQVNMLE1BQU1LLE1BQU0sRUFDckJDLFlBQVlOLE1BQU1NLFNBQVMsRUFDM0JDLFVBQVVQLE1BQU1PLE9BQU8sRUFDdkJDLGdCQUFnQlIsTUFBTVEsYUFBYTtJQUNyQ0Msd0NBQXdDLE1BQUcsU0FDekNFLFNBQVMsRUFDVEMsV0FBVyxFQUNYQyxpQkFBaUIsRUFDakJDLFFBQVEsRUFDUkMsT0FBTzs7UUFFUCxJQUFJQyxVQUFVWCxPQUFPO1FBQ3JCLElBQUksU0FBU1csUUFBUUMsT0FBTyxFQUFFO1lBQzVCLElBQUlDLE9BQU87Z0JBQUVDLFVBQVUsQ0FBQztnQkFBR0MsT0FBTztZQUFLO1lBQ3ZDSixRQUFRQyxPQUFPLEdBQUdDO1FBQ3BCLE9BQU9BLE9BQU9GLFFBQVFDLE9BQU87UUFDN0JELFVBQVVULFFBQ1I7WUFDRSxTQUFTYyxpQkFBaUJDLFlBQVk7Z0JBQ3BDLElBQUksQ0FBQ0MsU0FBUztvQkFDWkEsVUFBVSxDQUFDO29CQUNYQyxtQkFBbUJGO29CQUNuQkEsZUFBZVIsU0FBU1E7b0JBQ3hCLElBQUksS0FBSyxNQUFNUCxXQUFXRyxLQUFLQyxRQUFRLEVBQUU7d0JBQ3ZDLElBQUlNLG1CQUFtQlAsS0FBS0UsS0FBSzt3QkFDakMsSUFBSUwsUUFBUVUsa0JBQWtCSCxlQUM1QixPQUFRSSxvQkFBb0JEO29CQUNoQztvQkFDQSxPQUFRQyxvQkFBb0JKO2dCQUM5QjtnQkFDQUcsbUJBQW1CQztnQkFDbkIsSUFBSXhCLFNBQVNzQixrQkFBa0JGLGVBQzdCLE9BQU9HO2dCQUNULElBQUlFLGdCQUFnQmIsU0FBU1E7Z0JBQzdCLElBQUksS0FBSyxNQUFNUCxXQUFXQSxRQUFRVSxrQkFBa0JFLGdCQUNsRCxPQUFPLG1CQUFvQkwsY0FBZUc7Z0JBQzVDRCxtQkFBbUJGO2dCQUNuQixPQUFRSSxvQkFBb0JDO1lBQzlCO1lBQ0EsSUFBSUosVUFBVSxDQUFDLEdBQ2JDLGtCQUNBRSxtQkFDQUUseUJBQ0UsS0FBSyxNQUFNZixvQkFBb0IsT0FBT0E7WUFDMUMsT0FBTztnQkFDTDtvQkFDRSxPQUFPUSxpQkFBaUJUO2dCQUMxQjtnQkFDQSxTQUFTZ0IseUJBQ0wsS0FBSyxJQUNMO29CQUNFLE9BQU9QLGlCQUFpQk87Z0JBQzFCO2FBQ0w7UUFDSCxHQUNBO1lBQUNoQjtZQUFhQztZQUFtQkM7WUFBVUM7U0FBUTtRQUVyRCxJQUFJSyxRQUFRaEIscUJBQXFCTyxXQUFXSyxPQUFPLENBQUMsRUFBRSxFQUFFQSxPQUFPLENBQUMsRUFBRTtRQUNsRVYsVUFDRTtZQUNFWSxLQUFLQyxRQUFRLEdBQUcsQ0FBQztZQUNqQkQsS0FBS0UsS0FBSyxHQUFHQTtRQUNmLEdBQ0E7WUFBQ0E7U0FBTTtRQUVUWixjQUFjWTtRQUNkLE9BQU9BO0lBQ1Q7O1lBVmNoQjs7O0lBV2QsZ0JBQWdCLE9BQU9QLGtDQUNyQixlQUNFLE9BQU9BLCtCQUErQmdDLDBCQUEwQixJQUNsRWhDLCtCQUErQmdDLDBCQUEwQixDQUFDOUI7QUFDOUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy91c2Utc3luYy1leHRlcm5hbC1zdG9yZS9janMvdXNlLXN5bmMtZXh0ZXJuYWwtc3RvcmUtd2l0aC1zZWxlY3Rvci5kZXZlbG9wbWVudC5qcz84MmE3Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2UgUmVhY3RcbiAqIHVzZS1zeW5jLWV4dGVybmFsLXN0b3JlLXdpdGgtc2VsZWN0b3IuZGV2ZWxvcG1lbnQuanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cblwidXNlIHN0cmljdFwiO1xuXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WICYmXG4gIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gaXMoeCwgeSkge1xuICAgICAgcmV0dXJuICh4ID09PSB5ICYmICgwICE9PSB4IHx8IDEgLyB4ID09PSAxIC8geSkpIHx8ICh4ICE9PSB4ICYmIHkgIT09IHkpO1xuICAgIH1cbiAgICBcInVuZGVmaW5lZFwiICE9PSB0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fICYmXG4gICAgICBcImZ1bmN0aW9uXCIgPT09XG4gICAgICAgIHR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18ucmVnaXN0ZXJJbnRlcm5hbE1vZHVsZVN0YXJ0ICYmXG4gICAgICBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18ucmVnaXN0ZXJJbnRlcm5hbE1vZHVsZVN0YXJ0KEVycm9yKCkpO1xuICAgIHZhciBSZWFjdCA9IHJlcXVpcmUoXCJyZWFjdFwiKSxcbiAgICAgIG9iamVjdElzID0gXCJmdW5jdGlvblwiID09PSB0eXBlb2YgT2JqZWN0LmlzID8gT2JqZWN0LmlzIDogaXMsXG4gICAgICB1c2VTeW5jRXh0ZXJuYWxTdG9yZSA9IFJlYWN0LnVzZVN5bmNFeHRlcm5hbFN0b3JlLFxuICAgICAgdXNlUmVmID0gUmVhY3QudXNlUmVmLFxuICAgICAgdXNlRWZmZWN0ID0gUmVhY3QudXNlRWZmZWN0LFxuICAgICAgdXNlTWVtbyA9IFJlYWN0LnVzZU1lbW8sXG4gICAgICB1c2VEZWJ1Z1ZhbHVlID0gUmVhY3QudXNlRGVidWdWYWx1ZTtcbiAgICBleHBvcnRzLnVzZVN5bmNFeHRlcm5hbFN0b3JlV2l0aFNlbGVjdG9yID0gZnVuY3Rpb24gKFxuICAgICAgc3Vic2NyaWJlLFxuICAgICAgZ2V0U25hcHNob3QsXG4gICAgICBnZXRTZXJ2ZXJTbmFwc2hvdCxcbiAgICAgIHNlbGVjdG9yLFxuICAgICAgaXNFcXVhbFxuICAgICkge1xuICAgICAgdmFyIGluc3RSZWYgPSB1c2VSZWYobnVsbCk7XG4gICAgICBpZiAobnVsbCA9PT0gaW5zdFJlZi5jdXJyZW50KSB7XG4gICAgICAgIHZhciBpbnN0ID0geyBoYXNWYWx1ZTogITEsIHZhbHVlOiBudWxsIH07XG4gICAgICAgIGluc3RSZWYuY3VycmVudCA9IGluc3Q7XG4gICAgICB9IGVsc2UgaW5zdCA9IGluc3RSZWYuY3VycmVudDtcbiAgICAgIGluc3RSZWYgPSB1c2VNZW1vKFxuICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgZnVuY3Rpb24gbWVtb2l6ZWRTZWxlY3RvcihuZXh0U25hcHNob3QpIHtcbiAgICAgICAgICAgIGlmICghaGFzTWVtbykge1xuICAgICAgICAgICAgICBoYXNNZW1vID0gITA7XG4gICAgICAgICAgICAgIG1lbW9pemVkU25hcHNob3QgPSBuZXh0U25hcHNob3Q7XG4gICAgICAgICAgICAgIG5leHRTbmFwc2hvdCA9IHNlbGVjdG9yKG5leHRTbmFwc2hvdCk7XG4gICAgICAgICAgICAgIGlmICh2b2lkIDAgIT09IGlzRXF1YWwgJiYgaW5zdC5oYXNWYWx1ZSkge1xuICAgICAgICAgICAgICAgIHZhciBjdXJyZW50U2VsZWN0aW9uID0gaW5zdC52YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAoaXNFcXVhbChjdXJyZW50U2VsZWN0aW9uLCBuZXh0U25hcHNob3QpKVxuICAgICAgICAgICAgICAgICAgcmV0dXJuIChtZW1vaXplZFNlbGVjdGlvbiA9IGN1cnJlbnRTZWxlY3Rpb24pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiAobWVtb2l6ZWRTZWxlY3Rpb24gPSBuZXh0U25hcHNob3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VycmVudFNlbGVjdGlvbiA9IG1lbW9pemVkU2VsZWN0aW9uO1xuICAgICAgICAgICAgaWYgKG9iamVjdElzKG1lbW9pemVkU25hcHNob3QsIG5leHRTbmFwc2hvdCkpXG4gICAgICAgICAgICAgIHJldHVybiBjdXJyZW50U2VsZWN0aW9uO1xuICAgICAgICAgICAgdmFyIG5leHRTZWxlY3Rpb24gPSBzZWxlY3RvcihuZXh0U25hcHNob3QpO1xuICAgICAgICAgICAgaWYgKHZvaWQgMCAhPT0gaXNFcXVhbCAmJiBpc0VxdWFsKGN1cnJlbnRTZWxlY3Rpb24sIG5leHRTZWxlY3Rpb24pKVxuICAgICAgICAgICAgICByZXR1cm4gKG1lbW9pemVkU25hcHNob3QgPSBuZXh0U25hcHNob3QpLCBjdXJyZW50U2VsZWN0aW9uO1xuICAgICAgICAgICAgbWVtb2l6ZWRTbmFwc2hvdCA9IG5leHRTbmFwc2hvdDtcbiAgICAgICAgICAgIHJldHVybiAobWVtb2l6ZWRTZWxlY3Rpb24gPSBuZXh0U2VsZWN0aW9uKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGhhc01lbW8gPSAhMSxcbiAgICAgICAgICAgIG1lbW9pemVkU25hcHNob3QsXG4gICAgICAgICAgICBtZW1vaXplZFNlbGVjdGlvbixcbiAgICAgICAgICAgIG1heWJlR2V0U2VydmVyU25hcHNob3QgPVxuICAgICAgICAgICAgICB2b2lkIDAgPT09IGdldFNlcnZlclNuYXBzaG90ID8gbnVsbCA6IGdldFNlcnZlclNuYXBzaG90O1xuICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHJldHVybiBtZW1vaXplZFNlbGVjdG9yKGdldFNuYXBzaG90KCkpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG51bGwgPT09IG1heWJlR2V0U2VydmVyU25hcHNob3RcbiAgICAgICAgICAgICAgPyB2b2lkIDBcbiAgICAgICAgICAgICAgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gbWVtb2l6ZWRTZWxlY3RvcihtYXliZUdldFNlcnZlclNuYXBzaG90KCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICBdO1xuICAgICAgICB9LFxuICAgICAgICBbZ2V0U25hcHNob3QsIGdldFNlcnZlclNuYXBzaG90LCBzZWxlY3RvciwgaXNFcXVhbF1cbiAgICAgICk7XG4gICAgICB2YXIgdmFsdWUgPSB1c2VTeW5jRXh0ZXJuYWxTdG9yZShzdWJzY3JpYmUsIGluc3RSZWZbMF0sIGluc3RSZWZbMV0pO1xuICAgICAgdXNlRWZmZWN0KFxuICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaW5zdC5oYXNWYWx1ZSA9ICEwO1xuICAgICAgICAgIGluc3QudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgW3ZhbHVlXVxuICAgICAgKTtcbiAgICAgIHVzZURlYnVnVmFsdWUodmFsdWUpO1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH07XG4gICAgXCJ1bmRlZmluZWRcIiAhPT0gdHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyAmJlxuICAgICAgXCJmdW5jdGlvblwiID09PVxuICAgICAgICB0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fLnJlZ2lzdGVySW50ZXJuYWxNb2R1bGVTdG9wICYmXG4gICAgICBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18ucmVnaXN0ZXJJbnRlcm5hbE1vZHVsZVN0b3AoRXJyb3IoKSk7XG4gIH0pKCk7XG4iXSwibmFtZXMiOlsiaXMiLCJ4IiwieSIsIl9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyIsInJlZ2lzdGVySW50ZXJuYWxNb2R1bGVTdGFydCIsIkVycm9yIiwiUmVhY3QiLCJyZXF1aXJlIiwib2JqZWN0SXMiLCJPYmplY3QiLCJ1c2VTeW5jRXh0ZXJuYWxTdG9yZSIsInVzZVJlZiIsInVzZUVmZmVjdCIsInVzZU1lbW8iLCJ1c2VEZWJ1Z1ZhbHVlIiwiZXhwb3J0cyIsInVzZVN5bmNFeHRlcm5hbFN0b3JlV2l0aFNlbGVjdG9yIiwic3Vic2NyaWJlIiwiZ2V0U25hcHNob3QiLCJnZXRTZXJ2ZXJTbmFwc2hvdCIsInNlbGVjdG9yIiwiaXNFcXVhbCIsImluc3RSZWYiLCJjdXJyZW50IiwiaW5zdCIsImhhc1ZhbHVlIiwidmFsdWUiLCJtZW1vaXplZFNlbGVjdG9yIiwibmV4dFNuYXBzaG90IiwiaGFzTWVtbyIsIm1lbW9pemVkU25hcHNob3QiLCJjdXJyZW50U2VsZWN0aW9uIiwibWVtb2l6ZWRTZWxlY3Rpb24iLCJuZXh0U2VsZWN0aW9uIiwibWF5YmVHZXRTZXJ2ZXJTbmFwc2hvdCIsInJlZ2lzdGVySW50ZXJuYWxNb2R1bGVTdG9wIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../../../node_modules/use-sync-external-store/cjs/use-sync-external-store-with-selector.development.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../../../node_modules/use-sync-external-store/with-selector.js":
/*!*************************************************************************!*\
  !*** ../../../../node_modules/use-sync-external-store/with-selector.js ***!
  \*************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("\nif (false) {} else {\n    module.exports = __webpack_require__(/*! ./cjs/use-sync-external-store-with-selector.development.js */ \"(app-pages-browser)/../../../../node_modules/use-sync-external-store/cjs/use-sync-external-store-with-selector.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdXNlLXN5bmMtZXh0ZXJuYWwtc3RvcmUvd2l0aC1zZWxlY3Rvci5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBLElBQUlBLEtBQXlCLEVBQWMsRUFFMUMsTUFBTTtJQUNMQyx1T0FBeUI7QUFDM0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy91c2Utc3luYy1leHRlcm5hbC1zdG9yZS93aXRoLXNlbGVjdG9yLmpzPzhlYWUiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3VzZS1zeW5jLWV4dGVybmFsLXN0b3JlLXdpdGgtc2VsZWN0b3IucHJvZHVjdGlvbi5qcycpO1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy91c2Utc3luYy1leHRlcm5hbC1zdG9yZS13aXRoLXNlbGVjdG9yLmRldmVsb3BtZW50LmpzJyk7XG59XG4iXSwibmFtZXMiOlsicHJvY2VzcyIsIm1vZHVsZSIsImV4cG9ydHMiLCJyZXF1aXJlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../../../node_modules/use-sync-external-store/with-selector.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/app/globals.css":
/*!*****************************!*\
  !*** ./src/app/globals.css ***!
  \*****************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (\"c8af6905b61c\");\nif (true) { module.hot.accept() }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9hcHAvZ2xvYmFscy5jc3MiLCJtYXBwaW5ncyI6IjtBQUFBLCtEQUFlLGNBQWM7QUFDN0IsSUFBSSxJQUFVLElBQUksaUJBQWlCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9hcHAvZ2xvYmFscy5jc3M/ODkwMiJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCBcImM4YWY2OTA1YjYxY1wiXG5pZiAobW9kdWxlLmhvdCkgeyBtb2R1bGUuaG90LmFjY2VwdCgpIH1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/app/globals.css\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/image-component.js":
/*!**********************************************************!*\
  !*** ./node_modules/next/dist/client/image-component.js ***!
  \**********************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval(__webpack_require__.ts("/* __next_internal_client_entry_do_not_use__  cjs */ \nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"Image\", ({\n    enumerable: true,\n    get: function() {\n        return Image;\n    }\n}));\nconst _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_interop_require_default.js\");\nconst _interop_require_wildcard = __webpack_require__(/*! @swc/helpers/_/_interop_require_wildcard */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_interop_require_wildcard.js\");\nconst _jsxruntime = __webpack_require__(/*! react/jsx-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-runtime.js\");\nconst _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\"));\nconst _reactdom = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! react-dom */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react-dom/index.js\"));\nconst _head = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! ../shared/lib/head */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/head.js\"));\nconst _getimgprops = __webpack_require__(/*! ../shared/lib/get-img-props */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/get-img-props.js\");\nconst _imageconfig = __webpack_require__(/*! ../shared/lib/image-config */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/image-config.js\");\nconst _imageconfigcontextsharedruntime = __webpack_require__(/*! ../shared/lib/image-config-context.shared-runtime */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/image-config-context.shared-runtime.js\");\nconst _warnonce = __webpack_require__(/*! ../shared/lib/utils/warn-once */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/utils/warn-once.js\");\nconst _routercontextsharedruntime = __webpack_require__(/*! ../shared/lib/router-context.shared-runtime */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/router-context.shared-runtime.js\");\nconst _imageloader = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! next/dist/shared/lib/image-loader */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/image-loader.js\"));\n// This is replaced by webpack define plugin\nconst configEnv = {\"deviceSizes\":[640,750,828,1080,1200,1920,2048,3840],\"imageSizes\":[16,32,48,64,96,128,256,384],\"path\":\"/_next/image\",\"loader\":\"default\",\"dangerouslyAllowSVG\":false,\"unoptimized\":false,\"domains\":[\"localhost\"],\"remotePatterns\":[]};\nif (false) {}\n// See https://stackoverflow.com/q/39777833/266535 for why we use this ref\n// handler instead of the img's onLoad attribute.\nfunction handleLoading(img, placeholder, onLoadRef, onLoadingCompleteRef, setBlurComplete, unoptimized) {\n    const src = img == null ? void 0 : img.src;\n    if (!img || img[\"data-loaded-src\"] === src) {\n        return;\n    }\n    img[\"data-loaded-src\"] = src;\n    const p = \"decode\" in img ? img.decode() : Promise.resolve();\n    p.catch(()=>{}).then(()=>{\n        if (!img.parentElement || !img.isConnected) {\n            // Exit early in case of race condition:\n            // - onload() is called\n            // - decode() is called but incomplete\n            // - unmount is called\n            // - decode() completes\n            return;\n        }\n        if (placeholder !== \"empty\") {\n            setBlurComplete(true);\n        }\n        if (onLoadRef == null ? void 0 : onLoadRef.current) {\n            // Since we don't have the SyntheticEvent here,\n            // we must create one with the same shape.\n            // See https://reactjs.org/docs/events.html\n            const event = new Event(\"load\");\n            Object.defineProperty(event, \"target\", {\n                writable: false,\n                value: img\n            });\n            let prevented = false;\n            let stopped = false;\n            onLoadRef.current({\n                ...event,\n                nativeEvent: event,\n                currentTarget: img,\n                target: img,\n                isDefaultPrevented: ()=>prevented,\n                isPropagationStopped: ()=>stopped,\n                persist: ()=>{},\n                preventDefault: ()=>{\n                    prevented = true;\n                    event.preventDefault();\n                },\n                stopPropagation: ()=>{\n                    stopped = true;\n                    event.stopPropagation();\n                }\n            });\n        }\n        if (onLoadingCompleteRef == null ? void 0 : onLoadingCompleteRef.current) {\n            onLoadingCompleteRef.current(img);\n        }\n        if (true) {\n            const origSrc = new URL(src, \"http://n\").searchParams.get(\"url\") || src;\n            if (img.getAttribute(\"data-nimg\") === \"fill\") {\n                if (!unoptimized && (!img.getAttribute(\"sizes\") || img.getAttribute(\"sizes\") === \"100vw\")) {\n                    let widthViewportRatio = img.getBoundingClientRect().width / window.innerWidth;\n                    if (widthViewportRatio < 0.6) {\n                        (0, _warnonce.warnOnce)('Image with src \"' + origSrc + '\" has \"fill\" but is missing \"sizes\" prop. Please add it to improve page performance. Read more: https://nextjs.org/docs/api-reference/next/image#sizes');\n                    }\n                }\n                if (img.parentElement) {\n                    const { position } = window.getComputedStyle(img.parentElement);\n                    const valid = [\n                        \"absolute\",\n                        \"fixed\",\n                        \"relative\"\n                    ];\n                    if (!valid.includes(position)) {\n                        (0, _warnonce.warnOnce)('Image with src \"' + origSrc + '\" has \"fill\" and parent element with invalid \"position\". Provided \"' + position + '\" should be one of ' + valid.map(String).join(\",\") + \".\");\n                    }\n                }\n                if (img.height === 0) {\n                    (0, _warnonce.warnOnce)('Image with src \"' + origSrc + '\" has \"fill\" and a height value of 0. This is likely because the parent element of the image has not been styled to have a set height.');\n                }\n            }\n            const heightModified = img.height.toString() !== img.getAttribute(\"height\");\n            const widthModified = img.width.toString() !== img.getAttribute(\"width\");\n            if (heightModified && !widthModified || !heightModified && widthModified) {\n                (0, _warnonce.warnOnce)('Image with src \"' + origSrc + '\" has either width or height modified, but not the other. If you use CSS to change the size of your image, also include the styles \\'width: \"auto\"\\' or \\'height: \"auto\"\\' to maintain the aspect ratio.');\n            }\n        }\n    });\n}\nfunction getDynamicProps(fetchPriority) {\n    const [majorStr, minorStr] = _react.version.split(\".\", 2);\n    const major = parseInt(majorStr, 10);\n    const minor = parseInt(minorStr, 10);\n    if (major > 18 || major === 18 && minor >= 3) {\n        // In React 18.3.0 or newer, we must use camelCase\n        // prop to avoid \"Warning: Invalid DOM property\".\n        // See https://github.com/facebook/react/pull/25927\n        return {\n            fetchPriority\n        };\n    }\n    // In React 18.2.0 or older, we must use lowercase prop\n    // to avoid \"Warning: Invalid DOM property\".\n    return {\n        fetchpriority: fetchPriority\n    };\n}\nconst ImageElement = /*#__PURE__*/ (0, _react.forwardRef)((param, forwardedRef)=>{\n    let { src, srcSet, sizes, height, width, decoding, className, style, fetchPriority, placeholder, loading, unoptimized, fill, onLoadRef, onLoadingCompleteRef, setBlurComplete, setShowAltText, onLoad, onError, ...rest } = param;\n    return /*#__PURE__*/ (0, _jsxruntime.jsx)(\"img\", {\n        ...rest,\n        ...getDynamicProps(fetchPriority),\n        // It's intended to keep `loading` before `src` because React updates\n        // props in order which causes Safari/Firefox to not lazy load properly.\n        // See https://github.com/facebook/react/issues/25883\n        loading: loading,\n        width: width,\n        height: height,\n        decoding: decoding,\n        \"data-nimg\": fill ? \"fill\" : \"1\",\n        className: className,\n        style: style,\n        // It's intended to keep `src` the last attribute because React updates\n        // attributes in order. If we keep `src` the first one, Safari will\n        // immediately start to fetch `src`, before `sizes` and `srcSet` are even\n        // updated by React. That causes multiple unnecessary requests if `srcSet`\n        // and `sizes` are defined.\n        // This bug cannot be reproduced in Chrome or Firefox.\n        sizes: sizes,\n        srcSet: srcSet,\n        src: src,\n        ref: (0, _react.useCallback)((img)=>{\n            if (forwardedRef) {\n                if (typeof forwardedRef === \"function\") forwardedRef(img);\n                else if (typeof forwardedRef === \"object\") {\n                    // @ts-ignore - .current is read only it's usually assigned by react internally\n                    forwardedRef.current = img;\n                }\n            }\n            if (!img) {\n                return;\n            }\n            if (onError) {\n                // If the image has an error before react hydrates, then the error is lost.\n                // The workaround is to wait until the image is mounted which is after hydration,\n                // then we set the src again to trigger the error handler (if there was an error).\n                // eslint-disable-next-line no-self-assign\n                img.src = img.src;\n            }\n            if (true) {\n                if (!src) {\n                    console.error('Image is missing required \"src\" property:', img);\n                }\n                if (img.getAttribute(\"alt\") === null) {\n                    console.error('Image is missing required \"alt\" property. Please add Alternative Text to describe the image for screen readers and search engines.');\n                }\n            }\n            if (img.complete) {\n                handleLoading(img, placeholder, onLoadRef, onLoadingCompleteRef, setBlurComplete, unoptimized);\n            }\n        }, [\n            src,\n            placeholder,\n            onLoadRef,\n            onLoadingCompleteRef,\n            setBlurComplete,\n            onError,\n            unoptimized,\n            forwardedRef\n        ]),\n        onLoad: (event)=>{\n            const img = event.currentTarget;\n            handleLoading(img, placeholder, onLoadRef, onLoadingCompleteRef, setBlurComplete, unoptimized);\n        },\n        onError: (event)=>{\n            // if the real image fails to load, this will ensure \"alt\" is visible\n            setShowAltText(true);\n            if (placeholder !== \"empty\") {\n                // If the real image fails to load, this will still remove the placeholder.\n                setBlurComplete(true);\n            }\n            if (onError) {\n                onError(event);\n            }\n        }\n    });\n});\nfunction ImagePreload(param) {\n    let { isAppRouter, imgAttributes } = param;\n    const opts = {\n        as: \"image\",\n        imageSrcSet: imgAttributes.srcSet,\n        imageSizes: imgAttributes.sizes,\n        crossOrigin: imgAttributes.crossOrigin,\n        referrerPolicy: imgAttributes.referrerPolicy,\n        ...getDynamicProps(imgAttributes.fetchPriority)\n    };\n    if (isAppRouter && _reactdom.default.preload) {\n        // See https://github.com/facebook/react/pull/26940\n        _reactdom.default.preload(imgAttributes.src, opts);\n        return null;\n    }\n    return /*#__PURE__*/ (0, _jsxruntime.jsx)(_head.default, {\n        children: /*#__PURE__*/ (0, _jsxruntime.jsx)(\"link\", {\n            rel: \"preload\",\n            // Note how we omit the `href` attribute, as it would only be relevant\n            // for browsers that do not support `imagesrcset`, and in those cases\n            // it would cause the incorrect image to be preloaded.\n            //\n            // https://html.spec.whatwg.org/multipage/semantics.html#attr-link-imagesrcset\n            href: imgAttributes.srcSet ? undefined : imgAttributes.src,\n            ...opts\n        }, \"__nimg-\" + imgAttributes.src + imgAttributes.srcSet + imgAttributes.sizes)\n    });\n}\n_c = ImagePreload;\nconst Image = /*#__PURE__*/ (0, _react.forwardRef)((props, forwardedRef)=>{\n    const pagesRouter = (0, _react.useContext)(_routercontextsharedruntime.RouterContext);\n    // We're in the app directory if there is no pages router.\n    const isAppRouter = !pagesRouter;\n    const configContext = (0, _react.useContext)(_imageconfigcontextsharedruntime.ImageConfigContext);\n    const config = (0, _react.useMemo)(()=>{\n        const c = configEnv || configContext || _imageconfig.imageConfigDefault;\n        const allSizes = [\n            ...c.deviceSizes,\n            ...c.imageSizes\n        ].sort((a, b)=>a - b);\n        const deviceSizes = c.deviceSizes.sort((a, b)=>a - b);\n        return {\n            ...c,\n            allSizes,\n            deviceSizes\n        };\n    }, [\n        configContext\n    ]);\n    const { onLoad, onLoadingComplete } = props;\n    const onLoadRef = (0, _react.useRef)(onLoad);\n    (0, _react.useEffect)(()=>{\n        onLoadRef.current = onLoad;\n    }, [\n        onLoad\n    ]);\n    const onLoadingCompleteRef = (0, _react.useRef)(onLoadingComplete);\n    (0, _react.useEffect)(()=>{\n        onLoadingCompleteRef.current = onLoadingComplete;\n    }, [\n        onLoadingComplete\n    ]);\n    const [blurComplete, setBlurComplete] = (0, _react.useState)(false);\n    const [showAltText, setShowAltText] = (0, _react.useState)(false);\n    const { props: imgAttributes, meta: imgMeta } = (0, _getimgprops.getImgProps)(props, {\n        defaultLoader: _imageloader.default,\n        imgConf: config,\n        blurComplete,\n        showAltText\n    });\n    return /*#__PURE__*/ (0, _jsxruntime.jsxs)(_jsxruntime.Fragment, {\n        children: [\n            /*#__PURE__*/ (0, _jsxruntime.jsx)(ImageElement, {\n                ...imgAttributes,\n                unoptimized: imgMeta.unoptimized,\n                placeholder: imgMeta.placeholder,\n                fill: imgMeta.fill,\n                onLoadRef: onLoadRef,\n                onLoadingCompleteRef: onLoadingCompleteRef,\n                setBlurComplete: setBlurComplete,\n                setShowAltText: setShowAltText,\n                ref: forwardedRef\n            }),\n            imgMeta.priority ? /*#__PURE__*/ (0, _jsxruntime.jsx)(ImagePreload, {\n                isAppRouter: isAppRouter,\n                imgAttributes: imgAttributes\n            }) : null\n        ]\n    });\n});\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=image-component.js.map\nvar _c;\n$RefreshReg$(_c, \"ImagePreload\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2ltYWdlLWNvbXBvbmVudC5qcyIsIm1hcHBpbmdzIjoicURBRWE7QUFDYkEsOENBQTZDO0lBQ3pDRyxPQUFPO0FBQ1gsQ0FBQyxFQUFDO0FBQ0ZILHlDQUF3QztJQUNwQ0ksWUFBWTtJQUNaQyxLQUFLO1FBQ0QsT0FBT0M7SUFDWDtBQUNKLENBQUMsRUFBQztBQUNGLE1BQU1DLDJCQUEyQkMsbUJBQU9BLENBQUMsZ0lBQXlDO0FBQ2xGLE1BQU1DLDRCQUE0QkQsbUJBQU9BLENBQUMsa0lBQTBDO0FBQ3BGLE1BQU1FLGNBQWNGLG1CQUFPQSxDQUFDLHFHQUFtQjtBQUMvQyxNQUFNRyxTQUFTLFdBQVcsR0FBR0YsMEJBQTBCRyxDQUFDLENBQUNKLG1CQUFPQSxDQUFDLG1GQUFPO0FBQ3hFLE1BQU1LLFlBQVksV0FBVyxHQUFHTix5QkFBeUJLLENBQUMsQ0FBQ0osbUJBQU9BLENBQUMsMkZBQVc7QUFDOUUsTUFBTU0sUUFBUSxXQUFXLEdBQUdQLHlCQUF5QkssQ0FBQyxDQUFDSixtQkFBT0EsQ0FBQywyRkFBb0I7QUFDbkYsTUFBTU8sZUFBZVAsbUJBQU9BLENBQUMsNkdBQTZCO0FBQzFELE1BQU1RLGVBQWVSLG1CQUFPQSxDQUFDLDJHQUE0QjtBQUN6RCxNQUFNUyxtQ0FBbUNULG1CQUFPQSxDQUFDLHlKQUFtRDtBQUNwRyxNQUFNVSxZQUFZVixtQkFBT0EsQ0FBQyxpSEFBK0I7QUFDekQsTUFBTVcsOEJBQThCWCxtQkFBT0EsQ0FBQyw2SUFBNkM7QUFDekYsTUFBTVksZUFBZSxXQUFXLEdBQUdiLHlCQUF5QkssQ0FBQyxDQUFDSixtQkFBT0EsQ0FBQyxrSEFBbUM7QUFDekcsNENBQTRDO0FBQzVDLE1BQU1hLFlBQVlDLHFPQUE2QjtBQUMvQyxJQUFJLEtBQTZCLEVBQUUsRUFFbEM7QUFDRCwwRUFBMEU7QUFDMUUsaURBQWlEO0FBQ2pELFNBQVNLLGNBQWNDLEdBQUcsRUFB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LE9BQU9wSCxRQUFRb0gsT0FBTyxDQUFDbUMsVUFBVSxLQUFLLGFBQWE7SUFDckt6SixPQUFPQyxjQUFjLENBQUNDLFFBQVFvSCxPQUFPLEVBQUUsY0FBYztRQUFFbkgsT0FBTztJQUFLO0lBQ25FSCxPQUFPMEosTUFBTSxDQUFDeEosUUFBUW9ILE9BQU8sRUFBRXBIO0lBQy9CeUosT0FBT3pKLE9BQU8sR0FBR0EsUUFBUW9ILE9BQU87QUFDbEMsRUFFQSwyQ0FBMkMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvaW1hZ2UtY29tcG9uZW50LmpzP2FjNDIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2UgY2xpZW50XCI7XG5cblwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiSW1hZ2VcIiwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIEltYWdlO1xuICAgIH1cbn0pO1xuY29uc3QgX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0ID0gcmVxdWlyZShcIkBzd2MvaGVscGVycy9fL19pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdFwiKTtcbmNvbnN0IF9pbnRlcm9wX3JlcXVpcmVfd2lsZGNhcmQgPSByZXF1aXJlKFwiQHN3Yy9oZWxwZXJzL18vX2ludGVyb3BfcmVxdWlyZV93aWxkY2FyZFwiKTtcbmNvbnN0IF9qc3hydW50aW1lID0gcmVxdWlyZShcInJlYWN0L2pzeC1ydW50aW1lXCIpO1xuY29uc3QgX3JlYWN0ID0gLyojX19QVVJFX18qLyBfaW50ZXJvcF9yZXF1aXJlX3dpbGRjYXJkLl8ocmVxdWlyZShcInJlYWN0XCIpKTtcbmNvbnN0IF9yZWFjdGRvbSA9IC8qI19fUFVSRV9fKi8gX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0Ll8ocmVxdWlyZShcInJlYWN0LWRvbVwiKSk7XG5jb25zdCBfaGVhZCA9IC8qI19fUFVSRV9fKi8gX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0Ll8ocmVxdWlyZShcIi4uL3NoYXJlZC9saWIvaGVhZFwiKSk7XG5jb25zdCBfZ2V0aW1ncHJvcHMgPSByZXF1aXJlKFwiLi4vc2hhcmVkL2xpYi9nZXQtaW1nLXByb3BzXCIpO1xuY29uc3QgX2ltYWdlY29uZmlnID0gcmVxdWlyZShcIi4uL3NoYXJlZC9saWIvaW1hZ2UtY29uZmlnXCIpO1xuY29uc3QgX2ltYWdlY29uZmlnY29udGV4dHNoYXJlZHJ1bnRpbWUgPSByZXF1aXJlKFwiLi4vc2hhcmVkL2xpYi9pbWFnZS1jb25maWctY29udGV4dC5zaGFyZWQtcnVudGltZVwiKTtcbmNvbnN0IF93YXJub25jZSA9IHJlcXVpcmUoXCIuLi9zaGFyZWQvbGliL3V0aWxzL3dhcm4tb25jZVwiKTtcbmNvbnN0IF9yb3V0ZXJjb250ZXh0c2hhcmVkcnVudGltZSA9IHJlcXVpcmUoXCIuLi9zaGFyZWQvbGliL3JvdXRlci1jb250ZXh0LnNoYXJlZC1ydW50aW1lXCIpO1xuY29uc3QgX2ltYWdlbG9hZGVyID0gLyojX19QVVJFX18qLyBfaW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQuXyhyZXF1aXJlKFwibmV4dC9kaXN0L3NoYXJlZC9saWIvaW1hZ2UtbG9hZGVyXCIpKTtcbi8vIFRoaXMgaXMgcmVwbGFjZWQgYnkgd2VicGFjayBkZWZpbmUgcGx1Z2luXG5jb25zdCBjb25maWdFbnYgPSBwcm9jZXNzLmVudi5fX05FWFRfSU1BR0VfT1BUUztcbmlmICh0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgZ2xvYmFsVGhpcy5fX05FWFRfSU1BR0VfSU1QT1JURUQgPSB0cnVlO1xufVxuLy8gU2VlIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcS8zOTc3NzgzMy8yNjY1MzUgZm9yIHdoeSB3ZSB1c2UgdGhpcyByZWZcbi8vIGhhbmRsZXIgaW5zdGVhZCBvZiB0aGUgaW1nJ3Mgb25Mb2FkIGF0dHJpYnV0ZS5cbmZ1bmN0aW9uIGhhbmRsZUxvYWRpbmcoaW1nLCBwbGFjZWhvbGRlciwgb25Mb2FkUmVmLCBvbkxvYWRpbmdDb21wbGV0ZVJlZiwgc2V0Qmx1ckNvbXBsZXRlLCB1bm9wdGltaXplZCkge1xuICAgIGNvbnN0IHNyYyA9IGltZyA9PSBudWxsID8gdm9pZCAwIDogaW1nLnNyYztcbiAgICBpZiAoIWltZyB8fCBpbWdbXCJkYXRhLWxvYWRlZC1zcmNcIl0gPT09IHNyYykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGltZ1tcImRhdGEtbG9hZGVkLXNyY1wiXSA9IHNyYztcbiAgICBjb25zdCBwID0gXCJkZWNvZGVcIiBpbiBpbWcgPyBpbWcuZGVjb2RlKCkgOiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICBwLmNhdGNoKCgpPT57fSkudGhlbigoKT0+e1xuICAgICAgICBpZiAoIWltZy5wYXJlbnRFbGVtZW50IHx8ICFpbWcuaXNDb25uZWN0ZWQpIHtcbiAgICAgICAgICAgIC8vIEV4aXQgZWFybHkgaW4gY2FzZSBvZiByYWNlIGNvbmRpdGlvbjpcbiAgICAgICAgICAgIC8vIC0gb25sb2FkKCkgaXMgY2FsbGVkXG4gICAgICAgICAgICAvLyAtIGRlY29kZSgpIGlzIGNhbGxlZCBidXQgaW5jb21wbGV0ZVxuICAgICAgICAgICAgLy8gLSB1bm1vdW50IGlzIGNhbGxlZFxuICAgICAgICAgICAgLy8gLSBkZWNvZGUoKSBjb21wbGV0ZXNcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGxhY2Vob2xkZXIgIT09IFwiZW1wdHlcIikge1xuICAgICAgICAgICAgc2V0Qmx1ckNvbXBsZXRlKHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvbkxvYWRSZWYgPT0gbnVsbCA/IHZvaWQgMCA6IG9uTG9hZFJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgICAvLyBTaW5jZSB3ZSBkb24ndCBoYXZlIHRoZSBTeW50aGV0aWNFdmVudCBoZXJlLFxuICAgICAgICAgICAgLy8gd2UgbXVzdCBjcmVhdGUgb25lIHdpdGggdGhlIHNhbWUgc2hhcGUuXG4gICAgICAgICAgICAvLyBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL2V2ZW50cy5odG1sXG4gICAgICAgICAgICBjb25zdCBldmVudCA9IG5ldyBFdmVudChcImxvYWRcIik7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXZlbnQsIFwidGFyZ2V0XCIsIHtcbiAgICAgICAgICAgICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgdmFsdWU6IGltZ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBsZXQgcHJldmVudGVkID0gZmFsc2U7XG4gICAgICAgICAgICBsZXQgc3RvcHBlZCA9IGZhbHNlO1xuICAgICAgICAgICAgb25Mb2FkUmVmLmN1cnJlbnQoe1xuICAgICAgICAgICAgICAgIC4uLmV2ZW50LFxuICAgICAgICAgICAgICAgIG5hdGl2ZUV2ZW50OiBldmVudCxcbiAgICAgICAgICAgICAgICBjdXJyZW50VGFyZ2V0OiBpbWcsXG4gICAgICAgICAgICAgICAgdGFyZ2V0OiBpbWcsXG4gICAgICAgICAgICAgICAgaXNEZWZhdWx0UHJldmVudGVkOiAoKT0+cHJldmVudGVkLFxuICAgICAgICAgICAgICAgIGlzUHJvcGFnYXRpb25TdG9wcGVkOiAoKT0+c3RvcHBlZCxcbiAgICAgICAgICAgICAgICBwZXJzaXN0OiAoKT0+e30sXG4gICAgICAgICAgICAgICAgcHJldmVudERlZmF1bHQ6ICgpPT57XG4gICAgICAgICAgICAgICAgICAgIHByZXZlbnRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzdG9wUHJvcGFnYXRpb246ICgpPT57XG4gICAgICAgICAgICAgICAgICAgIHN0b3BwZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob25Mb2FkaW5nQ29tcGxldGVSZWYgPT0gbnVsbCA/IHZvaWQgMCA6IG9uTG9hZGluZ0NvbXBsZXRlUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIG9uTG9hZGluZ0NvbXBsZXRlUmVmLmN1cnJlbnQoaW1nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgICAgICBjb25zdCBvcmlnU3JjID0gbmV3IFVSTChzcmMsIFwiaHR0cDovL25cIikuc2VhcmNoUGFyYW1zLmdldChcInVybFwiKSB8fCBzcmM7XG4gICAgICAgICAgICBpZiAoaW1nLmdldEF0dHJpYnV0ZShcImRhdGEtbmltZ1wiKSA9PT0gXCJmaWxsXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXVub3B0aW1pemVkICYmICghaW1nLmdldEF0dHJpYnV0ZShcInNpemVzXCIpIHx8IGltZy5nZXRBdHRyaWJ1dGUoXCJzaXplc1wiKSA9PT0gXCIxMDB2d1wiKSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgd2lkdGhWaWV3cG9ydFJhdGlvID0gaW1nLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoIC8gd2luZG93LmlubmVyV2lkdGg7XG4gICAgICAgICAgICAgICAgICAgIGlmICh3aWR0aFZpZXdwb3J0UmF0aW8gPCAwLjYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICgwLCBfd2Fybm9uY2Uud2Fybk9uY2UpKCdJbWFnZSB3aXRoIHNyYyBcIicgKyBvcmlnU3JjICsgJ1wiIGhhcyBcImZpbGxcIiBidXQgaXMgbWlzc2luZyBcInNpemVzXCIgcHJvcC4gUGxlYXNlIGFkZCBpdCB0byBpbXByb3ZlIHBhZ2UgcGVyZm9ybWFuY2UuIFJlYWQgbW9yZTogaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvYXBpLXJlZmVyZW5jZS9uZXh0L2ltYWdlI3NpemVzJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGltZy5wYXJlbnRFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgcG9zaXRpb24gfSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGltZy5wYXJlbnRFbGVtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsaWQgPSBbXG4gICAgICAgICAgICAgICAgICAgICAgICBcImFic29sdXRlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBcImZpeGVkXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBcInJlbGF0aXZlXCJcbiAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF2YWxpZC5pbmNsdWRlcyhwb3NpdGlvbikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICgwLCBfd2Fybm9uY2Uud2Fybk9uY2UpKCdJbWFnZSB3aXRoIHNyYyBcIicgKyBvcmlnU3JjICsgJ1wiIGhhcyBcImZpbGxcIiBhbmQgcGFyZW50IGVsZW1lbnQgd2l0aCBpbnZhbGlkIFwicG9zaXRpb25cIi4gUHJvdmlkZWQgXCInICsgcG9zaXRpb24gKyAnXCIgc2hvdWxkIGJlIG9uZSBvZiAnICsgdmFsaWQubWFwKFN0cmluZykuam9pbihcIixcIikgKyBcIi5cIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGltZy5oZWlnaHQgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgKDAsIF93YXJub25jZS53YXJuT25jZSkoJ0ltYWdlIHdpdGggc3JjIFwiJyArIG9yaWdTcmMgKyAnXCIgaGFzIFwiZmlsbFwiIGFuZCBhIGhlaWdodCB2YWx1ZSBvZiAwLiBUaGlzIGlzIGxpa2VseSBiZWNhdXNlIHRoZSBwYXJlbnQgZWxlbWVudCBvZiB0aGUgaW1hZ2UgaGFzIG5vdCBiZWVuIHN0eWxlZCB0byBoYXZlIGEgc2V0IGhlaWdodC4nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBoZWlnaHRNb2RpZmllZCA9IGltZy5oZWlnaHQudG9TdHJpbmcoKSAhPT0gaW1nLmdldEF0dHJpYnV0ZShcImhlaWdodFwiKTtcbiAgICAgICAgICAgIGNvbnN0IHdpZHRoTW9kaWZpZWQgPSBpbWcud2lkdGgudG9TdHJpbmcoKSAhPT0gaW1nLmdldEF0dHJpYnV0ZShcIndpZHRoXCIpO1xuICAgICAgICAgICAgaWYgKGhlaWdodE1vZGlmaWVkICYmICF3aWR0aE1vZGlmaWVkIHx8ICFoZWlnaHRNb2RpZmllZCAmJiB3aWR0aE1vZGlmaWVkKSB7XG4gICAgICAgICAgICAgICAgKDAsIF93YXJub25jZS53YXJuT25jZSkoJ0ltYWdlIHdpdGggc3JjIFwiJyArIG9yaWdTcmMgKyAnXCIgaGFzIGVpdGhlciB3aWR0aCBvciBoZWlnaHQgbW9kaWZpZWQsIGJ1dCBub3QgdGhlIG90aGVyLiBJZiB5b3UgdXNlIENTUyB0byBjaGFuZ2UgdGhlIHNpemUgb2YgeW91ciBpbWFnZSwgYWxzbyBpbmNsdWRlIHRoZSBzdHlsZXMgXFwnd2lkdGg6IFwiYXV0b1wiXFwnIG9yIFxcJ2hlaWdodDogXCJhdXRvXCJcXCcgdG8gbWFpbnRhaW4gdGhlIGFzcGVjdCByYXRpby4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xufVxuZnVuY3Rpb24gZ2V0RHluYW1pY1Byb3BzKGZldGNoUHJpb3JpdHkpIHtcbiAgICBjb25zdCBbbWFqb3JTdHIsIG1pbm9yU3RyXSA9IF9yZWFjdC52ZXJzaW9uLnNwbGl0KFwiLlwiLCAyKTtcbiAgICBjb25zdCBtYWpvciA9IHBhcnNlSW50KG1ham9yU3RyLCAxMCk7XG4gICAgY29uc3QgbWlub3IgPSBwYXJzZUludChtaW5vclN0ciwgMTApO1xuICAgIGlmIChtYWpvciA+IDE4IHx8IG1ham9yID09PSAxOCAmJiBtaW5vciA+PSAzKSB7XG4gICAgICAgIC8vIEluIFJlYWN0IDE4LjMuMCBvciBuZXdlciwgd2UgbXVzdCB1c2UgY2FtZWxDYXNlXG4gICAgICAgIC8vIHByb3AgdG8gYXZvaWQgXCJXYXJuaW5nOiBJbnZhbGlkIERPTSBwcm9wZXJ0eVwiLlxuICAgICAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L3B1bGwvMjU5MjdcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGZldGNoUHJpb3JpdHlcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLy8gSW4gUmVhY3QgMTguMi4wIG9yIG9sZGVyLCB3ZSBtdXN0IHVzZSBsb3dlcmNhc2UgcHJvcFxuICAgIC8vIHRvIGF2b2lkIFwiV2FybmluZzogSW52YWxpZCBET00gcHJvcGVydHlcIi5cbiAgICByZXR1cm4ge1xuICAgICAgICBmZXRjaHByaW9yaXR5OiBmZXRjaFByaW9yaXR5XG4gICAgfTtcbn1cbmNvbnN0IEltYWdlRWxlbWVudCA9IC8qI19fUFVSRV9fKi8gKDAsIF9yZWFjdC5mb3J3YXJkUmVmKSgocGFyYW0sIGZvcndhcmRlZFJlZik9PntcbiAgICBsZXQgeyBzcmMsIHNyY1NldCwgc2l6ZXMsIGhlaWdodCwgd2lkdGgsIGRlY29kaW5nLCBjbGFzc05hbWUsIHN0eWxlLCBmZXRjaFByaW9yaXR5LCBwbGFjZWhvbGRlciwgbG9hZGluZywgdW5vcHRpbWl6ZWQsIGZpbGwsIG9uTG9hZFJlZiwgb25Mb2FkaW5nQ29tcGxldGVSZWYsIHNldEJsdXJDb21wbGV0ZSwgc2V0U2hvd0FsdFRleHQsIG9uTG9hZCwgb25FcnJvciwgLi4ucmVzdCB9ID0gcGFyYW07XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi8gKDAsIF9qc3hydW50aW1lLmpzeCkoXCJpbWdcIiwge1xuICAgICAgICAuLi5yZXN0LFxuICAgICAgICAuLi5nZXREeW5hbWljUHJvcHMoZmV0Y2hQcmlvcml0eSksXG4gICAgICAgIC8vIEl0J3MgaW50ZW5kZWQgdG8ga2VlcCBgbG9hZGluZ2AgYmVmb3JlIGBzcmNgIGJlY2F1c2UgUmVhY3QgdXBkYXRlc1xuICAgICAgICAvLyBwcm9wcyBpbiBvcmRlciB3aGljaCBjYXVzZXMgU2FmYXJpL0ZpcmVmb3ggdG8gbm90IGxhenkgbG9hZCBwcm9wZXJseS5cbiAgICAgICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMjU4ODNcbiAgICAgICAgbG9hZGluZzogbG9hZGluZyxcbiAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICAgICAgZGVjb2Rpbmc6IGRlY29kaW5nLFxuICAgICAgICBcImRhdGEtbmltZ1wiOiBmaWxsID8gXCJmaWxsXCIgOiBcIjFcIixcbiAgICAgICAgY2xhc3NOYW1lOiBjbGFzc05hbWUsXG4gICAgICAgIHN0eWxlOiBzdHlsZSxcbiAgICAgICAgLy8gSXQncyBpbnRlbmRlZCB0byBrZWVwIGBzcmNgIHRoZSBsYXN0IGF0dHJpYnV0ZSBiZWNhdXNlIFJlYWN0IHVwZGF0ZXNcbiAgICAgICAgLy8gYXR0cmlidXRlcyBpbiBvcmRlci4gSWYgd2Uga2VlcCBgc3JjYCB0aGUgZmlyc3Qgb25lLCBTYWZhcmkgd2lsbFxuICAgICAgICAvLyBpbW1lZGlhdGVseSBzdGFydCB0byBmZXRjaCBgc3JjYCwgYmVmb3JlIGBzaXplc2AgYW5kIGBzcmNTZXRgIGFyZSBldmVuXG4gICAgICAgIC8vIHVwZGF0ZWQgYnkgUmVhY3QuIFRoYXQgY2F1c2VzIG11bHRpcGxlIHVubmVjZXNzYXJ5IHJlcXVlc3RzIGlmIGBzcmNTZXRgXG4gICAgICAgIC8vIGFuZCBgc2l6ZXNgIGFyZSBkZWZpbmVkLlxuICAgICAgICAvLyBUaGlzIGJ1ZyBjYW5ub3QgYmUgcmVwcm9kdWNlZCBpbiBDaHJvbWUgb3IgRmlyZWZveC5cbiAgICAgICAgc2l6ZXM6IHNpemVzLFxuICAgICAgICBzcmNTZXQ6IHNyY1NldCxcbiAgICAgICAgc3JjOiBzcmMsXG4gICAgICAgIHJlZjogKDAsIF9yZWFjdC51c2VDYWxsYmFjaykoKGltZyk9PntcbiAgICAgICAgICAgIGlmIChmb3J3YXJkZWRSZWYpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGZvcndhcmRlZFJlZiA9PT0gXCJmdW5jdGlvblwiKSBmb3J3YXJkZWRSZWYoaW1nKTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgZm9yd2FyZGVkUmVmID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmUgLSAuY3VycmVudCBpcyByZWFkIG9ubHkgaXQncyB1c3VhbGx5IGFzc2lnbmVkIGJ5IHJlYWN0IGludGVybmFsbHlcbiAgICAgICAgICAgICAgICAgICAgZm9yd2FyZGVkUmVmLmN1cnJlbnQgPSBpbWc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFpbWcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob25FcnJvcikge1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBpbWFnZSBoYXMgYW4gZXJyb3IgYmVmb3JlIHJlYWN0IGh5ZHJhdGVzLCB0aGVuIHRoZSBlcnJvciBpcyBsb3N0LlxuICAgICAgICAgICAgICAgIC8vIFRoZSB3b3JrYXJvdW5kIGlzIHRvIHdhaXQgdW50aWwgdGhlIGltYWdlIGlzIG1vdW50ZWQgd2hpY2ggaXMgYWZ0ZXIgaHlkcmF0aW9uLFxuICAgICAgICAgICAgICAgIC8vIHRoZW4gd2Ugc2V0IHRoZSBzcmMgYWdhaW4gdG8gdHJpZ2dlciB0aGUgZXJyb3IgaGFuZGxlciAoaWYgdGhlcmUgd2FzIGFuIGVycm9yKS5cbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1hc3NpZ25cbiAgICAgICAgICAgICAgICBpbWcuc3JjID0gaW1nLnNyYztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXNyYykge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdJbWFnZSBpcyBtaXNzaW5nIHJlcXVpcmVkIFwic3JjXCIgcHJvcGVydHk6JywgaW1nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGltZy5nZXRBdHRyaWJ1dGUoXCJhbHRcIikgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignSW1hZ2UgaXMgbWlzc2luZyByZXF1aXJlZCBcImFsdFwiIHByb3BlcnR5LiBQbGVhc2UgYWRkIEFsdGVybmF0aXZlIFRleHQgdG8gZGVzY3JpYmUgdGhlIGltYWdlIGZvciBzY3JlZW4gcmVhZGVycyBhbmQgc2VhcmNoIGVuZ2luZXMuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGltZy5jb21wbGV0ZSkge1xuICAgICAgICAgICAgICAgIGhhbmRsZUxvYWRpbmcoaW1nLCBwbGFjZWhvbGRlciwgb25Mb2FkUmVmLCBvbkxvYWRpbmdDb21wbGV0ZVJlZiwgc2V0Qmx1ckNvbXBsZXRlLCB1bm9wdGltaXplZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIFtcbiAgICAgICAgICAgIHNyYyxcbiAgICAgICAgICAgIHBsYWNlaG9sZGVyLFxuICAgICAgICAgICAgb25Mb2FkUmVmLFxuICAgICAgICAgICAgb25Mb2FkaW5nQ29tcGxldGVSZWYsXG4gICAgICAgICAgICBzZXRCbHVyQ29tcGxldGUsXG4gICAgICAgICAgICBvbkVycm9yLFxuICAgICAgICAgICAgdW5vcHRpbWl6ZWQsXG4gICAgICAgICAgICBmb3J3YXJkZWRSZWZcbiAgICAgICAgXSksXG4gICAgICAgIG9uTG9hZDogKGV2ZW50KT0+e1xuICAgICAgICAgICAgY29uc3QgaW1nID0gZXZlbnQuY3VycmVudFRhcmdldDtcbiAgICAgICAgICAgIGhhbmRsZUxvYWRpbmcoaW1nLCBwbGFjZWhvbGRlciwgb25Mb2FkUmVmLCBvbkxvYWRpbmdDb21wbGV0ZVJlZiwgc2V0Qmx1ckNvbXBsZXRlLCB1bm9wdGltaXplZCk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uRXJyb3I6IChldmVudCk9PntcbiAgICAgICAgICAgIC8vIGlmIHRoZSByZWFsIGltYWdlIGZhaWxzIHRvIGxvYWQsIHRoaXMgd2lsbCBlbnN1cmUgXCJhbHRcIiBpcyB2aXNpYmxlXG4gICAgICAgICAgICBzZXRTaG93QWx0VGV4dCh0cnVlKTtcbiAgICAgICAgICAgIGlmIChwbGFjZWhvbGRlciAhPT0gXCJlbXB0eVwiKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIHJlYWwgaW1hZ2UgZmFpbHMgdG8gbG9hZCwgdGhpcyB3aWxsIHN0aWxsIHJlbW92ZSB0aGUgcGxhY2Vob2xkZXIuXG4gICAgICAgICAgICAgICAgc2V0Qmx1ckNvbXBsZXRlKHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9uRXJyb3IpIHtcbiAgICAgICAgICAgICAgICBvbkVycm9yKGV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xufSk7XG5mdW5jdGlvbiBJbWFnZVByZWxvYWQocGFyYW0pIHtcbiAgICBsZXQgeyBpc0FwcFJvdXRlciwgaW1nQXR0cmlidXRlcyB9ID0gcGFyYW07XG4gICAgY29uc3Qgb3B0cyA9IHtcbiAgICAgICAgYXM6IFwiaW1hZ2VcIixcbiAgICAgICAgaW1hZ2VTcmNTZXQ6IGltZ0F0dHJpYnV0ZXMuc3JjU2V0LFxuICAgICAgICBpbWFnZVNpemVzOiBpbWdBdHRyaWJ1dGVzLnNpemVzLFxuICAgICAgICBjcm9zc09yaWdpbjogaW1nQXR0cmlidXRlcy5jcm9zc09yaWdpbixcbiAgICAgICAgcmVmZXJyZXJQb2xpY3k6IGltZ0F0dHJpYnV0ZXMucmVmZXJyZXJQb2xpY3ksXG4gICAgICAgIC4uLmdldER5bmFtaWNQcm9wcyhpbWdBdHRyaWJ1dGVzLmZldGNoUHJpb3JpdHkpXG4gICAgfTtcbiAgICBpZiAoaXNBcHBSb3V0ZXIgJiYgX3JlYWN0ZG9tLmRlZmF1bHQucHJlbG9hZCkge1xuICAgICAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L3B1bGwvMjY5NDBcbiAgICAgICAgX3JlYWN0ZG9tLmRlZmF1bHQucHJlbG9hZChpbWdBdHRyaWJ1dGVzLnNyYywgLy8gQHRzLWV4cGVjdC1lcnJvciBUT0RPOiB1cGdyYWRlIHRvIGBAdHlwZXMvcmVhY3QtZG9tQDE4LjMueGBcbiAgICAgICAgb3B0cyk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gLyojX19QVVJFX18qLyAoMCwgX2pzeHJ1bnRpbWUuanN4KShfaGVhZC5kZWZhdWx0LCB7XG4gICAgICAgIGNoaWxkcmVuOiAvKiNfX1BVUkVfXyovICgwLCBfanN4cnVudGltZS5qc3gpKFwibGlua1wiLCB7XG4gICAgICAgICAgICByZWw6IFwicHJlbG9hZFwiLFxuICAgICAgICAgICAgLy8gTm90ZSBob3cgd2Ugb21pdCB0aGUgYGhyZWZgIGF0dHJpYnV0ZSwgYXMgaXQgd291bGQgb25seSBiZSByZWxldmFudFxuICAgICAgICAgICAgLy8gZm9yIGJyb3dzZXJzIHRoYXQgZG8gbm90IHN1cHBvcnQgYGltYWdlc3Jjc2V0YCwgYW5kIGluIHRob3NlIGNhc2VzXG4gICAgICAgICAgICAvLyBpdCB3b3VsZCBjYXVzZSB0aGUgaW5jb3JyZWN0IGltYWdlIHRvIGJlIHByZWxvYWRlZC5cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zZW1hbnRpY3MuaHRtbCNhdHRyLWxpbmstaW1hZ2VzcmNzZXRcbiAgICAgICAgICAgIGhyZWY6IGltZ0F0dHJpYnV0ZXMuc3JjU2V0ID8gdW5kZWZpbmVkIDogaW1nQXR0cmlidXRlcy5zcmMsXG4gICAgICAgICAgICAuLi5vcHRzXG4gICAgICAgIH0sIFwiX19uaW1nLVwiICsgaW1nQXR0cmlidXRlcy5zcmMgKyBpbWdBdHRyaWJ1dGVzLnNyY1NldCArIGltZ0F0dHJpYnV0ZXMuc2l6ZXMpXG4gICAgfSk7XG59XG5jb25zdCBJbWFnZSA9IC8qI19fUFVSRV9fKi8gKDAsIF9yZWFjdC5mb3J3YXJkUmVmKSgocHJvcHMsIGZvcndhcmRlZFJlZik9PntcbiAgICBjb25zdCBwYWdlc1JvdXRlciA9ICgwLCBfcmVhY3QudXNlQ29udGV4dCkoX3JvdXRlcmNvbnRleHRzaGFyZWRydW50aW1lLlJvdXRlckNvbnRleHQpO1xuICAgIC8vIFdlJ3JlIGluIHRoZSBhcHAgZGlyZWN0b3J5IGlmIHRoZXJlIGlzIG5vIHBhZ2VzIHJvdXRlci5cbiAgICBjb25zdCBpc0FwcFJvdXRlciA9ICFwYWdlc1JvdXRlcjtcbiAgICBjb25zdCBjb25maWdDb250ZXh0ID0gKDAsIF9yZWFjdC51c2VDb250ZXh0KShfaW1hZ2Vjb25maWdjb250ZXh0c2hhcmVkcnVudGltZS5JbWFnZUNvbmZpZ0NvbnRleHQpO1xuICAgIGNvbnN0IGNvbmZpZyA9ICgwLCBfcmVhY3QudXNlTWVtbykoKCk9PntcbiAgICAgICAgY29uc3QgYyA9IGNvbmZpZ0VudiB8fCBjb25maWdDb250ZXh0IHx8IF9pbWFnZWNvbmZpZy5pbWFnZUNvbmZpZ0RlZmF1bHQ7XG4gICAgICAgIGNvbnN0IGFsbFNpemVzID0gW1xuICAgICAgICAgICAgLi4uYy5kZXZpY2VTaXplcyxcbiAgICAgICAgICAgIC4uLmMuaW1hZ2VTaXplc1xuICAgICAgICBdLnNvcnQoKGEsIGIpPT5hIC0gYik7XG4gICAgICAgIGNvbnN0IGRldmljZVNpemVzID0gYy5kZXZpY2VTaXplcy5zb3J0KChhLCBiKT0+YSAtIGIpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uYyxcbiAgICAgICAgICAgIGFsbFNpemVzLFxuICAgICAgICAgICAgZGV2aWNlU2l6ZXNcbiAgICAgICAgfTtcbiAgICB9LCBbXG4gICAgICAgIGNvbmZpZ0NvbnRleHRcbiAgICBdKTtcbiAgICBjb25zdCB7IG9uTG9hZCwgb25Mb2FkaW5nQ29tcGxldGUgfSA9IHByb3BzO1xuICAgIGNvbnN0IG9uTG9hZFJlZiA9ICgwLCBfcmVhY3QudXNlUmVmKShvbkxvYWQpO1xuICAgICgwLCBfcmVhY3QudXNlRWZmZWN0KSgoKT0+e1xuICAgICAgICBvbkxvYWRSZWYuY3VycmVudCA9IG9uTG9hZDtcbiAgICB9LCBbXG4gICAgICAgIG9uTG9hZFxuICAgIF0pO1xuICAgIGNvbnN0IG9uTG9hZGluZ0NvbXBsZXRlUmVmID0gKDAsIF9yZWFjdC51c2VSZWYpKG9uTG9hZGluZ0NvbXBsZXRlKTtcbiAgICAoMCwgX3JlYWN0LnVzZUVmZmVjdCkoKCk9PntcbiAgICAgICAgb25Mb2FkaW5nQ29tcGxldGVSZWYuY3VycmVudCA9IG9uTG9hZGluZ0NvbXBsZXRlO1xuICAgIH0sIFtcbiAgICAgICAgb25Mb2FkaW5nQ29tcGxldGVcbiAgICBdKTtcbiAgICBjb25zdCBbYmx1ckNvbXBsZXRlLCBzZXRCbHVyQ29tcGxldGVdID0gKDAsIF9yZWFjdC51c2VTdGF0ZSkoZmFsc2UpO1xuICAgIGNvbnN0IFtzaG93QWx0VGV4dCwgc2V0U2hvd0FsdFRleHRdID0gKDAsIF9yZWFjdC51c2VTdGF0ZSkoZmFsc2UpO1xuICAgIGNvbnN0IHsgcHJvcHM6IGltZ0F0dHJpYnV0ZXMsIG1ldGE6IGltZ01ldGEgfSA9ICgwLCBfZ2V0aW1ncHJvcHMuZ2V0SW1nUHJvcHMpKHByb3BzLCB7XG4gICAgICAgIGRlZmF1bHRMb2FkZXI6IF9pbWFnZWxvYWRlci5kZWZhdWx0LFxuICAgICAgICBpbWdDb25mOiBjb25maWcsXG4gICAgICAgIGJsdXJDb21wbGV0ZSxcbiAgICAgICAgc2hvd0FsdFRleHRcbiAgICB9KTtcbiAgICByZXR1cm4gLyojX19QVVJFX18qLyAoMCwgX2pzeHJ1bnRpbWUuanN4cykoX2pzeHJ1bnRpbWUuRnJhZ21lbnQsIHtcbiAgICAgICAgY2hpbGRyZW46IFtcbiAgICAgICAgICAgIC8qI19fUFVSRV9fKi8gKDAsIF9qc3hydW50aW1lLmpzeCkoSW1hZ2VFbGVtZW50LCB7XG4gICAgICAgICAgICAgICAgLi4uaW1nQXR0cmlidXRlcyxcbiAgICAgICAgICAgICAgICB1bm9wdGltaXplZDogaW1nTWV0YS51bm9wdGltaXplZCxcbiAgICAgICAgICAgICAgICBwbGFjZWhvbGRlcjogaW1nTWV0YS5wbGFjZWhvbGRlcixcbiAgICAgICAgICAgICAgICBmaWxsOiBpbWdNZXRhLmZpbGwsXG4gICAgICAgICAgICAgICAgb25Mb2FkUmVmOiBvbkxvYWRSZWYsXG4gICAgICAgICAgICAgICAgb25Mb2FkaW5nQ29tcGxldGVSZWY6IG9uTG9hZGluZ0NvbXBsZXRlUmVmLFxuICAgICAgICAgICAgICAgIHNldEJsdXJDb21wbGV0ZTogc2V0Qmx1ckNvbXBsZXRlLFxuICAgICAgICAgICAgICAgIHNldFNob3dBbHRUZXh0OiBzZXRTaG93QWx0VGV4dCxcbiAgICAgICAgICAgICAgICByZWY6IGZvcndhcmRlZFJlZlxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBpbWdNZXRhLnByaW9yaXR5ID8gLyojX19QVVJFX18qLyAoMCwgX2pzeHJ1bnRpbWUuanN4KShJbWFnZVByZWxvYWQsIHtcbiAgICAgICAgICAgICAgICBpc0FwcFJvdXRlcjogaXNBcHBSb3V0ZXIsXG4gICAgICAgICAgICAgICAgaW1nQXR0cmlidXRlczogaW1nQXR0cmlidXRlc1xuICAgICAgICAgICAgfSkgOiBudWxsXG4gICAgICAgIF1cbiAgICB9KTtcbn0pO1xuXG5pZiAoKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdmdW5jdGlvbicgfHwgKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdvYmplY3QnICYmIGV4cG9ydHMuZGVmYXVsdCAhPT0gbnVsbCkpICYmIHR5cGVvZiBleHBvcnRzLmRlZmF1bHQuX19lc01vZHVsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMuZGVmYXVsdCwgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuICBPYmplY3QuYXNzaWduKGV4cG9ydHMuZGVmYXVsdCwgZXhwb3J0cyk7XG4gIG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbWFnZS1jb21wb25lbnQuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiZW51bWVyYWJsZSIsImdldCIsIkltYWdlIiwiX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0IiwicmVxdWlyZSIsIl9pbnRlcm9wX3JlcXVpcmVfd2lsZGNhcmQiLCJfanN4cnVudGltZSIsIl9yZWFjdCIsIl8iLCJfcmVhY3Rkb20iLCJfaGVhZCIsIl9nZXRpbWdwcm9wcyIsIl9pbWFnZWNvbmZpZyIsIl9pbWFnZWNvbmZpZ2NvbnRleHRzaGFyZWRydW50aW1lIiwiX3dhcm5vbmNlIiwiX3JvdXRlcmNvbnRleHRzaGFyZWRydW50aW1lIiwiX2ltYWdlbG9hZGVyIiwiY29uZmlnRW52IiwicHJvY2VzcyIsImVudiIsIl9fTkVYVF9JTUFHRV9PUFRTIiwiZ2xvYmFsVGhpcyIsIl9fTkVYVF9JTUFHRV9JTVBPUlRFRCIsImhhbmRsZUxvYWRpbmciLCJpbWciLCJwbGFjZWhvbGRlciIsIm9uTG9hZFJlZiIsIm9uTG9hZGluZ0NvbXBsZXRlUmVmIiwic2V0Qmx1ckNvbXBsZXRlIiwidW5vcHRpbWl6ZWQiLCJzcmMiLCJwIiwiZGVjb2RlIiwiUHJvbWlzZSIsInJlc29sdmUiLCJjYXRjaCIsInRoZW4iLCJwYXJlbnRFbGVtZW50IiwiaXNDb25uZWN0ZWQiLCJjdXJyZW50IiwiZXZlbnQiLCJFdmVudCIsIndyaXRhYmxlIiwicHJldmVudGVkIiwic3RvcHBlZCIsIm5hdGl2ZUV2ZW50IiwiY3VycmVudFRhcmdldCIsInRhcmdldCIsImlzRGVmYXVsdFByZXZlbnRlZCIsImlzUHJvcGFnYXRpb25TdG9wcGVkIiwicGVyc2lzdCIsInByZXZlbnREZWZhdWx0Iiwic3RvcFByb3BhZ2F0aW9uIiwib3JpZ1NyYyIsIlVSTCIsInNlYXJjaFBhcmFtcyIsImdldEF0dHJpYnV0ZSIsIndpZHRoVmlld3BvcnRSYXRpbyIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsIndpZHRoIiwid2luZG93IiwiaW5uZXJXaWR0aCIsIndhcm5PbmNlIiwicG9zaXRpb24iLCJnZXRDb21wdXRlZFN0eWxlIiwidmFsaWQiLCJpbmNsdWRlcyIsIm1hcCIsIlN0cmluZyIsImpvaW4iLCJoZWlnaHQiLCJoZWlnaHRNb2RpZmllZCIsInRvU3RyaW5nIiwid2lkdGhNb2RpZmllZCIsImdldER5bmFtaWNQcm9wcyIsImZldGNoUHJpb3JpdHkiLCJtYWpvclN0ciIsIm1pbm9yU3RyIiwidmVyc2lvbiIsInNwbGl0IiwibWFqb3IiLCJwYXJzZUludCIsIm1pbm9yIiwiZmV0Y2hwcmlvcml0eSIsIkltYWdlRWxlbWVudCIsImZvcndhcmRSZWYiLCJwYXJhbSIsImZvcndhcmRlZFJlZiIsInNyY1NldCIsInNpemVzIiwiZGVjb2RpbmciLCJjbGFzc05hbWUiLCJzdHlsZSIsImxvYWRpbmciLCJmaWxsIiwic2V0U2hvd0FsdFRleHQiLCJvbkxvYWQiLCJvbkVycm9yIiwicmVzdCIsImpzeCIsInJlZiIsInVzZUNhbGxiYWNrIiwiY29uc29sZSIsImVycm9yIiwiY29tcGxldGUiLCJJbWFnZVByZWxvYWQiLCJpc0FwcFJvdXRlciIsImltZ0F0dHJpYnV0ZXMiLCJvcHRzIiwiYXMiLCJpbWFnZVNyY1NldCIsImltYWdlU2l6ZXMiLCJjcm9zc09yaWdpbiIsInJlZmVycmVyUG9saWN5IiwiZGVmYXVsdCIsInByZWxvYWQiLCJjaGlsZHJlbiIsInJlbCIsImhyZWYiLCJ1bmRlZmluZWQiLCJwcm9wcyIsInBhZ2VzUm91dGVyIiwidXNlQ29udGV4dCIsIlJvdXRlckNvbnRleHQiLCJjb25maWdDb250ZXh0IiwiSW1hZ2VDb25maWdDb250ZXh0IiwiY29uZmlnIiwidXNlTWVtbyIsImMiLCJpbWFnZUNvbmZpZ0RlZmF1bHQiLCJhbGxTaXplcyIsImRldmljZVNpemVzIiwic29ydCIsImEiLCJiIiwib25Mb2FkaW5nQ29tcGxldGUiLCJ1c2VSZWYiLCJ1c2VFZmZlY3QiLCJibHVyQ29tcGxldGUiLCJ1c2VTdGF0ZSIsInNob3dBbHRUZXh0IiwibWV0YSIsImltZ01ldGEiLCJnZXRJbWdQcm9wcyIsImRlZmF1bHRMb2FkZXIiLCJpbWdDb25mIiwianN4cyIsIkZyYWdtZW50IiwicHJpb3JpdHkiLCJfX2VzTW9kdWxlIiwiYXNzaWduIiwibW9kdWxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/image-component.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/amp-context.shared-runtime.js":
/*!*************************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/amp-context.shared-runtime.js ***!
  \*************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"AmpStateContext\", ({\n    enumerable: true,\n    get: function() {\n        return AmpStateContext;\n    }\n}));\nconst _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_interop_require_default.js\");\nconst _react = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\"));\nconst AmpStateContext = _react.default.createContext({});\nif (true) {\n    AmpStateContext.displayName = \"AmpStateContext\";\n} //# sourceMappingURL=amp-context.shared-runtime.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9hbXAtY29udGV4dC5zaGFyZWQtcnVudGltZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU87QUFDWCxDQUFDLEVBQUM7QUFDRkgsbURBQWtEO0lBQzlDSSxZQUFZO0lBQ1pDLEtBQUs7UUFDRCxPQUFPQztJQUNYO0FBQ0osQ0FBQyxFQUFDO0FBQ0YsTUFBTUMsMkJBQTJCQyxtQkFBT0EsQ0FBQyxnSUFBeUM7QUFDbEYsTUFBTUMsU0FBUyxXQUFXLEdBQUdGLHlCQUF5QkcsQ0FBQyxDQUFDRixtQkFBT0EsQ0FBQyxtRkFBTztBQUN2RSxNQUFNRixrQkFBa0JHLE9BQU9FLE9BQU8sQ0FBQ0MsYUFBYSxDQUFDLENBQUM7QUFDdEQsSUFBSUMsSUFBcUMsRUFBRTtJQUN2Q1AsZ0JBQWdCUSxXQUFXLEdBQUc7QUFDbEMsRUFFQSxzREFBc0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zaGFyZWQvbGliL2FtcC1jb250ZXh0LnNoYXJlZC1ydW50aW1lLmpzPzk4YjciXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJBbXBTdGF0ZUNvbnRleHRcIiwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIEFtcFN0YXRlQ29udGV4dDtcbiAgICB9XG59KTtcbmNvbnN0IF9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdCA9IHJlcXVpcmUoXCJAc3djL2hlbHBlcnMvXy9faW50ZXJvcF9yZXF1aXJlX2RlZmF1bHRcIik7XG5jb25zdCBfcmVhY3QgPSAvKiNfX1BVUkVfXyovIF9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdC5fKHJlcXVpcmUoXCJyZWFjdFwiKSk7XG5jb25zdCBBbXBTdGF0ZUNvbnRleHQgPSBfcmVhY3QuZGVmYXVsdC5jcmVhdGVDb250ZXh0KHt9KTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICBBbXBTdGF0ZUNvbnRleHQuZGlzcGxheU5hbWUgPSBcIkFtcFN0YXRlQ29udGV4dFwiO1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1hbXAtY29udGV4dC5zaGFyZWQtcnVudGltZS5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJlbnVtZXJhYmxlIiwiZ2V0IiwiQW1wU3RhdGVDb250ZXh0IiwiX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0IiwicmVxdWlyZSIsIl9yZWFjdCIsIl8iLCJkZWZhdWx0IiwiY3JlYXRlQ29udGV4dCIsInByb2Nlc3MiLCJkaXNwbGF5TmFtZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/amp-context.shared-runtime.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/amp-mode.js":
/*!*******************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/amp-mode.js ***!
  \*******************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"isInAmpMode\", ({\n    enumerable: true,\n    get: function() {\n        return isInAmpMode;\n    }\n}));\nfunction isInAmpMode(param) {\n    let { ampFirst = false, hybrid = false, hasQuery = false } = param === void 0 ? {} : param;\n    return ampFirst || hybrid && hasQuery;\n} //# sourceMappingURL=amp-mode.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9hbXAtbW9kZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU87QUFDWCxDQUFDLEVBQUM7QUFDRkgsK0NBQThDO0lBQzFDSSxZQUFZO0lBQ1pDLEtBQUs7UUFDRCxPQUFPQztJQUNYO0FBQ0osQ0FBQyxFQUFDO0FBQ0YsU0FBU0EsWUFBWUMsS0FBSztJQUN0QixJQUFJLEVBQUVDLFdBQVcsS0FBSyxFQUFFQyxTQUFTLEtBQUssRUFBRUMsV0FBVyxLQUFLLEVBQUUsR0FBR0gsVUFBVSxLQUFLLElBQUksQ0FBQyxJQUFJQTtJQUNyRixPQUFPQyxZQUFZQyxVQUFVQztBQUNqQyxFQUVBLG9DQUFvQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvYW1wLW1vZGUuanM/NjIzMSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImlzSW5BbXBNb2RlXCIsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBpc0luQW1wTW9kZTtcbiAgICB9XG59KTtcbmZ1bmN0aW9uIGlzSW5BbXBNb2RlKHBhcmFtKSB7XG4gICAgbGV0IHsgYW1wRmlyc3QgPSBmYWxzZSwgaHlicmlkID0gZmFsc2UsIGhhc1F1ZXJ5ID0gZmFsc2UgfSA9IHBhcmFtID09PSB2b2lkIDAgPyB7fSA6IHBhcmFtO1xuICAgIHJldHVybiBhbXBGaXJzdCB8fCBoeWJyaWQgJiYgaGFzUXVlcnk7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFtcC1tb2RlLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImVudW1lcmFibGUiLCJnZXQiLCJpc0luQW1wTW9kZSIsInBhcmFtIiwiYW1wRmlyc3QiLCJoeWJyaWQiLCJoYXNRdWVyeSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/amp-mode.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/get-img-props.js":
/*!************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/get-img-props.js ***!
  \************************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"getImgProps\", ({\n    enumerable: true,\n    get: function() {\n        return getImgProps;\n    }\n}));\nconst _warnonce = __webpack_require__(/*! ./utils/warn-once */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/utils/warn-once.js\");\nconst _imageblursvg = __webpack_require__(/*! ./image-blur-svg */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/image-blur-svg.js\");\nconst _imageconfig = __webpack_require__(/*! ./image-config */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/image-config.js\");\nconst VALID_LOADING_VALUES = [\n    \"lazy\",\n    \"eager\",\n    undefined\n];\nfunction isStaticRequire(src) {\n    return src.default !== undefined;\n}\nfunction isStaticImageData(src) {\n    return src.src !== undefined;\n}\nfunction isStaticImport(src) {\n    return typeof src === \"object\" && (isStaticRequire(src) || isStaticImageData(src));\n}\nconst allImgs = new Map();\nlet perfObserver;\nfunction getInt(x) {\n    if (typeof x === \"undefined\") {\n        return x;\n    }\n    if (typeof x === \"number\") {\n        return Number.isFinite(x) ? x : NaN;\n    }\n    if (typeof x === \"string\" && /^[0-9]+$/.test(x)) {\n        return parseInt(x, 10);\n    }\n    return NaN;\n}\nfunction getWidths(param, width, sizes) {\n    let { deviceSizes, allSizes } = param;\n    if (sizes) {\n        // Find all the \"vw\" percent sizes used in the sizes prop\n        const viewportWidthRe = /(^|\\s)(1?\\d?\\d)vw/g;\n        const percentSizes = [];\n        for(let match; match = viewportWidthRe.exec(sizes); match){\n            percentSizes.push(parseInt(match[2]));\n        }\n        if (percentSizes.length) {\n            const smallestRatio = Math.min(...percentSizes) * 0.01;\n            return {\n                widths: allSizes.filter((s)=>s >= deviceSizes[0] * smallestRatio),\n                kind: \"w\"\n            };\n        }\n        return {\n            widths: allSizes,\n            kind: \"w\"\n        };\n    }\n    if (typeof width !== \"number\") {\n        return {\n            widths: deviceSizes,\n            kind: \"w\"\n        };\n    }\n    const widths = [\n        ...new Set(// > are actually 3x in the green color, but only 1.5x in the red and\n        // > blue colors. Showing a 3x resolution image in the app vs a 2x\n        // > resolution image will be visually the same, though the 3x image\n        // > takes significantly more data. Even true 3x resolution screens are\n        // > wasteful as the human eye cannot see that level of detail without\n        // > something like a magnifying glass.\n        // https://blog.twitter.com/engineering/en_us/topics/infrastructure/2019/capping-image-fidelity-on-ultra-high-resolution-devices.html\n        [\n            width,\n            width * 2 /*, width * 3*/ \n        ].map((w)=>allSizes.find((p)=>p >= w) || allSizes[allSizes.length - 1]))\n    ];\n    return {\n        widths,\n        kind: \"x\"\n    };\n}\nfunction generateImgAttrs(param) {\n    let { config, src, unoptimized, width, quality, sizes, loader } = param;\n    if (unoptimized) {\n        return {\n            src,\n            srcSet: undefined,\n            sizes: undefined\n        };\n    }\n    const { widths, kind } = getWidths(config, width, sizes);\n    const last = widths.length - 1;\n    return {\n        sizes: !sizes && kind === \"w\" ? \"100vw\" : sizes,\n        srcSet: widths.map((w, i)=>loader({\n                config,\n                src,\n                quality,\n                width: w\n            }) + \" \" + (kind === \"w\" ? w : i + 1) + kind).join(\", \"),\n        // It's intended to keep `src` the last attribute because React updates\n        // attributes in order. If we keep `src` the first one, Safari will\n        // immediately start to fetch `src`, before `sizes` and `srcSet` are even\n        // updated by React. That causes multiple unnecessary requests if `srcSet`\n        // and `sizes` are defined.\n        // This bug cannot be reproduced in Chrome or Firefox.\n        src: loader({\n            config,\n            src,\n            quality,\n            width: widths[last]\n        })\n    };\n}\nfunction getImgProps(param, _state) {\n    let { src, sizes, unoptimized = false, priority = false, loading, className, quality, width, height, fill = false, style, onLoad, onLoadingComplete, placeholder = \"empty\", blurDataURL, fetchPriority, layout, objectFit, objectPosition, lazyBoundary, lazyRoot, ...rest } = param;\n    const { imgConf, showAltText, blurComplete, defaultLoader } = _state;\n    let config;\n    let c = imgConf || _imageconfig.imageConfigDefault;\n    if (\"allSizes\" in c) {\n        config = c;\n    } else {\n        const allSizes = [\n            ...c.deviceSizes,\n            ...c.imageSizes\n        ].sort((a, b)=>a - b);\n        const deviceSizes = c.deviceSizes.sort((a, b)=>a - b);\n        config = {\n            ...c,\n            allSizes,\n            deviceSizes\n        };\n    }\n    let loader = rest.loader || defaultLoader;\n    // Remove property so it's not spread on <img> element\n    delete rest.loader;\n    delete rest.srcSet;\n    // This special value indicates that the user\n    // didn't define a \"loader\" prop or \"loader\" config.\n    const isDefaultLoader = \"__next_img_default\" in loader;\n    if (isDefaultLoader) {\n        if (config.loader === \"custom\") {\n            throw new Error('Image with src \"' + src + '\" is missing \"loader\" prop.' + \"\\nRead more: https://nextjs.org/docs/messages/next-image-missing-loader\");\n        }\n    } else {\n        // The user defined a \"loader\" prop or config.\n        // Since the config object is internal only, we\n        // must not pass it to the user-defined \"loader\".\n        const customImageLoader = loader;\n        loader = (obj)=>{\n            const { config: _, ...opts } = obj;\n            return customImageLoader(opts);\n        };\n    }\n    if (layout) {\n        if (layout === \"fill\") {\n            fill = true;\n        }\n        const layoutToStyle = {\n            intrinsic: {\n                maxWidth: \"100%\",\n                height: \"auto\"\n            },\n            responsive: {\n                width: \"100%\",\n                height: \"auto\"\n            }\n        };\n        const layoutToSizes = {\n            responsive: \"100vw\",\n            fill: \"100vw\"\n        };\n        const layoutStyle = layoutToStyle[layout];\n        if (layoutStyle) {\n            style = {\n                ...style,\n                ...layoutStyle\n            };\n        }\n        const layoutSizes = layoutToSizes[layout];\n        if (layoutSizes && !sizes) {\n            sizes = layoutSizes;\n        }\n    }\n    let staticSrc = \"\";\n    let widthInt = getInt(width);\n    let heightInt = getInt(height);\n    let blurWidth;\n    let blurHeight;\n    if (isStaticImport(src)) {\n        const staticImageData = isStaticRequire(src) ? src.default : src;\n        if (!staticImageData.src) {\n            throw new Error(\"An object should only be passed to the image component src parameter if it comes from a static image import. It must include src. Received \" + JSON.stringify(staticImageData));\n        }\n        if (!staticImageData.height || !staticImageData.width) {\n            throw new Error(\"An object should only be passed to the image component src parameter if it comes from a static image import. It must include height and width. Received \" + JSON.stringify(staticImageData));\n        }\n        blurWidth = staticImageData.blurWidth;\n        blurHeight = staticImageData.blurHeight;\n        blurDataURL = blurDataURL || staticImageData.blurDataURL;\n        staticSrc = staticImageData.src;\n        if (!fill) {\n            if (!widthInt && !heightInt) {\n                widthInt = staticImageData.width;\n                heightInt = staticImageData.height;\n            } else if (widthInt && !heightInt) {\n                const ratio = widthInt / staticImageData.width;\n                heightInt = Math.round(staticImageData.height * ratio);\n            } else if (!widthInt && heightInt) {\n                const ratio = heightInt / staticImageData.height;\n                widthInt = Math.round(staticImageData.width * ratio);\n            }\n        }\n    }\n    src = typeof src === \"string\" ? src : staticSrc;\n    let isLazy = !priority && (loading === \"lazy\" || typeof loading === \"undefined\");\n    if (!src || src.startsWith(\"data:\") || src.startsWith(\"blob:\")) {\n        // https://developer.mozilla.org/docs/Web/HTTP/Basics_of_HTTP/Data_URIs\n        unoptimized = true;\n        isLazy = false;\n    }\n    if (config.unoptimized) {\n        unoptimized = true;\n    }\n    if (isDefaultLoader && src.endsWith(\".svg\") && !config.dangerouslyAllowSVG) {\n        // Special case to make svg serve as-is to avoid proxying\n        // through the built-in Image Optimization API.\n        unoptimized = true;\n    }\n    if (priority) {\n        fetchPriority = \"high\";\n    }\n    const qualityInt = getInt(quality);\n    if (true) {\n        if (config.output === \"export\" && isDefaultLoader && !unoptimized) {\n            throw new Error(\"Image Optimization using the default loader is not compatible with `{ output: 'export' }`.\\n  Possible solutions:\\n    - Remove `{ output: 'export' }` and run \\\"next start\\\" to run server mode including the Image Optimization API.\\n    - Configure `{ images: { unoptimized: true } }` in `next.config.js` to disable the Image Optimization API.\\n  Read more: https://nextjs.org/docs/messages/export-image-api\");\n        }\n        if (!src) {\n            // React doesn't show the stack trace and there's\n            // no `src` to help identify which image, so we\n            // instead console.error(ref) during mount.\n            unoptimized = true;\n        } else {\n            if (fill) {\n                if (width) {\n                    throw new Error('Image with src \"' + src + '\" has both \"width\" and \"fill\" properties. Only one should be used.');\n                }\n                if (height) {\n                    throw new Error('Image with src \"' + src + '\" has both \"height\" and \"fill\" properties. Only one should be used.');\n                }\n                if ((style == null ? void 0 : style.position) && style.position !== \"absolute\") {\n                    throw new Error('Image with src \"' + src + '\" has both \"fill\" and \"style.position\" properties. Images with \"fill\" always use position absolute - it cannot be modified.');\n                }\n                if ((style == null ? void 0 : style.width) && style.width !== \"100%\") {\n                    throw new Error('Image with src \"' + src + '\" has both \"fill\" and \"style.width\" properties. Images with \"fill\" always use width 100% - it cannot be modified.');\n                }\n                if ((style == null ? void 0 : style.height) && style.height !== \"100%\") {\n                    throw new Error('Image with src \"' + src + '\" has both \"fill\" and \"style.height\" properties. Images with \"fill\" always use height 100% - it cannot be modified.');\n                }\n            } else {\n                if (typeof widthInt === \"undefined\") {\n                    throw new Error('Image with src \"' + src + '\" is missing required \"width\" property.');\n                } else if (isNaN(widthInt)) {\n                    throw new Error('Image with src \"' + src + '\" has invalid \"width\" property. Expected a numeric value in pixels but received \"' + width + '\".');\n                }\n                if (typeof heightInt === \"undefined\") {\n                    throw new Error('Image with src \"' + src + '\" is missing required \"height\" property.');\n                } else if (isNaN(heightInt)) {\n                    throw new Error('Image with src \"' + src + '\" has invalid \"height\" property. Expected a numeric value in pixels but received \"' + height + '\".');\n                }\n            }\n        }\n        if (!VALID_LOADING_VALUES.includes(loading)) {\n            throw new Error('Image with src \"' + src + '\" has invalid \"loading\" property. Provided \"' + loading + '\" should be one of ' + VALID_LOADING_VALUES.map(String).join(\",\") + \".\");\n        }\n        if (priority && loading === \"lazy\") {\n            throw new Error('Image with src \"' + src + '\" has both \"priority\" and \"loading=\\'lazy\\'\" properties. Only one should be used.');\n        }\n        if (placeholder !== \"empty\" && placeholder !== \"blur\" && !placeholder.startsWith(\"data:image/\")) {\n            throw new Error('Image with src \"' + src + '\" has invalid \"placeholder\" property \"' + placeholder + '\".');\n        }\n        if (placeholder !== \"empty\") {\n            if (widthInt && heightInt && widthInt * heightInt < 1600) {\n                (0, _warnonce.warnOnce)('Image with src \"' + src + '\" is smaller than 40x40. Consider removing the \"placeholder\" property to improve performance.');\n            }\n        }\n        if (placeholder === \"blur\" && !blurDataURL) {\n            const VALID_BLUR_EXT = [\n                \"jpeg\",\n                \"png\",\n                \"webp\",\n                \"avif\"\n            ] // should match next-image-loader\n            ;\n            throw new Error('Image with src \"' + src + '\" has \"placeholder=\\'blur\\'\" property but is missing the \"blurDataURL\" property.\\n        Possible solutions:\\n          - Add a \"blurDataURL\" property, the contents should be a small Data URL to represent the image\\n          - Change the \"src\" property to a static import with one of the supported file types: ' + VALID_BLUR_EXT.join(\",\") + ' (animated images not supported)\\n          - Remove the \"placeholder\" property, effectively no blur effect\\n        Read more: https://nextjs.org/docs/messages/placeholder-blur-data-url');\n        }\n        if (\"ref\" in rest) {\n            (0, _warnonce.warnOnce)('Image with src \"' + src + '\" is using unsupported \"ref\" property. Consider using the \"onLoad\" property instead.');\n        }\n        if (!unoptimized && !isDefaultLoader) {\n            const urlStr = loader({\n                config,\n                src,\n                width: widthInt || 400,\n                quality: qualityInt || 75\n            });\n            let url;\n            try {\n                url = new URL(urlStr);\n            } catch (err) {}\n            if (urlStr === src || url && url.pathname === src && !url.search) {\n                (0, _warnonce.warnOnce)('Image with src \"' + src + '\" has a \"loader\" property that does not implement width. Please implement it or use the \"unoptimized\" property instead.' + \"\\nRead more: https://nextjs.org/docs/messages/next-image-missing-loader-width\");\n            }\n        }\n        if (onLoadingComplete) {\n            (0, _warnonce.warnOnce)('Image with src \"' + src + '\" is using deprecated \"onLoadingComplete\" property. Please use the \"onLoad\" property instead.');\n        }\n        for (const [legacyKey, legacyValue] of Object.entries({\n            layout,\n            objectFit,\n            objectPosition,\n            lazyBoundary,\n            lazyRoot\n        })){\n            if (legacyValue) {\n                (0, _warnonce.warnOnce)('Image with src \"' + src + '\" has legacy prop \"' + legacyKey + '\". Did you forget to run the codemod?' + \"\\nRead more: https://nextjs.org/docs/messages/next-image-upgrade-to-13\");\n            }\n        }\n        if ( true && !perfObserver && window.PerformanceObserver) {\n            perfObserver = new PerformanceObserver((entryList)=>{\n                for (const entry of entryList.getEntries()){\n                    var _entry_element;\n                    // @ts-ignore - missing \"LargestContentfulPaint\" class with \"element\" prop\n                    const imgSrc = (entry == null ? void 0 : (_entry_element = entry.element) == null ? void 0 : _entry_element.src) || \"\";\n                    const lcpImage = allImgs.get(imgSrc);\n                    if (lcpImage && !lcpImage.priority && lcpImage.placeholder === \"empty\" && !lcpImage.src.startsWith(\"data:\") && !lcpImage.src.startsWith(\"blob:\")) {\n                        // https://web.dev/lcp/#measure-lcp-in-javascript\n                        (0, _warnonce.warnOnce)('Image with src \"' + lcpImage.src + '\" was detected as the Largest Contentful Paint (LCP). Please add the \"priority\" property if this image is above the fold.' + \"\\nRead more: https://nextjs.org/docs/api-reference/next/image#priority\");\n                    }\n                }\n            });\n            try {\n                perfObserver.observe({\n                    type: \"largest-contentful-paint\",\n                    buffered: true\n                });\n            } catch (err) {\n                // Log error but don't crash the app\n                console.error(err);\n            }\n        }\n    }\n    const imgStyle = Object.assign(fill ? {\n        position: \"absolute\",\n        height: \"100%\",\n        width: \"100%\",\n        left: 0,\n        top: 0,\n        right: 0,\n        bottom: 0,\n        objectFit,\n        objectPosition\n    } : {}, showAltText ? {} : {\n        color: \"transparent\"\n    }, style);\n    const backgroundImage = !blurComplete && placeholder !== \"empty\" ? placeholder === \"blur\" ? 'url(\"data:image/svg+xml;charset=utf-8,' + (0, _imageblursvg.getImageBlurSvg)({\n        widthInt,\n        heightInt,\n        blurWidth,\n        blurHeight,\n        blurDataURL: blurDataURL || \"\",\n        objectFit: imgStyle.objectFit\n    }) + '\")' : 'url(\"' + placeholder + '\")' // assume `data:image/`\n     : null;\n    let placeholderStyle = backgroundImage ? {\n        backgroundSize: imgStyle.objectFit || \"cover\",\n        backgroundPosition: imgStyle.objectPosition || \"50% 50%\",\n        backgroundRepeat: \"no-repeat\",\n        backgroundImage\n    } : {};\n    if (true) {\n        if (placeholderStyle.backgroundImage && placeholder === \"blur\" && (blurDataURL == null ? void 0 : blurDataURL.startsWith(\"/\"))) {\n            // During `next dev`, we don't want to generate blur placeholders with webpack\n            // because it can delay starting the dev server. Instead, `next-image-loader.js`\n            // will inline a special url to lazily generate the blur placeholder at request time.\n            placeholderStyle.backgroundImage = 'url(\"' + blurDataURL + '\")';\n        }\n    }\n    const imgAttributes = generateImgAttrs({\n        config,\n        src,\n        unoptimized,\n        width: widthInt,\n        quality: qualityInt,\n        sizes,\n        loader\n    });\n    if (true) {\n        if (true) {\n            let fullUrl;\n            try {\n                fullUrl = new URL(imgAttributes.src);\n            } catch (e) {\n                fullUrl = new URL(imgAttributes.src, window.location.href);\n            }\n            allImgs.set(fullUrl.href, {\n                src,\n                priority,\n                placeholder\n            });\n        }\n    }\n    const props = {\n        ...rest,\n        loading: isLazy ? \"lazy\" : loading,\n        fetchPriority,\n        width: widthInt,\n        height: heightInt,\n        decoding: \"async\",\n        className,\n        style: {\n            ...imgStyle,\n            ...placeholderStyle\n        },\n        sizes: imgAttributes.sizes,\n        srcSet: imgAttributes.srcSet,\n        src: imgAttributes.src\n    };\n    const meta = {\n        unoptimized,\n        priority,\n        placeholder,\n        fill\n    };\n    return {\n        props,\n        meta\n    };\n} //# sourceMappingURL=get-img-props.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9nZXQtaW1nLXByb3BzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUN6Q0csT0FBTztBQUNYLENBQUMsRUFBQztBQUNGSCwrQ0FBOEM7SUFDMUNJLFlBQVk7SUFDWkMsS0FBSztRQUNELE9BQU9DO0lBQ1g7QUFDSixDQUFDLEVBQUM7QUFDRixNQUFNQyxZQUFZQyxtQkFBT0EsQ0FBQyxxR0FBbUI7QUFDN0MsTUFBTUMsZ0JBQWdCRCxtQkFBT0EsQ0FBQyxtR0FBa0I7QUFDaEQsTUFBTUUsZUFBZUYsbUJBQU9BLENBQUMsK0ZBQWdCO0FBQzdDLE1BQU1HLHVCQUF1QjtJQUN6QjtJQUNBO0lBQ0FDO0NBQ0g7QUFDRCxTQUFTQyxnQkFBZ0JDLEdBQUc7SUFDeEIsT0FBT0EsSUFBSUMsT0FBTyxLQUFLSDtBQUMzQjtBQUNBLFNBQVNJLGtCQUFrQkYsR0FBRztJQUMxQixPQUFPQSxJQUFJQSxHQUFHLEtBQUtGO0FBQ3ZCO0FBQ0EsU0FBU0ssZUFBZUgsR0FBRztJQUN2QixPQUFPLE9BQU9BLFFBQVEsWUFBYUQsQ0FBQUEsZ0JBQWdCQyxRQUFRRSxrQkFBa0JGLElBQUc7QUFDcEY7QUFDQSxNQUFNSSxVQUFVLElBQUlDO0FBQ3BCLElBQUlDO0FBQ0osU0FBU0MsT0FBT0MsQ0FBQztJQUNiLElBQUksT0FBT0EsTUFBTSxhQUFhO1FBQzFCLE9BQU9BO0lBQ1g7SUFDQSxJQUFJLE9BQU9BLE1BQU0sVUFBVTtRQUN2QixPQUFPQyxPQUFPQyxRQUFRLENBQUNGLEtBQUtBLElBQUlHO0lBQ3BDO0lBQ0EsSUFBSSxPQUFPSCxNQUFNLFlBQVksV0FBV0ksSUFBSSxDQUFDSixJQUFJO1FBQzdDLE9BQU9LLFNBQVNMLEdBQUc7SUFDdkI7SUFDQSxPQUFPRztBQUNYO0FBQ0EsU0FBU0csVUFBVUMsS0FBSyxFQUFFQyxLQUFLLEVBQUVDLEtBQUs7SUFDbEMsSUFBSSxF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VXBGLGNBQWM7UUFDL0Q7SUFDSjtJQUNBLE1BQU0wRixnQkFBZ0I3RyxpQkFBaUI7UUFDbkNDO1FBQ0F2QztRQUNBd0M7UUFDQXhCLE9BQU95RTtRQUNQaEQsU0FBUzZEO1FBQ1RyRjtRQUNBeUI7SUFDSjtJQUNBLElBQUk2RCxJQUFxQyxFQUFFO1FBQ3ZDLElBQUksSUFBNkIsRUFBRTtZQUMvQixJQUFJNkM7WUFDSixJQUFJO2dCQUNBQSxVQUFVLElBQUluQyxJQUFJa0MsY0FBY25KLEdBQUc7WUFDdkMsRUFBRSxPQUFPcUosR0FBRztnQkFDUkQsVUFBVSxJQUFJbkMsSUFBSWtDLGNBQWNuSixHQUFHLEVBQUV3SCxPQUFPOEIsUUFBUSxDQUFDQyxJQUFJO1lBQzdEO1lBQ0FuSixRQUFRb0osR0FBRyxDQUFDSixRQUFRRyxJQUFJLEVBQUU7Z0JBQ3RCdko7Z0JBQ0FnRDtnQkFDQVE7WUFDSjtRQUNKO0lBQ0o7SUFDQSxNQUFNaUcsUUFBUTtRQUNWLEdBQUd6RixJQUFJO1FBQ1BmLFNBQVNpRCxTQUFTLFNBQVNqRDtRQUMzQlM7UUFDQTFDLE9BQU95RTtRQUNQdEMsUUFBUXVDO1FBQ1JnRSxVQUFVO1FBQ1Z4RztRQUNBRyxPQUFPO1lBQ0gsR0FBR2lGLFFBQVE7WUFDWCxHQUFHUyxnQkFBZ0I7UUFDdkI7UUFDQTlILE9BQU9rSSxjQUFjbEksS0FBSztRQUMxQjBCLFFBQVF3RyxjQUFjeEcsTUFBTTtRQUM1QjNDLEtBQUttSixjQUFjbkosR0FBRztJQUMxQjtJQUNBLE1BQU0ySixPQUFPO1FBQ1RuSDtRQUNBUTtRQUNBUTtRQUNBSjtJQUNKO0lBQ0EsT0FBTztRQUNIcUc7UUFDQUU7SUFDSjtBQUNKLEVBRUEseUNBQXlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9nZXQtaW1nLXByb3BzLmpzP2JiYWEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJnZXRJbWdQcm9wc1wiLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gZ2V0SW1nUHJvcHM7XG4gICAgfVxufSk7XG5jb25zdCBfd2Fybm9uY2UgPSByZXF1aXJlKFwiLi91dGlscy93YXJuLW9uY2VcIik7XG5jb25zdCBfaW1hZ2VibHVyc3ZnID0gcmVxdWlyZShcIi4vaW1hZ2UtYmx1ci1zdmdcIik7XG5jb25zdCBfaW1hZ2Vjb25maWcgPSByZXF1aXJlKFwiLi9pbWFnZS1jb25maWdcIik7XG5jb25zdCBWQUxJRF9MT0FESU5HX1ZBTFVFUyA9IFtcbiAgICBcImxhenlcIixcbiAgICBcImVhZ2VyXCIsXG4gICAgdW5kZWZpbmVkXG5dO1xuZnVuY3Rpb24gaXNTdGF0aWNSZXF1aXJlKHNyYykge1xuICAgIHJldHVybiBzcmMuZGVmYXVsdCAhPT0gdW5kZWZpbmVkO1xufVxuZnVuY3Rpb24gaXNTdGF0aWNJbWFnZURhdGEoc3JjKSB7XG4gICAgcmV0dXJuIHNyYy5zcmMgIT09IHVuZGVmaW5lZDtcbn1cbmZ1bmN0aW9uIGlzU3RhdGljSW1wb3J0KHNyYykge1xuICAgIHJldHVybiB0eXBlb2Ygc3JjID09PSBcIm9iamVjdFwiICYmIChpc1N0YXRpY1JlcXVpcmUoc3JjKSB8fCBpc1N0YXRpY0ltYWdlRGF0YShzcmMpKTtcbn1cbmNvbnN0IGFsbEltZ3MgPSBuZXcgTWFwKCk7XG5sZXQgcGVyZk9ic2VydmVyO1xuZnVuY3Rpb24gZ2V0SW50KHgpIHtcbiAgICBpZiAodHlwZW9mIHggPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgcmV0dXJuIHg7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgeCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICByZXR1cm4gTnVtYmVyLmlzRmluaXRlKHgpID8geCA6IE5hTjtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB4ID09PSBcInN0cmluZ1wiICYmIC9eWzAtOV0rJC8udGVzdCh4KSkge1xuICAgICAgICByZXR1cm4gcGFyc2VJbnQoeCwgMTApO1xuICAgIH1cbiAgICByZXR1cm4gTmFOO1xufVxuZnVuY3Rpb24gZ2V0V2lkdGhzKHBhcmFtLCB3aWR0aCwgc2l6ZXMpIHtcbiAgICBsZXQgeyBkZXZpY2VTaXplcywgYWxsU2l6ZXMgfSA9IHBhcmFtO1xuICAgIGlmIChzaXplcykge1xuICAgICAgICAvLyBGaW5kIGFsbCB0aGUgXCJ2d1wiIHBlcmNlbnQgc2l6ZXMgdXNlZCBpbiB0aGUgc2l6ZXMgcHJvcFxuICAgICAgICBjb25zdCB2aWV3cG9ydFdpZHRoUmUgPSAvKF58XFxzKSgxP1xcZD9cXGQpdncvZztcbiAgICAgICAgY29uc3QgcGVyY2VudFNpemVzID0gW107XG4gICAgICAgIGZvcihsZXQgbWF0Y2g7IG1hdGNoID0gdmlld3BvcnRXaWR0aFJlLmV4ZWMoc2l6ZXMpOyBtYXRjaCl7XG4gICAgICAgICAgICBwZXJjZW50U2l6ZXMucHVzaChwYXJzZUludChtYXRjaFsyXSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwZXJjZW50U2l6ZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBjb25zdCBzbWFsbGVzdFJhdGlvID0gTWF0aC5taW4oLi4ucGVyY2VudFNpemVzKSAqIDAuMDE7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHdpZHRoczogYWxsU2l6ZXMuZmlsdGVyKChzKT0+cyA+PSBkZXZpY2VTaXplc1swXSAqIHNtYWxsZXN0UmF0aW8pLFxuICAgICAgICAgICAgICAgIGtpbmQ6IFwid1wiXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB3aWR0aHM6IGFsbFNpemVzLFxuICAgICAgICAgICAga2luZDogXCJ3XCJcbiAgICAgICAgfTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB3aWR0aCAhPT0gXCJudW1iZXJcIikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgd2lkdGhzOiBkZXZpY2VTaXplcyxcbiAgICAgICAgICAgIGtpbmQ6IFwid1wiXG4gICAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IHdpZHRocyA9IFtcbiAgICAgICAgLi4ubmV3IFNldCgvLyA+IFRoaXMgbWVhbnMgdGhhdCBtb3N0IE9MRUQgc2NyZWVucyB0aGF0IHNheSB0aGV5IGFyZSAzeCByZXNvbHV0aW9uLFxuICAgICAgICAvLyA+IGFyZSBhY3R1YWxseSAzeCBpbiB0aGUgZ3JlZW4gY29sb3IsIGJ1dCBvbmx5IDEuNXggaW4gdGhlIHJlZCBhbmRcbiAgICAgICAgLy8gPiBibHVlIGNvbG9ycy4gU2hvd2luZyBhIDN4IHJlc29sdXRpb24gaW1hZ2UgaW4gdGhlIGFwcCB2cyBhIDJ4XG4gICAgICAgIC8vID4gcmVzb2x1dGlvbiBpbWFnZSB3aWxsIGJlIHZpc3VhbGx5IHRoZSBzYW1lLCB0aG91Z2ggdGhlIDN4IGltYWdlXG4gICAgICAgIC8vID4gdGFrZXMgc2lnbmlmaWNhbnRseSBtb3JlIGRhdGEuIEV2ZW4gdHJ1ZSAzeCByZXNvbHV0aW9uIHNjcmVlbnMgYXJlXG4gICAgICAgIC8vID4gd2FzdGVmdWwgYXMgdGhlIGh1bWFuIGV5ZSBjYW5ub3Qgc2VlIHRoYXQgbGV2ZWwgb2YgZGV0YWlsIHdpdGhvdXRcbiAgICAgICAgLy8gPiBzb21ldGhpbmcgbGlrZSBhIG1hZ25pZnlpbmcgZ2xhc3MuXG4gICAgICAgIC8vIGh0dHBzOi8vYmxvZy50d2l0dGVyLmNvbS9lbmdpbmVlcmluZy9lbl91cy90b3BpY3MvaW5mcmFzdHJ1Y3R1cmUvMjAxOS9jYXBwaW5nLWltYWdlLWZpZGVsaXR5LW9uLXVsdHJhLWhpZ2gtcmVzb2x1dGlvbi1kZXZpY2VzLmh0bWxcbiAgICAgICAgW1xuICAgICAgICAgICAgd2lkdGgsXG4gICAgICAgICAgICB3aWR0aCAqIDIgLyosIHdpZHRoICogMyovIFxuICAgICAgICBdLm1hcCgodyk9PmFsbFNpemVzLmZpbmQoKHApPT5wID49IHcpIHx8IGFsbFNpemVzW2FsbFNpemVzLmxlbmd0aCAtIDFdKSlcbiAgICBdO1xuICAgIHJldHVybiB7XG4gICAgICAgIHdpZHRocyxcbiAgICAgICAga2luZDogXCJ4XCJcbiAgICB9O1xufVxuZnVuY3Rpb24gZ2VuZXJhdGVJbWdBdHRycyhwYXJhbSkge1xuICAgIGxldCB7IGNvbmZpZywgc3JjLCB1bm9wdGltaXplZCwgd2lkdGgsIHF1YWxpdHksIHNpemVzLCBsb2FkZXIgfSA9IHBhcmFtO1xuICAgIGlmICh1bm9wdGltaXplZCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3JjLFxuICAgICAgICAgICAgc3JjU2V0OiB1bmRlZmluZWQsXG4gICAgICAgICAgICBzaXplczogdW5kZWZpbmVkXG4gICAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IHsgd2lkdGhzLCBraW5kIH0gPSBnZXRXaWR0aHMoY29uZmlnLCB3aWR0aCwgc2l6ZXMpO1xuICAgIGNvbnN0IGxhc3QgPSB3aWR0aHMubGVuZ3RoIC0gMTtcbiAgICByZXR1cm4ge1xuICAgICAgICBzaXplczogIXNpemVzICYmIGtpbmQgPT09IFwid1wiID8gXCIxMDB2d1wiIDogc2l6ZXMsXG4gICAgICAgIHNyY1NldDogd2lkdGhzLm1hcCgodywgaSk9PmxvYWRlcih7XG4gICAgICAgICAgICAgICAgY29uZmlnLFxuICAgICAgICAgICAgICAgIHNyYyxcbiAgICAgICAgICAgICAgICBxdWFsaXR5LFxuICAgICAgICAgICAgICAgIHdpZHRoOiB3XG4gICAgICAgICAgICB9KSArIFwiIFwiICsgKGtpbmQgPT09IFwid1wiID8gdyA6IGkgKyAxKSArIGtpbmQpLmpvaW4oXCIsIFwiKSxcbiAgICAgICAgLy8gSXQncyBpbnRlbmRlZCB0byBrZWVwIGBzcmNgIHRoZSBsYXN0IGF0dHJpYnV0ZSBiZWNhdXNlIFJlYWN0IHVwZGF0ZXNcbiAgICAgICAgLy8gYXR0cmlidXRlcyBpbiBvcmRlci4gSWYgd2Uga2VlcCBgc3JjYCB0aGUgZmlyc3Qgb25lLCBTYWZhcmkgd2lsbFxuICAgICAgICAvLyBpbW1lZGlhdGVseSBzdGFydCB0byBmZXRjaCBgc3JjYCwgYmVmb3JlIGBzaXplc2AgYW5kIGBzcmNTZXRgIGFyZSBldmVuXG4gICAgICAgIC8vIHVwZGF0ZWQgYnkgUmVhY3QuIFRoYXQgY2F1c2VzIG11bHRpcGxlIHVubmVjZXNzYXJ5IHJlcXVlc3RzIGlmIGBzcmNTZXRgXG4gICAgICAgIC8vIGFuZCBgc2l6ZXNgIGFyZSBkZWZpbmVkLlxuICAgICAgICAvLyBUaGlzIGJ1ZyBjYW5ub3QgYmUgcmVwcm9kdWNlZCBpbiBDaHJvbWUgb3IgRmlyZWZveC5cbiAgICAgICAgc3JjOiBsb2FkZXIoe1xuICAgICAgICAgICAgY29uZmlnLFxuICAgICAgICAgICAgc3JjLFxuICAgICAgICAgICAgcXVhbGl0eSxcbiAgICAgICAgICAgIHdpZHRoOiB3aWR0aHNbbGFzdF1cbiAgICAgICAgfSlcbiAgICB9O1xufVxuZnVuY3Rpb24gZ2V0SW1nUHJvcHMocGFyYW0sIF9zdGF0ZSkge1xuICAgIGxldCB7IHNyYywgc2l6ZXMsIHVub3B0aW1pemVkID0gZmFsc2UsIHByaW9yaXR5ID0gZmFsc2UsIGxvYWRpbmcsIGNsYXNzTmFtZSwgcXVhbGl0eSwgd2lkdGgsIGhlaWdodCwgZmlsbCA9IGZhbHNlLCBzdHlsZSwgb25Mb2FkLCBvbkxvYWRpbmdDb21wbGV0ZSwgcGxhY2Vob2xkZXIgPSBcImVtcHR5XCIsIGJsdXJEYXRhVVJMLCBmZXRjaFByaW9yaXR5LCBsYXlvdXQsIG9iamVjdEZpdCwgb2JqZWN0UG9zaXRpb24sIGxhenlCb3VuZGFyeSwgbGF6eVJvb3QsIC4uLnJlc3QgfSA9IHBhcmFtO1xuICAgIGNvbnN0IHsgaW1nQ29uZiwgc2hvd0FsdFRleHQsIGJsdXJDb21wbGV0ZSwgZGVmYXVsdExvYWRlciB9ID0gX3N0YXRlO1xuICAgIGxldCBjb25maWc7XG4gICAgbGV0IGMgPSBpbWdDb25mIHx8IF9pbWFnZWNvbmZpZy5pbWFnZUNvbmZpZ0RlZmF1bHQ7XG4gICAgaWYgKFwiYWxsU2l6ZXNcIiBpbiBjKSB7XG4gICAgICAgIGNvbmZpZyA9IGM7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgYWxsU2l6ZXMgPSBbXG4gICAgICAgICAgICAuLi5jLmRldmljZVNpemVzLFxuICAgICAgICAgICAgLi4uYy5pbWFnZVNpemVzXG4gICAgICAgIF0uc29ydCgoYSwgYik9PmEgLSBiKTtcbiAgICAgICAgY29uc3QgZGV2aWNlU2l6ZXMgPSBjLmRldmljZVNpemVzLnNvcnQoKGEsIGIpPT5hIC0gYik7XG4gICAgICAgIGNvbmZpZyA9IHtcbiAgICAgICAgICAgIC4uLmMsXG4gICAgICAgICAgICBhbGxTaXplcyxcbiAgICAgICAgICAgIGRldmljZVNpemVzXG4gICAgICAgIH07XG4gICAgfVxuICAgIGxldCBsb2FkZXIgPSByZXN0LmxvYWRlciB8fCBkZWZhdWx0TG9hZGVyO1xuICAgIC8vIFJlbW92ZSBwcm9wZXJ0eSBzbyBpdCdzIG5vdCBzcHJlYWQgb24gPGltZz4gZWxlbWVudFxuICAgIGRlbGV0ZSByZXN0LmxvYWRlcjtcbiAgICBkZWxldGUgcmVzdC5zcmNTZXQ7XG4gICAgLy8gVGhpcyBzcGVjaWFsIHZhbHVlIGluZGljYXRlcyB0aGF0IHRoZSB1c2VyXG4gICAgLy8gZGlkbid0IGRlZmluZSBhIFwibG9hZGVyXCIgcHJvcCBvciBcImxvYWRlclwiIGNvbmZpZy5cbiAgICBjb25zdCBpc0RlZmF1bHRMb2FkZXIgPSBcIl9fbmV4dF9pbWdfZGVmYXVsdFwiIGluIGxvYWRlcjtcbiAgICBpZiAoaXNEZWZhdWx0TG9hZGVyKSB7XG4gICAgICAgIGlmIChjb25maWcubG9hZGVyID09PSBcImN1c3RvbVwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ltYWdlIHdpdGggc3JjIFwiJyArIHNyYyArICdcIiBpcyBtaXNzaW5nIFwibG9hZGVyXCIgcHJvcC4nICsgXCJcXG5SZWFkIG1vcmU6IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL21lc3NhZ2VzL25leHQtaW1hZ2UtbWlzc2luZy1sb2FkZXJcIik7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUaGUgdXNlciBkZWZpbmVkIGEgXCJsb2FkZXJcIiBwcm9wIG9yIGNvbmZpZy5cbiAgICAgICAgLy8gU2luY2UgdGhlIGNvbmZpZyBvYmplY3QgaXMgaW50ZXJuYWwgb25seSwgd2VcbiAgICAgICAgLy8gbXVzdCBub3QgcGFzcyBpdCB0byB0aGUgdXNlci1kZWZpbmVkIFwibG9hZGVyXCIuXG4gICAgICAgIGNvbnN0IGN1c3RvbUltYWdlTG9hZGVyID0gbG9hZGVyO1xuICAgICAgICBsb2FkZXIgPSAob2JqKT0+e1xuICAgICAgICAgICAgY29uc3QgeyBjb25maWc6IF8sIC4uLm9wdHMgfSA9IG9iajtcbiAgICAgICAgICAgIHJldHVybiBjdXN0b21JbWFnZUxvYWRlcihvcHRzKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgaWYgKGxheW91dCkge1xuICAgICAgICBpZiAobGF5b3V0ID09PSBcImZpbGxcIikge1xuICAgICAgICAgICAgZmlsbCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbGF5b3V0VG9TdHlsZSA9IHtcbiAgICAgICAgICAgIGludHJpbnNpYzoge1xuICAgICAgICAgICAgICAgIG1heFdpZHRoOiBcIjEwMCVcIixcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IFwiYXV0b1wiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmVzcG9uc2l2ZToge1xuICAgICAgICAgICAgICAgIHdpZHRoOiBcIjEwMCVcIixcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IFwiYXV0b1wiXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGxheW91dFRvU2l6ZXMgPSB7XG4gICAgICAgICAgICByZXNwb25zaXZlOiBcIjEwMHZ3XCIsXG4gICAgICAgICAgICBmaWxsOiBcIjEwMHZ3XCJcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgbGF5b3V0U3R5bGUgPSBsYXlvdXRUb1N0eWxlW2xheW91dF07XG4gICAgICAgIGlmIChsYXlvdXRTdHlsZSkge1xuICAgICAgICAgICAgc3R5bGUgPSB7XG4gICAgICAgICAgICAgICAgLi4uc3R5bGUsXG4gICAgICAgICAgICAgICAgLi4ubGF5b3V0U3R5bGVcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbGF5b3V0U2l6ZXMgPSBsYXlvdXRUb1NpemVzW2xheW91dF07XG4gICAgICAgIGlmIChsYXlvdXRTaXplcyAmJiAhc2l6ZXMpIHtcbiAgICAgICAgICAgIHNpemVzID0gbGF5b3V0U2l6ZXM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbGV0IHN0YXRpY1NyYyA9IFwiXCI7XG4gICAgbGV0IHdpZHRoSW50ID0gZ2V0SW50KHdpZHRoKTtcbiAgICBsZXQgaGVpZ2h0SW50ID0gZ2V0SW50KGhlaWdodCk7XG4gICAgbGV0IGJsdXJXaWR0aDtcbiAgICBsZXQgYmx1ckhlaWdodDtcbiAgICBpZiAoaXNTdGF0aWNJbXBvcnQoc3JjKSkge1xuICAgICAgICBjb25zdCBzdGF0aWNJbWFnZURhdGEgPSBpc1N0YXRpY1JlcXVpcmUoc3JjKSA/IHNyYy5kZWZhdWx0IDogc3JjO1xuICAgICAgICBpZiAoIXN0YXRpY0ltYWdlRGF0YS5zcmMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkFuIG9iamVjdCBzaG91bGQgb25seSBiZSBwYXNzZWQgdG8gdGhlIGltYWdlIGNvbXBvbmVudCBzcmMgcGFyYW1ldGVyIGlmIGl0IGNvbWVzIGZyb20gYSBzdGF0aWMgaW1hZ2UgaW1wb3J0LiBJdCBtdXN0IGluY2x1ZGUgc3JjLiBSZWNlaXZlZCBcIiArIEpTT04uc3RyaW5naWZ5KHN0YXRpY0ltYWdlRGF0YSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghc3RhdGljSW1hZ2VEYXRhLmhlaWdodCB8fCAhc3RhdGljSW1hZ2VEYXRhLndpZHRoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBbiBvYmplY3Qgc2hvdWxkIG9ubHkgYmUgcGFzc2VkIHRvIHRoZSBpbWFnZSBjb21wb25lbnQgc3JjIHBhcmFtZXRlciBpZiBpdCBjb21lcyBmcm9tIGEgc3RhdGljIGltYWdlIGltcG9ydC4gSXQgbXVzdCBpbmNsdWRlIGhlaWdodCBhbmQgd2lkdGguIFJlY2VpdmVkIFwiICsgSlNPTi5zdHJpbmdpZnkoc3RhdGljSW1hZ2VEYXRhKSk7XG4gICAgICAgIH1cbiAgICAgICAgYmx1cldpZHRoID0gc3RhdGljSW1hZ2VEYXRhLmJsdXJXaWR0aDtcbiAgICAgICAgYmx1ckhlaWdodCA9IHN0YXRpY0ltYWdlRGF0YS5ibHVySGVpZ2h0O1xuICAgICAgICBibHVyRGF0YVVSTCA9IGJsdXJEYXRhVVJMIHx8IHN0YXRpY0ltYWdlRGF0YS5ibHVyRGF0YVVSTDtcbiAgICAgICAgc3RhdGljU3JjID0gc3RhdGljSW1hZ2VEYXRhLnNyYztcbiAgICAgICAgaWYgKCFmaWxsKSB7XG4gICAgICAgICAgICBpZiAoIXdpZHRoSW50ICYmICFoZWlnaHRJbnQpIHtcbiAgICAgICAgICAgICAgICB3aWR0aEludCA9IHN0YXRpY0ltYWdlRGF0YS53aWR0aDtcbiAgICAgICAgICAgICAgICBoZWlnaHRJbnQgPSBzdGF0aWNJbWFnZURhdGEuaGVpZ2h0O1xuICAgICAgICAgICAgfSBlbHNlIGlmICh3aWR0aEludCAmJiAhaGVpZ2h0SW50KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmF0aW8gPSB3aWR0aEludCAvIHN0YXRpY0ltYWdlRGF0YS53aWR0aDtcbiAgICAgICAgICAgICAgICBoZWlnaHRJbnQgPSBNYXRoLnJvdW5kKHN0YXRpY0ltYWdlRGF0YS5oZWlnaHQgKiByYXRpbyk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCF3aWR0aEludCAmJiBoZWlnaHRJbnQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByYXRpbyA9IGhlaWdodEludCAvIHN0YXRpY0ltYWdlRGF0YS5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgd2lkdGhJbnQgPSBNYXRoLnJvdW5kKHN0YXRpY0ltYWdlRGF0YS53aWR0aCAqIHJhdGlvKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBzcmMgPSB0eXBlb2Ygc3JjID09PSBcInN0cmluZ1wiID8gc3JjIDogc3RhdGljU3JjO1xuICAgIGxldCBpc0xhenkgPSAhcHJpb3JpdHkgJiYgKGxvYWRpbmcgPT09IFwibGF6eVwiIHx8IHR5cGVvZiBsb2FkaW5nID09PSBcInVuZGVmaW5lZFwiKTtcbiAgICBpZiAoIXNyYyB8fCBzcmMuc3RhcnRzV2l0aChcImRhdGE6XCIpIHx8IHNyYy5zdGFydHNXaXRoKFwiYmxvYjpcIikpIHtcbiAgICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvSFRUUC9CYXNpY3Nfb2ZfSFRUUC9EYXRhX1VSSXNcbiAgICAgICAgdW5vcHRpbWl6ZWQgPSB0cnVlO1xuICAgICAgICBpc0xhenkgPSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGNvbmZpZy51bm9wdGltaXplZCkge1xuICAgICAgICB1bm9wdGltaXplZCA9IHRydWU7XG4gICAgfVxuICAgIGlmIChpc0RlZmF1bHRMb2FkZXIgJiYgc3JjLmVuZHNXaXRoKFwiLnN2Z1wiKSAmJiAhY29uZmlnLmRhbmdlcm91c2x5QWxsb3dTVkcpIHtcbiAgICAgICAgLy8gU3BlY2lhbCBjYXNlIHRvIG1ha2Ugc3ZnIHNlcnZlIGFzLWlzIHRvIGF2b2lkIHByb3h5aW5nXG4gICAgICAgIC8vIHRocm91Z2ggdGhlIGJ1aWx0LWluIEltYWdlIE9wdGltaXphdGlvbiBBUEkuXG4gICAgICAgIHVub3B0aW1pemVkID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHByaW9yaXR5KSB7XG4gICAgICAgIGZldGNoUHJpb3JpdHkgPSBcImhpZ2hcIjtcbiAgICB9XG4gICAgY29uc3QgcXVhbGl0eUludCA9IGdldEludChxdWFsaXR5KTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgIGlmIChjb25maWcub3V0cHV0ID09PSBcImV4cG9ydFwiICYmIGlzRGVmYXVsdExvYWRlciAmJiAhdW5vcHRpbWl6ZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkltYWdlIE9wdGltaXphdGlvbiB1c2luZyB0aGUgZGVmYXVsdCBsb2FkZXIgaXMgbm90IGNvbXBhdGlibGUgd2l0aCBgeyBvdXRwdXQ6ICdleHBvcnQnIH1gLlxcbiAgUG9zc2libGUgc29sdXRpb25zOlxcbiAgICAtIFJlbW92ZSBgeyBvdXRwdXQ6ICdleHBvcnQnIH1gIGFuZCBydW4gXFxcIm5leHQgc3RhcnRcXFwiIHRvIHJ1biBzZXJ2ZXIgbW9kZSBpbmNsdWRpbmcgdGhlIEltYWdlIE9wdGltaXphdGlvbiBBUEkuXFxuICAgIC0gQ29uZmlndXJlIGB7IGltYWdlczogeyB1bm9wdGltaXplZDogdHJ1ZSB9IH1gIGluIGBuZXh0LmNvbmZpZy5qc2AgdG8gZGlzYWJsZSB0aGUgSW1hZ2UgT3B0aW1pemF0aW9uIEFQSS5cXG4gIFJlYWQgbW9yZTogaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvbWVzc2FnZXMvZXhwb3J0LWltYWdlLWFwaVwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXNyYykge1xuICAgICAgICAgICAgLy8gUmVhY3QgZG9lc24ndCBzaG93IHRoZSBzdGFjayB0cmFjZSBhbmQgdGhlcmUnc1xuICAgICAgICAgICAgLy8gbm8gYHNyY2AgdG8gaGVscCBpZGVudGlmeSB3aGljaCBpbWFnZSwgc28gd2VcbiAgICAgICAgICAgIC8vIGluc3RlYWQgY29uc29sZS5lcnJvcihyZWYpIGR1cmluZyBtb3VudC5cbiAgICAgICAgICAgIHVub3B0aW1pemVkID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChmaWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKHdpZHRoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW1hZ2Ugd2l0aCBzcmMgXCInICsgc3JjICsgJ1wiIGhhcyBib3RoIFwid2lkdGhcIiBhbmQgXCJmaWxsXCIgcHJvcGVydGllcy4gT25seSBvbmUgc2hvdWxkIGJlIHVzZWQuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChoZWlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbWFnZSB3aXRoIHNyYyBcIicgKyBzcmMgKyAnXCIgaGFzIGJvdGggXCJoZWlnaHRcIiBhbmQgXCJmaWxsXCIgcHJvcGVydGllcy4gT25seSBvbmUgc2hvdWxkIGJlIHVzZWQuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICgoc3R5bGUgPT0gbnVsbCA/IHZvaWQgMCA6IHN0eWxlLnBvc2l0aW9uKSAmJiBzdHlsZS5wb3NpdGlvbiAhPT0gXCJhYnNvbHV0ZVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW1hZ2Ugd2l0aCBzcmMgXCInICsgc3JjICsgJ1wiIGhhcyBib3RoIFwiZmlsbFwiIGFuZCBcInN0eWxlLnBvc2l0aW9uXCIgcHJvcGVydGllcy4gSW1hZ2VzIHdpdGggXCJmaWxsXCIgYWx3YXlzIHVzZSBwb3NpdGlvbiBhYnNvbHV0ZSAtIGl0IGNhbm5vdCBiZSBtb2RpZmllZC4nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKChzdHlsZSA9PSBudWxsID8gdm9pZCAwIDogc3R5bGUud2lkdGgpICYmIHN0eWxlLndpZHRoICE9PSBcIjEwMCVcIikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ltYWdlIHdpdGggc3JjIFwiJyArIHNyYyArICdcIiBoYXMgYm90aCBcImZpbGxcIiBhbmQgXCJzdHlsZS53aWR0aFwiIHByb3BlcnRpZXMuIEltYWdlcyB3aXRoIFwiZmlsbFwiIGFsd2F5cyB1c2Ugd2lkdGggMTAwJSAtIGl0IGNhbm5vdCBiZSBtb2RpZmllZC4nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKChzdHlsZSA9PSBudWxsID8gdm9pZCAwIDogc3R5bGUuaGVpZ2h0KSAmJiBzdHlsZS5oZWlnaHQgIT09IFwiMTAwJVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW1hZ2Ugd2l0aCBzcmMgXCInICsgc3JjICsgJ1wiIGhhcyBib3RoIFwiZmlsbFwiIGFuZCBcInN0eWxlLmhlaWdodFwiIHByb3BlcnRpZXMuIEltYWdlcyB3aXRoIFwiZmlsbFwiIGFsd2F5cyB1c2UgaGVpZ2h0IDEwMCUgLSBpdCBjYW5ub3QgYmUgbW9kaWZpZWQuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHdpZHRoSW50ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW1hZ2Ugd2l0aCBzcmMgXCInICsgc3JjICsgJ1wiIGlzIG1pc3NpbmcgcmVxdWlyZWQgXCJ3aWR0aFwiIHByb3BlcnR5LicpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNOYU4od2lkdGhJbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW1hZ2Ugd2l0aCBzcmMgXCInICsgc3JjICsgJ1wiIGhhcyBpbnZhbGlkIFwid2lkdGhcIiBwcm9wZXJ0eS4gRXhwZWN0ZWQgYSBudW1lcmljIHZhbHVlIGluIHBpeGVscyBidXQgcmVjZWl2ZWQgXCInICsgd2lkdGggKyAnXCIuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgaGVpZ2h0SW50ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW1hZ2Ugd2l0aCBzcmMgXCInICsgc3JjICsgJ1wiIGlzIG1pc3NpbmcgcmVxdWlyZWQgXCJoZWlnaHRcIiBwcm9wZXJ0eS4nKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGlzTmFOKGhlaWdodEludCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbWFnZSB3aXRoIHNyYyBcIicgKyBzcmMgKyAnXCIgaGFzIGludmFsaWQgXCJoZWlnaHRcIiBwcm9wZXJ0eS4gRXhwZWN0ZWQgYSBudW1lcmljIHZhbHVlIGluIHBpeGVscyBidXQgcmVjZWl2ZWQgXCInICsgaGVpZ2h0ICsgJ1wiLicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIVZBTElEX0xPQURJTkdfVkFMVUVTLmluY2x1ZGVzKGxvYWRpbmcpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ltYWdlIHdpdGggc3JjIFwiJyArIHNyYyArICdcIiBoYXMgaW52YWxpZCBcImxvYWRpbmdcIiBwcm9wZXJ0eS4gUHJvdmlkZWQgXCInICsgbG9hZGluZyArICdcIiBzaG91bGQgYmUgb25lIG9mICcgKyBWQUxJRF9MT0FESU5HX1ZBTFVFUy5tYXAoU3RyaW5nKS5qb2luKFwiLFwiKSArIFwiLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJpb3JpdHkgJiYgbG9hZGluZyA9PT0gXCJsYXp5XCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW1hZ2Ugd2l0aCBzcmMgXCInICsgc3JjICsgJ1wiIGhhcyBib3RoIFwicHJpb3JpdHlcIiBhbmQgXCJsb2FkaW5nPVxcJ2xhenlcXCdcIiBwcm9wZXJ0aWVzLiBPbmx5IG9uZSBzaG91bGQgYmUgdXNlZC4nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGxhY2Vob2xkZXIgIT09IFwiZW1wdHlcIiAmJiBwbGFjZWhvbGRlciAhPT0gXCJibHVyXCIgJiYgIXBsYWNlaG9sZGVyLnN0YXJ0c1dpdGgoXCJkYXRhOmltYWdlL1wiKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbWFnZSB3aXRoIHNyYyBcIicgKyBzcmMgKyAnXCIgaGFzIGludmFsaWQgXCJwbGFjZWhvbGRlclwiIHByb3BlcnR5IFwiJyArIHBsYWNlaG9sZGVyICsgJ1wiLicpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwbGFjZWhvbGRlciAhPT0gXCJlbXB0eVwiKSB7XG4gICAgICAgICAgICBpZiAod2lkdGhJbnQgJiYgaGVpZ2h0SW50ICYmIHdpZHRoSW50ICogaGVpZ2h0SW50IDwgMTYwMCkge1xuICAgICAgICAgICAgICAgICgwLCBfd2Fybm9uY2Uud2Fybk9uY2UpKCdJbWFnZSB3aXRoIHNyYyBcIicgKyBzcmMgKyAnXCIgaXMgc21hbGxlciB0aGFuIDQweDQwLiBDb25zaWRlciByZW1vdmluZyB0aGUgXCJwbGFjZWhvbGRlclwiIHByb3BlcnR5IHRvIGltcHJvdmUgcGVyZm9ybWFuY2UuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBsYWNlaG9sZGVyID09PSBcImJsdXJcIiAmJiAhYmx1ckRhdGFVUkwpIHtcbiAgICAgICAgICAgIGNvbnN0IFZBTElEX0JMVVJfRVhUID0gW1xuICAgICAgICAgICAgICAgIFwianBlZ1wiLFxuICAgICAgICAgICAgICAgIFwicG5nXCIsXG4gICAgICAgICAgICAgICAgXCJ3ZWJwXCIsXG4gICAgICAgICAgICAgICAgXCJhdmlmXCJcbiAgICAgICAgICAgIF0gLy8gc2hvdWxkIG1hdGNoIG5leHQtaW1hZ2UtbG9hZGVyXG4gICAgICAgICAgICA7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ltYWdlIHdpdGggc3JjIFwiJyArIHNyYyArICdcIiBoYXMgXCJwbGFjZWhvbGRlcj1cXCdibHVyXFwnXCIgcHJvcGVydHkgYnV0IGlzIG1pc3NpbmcgdGhlIFwiYmx1ckRhdGFVUkxcIiBwcm9wZXJ0eS5cXG4gICAgICAgIFBvc3NpYmxlIHNvbHV0aW9uczpcXG4gICAgICAgICAgLSBBZGQgYSBcImJsdXJEYXRhVVJMXCIgcHJvcGVydHksIHRoZSBjb250ZW50cyBzaG91bGQgYmUgYSBzbWFsbCBEYXRhIFVSTCB0byByZXByZXNlbnQgdGhlIGltYWdlXFxuICAgICAgICAgIC0gQ2hhbmdlIHRoZSBcInNyY1wiIHByb3BlcnR5IHRvIGEgc3RhdGljIGltcG9ydCB3aXRoIG9uZSBvZiB0aGUgc3VwcG9ydGVkIGZpbGUgdHlwZXM6ICcgKyBWQUxJRF9CTFVSX0VYVC5qb2luKFwiLFwiKSArICcgKGFuaW1hdGVkIGltYWdlcyBub3Qgc3VwcG9ydGVkKVxcbiAgICAgICAgICAtIFJlbW92ZSB0aGUgXCJwbGFjZWhvbGRlclwiIHByb3BlcnR5LCBlZmZlY3RpdmVseSBubyBibHVyIGVmZmVjdFxcbiAgICAgICAgUmVhZCBtb3JlOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy9wbGFjZWhvbGRlci1ibHVyLWRhdGEtdXJsJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFwicmVmXCIgaW4gcmVzdCkge1xuICAgICAgICAgICAgKDAsIF93YXJub25jZS53YXJuT25jZSkoJ0ltYWdlIHdpdGggc3JjIFwiJyArIHNyYyArICdcIiBpcyB1c2luZyB1bnN1cHBvcnRlZCBcInJlZlwiIHByb3BlcnR5LiBDb25zaWRlciB1c2luZyB0aGUgXCJvbkxvYWRcIiBwcm9wZXJ0eSBpbnN0ZWFkLicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdW5vcHRpbWl6ZWQgJiYgIWlzRGVmYXVsdExvYWRlcikge1xuICAgICAgICAgICAgY29uc3QgdXJsU3RyID0gbG9hZGVyKHtcbiAgICAgICAgICAgICAgICBjb25maWcsXG4gICAgICAgICAgICAgICAgc3JjLFxuICAgICAgICAgICAgICAgIHdpZHRoOiB3aWR0aEludCB8fCA0MDAsXG4gICAgICAgICAgICAgICAgcXVhbGl0eTogcXVhbGl0eUludCB8fCA3NVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBsZXQgdXJsO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB1cmwgPSBuZXcgVVJMKHVybFN0cik7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHt9XG4gICAgICAgICAgICBpZiAodXJsU3RyID09PSBzcmMgfHwgdXJsICYmIHVybC5wYXRobmFtZSA9PT0gc3JjICYmICF1cmwuc2VhcmNoKSB7XG4gICAgICAgICAgICAgICAgKDAsIF93YXJub25jZS53YXJuT25jZSkoJ0ltYWdlIHdpdGggc3JjIFwiJyArIHNyYyArICdcIiBoYXMgYSBcImxvYWRlclwiIHByb3BlcnR5IHRoYXQgZG9lcyBub3QgaW1wbGVtZW50IHdpZHRoLiBQbGVhc2UgaW1wbGVtZW50IGl0IG9yIHVzZSB0aGUgXCJ1bm9wdGltaXplZFwiIHByb3BlcnR5IGluc3RlYWQuJyArIFwiXFxuUmVhZCBtb3JlOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy9uZXh0LWltYWdlLW1pc3NpbmctbG9hZGVyLXdpZHRoXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChvbkxvYWRpbmdDb21wbGV0ZSkge1xuICAgICAgICAgICAgKDAsIF93YXJub25jZS53YXJuT25jZSkoJ0ltYWdlIHdpdGggc3JjIFwiJyArIHNyYyArICdcIiBpcyB1c2luZyBkZXByZWNhdGVkIFwib25Mb2FkaW5nQ29tcGxldGVcIiBwcm9wZXJ0eS4gUGxlYXNlIHVzZSB0aGUgXCJvbkxvYWRcIiBwcm9wZXJ0eSBpbnN0ZWFkLicpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgW2xlZ2FjeUtleSwgbGVnYWN5VmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHtcbiAgICAgICAgICAgIGxheW91dCxcbiAgICAgICAgICAgIG9iamVjdEZpdCxcbiAgICAgICAgICAgIG9iamVjdFBvc2l0aW9uLFxuICAgICAgICAgICAgbGF6eUJvdW5kYXJ5LFxuICAgICAgICAgICAgbGF6eVJvb3RcbiAgICAgICAgfSkpe1xuICAgICAgICAgICAgaWYgKGxlZ2FjeVZhbHVlKSB7XG4gICAgICAgICAgICAgICAgKDAsIF93YXJub25jZS53YXJuT25jZSkoJ0ltYWdlIHdpdGggc3JjIFwiJyArIHNyYyArICdcIiBoYXMgbGVnYWN5IHByb3AgXCInICsgbGVnYWN5S2V5ICsgJ1wiLiBEaWQgeW91IGZvcmdldCB0byBydW4gdGhlIGNvZGVtb2Q/JyArIFwiXFxuUmVhZCBtb3JlOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy9uZXh0LWltYWdlLXVwZ3JhZGUtdG8tMTNcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgIXBlcmZPYnNlcnZlciAmJiB3aW5kb3cuUGVyZm9ybWFuY2VPYnNlcnZlcikge1xuICAgICAgICAgICAgcGVyZk9ic2VydmVyID0gbmV3IFBlcmZvcm1hbmNlT2JzZXJ2ZXIoKGVudHJ5TGlzdCk9PntcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGVudHJ5IG9mIGVudHJ5TGlzdC5nZXRFbnRyaWVzKCkpe1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2VudHJ5X2VsZW1lbnQ7XG4gICAgICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmUgLSBtaXNzaW5nIFwiTGFyZ2VzdENvbnRlbnRmdWxQYWludFwiIGNsYXNzIHdpdGggXCJlbGVtZW50XCIgcHJvcFxuICAgICAgICAgICAgICAgICAgICBjb25zdCBpbWdTcmMgPSAoZW50cnkgPT0gbnVsbCA/IHZvaWQgMCA6IChfZW50cnlfZWxlbWVudCA9IGVudHJ5LmVsZW1lbnQpID09IG51bGwgPyB2b2lkIDAgOiBfZW50cnlfZWxlbWVudC5zcmMpIHx8IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxjcEltYWdlID0gYWxsSW1ncy5nZXQoaW1nU3JjKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxjcEltYWdlICYmICFsY3BJbWFnZS5wcmlvcml0eSAmJiBsY3BJbWFnZS5wbGFjZWhvbGRlciA9PT0gXCJlbXB0eVwiICYmICFsY3BJbWFnZS5zcmMuc3RhcnRzV2l0aChcImRhdGE6XCIpICYmICFsY3BJbWFnZS5zcmMuc3RhcnRzV2l0aChcImJsb2I6XCIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBodHRwczovL3dlYi5kZXYvbGNwLyNtZWFzdXJlLWxjcC1pbi1qYXZhc2NyaXB0XG4gICAgICAgICAgICAgICAgICAgICAgICAoMCwgX3dhcm5vbmNlLndhcm5PbmNlKSgnSW1hZ2Ugd2l0aCBzcmMgXCInICsgbGNwSW1hZ2Uuc3JjICsgJ1wiIHdhcyBkZXRlY3RlZCBhcyB0aGUgTGFyZ2VzdCBDb250ZW50ZnVsIFBhaW50IChMQ1ApLiBQbGVhc2UgYWRkIHRoZSBcInByaW9yaXR5XCIgcHJvcGVydHkgaWYgdGhpcyBpbWFnZSBpcyBhYm92ZSB0aGUgZm9sZC4nICsgXCJcXG5SZWFkIG1vcmU6IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL2FwaS1yZWZlcmVuY2UvbmV4dC9pbWFnZSNwcmlvcml0eVwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBwZXJmT2JzZXJ2ZXIub2JzZXJ2ZSh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwibGFyZ2VzdC1jb250ZW50ZnVsLXBhaW50XCIsXG4gICAgICAgICAgICAgICAgICAgIGJ1ZmZlcmVkOiB0cnVlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAvLyBMb2cgZXJyb3IgYnV0IGRvbid0IGNyYXNoIHRoZSBhcHBcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgaW1nU3R5bGUgPSBPYmplY3QuYXNzaWduKGZpbGwgPyB7XG4gICAgICAgIHBvc2l0aW9uOiBcImFic29sdXRlXCIsXG4gICAgICAgIGhlaWdodDogXCIxMDAlXCIsXG4gICAgICAgIHdpZHRoOiBcIjEwMCVcIixcbiAgICAgICAgbGVmdDogMCxcbiAgICAgICAgdG9wOiAwLFxuICAgICAgICByaWdodDogMCxcbiAgICAgICAgYm90dG9tOiAwLFxuICAgICAgICBvYmplY3RGaXQsXG4gICAgICAgIG9iamVjdFBvc2l0aW9uXG4gICAgfSA6IHt9LCBzaG93QWx0VGV4dCA/IHt9IDoge1xuICAgICAgICBjb2xvcjogXCJ0cmFuc3BhcmVudFwiXG4gICAgfSwgc3R5bGUpO1xuICAgIGNvbnN0IGJhY2tncm91bmRJbWFnZSA9ICFibHVyQ29tcGxldGUgJiYgcGxhY2Vob2xkZXIgIT09IFwiZW1wdHlcIiA/IHBsYWNlaG9sZGVyID09PSBcImJsdXJcIiA/ICd1cmwoXCJkYXRhOmltYWdlL3N2Zyt4bWw7Y2hhcnNldD11dGYtOCwnICsgKDAsIF9pbWFnZWJsdXJzdmcuZ2V0SW1hZ2VCbHVyU3ZnKSh7XG4gICAgICAgIHdpZHRoSW50LFxuICAgICAgICBoZWlnaHRJbnQsXG4gICAgICAgIGJsdXJXaWR0aCxcbiAgICAgICAgYmx1ckhlaWdodCxcbiAgICAgICAgYmx1ckRhdGFVUkw6IGJsdXJEYXRhVVJMIHx8IFwiXCIsXG4gICAgICAgIG9iamVjdEZpdDogaW1nU3R5bGUub2JqZWN0Rml0XG4gICAgfSkgKyAnXCIpJyA6ICd1cmwoXCInICsgcGxhY2Vob2xkZXIgKyAnXCIpJyAvLyBhc3N1bWUgYGRhdGE6aW1hZ2UvYFxuICAgICA6IG51bGw7XG4gICAgbGV0IHBsYWNlaG9sZGVyU3R5bGUgPSBiYWNrZ3JvdW5kSW1hZ2UgPyB7XG4gICAgICAgIGJhY2tncm91bmRTaXplOiBpbWdTdHlsZS5vYmplY3RGaXQgfHwgXCJjb3ZlclwiLFxuICAgICAgICBiYWNrZ3JvdW5kUG9zaXRpb246IGltZ1N0eWxlLm9iamVjdFBvc2l0aW9uIHx8IFwiNTAlIDUwJVwiLFxuICAgICAgICBiYWNrZ3JvdW5kUmVwZWF0OiBcIm5vLXJlcGVhdFwiLFxuICAgICAgICBiYWNrZ3JvdW5kSW1hZ2VcbiAgICB9IDoge307XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcImRldmVsb3BtZW50XCIpIHtcbiAgICAgICAgaWYgKHBsYWNlaG9sZGVyU3R5bGUuYmFja2dyb3VuZEltYWdlICYmIHBsYWNlaG9sZGVyID09PSBcImJsdXJcIiAmJiAoYmx1ckRhdGFVUkwgPT0gbnVsbCA/IHZvaWQgMCA6IGJsdXJEYXRhVVJMLnN0YXJ0c1dpdGgoXCIvXCIpKSkge1xuICAgICAgICAgICAgLy8gRHVyaW5nIGBuZXh0IGRldmAsIHdlIGRvbid0IHdhbnQgdG8gZ2VuZXJhdGUgYmx1ciBwbGFjZWhvbGRlcnMgd2l0aCB3ZWJwYWNrXG4gICAgICAgICAgICAvLyBiZWNhdXNlIGl0IGNhbiBkZWxheSBzdGFydGluZyB0aGUgZGV2IHNlcnZlci4gSW5zdGVhZCwgYG5leHQtaW1hZ2UtbG9hZGVyLmpzYFxuICAgICAgICAgICAgLy8gd2lsbCBpbmxpbmUgYSBzcGVjaWFsIHVybCB0byBsYXppbHkgZ2VuZXJhdGUgdGhlIGJsdXIgcGxhY2Vob2xkZXIgYXQgcmVxdWVzdCB0aW1lLlxuICAgICAgICAgICAgcGxhY2Vob2xkZXJTdHlsZS5iYWNrZ3JvdW5kSW1hZ2UgPSAndXJsKFwiJyArIGJsdXJEYXRhVVJMICsgJ1wiKSc7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgaW1nQXR0cmlidXRlcyA9IGdlbmVyYXRlSW1nQXR0cnMoe1xuICAgICAgICBjb25maWcsXG4gICAgICAgIHNyYyxcbiAgICAgICAgdW5vcHRpbWl6ZWQsXG4gICAgICAgIHdpZHRoOiB3aWR0aEludCxcbiAgICAgICAgcXVhbGl0eTogcXVhbGl0eUludCxcbiAgICAgICAgc2l6ZXMsXG4gICAgICAgIGxvYWRlclxuICAgIH0pO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIGxldCBmdWxsVXJsO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBmdWxsVXJsID0gbmV3IFVSTChpbWdBdHRyaWJ1dGVzLnNyYyk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgZnVsbFVybCA9IG5ldyBVUkwoaW1nQXR0cmlidXRlcy5zcmMsIHdpbmRvdy5sb2NhdGlvbi5ocmVmKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFsbEltZ3Muc2V0KGZ1bGxVcmwuaHJlZiwge1xuICAgICAgICAgICAgICAgIHNyYyxcbiAgICAgICAgICAgICAgICBwcmlvcml0eSxcbiAgICAgICAgICAgICAgICBwbGFjZWhvbGRlclxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgcHJvcHMgPSB7XG4gICAgICAgIC4uLnJlc3QsXG4gICAgICAgIGxvYWRpbmc6IGlzTGF6eSA/IFwibGF6eVwiIDogbG9hZGluZyxcbiAgICAgICAgZmV0Y2hQcmlvcml0eSxcbiAgICAgICAgd2lkdGg6IHdpZHRoSW50LFxuICAgICAgICBoZWlnaHQ6IGhlaWdodEludCxcbiAgICAgICAgZGVjb2Rpbmc6IFwiYXN5bmNcIixcbiAgICAgICAgY2xhc3NOYW1lLFxuICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgLi4uaW1nU3R5bGUsXG4gICAgICAgICAgICAuLi5wbGFjZWhvbGRlclN0eWxlXG4gICAgICAgIH0sXG4gICAgICAgIHNpemVzOiBpbWdBdHRyaWJ1dGVzLnNpemVzLFxuICAgICAgICBzcmNTZXQ6IGltZ0F0dHJpYnV0ZXMuc3JjU2V0LFxuICAgICAgICBzcmM6IGltZ0F0dHJpYnV0ZXMuc3JjXG4gICAgfTtcbiAgICBjb25zdCBtZXRhID0ge1xuICAgICAgICB1bm9wdGltaXplZCxcbiAgICAgICAgcHJpb3JpdHksXG4gICAgICAgIHBsYWNlaG9sZGVyLFxuICAgICAgICBmaWxsXG4gICAgfTtcbiAgICByZXR1cm4ge1xuICAgICAgICBwcm9wcyxcbiAgICAgICAgbWV0YVxuICAgIH07XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdldC1pbWctcHJvcHMuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiZW51bWVyYWJsZSIsImdldCIsImdldEltZ1Byb3BzIiwiX3dhcm5vbmNlIiwicmVxdWlyZSIsIl9pbWFnZWJsdXJzdmciLCJfaW1hZ2Vjb25maWciLCJWQUxJRF9MT0FESU5HX1ZBTFVFUyIsInVuZGVmaW5lZCIsImlzU3RhdGljUmVxdWlyZSIsInNyYyIsImRlZmF1bHQiLCJpc1N0YXRpY0ltYWdlRGF0YSIsImlzU3RhdGljSW1wb3J0IiwiYWxsSW1ncyIsIk1hcCIsInBlcmZPYnNlcnZlciIsImdldEludCIsIngiLCJOdW1iZXIiLCJpc0Zpbml0ZSIsIk5hTiIsInRlc3QiLCJwYXJzZUludCIsImdldFdpZHRocyIsInBhcmFtIiwid2lkdGgiLCJzaXplcyIsImRldmljZVNpemVzIiwiYWxsU2l6ZXMiLCJ2aWV3cG9ydFdpZHRoUmUiLCJwZXJjZW50U2l6ZXMiLCJtYXRjaCIsImV4ZWMiLCJwdXNoIiwibGVuZ3RoIiwic21hbGxlc3RSYXRpbyIsIk1hdGgiLCJtaW4iLCJ3aWR0aHMiLCJmaWx0ZXIiLCJzIiwia2luZCIsIlNldCIsIm1hcCIsInciLCJmaW5kIiwicCIsImdlbmVyYXRlSW1nQXR0cnMiLCJjb25maWciLCJ1bm9wdGltaXplZCIsInF1YWxpdHkiLCJsb2FkZXIiLCJzcmNTZXQiLCJsYXN0IiwiaSIsImpvaW4iLCJfc3RhdGUiLCJwcmlvcml0eSIsImxvYWRpbmciLCJjbGFzc05hbWUiLCJoZWlnaHQiLCJmaWxsIiwic3R5bGUiLCJvbkxvYWQiLCJvbkxvYWRpbmdDb21wbGV0ZSIsInBsYWNlaG9sZGVyIiwiYmx1ckRhdGFVUkwiLCJmZXRjaFByaW9yaXR5IiwibGF5b3V0Iiwib2JqZWN0Rml0Iiwib2JqZWN0UG9zaXRpb24iLCJsYXp5Qm91bmRhcnkiLCJsYXp5Um9vdCIsInJlc3QiLCJpbWdDb25mIiwic2hvd0FsdFRleHQiLCJibHVyQ29tcGxldGUiLCJkZWZhdWx0TG9hZGVyIiwiYyIsImltYWdlQ29uZmlnRGVmYXVsdCIsImltYWdlU2l6ZXMiLCJzb3J0IiwiYSIsImIiLCJpc0RlZmF1bHRMb2FkZXIiLCJFcnJvciIsImN1c3RvbUltYWdlTG9hZGVyIiwib2JqIiwiXyIsIm9wdHMiLCJsYXlvdXRUb1N0eWxlIiwiaW50cmluc2ljIiwibWF4V2lkdGgiLCJyZXNwb25zaXZlIiwibGF5b3V0VG9TaXplcyIsImxheW91dFN0eWxlIiwibGF5b3V0U2l6ZXMiLCJzdGF0aWNTcmMiLCJ3aWR0aEludCIsImhlaWdodEludCIsImJsdXJXaWR0aCIsImJsdXJIZWlnaHQiLCJzdGF0aWNJbWFnZURhdGEiLCJKU09OIiwic3RyaW5naWZ5IiwicmF0aW8iLCJyb3VuZCIsImlzTGF6eSIsInN0YXJ0c1dpdGgiLCJlbmRzV2l0aCIsImRhbmdlcm91c2x5QWxsb3dTVkciLCJxdWFsaXR5SW50IiwicHJvY2VzcyIsIm91dHB1dCIsInBvc2l0aW9uIiwiaXNOYU4iLCJpbmNsdWRlcyIsIlN0cmluZyIsIndhcm5PbmNlIiwiVkFMSURfQkxVUl9FWFQiLCJ1cmxTdHIiLCJ1cmwiLCJVUkwiLCJlcnIiLCJwYXRobmFtZSIsInNlYXJjaCIsImxlZ2FjeUtleSIsImxlZ2FjeVZhbHVlIiwiZW50cmllcyIsIndpbmRvdyIsIlBlcmZvcm1hbmNlT2JzZXJ2ZXIiLCJlbnRyeUxpc3QiLCJlbnRyeSIsImdldEVudHJpZXMiLCJfZW50cnlfZWxlbWVudCIsImltZ1NyYyIsImVsZW1lbnQiLCJsY3BJbWFnZSIsIm9ic2VydmUiLCJ0eXBlIiwiYnVmZmVyZWQiLCJjb25zb2xlIiwiZXJyb3IiLCJpbWdTdHlsZSIsImFzc2lnbiIsImxlZnQiLCJ0b3AiLCJyaWdodCIsImJvdHRvbSIsImNvbG9yIiwiYmFja2dyb3VuZEltYWdlIiwiZ2V0SW1hZ2VCbHVyU3ZnIiwicGxhY2Vob2xkZXJTdHlsZSIsImJhY2tncm91bmRTaXplIiwiYmFja2dyb3VuZFBvc2l0aW9uIiwiYmFja2dyb3VuZFJlcGVhdCIsImltZ0F0dHJpYnV0ZXMiLCJmdWxsVXJsIiwiZSIsImxvY2F0aW9uIiwiaHJlZiIsInNldCIsInByb3BzIiwiZGVjb2RpbmciLCJtZXRhIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/get-img-props.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/head.js":
/*!***************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/head.js ***!
  \***************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval(__webpack_require__.ts("/* __next_internal_client_entry_do_not_use__  cjs */ \nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    defaultHead: function() {\n        return defaultHead;\n    },\n    default: function() {\n        return _default;\n    }\n});\nconst _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_interop_require_default.js\");\nconst _interop_require_wildcard = __webpack_require__(/*! @swc/helpers/_/_interop_require_wildcard */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_interop_require_wildcard.js\");\nconst _jsxruntime = __webpack_require__(/*! react/jsx-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-runtime.js\");\nconst _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\"));\nconst _sideeffect = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! ./side-effect */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/side-effect.js\"));\nconst _ampcontextsharedruntime = __webpack_require__(/*! ./amp-context.shared-runtime */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/amp-context.shared-runtime.js\");\nconst _headmanagercontextsharedruntime = __webpack_require__(/*! ./head-manager-context.shared-runtime */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/head-manager-context.shared-runtime.js\");\nconst _ampmode = __webpack_require__(/*! ./amp-mode */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/amp-mode.js\");\nconst _warnonce = __webpack_require__(/*! ./utils/warn-once */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/utils/warn-once.js\");\nfunction defaultHead(inAmpMode) {\n    if (inAmpMode === void 0) inAmpMode = false;\n    const head = [\n        /*#__PURE__*/ (0, _jsxruntime.jsx)(\"meta\", {\n            charSet: \"utf-8\"\n        })\n    ];\n    if (!inAmpMode) {\n        head.push(/*#__PURE__*/ (0, _jsxruntime.jsx)(\"meta\", {\n            name: \"viewport\",\n            content: \"width=device-width\"\n        }));\n    }\n    return head;\n}\nfunction onlyReactElement(list, child) {\n    // React children can be \"string\" or \"number\" in this case we ignore them for backwards compat\n    if (typeof child === \"string\" || typeof child === \"number\") {\n        return list;\n    }\n    // Adds support for React.Fragment\n    if (child.type === _react.default.Fragment) {\n        return list.concat(_react.default.Children.toArray(child.props.children).reduce((fragmentList, fragmentChild)=>{\n            if (typeof fragmentChild === \"string\" || typeof fragmentChild === \"number\") {\n                return fragmentList;\n            }\n            return fragmentList.concat(fragmentChild);\n        }, []));\n    }\n    return list.concat(child);\n}\nconst METATYPES = [\n    \"name\",\n    \"httpEquiv\",\n    \"charSet\",\n    \"itemProp\"\n];\n/*\n returns a function for filtering head child elements\n which shouldn't be duplicated, like <title/>\n Also adds support for deduplicated `key` properties\n*/ function unique() {\n    const keys = new Set();\n    const tags = new Set();\n    const metaTypes = new Set();\n    const metaCategories = {};\n    return (h)=>{\n        let isUnique = true;\n        let hasKey = false;\n        if (h.key && typeof h.key !== \"number\" && h.key.indexOf(\"$\") > 0) {\n            hasKey = true;\n            const key = h.key.slice(h.key.indexOf(\"$\") + 1);\n            if (keys.has(key)) {\n                isUnique = false;\n            } else {\n                keys.add(key);\n            }\n        }\n        // eslint-disable-next-line default-case\n        switch(h.type){\n            case \"title\":\n            case \"base\":\n                if (tags.has(h.type)) {\n                    isUnique = false;\n                } else {\n                    tags.add(h.type);\n                }\n                break;\n            case \"meta\":\n                for(let i = 0, len = METATYPES.length; i < len; i++){\n                    const metatype = METATYPES[i];\n                    if (!h.props.hasOwnProperty(metatype)) continue;\n                    if (metatype === \"charSet\") {\n                        if (metaTypes.has(metatype)) {\n                            isUnique = false;\n                        } else {\n                            metaTypes.add(metatype);\n                        }\n                    } else {\n                        const category = h.props[metatype];\n                        const categories = metaCategories[metatype] || new Set();\n                        if ((metatype !== \"name\" || !hasKey) && categories.has(category)) {\n                            isUnique = false;\n                        } else {\n                            categories.add(category);\n                            metaCategories[metatype] = categories;\n                        }\n                    }\n                }\n                break;\n        }\n        return isUnique;\n    };\n}\n/**\n *\n * @param headChildrenElements List of children of <Head>\n */ function reduceComponents(headChildrenElements, props) {\n    const { inAmpMode } = props;\n    return headChildrenElements.reduce(onlyReactElement, []).reverse().concat(defaultHead(inAmpMode).reverse()).filter(unique()).reverse().map((c, i)=>{\n        const key = c.key || i;\n        if (false) {}\n        if (true) {\n            // omit JSON-LD structured data snippets from the warning\n            if (c.type === \"script\" && c.props[\"type\"] !== \"application/ld+json\") {\n                const srcMessage = c.props[\"src\"] ? '<script> tag with src=\"' + c.props[\"src\"] + '\"' : \"inline <script>\";\n                (0, _warnonce.warnOnce)(\"Do not add <script> tags using next/head (see \" + srcMessage + \"). Use next/script instead. \\nSee more info here: https://nextjs.org/docs/messages/no-script-tags-in-head-component\");\n            } else if (c.type === \"link\" && c.props[\"rel\"] === \"stylesheet\") {\n                (0, _warnonce.warnOnce)('Do not add stylesheets using next/head (see <link rel=\"stylesheet\"> tag with href=\"' + c.props[\"href\"] + '\"). Use Document instead. \\nSee more info here: https://nextjs.org/docs/messages/no-stylesheets-in-head-component');\n            }\n        }\n        return /*#__PURE__*/ _react.default.cloneElement(c, {\n            key\n        });\n    });\n}\n/**\n * This component injects elements to `<head>` of your page.\n * To avoid duplicated `tags` in `<head>` you can use the `key` property, which will make sure every tag is only rendered once.\n */ function Head(param) {\n    let { children } = param;\n    const ampState = (0, _react.useContext)(_ampcontextsharedruntime.AmpStateContext);\n    const headManager = (0, _react.useContext)(_headmanagercontextsharedruntime.HeadManagerContext);\n    return /*#__PURE__*/ (0, _jsxruntime.jsx)(_sideeffect.default, {\n        reduceComponentsToState: reduceComponents,\n        headManager: headManager,\n        inAmpMode: (0, _ampmode.isInAmpMode)(ampState),\n        children: children\n    });\n}\n_c = Head;\nconst _default = Head;\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=head.js.map\nvar _c;\n$RefreshReg$(_c, \"Head\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9oZWFkLmpzIiwibWFwcGluZ3MiOiJxREFFYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU87QUFDWCxDQUFDLEVBQUM7QUFDRixLQUFNQyxDQUFBQSxDQUdOO0FBQ0EsU0FBU0csUUFBUUMsTUFBTSxFQUFFQyxHQUFHO0lBQ3hCLElBQUksSUFBSUMsUUFBUUQsSUFBSVQsT0FBT0MsY0FBYyxDQUFDTyxRQUFRRSxNQUFNO1FBQ3BEQyxZQUFZO1FBQ1pDLEtBQUtILEdBQUcsQ0FBQ0MsS0FBSztJQUNsQjtBQUNKO0FBQ0FILFFBQVFMLFNBQVM7SUFDYkcsYUFBYTtRQUNULE9BQU9BO0lBQ1g7SUFDQUMsU0FBUztRQUNMLE9BQU9PO0lBQ1g7QUFDSjtBQUNBLE1BQU1DLDJCQUEyQkMsbUJBQU9BLENBQUMsZ0lBQXlDO0FBQ2xGLE1BQU1DLDRCQUE0QkQsbUJBQU9BLENBQUMsa0lBQTBDO0FBQ3BGLE1BQU1FLGNBQWNGLG1CQUFPQSxDQUFDLHFHQUFtQjtBQUMvQyxNQUFNRyxTQUFTLFdBQVcsR0FBR0YsMEJBQTBCRyxDQUFDLENBQUNKLG1CQUFPQSxDQUFDLG1GQUFPO0FBQ3hFLE1BQU1LLGNBQWMsV0FBVyxHQUFHTix5QkFBeUJLLENBQUMsQ0FBQ0osbUJBQU9BLENBQUMsNkZBQWU7QUFDcEYsTUFBTU0sMkJBQTJCTixtQkFBT0EsQ0FBQywySEFBOEI7QUFDdkUsTUFBTU8sbUNBQW1DUCxtQkFBT0EsQ0FBQyw2SUFBdUM7QUFDeEYsTUFBTVEsV0FBV1IsbUJBQU9BLENBQUMsdUZBQVk7QUFDckMsTUFBTVMsWUFBWVQsbUJBQU9BLENBQUMscUdBQW1CO0FBQzdDLFNBQVNWLFlBQVlvQixTQUFTO0lBQzFCLElBQUlBLGNBQWMsS0FBSyxHQUFHQSxZQUFZO0lBQ3RDLE1BQU1DLE9BQU87UUFDVCxXQUFXLEdBQUksSUFBR1QsWUFBWVUsR0FBRyxFQUFFLFFBQVE7WUFDdkND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VSxFQUFFakUseUJBQXlCa0UsZUFBZTtJQUNoRixNQUFNQyxjQUFjLENBQUMsR0FBR3RFLE9BQU9vRSxVQUFVLEVBQUVoRSxpQ0FBaUNtRSxrQkFBa0I7SUFDOUYsT0FBcUIsV0FBSCxHQUFJLElBQUd4RSxZQUFZVSxHQUFHLEVBQUVQLFlBQVlkLE9BQU8sRUFBRTtRQUMzRG9GLHlCQUF5QnhCO1FBQ3pCc0IsYUFBYUE7UUFDYi9ELFdBQVcsQ0FBQyxHQUFHRixTQUFTb0UsV0FBVyxFQUFFTjtRQUNyQzdDLFVBQVVBO0lBQ2Q7QUFDSjtLQVZhMkM7QUFXYixNQUFNdEUsV0FBV3NFO0FBRWpCLElBQUksQ0FBQyxPQUFPakYsUUFBUUksT0FBTyxLQUFLLGNBQWUsT0FBT0osUUFBUUksT0FBTyxLQUFLLFlBQVlKLFFBQVFJLE9BQU8sS0FBSyxJQUFJLEtBQU0sT0FBT0osUUFBUUksT0FBTyxDQUFDc0YsVUFBVSxLQUFLLGFBQWE7SUFDcks1RixPQUFPQyxjQUFjLENBQUNDLFFBQVFJLE9BQU8sRUFBRSxjQUFjO1FBQUVILE9BQU87SUFBSztJQUNuRUgsT0FBTzZGLE1BQU0sQ0FBQzNGLFFBQVFJLE9BQU8sRUFBRUo7SUFDL0JFLE9BQU9GLE9BQU8sR0FBR0EsUUFBUUksT0FBTztBQUNsQyxFQUVBLGdDQUFnQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvaGVhZC5qcz9mYjVkIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIGNsaWVudFwiO1xuXG5cInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbjAgJiYgKG1vZHVsZS5leHBvcnRzID0ge1xuICAgIGRlZmF1bHRIZWFkOiBudWxsLFxuICAgIGRlZmF1bHQ6IG51bGxcbn0pO1xuZnVuY3Rpb24gX2V4cG9ydCh0YXJnZXQsIGFsbCkge1xuICAgIGZvcih2YXIgbmFtZSBpbiBhbGwpT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgbmFtZSwge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6IGFsbFtuYW1lXVxuICAgIH0pO1xufVxuX2V4cG9ydChleHBvcnRzLCB7XG4gICAgZGVmYXVsdEhlYWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gZGVmYXVsdEhlYWQ7XG4gICAgfSxcbiAgICBkZWZhdWx0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIF9kZWZhdWx0O1xuICAgIH1cbn0pO1xuY29uc3QgX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0ID0gcmVxdWlyZShcIkBzd2MvaGVscGVycy9fL19pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdFwiKTtcbmNvbnN0IF9pbnRlcm9wX3JlcXVpcmVfd2lsZGNhcmQgPSByZXF1aXJlKFwiQHN3Yy9oZWxwZXJzL18vX2ludGVyb3BfcmVxdWlyZV93aWxkY2FyZFwiKTtcbmNvbnN0IF9qc3hydW50aW1lID0gcmVxdWlyZShcInJlYWN0L2pzeC1ydW50aW1lXCIpO1xuY29uc3QgX3JlYWN0ID0gLyojX19QVVJFX18qLyBfaW50ZXJvcF9yZXF1aXJlX3dpbGRjYXJkLl8ocmVxdWlyZShcInJlYWN0XCIpKTtcbmNvbnN0IF9zaWRlZWZmZWN0ID0gLyojX19QVVJFX18qLyBfaW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQuXyhyZXF1aXJlKFwiLi9zaWRlLWVmZmVjdFwiKSk7XG5jb25zdCBfYW1wY29udGV4dHNoYXJlZHJ1bnRpbWUgPSByZXF1aXJlKFwiLi9hbXAtY29udGV4dC5zaGFyZWQtcnVudGltZVwiKTtcbmNvbnN0IF9oZWFkbWFuYWdlcmNvbnRleHRzaGFyZWRydW50aW1lID0gcmVxdWlyZShcIi4vaGVhZC1tYW5hZ2VyLWNvbnRleHQuc2hhcmVkLXJ1bnRpbWVcIik7XG5jb25zdCBfYW1wbW9kZSA9IHJlcXVpcmUoXCIuL2FtcC1tb2RlXCIpO1xuY29uc3QgX3dhcm5vbmNlID0gcmVxdWlyZShcIi4vdXRpbHMvd2Fybi1vbmNlXCIpO1xuZnVuY3Rpb24gZGVmYXVsdEhlYWQoaW5BbXBNb2RlKSB7XG4gICAgaWYgKGluQW1wTW9kZSA9PT0gdm9pZCAwKSBpbkFtcE1vZGUgPSBmYWxzZTtcbiAgICBjb25zdCBoZWFkID0gW1xuICAgICAgICAvKiNfX1BVUkVfXyovICgwLCBfanN4cnVudGltZS5qc3gpKFwibWV0YVwiLCB7XG4gICAgICAgICAgICBjaGFyU2V0OiBcInV0Zi04XCJcbiAgICAgICAgfSlcbiAgICBdO1xuICAgIGlmICghaW5BbXBNb2RlKSB7XG4gICAgICAgIGhlYWQucHVzaCgvKiNfX1BVUkVfXyovICgwLCBfanN4cnVudGltZS5qc3gpKFwibWV0YVwiLCB7XG4gICAgICAgICAgICBuYW1lOiBcInZpZXdwb3J0XCIsXG4gICAgICAgICAgICBjb250ZW50OiBcIndpZHRoPWRldmljZS13aWR0aFwiXG4gICAgICAgIH0pKTtcbiAgICB9XG4gICAgcmV0dXJuIGhlYWQ7XG59XG5mdW5jdGlvbiBvbmx5UmVhY3RFbGVtZW50KGxpc3QsIGNoaWxkKSB7XG4gICAgLy8gUmVhY3QgY2hpbGRyZW4gY2FuIGJlIFwic3RyaW5nXCIgb3IgXCJudW1iZXJcIiBpbiB0aGlzIGNhc2Ugd2UgaWdub3JlIHRoZW0gZm9yIGJhY2t3YXJkcyBjb21wYXRcbiAgICBpZiAodHlwZW9mIGNoaWxkID09PSBcInN0cmluZ1wiIHx8IHR5cGVvZiBjaGlsZCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICByZXR1cm4gbGlzdDtcbiAgICB9XG4gICAgLy8gQWRkcyBzdXBwb3J0IGZvciBSZWFjdC5GcmFnbWVudFxuICAgIGlmIChjaGlsZC50eXBlID09PSBfcmVhY3QuZGVmYXVsdC5GcmFnbWVudCkge1xuICAgICAgICByZXR1cm4gbGlzdC5jb25jYXQoLy8gQHRzLWV4cGVjdC1lcnJvciBAdHlwZXMvcmVhY3QgZG9lcyBub3QgcmVtb3ZlIGZyYWdtZW50cyBidXQgdGhpcyBjb3VsZCBhbHNvIHJldHVybiBSZWFjdFBvcnRhbFtdXG4gICAgICAgIF9yZWFjdC5kZWZhdWx0LkNoaWxkcmVuLnRvQXJyYXkoY2hpbGQucHJvcHMuY2hpbGRyZW4pLnJlZHVjZSgvLyBAdHMtZXhwZWN0LWVycm9yIEB0eXBlcy9yZWFjdCBkb2VzIG5vdCByZW1vdmUgZnJhZ21lbnRzIGJ1dCB0aGlzIGNvdWxkIGFsc28gcmV0dXJuIFJlYWN0UG9ydGFsW11cbiAgICAgICAgKGZyYWdtZW50TGlzdCwgZnJhZ21lbnRDaGlsZCk9PntcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZnJhZ21lbnRDaGlsZCA9PT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YgZnJhZ21lbnRDaGlsZCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBmcmFnbWVudExpc3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZnJhZ21lbnRMaXN0LmNvbmNhdChmcmFnbWVudENoaWxkKTtcbiAgICAgICAgfSwgW10pKTtcbiAgICB9XG4gICAgcmV0dXJuIGxpc3QuY29uY2F0KGNoaWxkKTtcbn1cbmNvbnN0IE1FVEFUWVBFUyA9IFtcbiAgICBcIm5hbWVcIixcbiAgICBcImh0dHBFcXVpdlwiLFxuICAgIFwiY2hhclNldFwiLFxuICAgIFwiaXRlbVByb3BcIlxuXTtcbi8qXG4gcmV0dXJucyBhIGZ1bmN0aW9uIGZvciBmaWx0ZXJpbmcgaGVhZCBjaGlsZCBlbGVtZW50c1xuIHdoaWNoIHNob3VsZG4ndCBiZSBkdXBsaWNhdGVkLCBsaWtlIDx0aXRsZS8+XG4gQWxzbyBhZGRzIHN1cHBvcnQgZm9yIGRlZHVwbGljYXRlZCBga2V5YCBwcm9wZXJ0aWVzXG4qLyBmdW5jdGlvbiB1bmlxdWUoKSB7XG4gICAgY29uc3Qga2V5cyA9IG5ldyBTZXQoKTtcbiAgICBjb25zdCB0YWdzID0gbmV3IFNldCgpO1xuICAgIGNvbnN0IG1ldGFUeXBlcyA9IG5ldyBTZXQoKTtcbiAgICBjb25zdCBtZXRhQ2F0ZWdvcmllcyA9IHt9O1xuICAgIHJldHVybiAoaCk9PntcbiAgICAgICAgbGV0IGlzVW5pcXVlID0gdHJ1ZTtcbiAgICAgICAgbGV0IGhhc0tleSA9IGZhbHNlO1xuICAgICAgICBpZiAoaC5rZXkgJiYgdHlwZW9mIGgua2V5ICE9PSBcIm51bWJlclwiICYmIGgua2V5LmluZGV4T2YoXCIkXCIpID4gMCkge1xuICAgICAgICAgICAgaGFzS2V5ID0gdHJ1ZTtcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IGgua2V5LnNsaWNlKGgua2V5LmluZGV4T2YoXCIkXCIpICsgMSk7XG4gICAgICAgICAgICBpZiAoa2V5cy5oYXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGlzVW5pcXVlID0gZmFsc2U7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGtleXMuYWRkKGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGRlZmF1bHQtY2FzZVxuICAgICAgICBzd2l0Y2goaC50eXBlKXtcbiAgICAgICAgICAgIGNhc2UgXCJ0aXRsZVwiOlxuICAgICAgICAgICAgY2FzZSBcImJhc2VcIjpcbiAgICAgICAgICAgICAgICBpZiAodGFncy5oYXMoaC50eXBlKSkge1xuICAgICAgICAgICAgICAgICAgICBpc1VuaXF1ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRhZ3MuYWRkKGgudHlwZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIm1ldGFcIjpcbiAgICAgICAgICAgICAgICBmb3IobGV0IGkgPSAwLCBsZW4gPSBNRVRBVFlQRVMubGVuZ3RoOyBpIDwgbGVuOyBpKyspe1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBtZXRhdHlwZSA9IE1FVEFUWVBFU1tpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFoLnByb3BzLmhhc093blByb3BlcnR5KG1ldGF0eXBlKSkgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtZXRhdHlwZSA9PT0gXCJjaGFyU2V0XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtZXRhVHlwZXMuaGFzKG1ldGF0eXBlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzVW5pcXVlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ldGFUeXBlcy5hZGQobWV0YXR5cGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY2F0ZWdvcnkgPSBoLnByb3BzW21ldGF0eXBlXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNhdGVnb3JpZXMgPSBtZXRhQ2F0ZWdvcmllc1ttZXRhdHlwZV0gfHwgbmV3IFNldCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChtZXRhdHlwZSAhPT0gXCJuYW1lXCIgfHwgIWhhc0tleSkgJiYgY2F0ZWdvcmllcy5oYXMoY2F0ZWdvcnkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNVbmlxdWUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2F0ZWdvcmllcy5hZGQoY2F0ZWdvcnkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ldGFDYXRlZ29yaWVzW21ldGF0eXBlXSA9IGNhdGVnb3JpZXM7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlzVW5pcXVlO1xuICAgIH07XG59XG4vKipcbiAqXG4gKiBAcGFyYW0gaGVhZENoaWxkcmVuRWxlbWVudHMgTGlzdCBvZiBjaGlsZHJlbiBvZiA8SGVhZD5cbiAqLyBmdW5jdGlvbiByZWR1Y2VDb21wb25lbnRzKGhlYWRDaGlsZHJlbkVsZW1lbnRzLCBwcm9wcykge1xuICAgIGNvbnN0IHsgaW5BbXBNb2RlIH0gPSBwcm9wcztcbiAgICByZXR1cm4gaGVhZENoaWxkcmVuRWxlbWVudHMucmVkdWNlKG9ubHlSZWFjdEVsZW1lbnQsIFtdKS5yZXZlcnNlKCkuY29uY2F0KGRlZmF1bHRIZWFkKGluQW1wTW9kZSkucmV2ZXJzZSgpKS5maWx0ZXIodW5pcXVlKCkpLnJldmVyc2UoKS5tYXAoKGMsIGkpPT57XG4gICAgICAgIGNvbnN0IGtleSA9IGMua2V5IHx8IGk7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJkZXZlbG9wbWVudFwiICYmIHByb2Nlc3MuZW52Ll9fTkVYVF9PUFRJTUlaRV9GT05UUyAmJiAhaW5BbXBNb2RlKSB7XG4gICAgICAgICAgICBpZiAoYy50eXBlID09PSBcImxpbmtcIiAmJiBjLnByb3BzW1wiaHJlZlwiXSAmJiAvLyBUT0RPKHByYXRlZWtiaEApOiBSZXBsYWNlIHRoaXMgd2l0aCBjb25zdCBmcm9tIGBjb25zdGFudHNgIHdoZW4gdGhlIHRyZWUgc2hha2luZyB3b3Jrcy5cbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBcImh0dHBzOi8vZm9udHMuZ29vZ2xlYXBpcy5jb20vY3NzXCIsXG4gICAgICAgICAgICAgICAgXCJodHRwczovL3VzZS50eXBla2l0Lm5ldC9cIlxuICAgICAgICAgICAgXS5zb21lKCh1cmwpPT5jLnByb3BzW1wiaHJlZlwiXS5zdGFydHNXaXRoKHVybCkpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV3UHJvcHMgPSB7XG4gICAgICAgICAgICAgICAgICAgIC4uLmMucHJvcHMgfHwge31cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIG5ld1Byb3BzW1wiZGF0YS1ocmVmXCJdID0gbmV3UHJvcHNbXCJocmVmXCJdO1xuICAgICAgICAgICAgICAgIG5ld1Byb3BzW1wiaHJlZlwiXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAvLyBBZGQgdGhpcyBhdHRyaWJ1dGUgdG8gbWFrZSBpdCBlYXN5IHRvIGlkZW50aWZ5IG9wdGltaXplZCB0YWdzXG4gICAgICAgICAgICAgICAgbmV3UHJvcHNbXCJkYXRhLW9wdGltaXplZC1mb250c1wiXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY2xvbmVFbGVtZW50KGMsIG5ld1Byb3BzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwiZGV2ZWxvcG1lbnRcIikge1xuICAgICAgICAgICAgLy8gb21pdCBKU09OLUxEIHN0cnVjdHVyZWQgZGF0YSBzbmlwcGV0cyBmcm9tIHRoZSB3YXJuaW5nXG4gICAgICAgICAgICBpZiAoYy50eXBlID09PSBcInNjcmlwdFwiICYmIGMucHJvcHNbXCJ0eXBlXCJdICE9PSBcImFwcGxpY2F0aW9uL2xkK2pzb25cIikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNyY01lc3NhZ2UgPSBjLnByb3BzW1wic3JjXCJdID8gJzxzY3JpcHQ+IHRhZyB3aXRoIHNyYz1cIicgKyBjLnByb3BzW1wic3JjXCJdICsgJ1wiJyA6IFwiaW5saW5lIDxzY3JpcHQ+XCI7XG4gICAgICAgICAgICAgICAgKDAsIF93YXJub25jZS53YXJuT25jZSkoXCJEbyBub3QgYWRkIDxzY3JpcHQ+IHRhZ3MgdXNpbmcgbmV4dC9oZWFkIChzZWUgXCIgKyBzcmNNZXNzYWdlICsgXCIpLiBVc2UgbmV4dC9zY3JpcHQgaW5zdGVhZC4gXFxuU2VlIG1vcmUgaW5mbyBoZXJlOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy9uby1zY3JpcHQtdGFncy1pbi1oZWFkLWNvbXBvbmVudFwiKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYy50eXBlID09PSBcImxpbmtcIiAmJiBjLnByb3BzW1wicmVsXCJdID09PSBcInN0eWxlc2hlZXRcIikge1xuICAgICAgICAgICAgICAgICgwLCBfd2Fybm9uY2Uud2Fybk9uY2UpKCdEbyBub3QgYWRkIHN0eWxlc2hlZXRzIHVzaW5nIG5leHQvaGVhZCAoc2VlIDxsaW5rIHJlbD1cInN0eWxlc2hlZXRcIj4gdGFnIHdpdGggaHJlZj1cIicgKyBjLnByb3BzW1wiaHJlZlwiXSArICdcIikuIFVzZSBEb2N1bWVudCBpbnN0ZWFkLiBcXG5TZWUgbW9yZSBpbmZvIGhlcmU6IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL21lc3NhZ2VzL25vLXN0eWxlc2hlZXRzLWluLWhlYWQtY29tcG9uZW50Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY2xvbmVFbGVtZW50KGMsIHtcbiAgICAgICAgICAgIGtleVxuICAgICAgICB9KTtcbiAgICB9KTtcbn1cbi8qKlxuICogVGhpcyBjb21wb25lbnQgaW5qZWN0cyBlbGVtZW50cyB0byBgPGhlYWQ+YCBvZiB5b3VyIHBhZ2UuXG4gKiBUbyBhdm9pZCBkdXBsaWNhdGVkIGB0YWdzYCBpbiBgPGhlYWQ+YCB5b3UgY2FuIHVzZSB0aGUgYGtleWAgcHJvcGVydHksIHdoaWNoIHdpbGwgbWFrZSBzdXJlIGV2ZXJ5IHRhZyBpcyBvbmx5IHJlbmRlcmVkIG9uY2UuXG4gKi8gZnVuY3Rpb24gSGVhZChwYXJhbSkge1xuICAgIGxldCB7IGNoaWxkcmVuIH0gPSBwYXJhbTtcbiAgICBjb25zdCBhbXBTdGF0ZSA9ICgwLCBfcmVhY3QudXNlQ29udGV4dCkoX2FtcGNvbnRleHRzaGFyZWRydW50aW1lLkFtcFN0YXRlQ29udGV4dCk7XG4gICAgY29uc3QgaGVhZE1hbmFnZXIgPSAoMCwgX3JlYWN0LnVzZUNvbnRleHQpKF9oZWFkbWFuYWdlcmNvbnRleHRzaGFyZWRydW50aW1lLkhlYWRNYW5hZ2VyQ29udGV4dCk7XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi8gKDAsIF9qc3hydW50aW1lLmpzeCkoX3NpZGVlZmZlY3QuZGVmYXVsdCwge1xuICAgICAgICByZWR1Y2VDb21wb25lbnRzVG9TdGF0ZTogcmVkdWNlQ29tcG9uZW50cyxcbiAgICAgICAgaGVhZE1hbmFnZXI6IGhlYWRNYW5hZ2VyLFxuICAgICAgICBpbkFtcE1vZGU6ICgwLCBfYW1wbW9kZS5pc0luQW1wTW9kZSkoYW1wU3RhdGUpLFxuICAgICAgICBjaGlsZHJlbjogY2hpbGRyZW5cbiAgICB9KTtcbn1cbmNvbnN0IF9kZWZhdWx0ID0gSGVhZDtcblxuaWYgKCh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnZnVuY3Rpb24nIHx8ICh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnb2JqZWN0JyAmJiBleHBvcnRzLmRlZmF1bHQgIT09IG51bGwpKSAmJiB0eXBlb2YgZXhwb3J0cy5kZWZhdWx0Ll9fZXNNb2R1bGUgPT09ICd1bmRlZmluZWQnKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLmRlZmF1bHQsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgT2JqZWN0LmFzc2lnbihleHBvcnRzLmRlZmF1bHQsIGV4cG9ydHMpO1xuICBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aGVhZC5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJtb2R1bGUiLCJkZWZhdWx0SGVhZCIsImRlZmF1bHQiLCJfZXhwb3J0IiwidGFyZ2V0IiwiYWxsIiwibmFtZSIsImVudW1lcmFibGUiLCJnZXQiLCJfZGVmYXVsdCIsIl9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdCIsInJlcXVpcmUiLCJfaW50ZXJvcF9yZXF1aXJlX3dpbGRjYXJkIiwiX2pzeHJ1bnRpbWUiLCJfcmVhY3QiLCJfIiwiX3NpZGVlZmZlY3QiLCJfYW1wY29udGV4dHNoYXJlZHJ1bnRpbWUiLCJfaGVhZG1hbmFnZXJjb250ZXh0c2hhcmVkcnVudGltZSIsIl9hbXBtb2RlIiwiX3dhcm5vbmNlIiwiaW5BbXBNb2RlIiwiaGVhZCIsImpzeCIsImNoYXJTZXQiLCJwdXNoIiwiY29udGVudCIsIm9ubHlSZWFjdEVsZW1lbnQiLCJsaXN0IiwiY2hpbGQiLCJ0eXBlIiwiRnJhZ21lbnQiLCJjb25jYXQiLCJDaGlsZHJlbiIsInRvQXJyYXkiLCJwcm9wcyIsImNoaWxkcmVuIiwicmVkdWNlIiwiZnJhZ21lbnRMaXN0IiwiZnJhZ21lbnRDaGlsZCIsIk1FVEFUWVBFUyIsInVuaXF1ZSIsImtleXMiLCJTZXQiLCJ0YWdzIiwibWV0YVR5cGVzIiwibWV0YUNhdGVnb3JpZXMiLCJoIiwiaXNVbmlxdWUiLCJoYXNLZXkiLCJrZXkiLCJpbmRleE9mIiwic2xpY2UiLCJoYXMiLCJhZGQiLCJpIiwibGVuIiwibGVuZ3RoIiwibWV0YXR5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsImNhdGVnb3J5IiwiY2F0ZWdvcmllcyIsInJlZHVjZUNvbXBvbmVudHMiLCJoZWFkQ2hpbGRyZW5FbGVtZW50cyIsInJldmVyc2UiLCJmaWx0ZXIiLCJtYXAiLCJjIiwicHJvY2VzcyIsImVudiIsIl9fTkVYVF9PUFRJTUlaRV9GT05UUyIsInNvbWUiLCJ1cmwiLCJzdGFydHNXaXRoIiwibmV3UHJvcHMiLCJ1bmRlZmluZWQiLCJjbG9uZUVsZW1lbnQiLCJzcmNNZXNzYWdlIiwid2Fybk9uY2UiLCJIZWFkIiwicGFyYW0iLCJhbXBTdGF0ZSIsInVzZUNvbnRleHQiLCJBbXBTdGF0ZUNvbnRleHQiLCJoZWFkTWFuYWdlciIsIkhlYWRNYW5hZ2VyQ29udGV4dCIsInJlZHVjZUNvbXBvbmVudHNUb1N0YXRlIiwiaXNJbkFtcE1vZGUiLCJfX2VzTW9kdWxlIiwiYXNzaWduIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/head.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/image-blur-svg.js":
/*!*************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/image-blur-svg.js ***!
  \*************************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval(__webpack_require__.ts("/**\n * A shared function, used on both client and server, to generate a SVG blur placeholder.\n */ \nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"getImageBlurSvg\", ({\n    enumerable: true,\n    get: function() {\n        return getImageBlurSvg;\n    }\n}));\nfunction getImageBlurSvg(param) {\n    let { widthInt, heightInt, blurWidth, blurHeight, blurDataURL, objectFit } = param;\n    const std = 20;\n    const svgWidth = blurWidth ? blurWidth * 40 : widthInt;\n    const svgHeight = blurHeight ? blurHeight * 40 : heightInt;\n    const viewBox = svgWidth && svgHeight ? \"viewBox='0 0 \" + svgWidth + \" \" + svgHeight + \"'\" : \"\";\n    const preserveAspectRatio = viewBox ? \"none\" : objectFit === \"contain\" ? \"xMidYMid\" : objectFit === \"cover\" ? \"xMidYMid slice\" : \"none\";\n    return \"%3Csvg xmlns='http://www.w3.org/2000/svg' \" + viewBox + \"%3E%3Cfilter id='b' color-interpolation-filters='sRGB'%3E%3CfeGaussianBlur stdDeviation='\" + std + \"'/%3E%3CfeColorMatrix values='1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 100 -1' result='s'/%3E%3CfeFlood x='0' y='0' width='100%25' height='100%25'/%3E%3CfeComposite operator='out' in='s'/%3E%3CfeComposite in2='SourceGraphic'/%3E%3CfeGaussianBlur stdDeviation='\" + std + \"'/%3E%3C/filter%3E%3Cimage width='100%25' height='100%25' x='0' y='0' preserveAspectRatio='\" + preserveAspectRatio + \"' style='filter: url(%23b);' href='\" + blurDataURL + \"'/%3E%3C/svg%3E\";\n} //# sourceMappingURL=image-blur-svg.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9pbWFnZS1ibHVyLXN2Zy5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7Q0FFQyxHQUFnQjtBQUNqQkEsOENBQTZDO0lBQ3pDRyxPQUFPO0FBQ1gsQ0FBQyxFQUFDO0FBQ0ZILG1EQUFrRDtJQUM5Q0ksWUFBWTtJQUNaQyxLQUFLO1FBQ0QsT0FBT0M7SUFDWDtBQUNKLENBQUMsRUFBQztBQUNGLFNBQVNBLGdCQUFnQkMsS0FBSztJQUMxQixJQUFJLEVBQUVDLFFBQVEsRUFBRUMsU0FBUyxFQUFFQyxTQUFTLEVBQUVDLFVBQVUsRUFBRUMsV0FBVyxFQUFFQyxTQUFTLEVBQUUsR0FBR047SUFDN0UsTUFBTU8sTUFBTTtJQUNaLE1BQU1DLFdBQVdMLFlBQVlBLFlBQVksS0FBS0Y7SUFDOUMsTUFBTVEsWUFBWUwsYUFBYUEsYUFBYSxLQUFLRjtJQUNqRCxNQUFNUSxVQUFVRixZQUFZQyxZQUFZLGtCQUFrQkQsV0FBVyxNQUFNQyxZQUFZLE1BQU07SUFDN0YsTUFBTUUsc0JBQXNCRCxVQUFVLFNBQVNKLGNBQWMsWUFBWSxhQUFhQSxjQUFjLFVBQVUsbUJBQW1CO0lBQ2pJLE9BQU8sK0NBQStDSSxVQUFVLDhGQUE4RkgsTUFBTSxvUUFBb1FBLE1BQU0sZ0dBQWdHSSxzQkFBc0Isd0NBQXdDTixjQUFjO0FBQzlsQixFQUVBLDBDQUEwQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvaW1hZ2UtYmx1ci1zdmcuanM/OTU3MCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEEgc2hhcmVkIGZ1bmN0aW9uLCB1c2VkIG9uIGJvdGggY2xpZW50IGFuZCBzZXJ2ZXIsIHRvIGdlbmVyYXRlIGEgU1ZHIGJsdXIgcGxhY2Vob2xkZXIuXG4gKi8gXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJnZXRJbWFnZUJsdXJTdmdcIiwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGdldEltYWdlQmx1clN2ZztcbiAgICB9XG59KTtcbmZ1bmN0aW9uIGdldEltYWdlQmx1clN2ZyhwYXJhbSkge1xuICAgIGxldCB7IHdpZHRoSW50LCBoZWlnaHRJbnQsIGJsdXJXaWR0aCwgYmx1ckhlaWdodCwgYmx1ckRhdGFVUkwsIG9iamVjdEZpdCB9ID0gcGFyYW07XG4gICAgY29uc3Qgc3RkID0gMjA7XG4gICAgY29uc3Qgc3ZnV2lkdGggPSBibHVyV2lkdGggPyBibHVyV2lkdGggKiA0MCA6IHdpZHRoSW50O1xuICAgIGNvbnN0IHN2Z0hlaWdodCA9IGJsdXJIZWlnaHQgPyBibHVySGVpZ2h0ICogNDAgOiBoZWlnaHRJbnQ7XG4gICAgY29uc3Qgdmlld0JveCA9IHN2Z1dpZHRoICYmIHN2Z0hlaWdodCA/IFwidmlld0JveD0nMCAwIFwiICsgc3ZnV2lkdGggKyBcIiBcIiArIHN2Z0hlaWdodCArIFwiJ1wiIDogXCJcIjtcbiAgICBjb25zdCBwcmVzZXJ2ZUFzcGVjdFJhdGlvID0gdmlld0JveCA/IFwibm9uZVwiIDogb2JqZWN0Rml0ID09PSBcImNvbnRhaW5cIiA/IFwieE1pZFlNaWRcIiA6IG9iamVjdEZpdCA9PT0gXCJjb3ZlclwiID8gXCJ4TWlkWU1pZCBzbGljZVwiIDogXCJub25lXCI7XG4gICAgcmV0dXJuIFwiJTNDc3ZnIHhtbG5zPSdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycgXCIgKyB2aWV3Qm94ICsgXCIlM0UlM0NmaWx0ZXIgaWQ9J2InIGNvbG9yLWludGVycG9sYXRpb24tZmlsdGVycz0nc1JHQiclM0UlM0NmZUdhdXNzaWFuQmx1ciBzdGREZXZpYXRpb249J1wiICsgc3RkICsgXCInLyUzRSUzQ2ZlQ29sb3JNYXRyaXggdmFsdWVzPScxIDAgMCAwIDAgMCAxIDAgMCAwIDAgMCAxIDAgMCAwIDAgMCAxMDAgLTEnIHJlc3VsdD0ncycvJTNFJTNDZmVGbG9vZCB4PScwJyB5PScwJyB3aWR0aD0nMTAwJTI1JyBoZWlnaHQ9JzEwMCUyNScvJTNFJTNDZmVDb21wb3NpdGUgb3BlcmF0b3I9J291dCcgaW49J3MnLyUzRSUzQ2ZlQ29tcG9zaXRlIGluMj0nU291cmNlR3JhcGhpYycvJTNFJTNDZmVHYXVzc2lhbkJsdXIgc3RkRGV2aWF0aW9uPSdcIiArIHN0ZCArIFwiJy8lM0UlM0MvZmlsdGVyJTNFJTNDaW1hZ2Ugd2lkdGg9JzEwMCUyNScgaGVpZ2h0PScxMDAlMjUnIHg9JzAnIHk9JzAnIHByZXNlcnZlQXNwZWN0UmF0aW89J1wiICsgcHJlc2VydmVBc3BlY3RSYXRpbyArIFwiJyBzdHlsZT0nZmlsdGVyOiB1cmwoJTIzYik7JyBocmVmPSdcIiArIGJsdXJEYXRhVVJMICsgXCInLyUzRSUzQy9zdmclM0VcIjtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW1hZ2UtYmx1ci1zdmcuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiZW51bWVyYWJsZSIsImdldCIsImdldEltYWdlQmx1clN2ZyIsInBhcmFtIiwid2lkdGhJbnQiLCJoZWlnaHRJbnQiLCJibHVyV2lkdGgiLCJibHVySGVpZ2h0IiwiYmx1ckRhdGFVUkwiLCJvYmplY3RGaXQiLCJzdGQiLCJzdmdXaWR0aCIsInN2Z0hlaWdodCIsInZpZXdCb3giLCJwcmVzZXJ2ZUFzcGVjdFJhdGlvIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/image-blur-svg.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/image-config-context.shared-runtime.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/image-config-context.shared-runtime.js ***!
  \**********************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"ImageConfigContext\", ({\n    enumerable: true,\n    get: function() {\n        return ImageConfigContext;\n    }\n}));\nconst _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_interop_require_default.js\");\nconst _react = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\"));\nconst _imageconfig = __webpack_require__(/*! ./image-config */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/image-config.js\");\nconst ImageConfigContext = _react.default.createContext(_imageconfig.imageConfigDefault);\nif (true) {\n    ImageConfigContext.displayName = \"ImageConfigContext\";\n} //# sourceMappingURL=image-config-context.shared-runtime.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9pbWFnZS1jb25maWctY29udGV4dC5zaGFyZWQtcnVudGltZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU87QUFDWCxDQUFDLEVBQUM7QUFDRkgsc0RBQXFEO0lBQ2pESSxZQUFZO0lBQ1pDLEtBQUs7UUFDRCxPQUFPQztJQUNYO0FBQ0osQ0FBQyxFQUFDO0FBQ0YsTUFBTUMsMkJBQTJCQyxtQkFBT0EsQ0FBQyxnSUFBeUM7QUFDbEYsTUFBTUMsU0FBUyxXQUFXLEdBQUdGLHlCQUF5QkcsQ0FBQyxDQUFDRixtQkFBT0EsQ0FBQyxtRkFBTztBQUN2RSxNQUFNRyxlQUFlSCxtQkFBT0EsQ0FBQywrRkFBZ0I7QUFDN0MsTUFBTUYscUJBQXFCRyxPQUFPRyxPQUFPLENBQUNDLGFBQWEsQ0FBQ0YsYUFBYUcsa0JBQWtCO0FBQ3ZGLElBQUlDLElBQXFDLEVBQUU7SUFDdkNULG1CQUFtQlUsV0FBVyxHQUFHO0FBQ3JDLEVBRUEsK0RBQStEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9pbWFnZS1jb25maWctY29udGV4dC5zaGFyZWQtcnVudGltZS5qcz8yNzhiIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiSW1hZ2VDb25maWdDb250ZXh0XCIsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBJbWFnZUNvbmZpZ0NvbnRleHQ7XG4gICAgfVxufSk7XG5jb25zdCBfaW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQgPSByZXF1aXJlKFwiQHN3Yy9oZWxwZXJzL18vX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0XCIpO1xuY29uc3QgX3JlYWN0ID0gLyojX19QVVJFX18qLyBfaW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQuXyhyZXF1aXJlKFwicmVhY3RcIikpO1xuY29uc3QgX2ltYWdlY29uZmlnID0gcmVxdWlyZShcIi4vaW1hZ2UtY29uZmlnXCIpO1xuY29uc3QgSW1hZ2VDb25maWdDb250ZXh0ID0gX3JlYWN0LmRlZmF1bHQuY3JlYXRlQ29udGV4dChfaW1hZ2Vjb25maWcuaW1hZ2VDb25maWdEZWZhdWx0KTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICBJbWFnZUNvbmZpZ0NvbnRleHQuZGlzcGxheU5hbWUgPSBcIkltYWdlQ29uZmlnQ29udGV4dFwiO1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbWFnZS1jb25maWctY29udGV4dC5zaGFyZWQtcnVudGltZS5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJlbnVtZXJhYmxlIiwiZ2V0IiwiSW1hZ2VDb25maWdDb250ZXh0IiwiX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0IiwicmVxdWlyZSIsIl9yZWFjdCIsIl8iLCJfaW1hZ2Vjb25maWciLCJkZWZhdWx0IiwiY3JlYXRlQ29udGV4dCIsImltYWdlQ29uZmlnRGVmYXVsdCIsInByb2Nlc3MiLCJkaXNwbGF5TmFtZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/image-config-context.shared-runtime.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/image-config.js":
/*!***********************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/image-config.js ***!
  \***********************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    VALID_LOADERS: function() {\n        return VALID_LOADERS;\n    },\n    imageConfigDefault: function() {\n        return imageConfigDefault;\n    }\n});\nconst VALID_LOADERS = [\n    \"default\",\n    \"imgix\",\n    \"cloudinary\",\n    \"akamai\",\n    \"custom\"\n];\nconst imageConfigDefault = {\n    deviceSizes: [\n        640,\n        750,\n        828,\n        1080,\n        1200,\n        1920,\n        2048,\n        3840\n    ],\n    imageSizes: [\n        16,\n        32,\n        48,\n        64,\n        96,\n        128,\n        256,\n        384\n    ],\n    path: \"/_next/image\",\n    loader: \"default\",\n    loaderFile: \"\",\n    domains: [],\n    disableStaticImages: false,\n    minimumCacheTTL: 60,\n    formats: [\n        \"image/webp\"\n    ],\n    dangerouslyAllowSVG: false,\n    contentSecurityPolicy: \"script-src 'none'; frame-src 'none'; sandbox;\",\n    contentDispositionType: \"inline\",\n    remotePatterns: [],\n    unoptimized: false\n}; //# sourceMappingURL=image-config.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9pbWFnZS1jb25maWcuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQ3pDRyxPQUFPO0FBQ1gsQ0FBQyxFQUFDO0FBQ0YsS0FBTUMsQ0FBQUEsQ0FHTjtBQUNBLFNBQVNHLFFBQVFDLE1BQU0sRUFBRUMsR0FBRztJQUN4QixJQUFJLElBQUlDLFFBQVFELElBQUlULE9BQU9DLGNBQWMsQ0FBQ08sUUFBUUUsTUFBTTtRQUNwREMsWUFBWTtRQUNaQyxLQUFLSCxHQUFHLENBQUNDLEtBQUs7SUFDbEI7QUFDSjtBQUNBSCxRQUFRTCxTQUFTO0lBQ2JHLGVBQWU7UUFDWCxPQUFPQTtJQUNYO0lBQ0FDLG9CQUFvQjtRQUNoQixPQUFPQTtJQUNYO0FBQ0o7QUFDQSxNQUFNRCxnQkFBZ0I7SUFDbEI7SUFDQTtJQUNBO0lBQ0E7SUFDQTtDQUNIO0FBQ0QsTUFBTUMscUJBQXFCO0lBQ3ZCTyxhQUFhO1FBQ1Q7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtLQUNIO0lBQ0RDLFlBQVk7UUFDUjtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO0tBQ0g7SUFDREMsTUFBTTtJQUNOQyxRQUFRO0lBQ1JDLFlBQVk7SUFDWkMsU0FBUyxFQUFFO0lBQ1hDLHFCQUFxQjtJQUNyQkMsaUJBQWlCO0lBQ2pCQyxTQUFTO1FBQ0w7S0FDSDtJQUNEQyxxQkFBcUI7SUFDckJDLHVCQUF1QjtJQUN2QkMsd0JBQXdCO0lBQ3hCQyxnQkFBZ0IsRUFBRTtJQUNsQkMsYUFBYTtBQUNqQixHQUVBLHdDQUF3QyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvaW1hZ2UtY29uZmlnLmpzPzMxMjYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG4wICYmIChtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBWQUxJRF9MT0FERVJTOiBudWxsLFxuICAgIGltYWdlQ29uZmlnRGVmYXVsdDogbnVsbFxufSk7XG5mdW5jdGlvbiBfZXhwb3J0KHRhcmdldCwgYWxsKSB7XG4gICAgZm9yKHZhciBuYW1lIGluIGFsbClPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBuYW1lLCB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGdldDogYWxsW25hbWVdXG4gICAgfSk7XG59XG5fZXhwb3J0KGV4cG9ydHMsIHtcbiAgICBWQUxJRF9MT0FERVJTOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIFZBTElEX0xPQURFUlM7XG4gICAgfSxcbiAgICBpbWFnZUNvbmZpZ0RlZmF1bHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gaW1hZ2VDb25maWdEZWZhdWx0O1xuICAgIH1cbn0pO1xuY29uc3QgVkFMSURfTE9BREVSUyA9IFtcbiAgICBcImRlZmF1bHRcIixcbiAgICBcImltZ2l4XCIsXG4gICAgXCJjbG91ZGluYXJ5XCIsXG4gICAgXCJha2FtYWlcIixcbiAgICBcImN1c3RvbVwiXG5dO1xuY29uc3QgaW1hZ2VDb25maWdEZWZhdWx0ID0ge1xuICAgIGRldmljZVNpemVzOiBbXG4gICAgICAgIDY0MCxcbiAgICAgICAgNzUwLFxuICAgICAgICA4MjgsXG4gICAgICAgIDEwODAsXG4gICAgICAgIDEyMDAsXG4gICAgICAgIDE5MjAsXG4gICAgICAgIDIwNDgsXG4gICAgICAgIDM4NDBcbiAgICBdLFxuICAgIGltYWdlU2l6ZXM6IFtcbiAgICAgICAgMTYsXG4gICAgICAgIDMyLFxuICAgICAgICA0OCxcbiAgICAgICAgNjQsXG4gICAgICAgIDk2LFxuICAgICAgICAxMjgsXG4gICAgICAgIDI1NixcbiAgICAgICAgMzg0XG4gICAgXSxcbiAgICBwYXRoOiBcIi9fbmV4dC9pbWFnZVwiLFxuICAgIGxvYWRlcjogXCJkZWZhdWx0XCIsXG4gICAgbG9hZGVyRmlsZTogXCJcIixcbiAgICBkb21haW5zOiBbXSxcbiAgICBkaXNhYmxlU3RhdGljSW1hZ2VzOiBmYWxzZSxcbiAgICBtaW5pbXVtQ2FjaGVUVEw6IDYwLFxuICAgIGZvcm1hdHM6IFtcbiAgICAgICAgXCJpbWFnZS93ZWJwXCJcbiAgICBdLFxuICAgIGRhbmdlcm91c2x5QWxsb3dTVkc6IGZhbHNlLFxuICAgIGNvbnRlbnRTZWN1cml0eVBvbGljeTogXCJzY3JpcHQtc3JjICdub25lJzsgZnJhbWUtc3JjICdub25lJzsgc2FuZGJveDtcIixcbiAgICBjb250ZW50RGlzcG9zaXRpb25UeXBlOiBcImlubGluZVwiLFxuICAgIHJlbW90ZVBhdHRlcm5zOiBbXSxcbiAgICB1bm9wdGltaXplZDogZmFsc2Vcbn07XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWltYWdlLWNvbmZpZy5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJtb2R1bGUiLCJWQUxJRF9MT0FERVJTIiwiaW1hZ2VDb25maWdEZWZhdWx0IiwiX2V4cG9ydCIsInRhcmdldCIsImFsbCIsIm5hbWUiLCJlbnVtZXJhYmxlIiwiZ2V0IiwiZGV2aWNlU2l6ZXMiLCJpbWFnZVNpemVzIiwicGF0aCIsImxvYWRlciIsImxvYWRlckZpbGUiLCJkb21haW5zIiwiZGlzYWJsZVN0YXRpY0ltYWdlcyIsIm1pbmltdW1DYWNoZVRUTCIsImZvcm1hdHMiLCJkYW5nZXJvdXNseUFsbG93U1ZHIiwiY29udGVudFNlY3VyaXR5UG9saWN5IiwiY29udGVudERpc3Bvc2l0aW9uVHlwZSIsInJlbW90ZVBhdHRlcm5zIiwidW5vcHRpbWl6ZWQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/image-config.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/image-external.js":
/*!*************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/image-external.js ***!
  \*************************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    getImageProps: function() {\n        return getImageProps;\n    },\n    default: function() {\n        return _default;\n    }\n});\nconst _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_interop_require_default.js\");\nconst _getimgprops = __webpack_require__(/*! ./get-img-props */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/get-img-props.js\");\nconst _imagecomponent = __webpack_require__(/*! ../../client/image-component */ \"(app-pages-browser)/./node_modules/next/dist/client/image-component.js\");\nconst _imageloader = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! next/dist/shared/lib/image-loader */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/image-loader.js\"));\nconst getImageProps = (imgProps)=>{\n    const { props } = (0, _getimgprops.getImgProps)(imgProps, {\n        defaultLoader: _imageloader.default,\n        // This is replaced by webpack define plugin\n        imgConf: {\"deviceSizes\":[640,750,828,1080,1200,1920,2048,3840],\"imageSizes\":[16,32,48,64,96,128,256,384],\"path\":\"/_next/image\",\"loader\":\"default\",\"dangerouslyAllowSVG\":false,\"unoptimized\":false,\"domains\":[\"localhost\"],\"remotePatterns\":[]}\n    });\n    // Normally we don't care about undefined props because we pass to JSX,\n    // but this exported function could be used by the end user for anything\n    // so we delete undefined props to clean it up a little.\n    for (const [key, value] of Object.entries(props)){\n        if (value === undefined) {\n            delete props[key];\n        }\n    }\n    return {\n        props\n    };\n};\nconst _default = _imagecomponent.Image; //# sourceMappingURL=image-external.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9pbWFnZS1leHRlcm5hbC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU87QUFDWCxDQUFDLEVBQUM7QUFDRixLQUFNQyxDQUFBQSxDQUdOO0FBQ0EsU0FBU0csUUFBUUMsTUFBTSxFQUFFQyxHQUFHO0lBQ3hCLElBQUksSUFBSUMsUUFBUUQsSUFBSVQsT0FBT0MsY0FBYyxDQUFDTyxRQUFRRSxNQUFNO1FBQ3BEQyxZQUFZO1FBQ1pDLEtBQUtILEdBQUcsQ0FBQ0MsS0FBSztJQUNsQjtBQUNKO0FBQ0FILFFBQVFMLFNBQVM7SUFDYkcsZUFBZTtRQUNYLE9BQU9BO0lBQ1g7SUFDQUMsU0FBUztRQUNMLE9BQU9PO0lBQ1g7QUFDSjtBQUNBLE1BQU1DLDJCQUEyQkMsbUJBQU9BLENBQUMsZ0lBQXlDO0FBQ2xGLE1BQU1DLGVBQWVELG1CQUFPQSxDQUFDLGlHQUFpQjtBQUM5QyxNQUFNRSxrQkFBa0JGLG1CQUFPQSxDQUFDLDRHQUE4QjtBQUM5RCxNQUFNRyxlQUFlLFdBQVcsR0FBR0oseUJBQXlCSyxDQUFDLENBQUNKLG1CQUFPQSxDQUFDLGtIQUFtQztBQUN6RyxNQUFNVixnQkFBZ0IsQ0FBQ2U7SUFDbkIsTUFBTSxFQUFFQyxLQUFLLEVBQUUsR0FBRyxDQUFDLEdBQUdMLGFBQWFNLFdBQVcsRUFBRUYsVUFBVTtRQUN0REcsZUFBZUwsYUFBYVosT0FBTztRQUNuQyw0Q0FBNEM7UUFDNUNrQixTQUFTQyxxT0FBNkI7SUFDMUM7SUFDQSx1RUFBdUU7SUFDdkUsd0VBQXdFO0lBQ3hFLHdEQUF3RDtJQUN4RCxLQUFLLE1BQU0sQ0FBQ0csS0FBS3pCLE1BQU0sSUFBSUgsT0FBTzZCLE9BQU8sQ0FBQ1IsT0FBTztRQUM3QyxJQUFJbEIsVUFBVTJCLFdBQVc7WUFDckIsT0FBT1QsS0FBSyxDQUFDTyxJQUFJO1FBQ3JCO0lBQ0o7SUFDQSxPQUFPO1FBQ0hQO0lBQ0o7QUFDSjtBQUNBLE1BQU1SLFdBQVdJLGdCQUFnQmMsS0FBSyxFQUV0QywwQ0FBMEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zaGFyZWQvbGliL2ltYWdlLWV4dGVybmFsLmpzPzY4Y2IiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG4wICYmIChtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBnZXRJbWFnZVByb3BzOiBudWxsLFxuICAgIGRlZmF1bHQ6IG51bGxcbn0pO1xuZnVuY3Rpb24gX2V4cG9ydCh0YXJnZXQsIGFsbCkge1xuICAgIGZvcih2YXIgbmFtZSBpbiBhbGwpT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgbmFtZSwge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6IGFsbFtuYW1lXVxuICAgIH0pO1xufVxuX2V4cG9ydChleHBvcnRzLCB7XG4gICAgZ2V0SW1hZ2VQcm9wczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBnZXRJbWFnZVByb3BzO1xuICAgIH0sXG4gICAgZGVmYXVsdDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBfZGVmYXVsdDtcbiAgICB9XG59KTtcbmNvbnN0IF9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdCA9IHJlcXVpcmUoXCJAc3djL2hlbHBlcnMvXy9faW50ZXJvcF9yZXF1aXJlX2RlZmF1bHRcIik7XG5jb25zdCBfZ2V0aW1ncHJvcHMgPSByZXF1aXJlKFwiLi9nZXQtaW1nLXByb3BzXCIpO1xuY29uc3QgX2ltYWdlY29tcG9uZW50ID0gcmVxdWlyZShcIi4uLy4uL2NsaWVudC9pbWFnZS1jb21wb25lbnRcIik7XG5jb25zdCBfaW1hZ2Vsb2FkZXIgPSAvKiNfX1BVUkVfXyovIF9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdC5fKHJlcXVpcmUoXCJuZXh0L2Rpc3Qvc2hhcmVkL2xpYi9pbWFnZS1sb2FkZXJcIikpO1xuY29uc3QgZ2V0SW1hZ2VQcm9wcyA9IChpbWdQcm9wcyk9PntcbiAgICBjb25zdCB7IHByb3BzIH0gPSAoMCwgX2dldGltZ3Byb3BzLmdldEltZ1Byb3BzKShpbWdQcm9wcywge1xuICAgICAgICBkZWZhdWx0TG9hZGVyOiBfaW1hZ2Vsb2FkZXIuZGVmYXVsdCxcbiAgICAgICAgLy8gVGhpcyBpcyByZXBsYWNlZCBieSB3ZWJwYWNrIGRlZmluZSBwbHVnaW5cbiAgICAgICAgaW1nQ29uZjogcHJvY2Vzcy5lbnYuX19ORVhUX0lNQUdFX09QVFNcbiAgICB9KTtcbiAgICAvLyBOb3JtYWxseSB3ZSBkb24ndCBjYXJlIGFib3V0IHVuZGVmaW5lZCBwcm9wcyBiZWNhdXNlIHdlIHBhc3MgdG8gSlNYLFxuICAgIC8vIGJ1dCB0aGlzIGV4cG9ydGVkIGZ1bmN0aW9uIGNvdWxkIGJlIHVzZWQgYnkgdGhlIGVuZCB1c2VyIGZvciBhbnl0aGluZ1xuICAgIC8vIHNvIHdlIGRlbGV0ZSB1bmRlZmluZWQgcHJvcHMgdG8gY2xlYW4gaXQgdXAgYSBsaXR0bGUuXG4gICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMocHJvcHMpKXtcbiAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBwcm9wc1trZXldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHByb3BzXG4gICAgfTtcbn07XG5jb25zdCBfZGVmYXVsdCA9IF9pbWFnZWNvbXBvbmVudC5JbWFnZTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW1hZ2UtZXh0ZXJuYWwuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwibW9kdWxlIiwiZ2V0SW1hZ2VQcm9wcyIsImRlZmF1bHQiLCJfZXhwb3J0IiwidGFyZ2V0IiwiYWxsIiwibmFtZSIsImVudW1lcmFibGUiLCJnZXQiLCJfZGVmYXVsdCIsIl9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdCIsInJlcXVpcmUiLCJfZ2V0aW1ncHJvcHMiLCJfaW1hZ2Vjb21wb25lbnQiLCJfaW1hZ2Vsb2FkZXIiLCJfIiwiaW1nUHJvcHMiLCJwcm9wcyIsImdldEltZ1Byb3BzIiwiZGVmYXVsdExvYWRlciIsImltZ0NvbmYiLCJwcm9jZXNzIiwiZW52IiwiX19ORVhUX0lNQUdFX09QVFMiLCJrZXkiLCJlbnRyaWVzIiwidW5kZWZpbmVkIiwiSW1hZ2UiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/image-external.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/image-loader.js":
/*!***********************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/image-loader.js ***!
  \***********************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"default\", ({\n    enumerable: true,\n    get: function() {\n        return _default;\n    }\n}));\nfunction defaultLoader(param) {\n    let { config, src, width, quality } = param;\n    if (true) {\n        const missingValues = [];\n        // these should always be provided but make sure they are\n        if (!src) missingValues.push(\"src\");\n        if (!width) missingValues.push(\"width\");\n        if (missingValues.length > 0) {\n            throw new Error(\"Next Image Optimization requires \" + missingValues.join(\", \") + \" to be provided. Make sure you pass them as props to the `next/image` component. Received: \" + JSON.stringify({\n                src,\n                width,\n                quality\n            }));\n        }\n        if (src.startsWith(\"//\")) {\n            throw new Error('Failed to parse src \"' + src + '\" on `next/image`, protocol-relative URL (//) must be changed to an absolute URL (http:// or https://)');\n        }\n        if (!src.startsWith(\"/\") && (config.domains || config.remotePatterns)) {\n            let parsedSrc;\n            try {\n                parsedSrc = new URL(src);\n            } catch (err) {\n                console.error(err);\n                throw new Error('Failed to parse src \"' + src + '\" on `next/image`, if using relative image it must start with a leading slash \"/\" or be an absolute URL (http:// or https://)');\n            }\n            if (true) {\n                // We use dynamic require because this should only error in development\n                const { hasMatch } = __webpack_require__(/*! ./match-remote-pattern */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/match-remote-pattern.js\");\n                if (!hasMatch(config.domains, config.remotePatterns, parsedSrc)) {\n                    throw new Error(\"Invalid src prop (\" + src + ') on `next/image`, hostname \"' + parsedSrc.hostname + '\" is not configured under images in your `next.config.js`\\n' + \"See more info: https://nextjs.org/docs/messages/next-image-unconfigured-host\");\n                }\n            }\n        }\n    }\n    return config.path + \"?url=\" + encodeURIComponent(src) + \"&w=\" + width + \"&q=\" + (quality || 75) + ( false ? 0 : \"\");\n}\n// We use this to determine if the import is the default loader\n// or a custom loader defined by the user in next.config.js\ndefaultLoader.__next_img_default = true;\nconst _default = defaultLoader; //# sourceMappingURL=image-loader.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9pbWFnZS1sb2FkZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQ3pDRyxPQUFPO0FBQ1gsQ0FBQyxFQUFDO0FBQ0ZILDJDQUEwQztJQUN0Q0ksWUFBWTtJQUNaQyxLQUFLO1FBQ0QsT0FBT0M7SUFDWDtBQUNKLENBQUMsRUFBQztBQUNGLFNBQVNDLGNBQWNDLEtBQUs7SUFDeEIsSUFBSSxFQUFFQyxNQUFNLEVBQUVDLEdBQUcsRUFBRUMsS0FBSyxFQUFFQyxPQUFPLEVBQUUsR0FBR0o7SUFDdEMsSUFBSUssSUFBcUMsRUFBRTtRQUN2QyxNQUFNQyxnQkFBZ0IsRUFBRTtRQUN4Qix5REFBeUQ7UUFDekQsSUFBSSxDQUFDSixLQUFLSSxjQUFjQyxJQUFJLENBQUM7UUFDN0IsSUFBSSxDQUFDSixPQUFPRyxjQUFjQyxJQUFJLENBQUM7UUFDL0IsSUFBSUQsY0FBY0UsTUFBTSxHQUFHLEdBQUc7WUFDMUIsTUFBTSxJQUFJQyxNQUFNLHNDQUFzQ0gsY0FBY0ksSUFBSSxDQUFDLFFBQVEsZ0dBQWdHQyxLQUFLQyxTQUFTLENBQUM7Z0JBQzVMVjtnQkFDQUM7Z0JBQ0FDO1lBQ0o7UUFDSjtRQUNBLElBQUlGLElBQUlXLFVBQVUsQ0FBQyxPQUFPO1lBQ3RCLE1BQU0sSUFBSUosTUFBTSwwQkFBMEJQLE1BQU07UUFDcEQ7UUFDQSxJQUFJLENBQUNBLElBQUlXLFVBQVUsQ0FBQyxRQUFTWixDQUFBQSxPQUFPYSxPQUFPLElBQUliLE9BQU9jLGNBQWMsR0FBRztZQUNuRSxJQUFJQztZQUNKLElBQUk7Z0JBQ0FBLFlBQVksSUFBSUMsSUFBSWY7WUFDeEIsRUFBRSxPQUFPZ0IsS0FBSztnQkFDVkMsUUFBUUMsS0FBSyxDQUFDRjtnQkFDZCxNQUFNLElBQUlULE1BQU0sMEJBQTBCUCxNQUFNO1lBQ3BEO1lBQ0EsSUFBSUcsSUFDK0IsRUFBRTtnQkFDakMsdUVBQXVFO2dCQUN2RSxNQUFNLEVBQUVrQixRQUFRLEVBQUUsR0FBR0MsbUJBQU9BLENBQUMsK0dBQXdCO2dCQUNyRCxJQUFJLENBQUNELFNBQVN0QixPQUFPYSxPQUFPLEVBQUViLE9BQU9jLGNBQWMsRUFBRUMsWUFBWTtvQkFDN0QsTUFBTSxJQUFJUCxNQUFNLHVCQUF1QlAsTUFBTSxrQ0FBa0NjLFVBQVVTLFFBQVEsR0FBRyxnRUFBZ0U7Z0JBQ3hLO1lBQ0o7UUFDSjtJQUNKO0lBQ0EsT0FBT3hCLE9BQU95QixJQUFJLEdBQUcsVUFBVUMsbUJBQW1CekIsT0FBTyxRQUFRQyxRQUFRLFFBQVNDLENBQUFBLFdBQVcsRUFBQyxJQUFNQyxDQUFBQSxNQUE4QixHQUFHLENBQXdDLEdBQUcsRUFBQztBQUNyTDtBQUNBLCtEQUErRDtBQUMvRCwyREFBMkQ7QUFDM0ROLGNBQWM4QixrQkFBa0IsR0FBRztBQUNuQyxNQUFNL0IsV0FBV0MsZUFFakIsd0NBQXdDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9pbWFnZS1sb2FkZXIuanM/YzBhMSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImRlZmF1bHRcIiwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIF9kZWZhdWx0O1xuICAgIH1cbn0pO1xuZnVuY3Rpb24gZGVmYXVsdExvYWRlcihwYXJhbSkge1xuICAgIGxldCB7IGNvbmZpZywgc3JjLCB3aWR0aCwgcXVhbGl0eSB9ID0gcGFyYW07XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICBjb25zdCBtaXNzaW5nVmFsdWVzID0gW107XG4gICAgICAgIC8vIHRoZXNlIHNob3VsZCBhbHdheXMgYmUgcHJvdmlkZWQgYnV0IG1ha2Ugc3VyZSB0aGV5IGFyZVxuICAgICAgICBpZiAoIXNyYykgbWlzc2luZ1ZhbHVlcy5wdXNoKFwic3JjXCIpO1xuICAgICAgICBpZiAoIXdpZHRoKSBtaXNzaW5nVmFsdWVzLnB1c2goXCJ3aWR0aFwiKTtcbiAgICAgICAgaWYgKG1pc3NpbmdWYWx1ZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTmV4dCBJbWFnZSBPcHRpbWl6YXRpb24gcmVxdWlyZXMgXCIgKyBtaXNzaW5nVmFsdWVzLmpvaW4oXCIsIFwiKSArIFwiIHRvIGJlIHByb3ZpZGVkLiBNYWtlIHN1cmUgeW91IHBhc3MgdGhlbSBhcyBwcm9wcyB0byB0aGUgYG5leHQvaW1hZ2VgIGNvbXBvbmVudC4gUmVjZWl2ZWQ6IFwiICsgSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgICAgIHNyYyxcbiAgICAgICAgICAgICAgICB3aWR0aCxcbiAgICAgICAgICAgICAgICBxdWFsaXR5XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNyYy5zdGFydHNXaXRoKFwiLy9cIikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIHBhcnNlIHNyYyBcIicgKyBzcmMgKyAnXCIgb24gYG5leHQvaW1hZ2VgLCBwcm90b2NvbC1yZWxhdGl2ZSBVUkwgKC8vKSBtdXN0IGJlIGNoYW5nZWQgdG8gYW4gYWJzb2x1dGUgVVJMIChodHRwOi8vIG9yIGh0dHBzOi8vKScpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghc3JjLnN0YXJ0c1dpdGgoXCIvXCIpICYmIChjb25maWcuZG9tYWlucyB8fCBjb25maWcucmVtb3RlUGF0dGVybnMpKSB7XG4gICAgICAgICAgICBsZXQgcGFyc2VkU3JjO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBwYXJzZWRTcmMgPSBuZXcgVVJMKHNyYyk7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycik7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gcGFyc2Ugc3JjIFwiJyArIHNyYyArICdcIiBvbiBgbmV4dC9pbWFnZWAsIGlmIHVzaW5nIHJlbGF0aXZlIGltYWdlIGl0IG11c3Qgc3RhcnQgd2l0aCBhIGxlYWRpbmcgc2xhc2ggXCIvXCIgb3IgYmUgYW4gYWJzb2x1dGUgVVJMIChodHRwOi8vIG9yIGh0dHBzOi8vKScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInRlc3RcIiAmJiAvLyBtaWNyb21hdGNoIGlzbid0IGNvbXBhdGlibGUgd2l0aCBlZGdlIHJ1bnRpbWVcbiAgICAgICAgICAgIHByb2Nlc3MuZW52Lk5FWFRfUlVOVElNRSAhPT0gXCJlZGdlXCIpIHtcbiAgICAgICAgICAgICAgICAvLyBXZSB1c2UgZHluYW1pYyByZXF1aXJlIGJlY2F1c2UgdGhpcyBzaG91bGQgb25seSBlcnJvciBpbiBkZXZlbG9wbWVudFxuICAgICAgICAgICAgICAgIGNvbnN0IHsgaGFzTWF0Y2ggfSA9IHJlcXVpcmUoXCIuL21hdGNoLXJlbW90ZS1wYXR0ZXJuXCIpO1xuICAgICAgICAgICAgICAgIGlmICghaGFzTWF0Y2goY29uZmlnLmRvbWFpbnMsIGNvbmZpZy5yZW1vdGVQYXR0ZXJucywgcGFyc2VkU3JjKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHNyYyBwcm9wIChcIiArIHNyYyArICcpIG9uIGBuZXh0L2ltYWdlYCwgaG9zdG5hbWUgXCInICsgcGFyc2VkU3JjLmhvc3RuYW1lICsgJ1wiIGlzIG5vdCBjb25maWd1cmVkIHVuZGVyIGltYWdlcyBpbiB5b3VyIGBuZXh0LmNvbmZpZy5qc2BcXG4nICsgXCJTZWUgbW9yZSBpbmZvOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy9uZXh0LWltYWdlLXVuY29uZmlndXJlZC1ob3N0XCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY29uZmlnLnBhdGggKyBcIj91cmw9XCIgKyBlbmNvZGVVUklDb21wb25lbnQoc3JjKSArIFwiJnc9XCIgKyB3aWR0aCArIFwiJnE9XCIgKyAocXVhbGl0eSB8fCA3NSkgKyAocHJvY2Vzcy5lbnYuTkVYVF9ERVBMT1lNRU5UX0lEID8gXCImZHBsPVwiICsgcHJvY2Vzcy5lbnYuTkVYVF9ERVBMT1lNRU5UX0lEIDogXCJcIik7XG59XG4vLyBXZSB1c2UgdGhpcyB0byBkZXRlcm1pbmUgaWYgdGhlIGltcG9ydCBpcyB0aGUgZGVmYXVsdCBsb2FkZXJcbi8vIG9yIGEgY3VzdG9tIGxvYWRlciBkZWZpbmVkIGJ5IHRoZSB1c2VyIGluIG5leHQuY29uZmlnLmpzXG5kZWZhdWx0TG9hZGVyLl9fbmV4dF9pbWdfZGVmYXVsdCA9IHRydWU7XG5jb25zdCBfZGVmYXVsdCA9IGRlZmF1bHRMb2FkZXI7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWltYWdlLWxvYWRlci5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJlbnVtZXJhYmxlIiwiZ2V0IiwiX2RlZmF1bHQiLCJkZWZhdWx0TG9hZGVyIiwicGFyYW0iLCJjb25maWciLCJzcmMiLCJ3aWR0aCIsInF1YWxpdHkiLCJwcm9jZXNzIiwibWlzc2luZ1ZhbHVlcyIsInB1c2giLCJsZW5ndGgiLCJFcnJvciIsImpvaW4iLCJKU09OIiwic3RyaW5naWZ5Iiwic3RhcnRzV2l0aCIsImRvbWFpbnMiLCJyZW1vdGVQYXR0ZXJucyIsInBhcnNlZFNyYyIsIlVSTCIsImVyciIsImNvbnNvbGUiLCJlcnJvciIsImVudiIsIk5FWFRfUlVOVElNRSIsImhhc01hdGNoIiwicmVxdWlyZSIsImhvc3RuYW1lIiwicGF0aCIsImVuY29kZVVSSUNvbXBvbmVudCIsIk5FWFRfREVQTE9ZTUVOVF9JRCIsIl9fbmV4dF9pbWdfZGVmYXVsdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/image-loader.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/match-remote-pattern.js":
/*!*******************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/match-remote-pattern.js ***!
  \*******************************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    matchRemotePattern: function() {\n        return matchRemotePattern;\n    },\n    hasMatch: function() {\n        return hasMatch;\n    }\n});\nconst _micromatch = __webpack_require__(/*! next/dist/compiled/micromatch */ \"(app-pages-browser)/./node_modules/next/dist/compiled/micromatch/index.js\");\nfunction matchRemotePattern(pattern, url) {\n    if (pattern.protocol !== undefined) {\n        const actualProto = url.protocol.slice(0, -1);\n        if (pattern.protocol !== actualProto) {\n            return false;\n        }\n    }\n    if (pattern.port !== undefined) {\n        if (pattern.port !== url.port) {\n            return false;\n        }\n    }\n    if (pattern.hostname === undefined) {\n        throw new Error(\"Pattern should define hostname but found\\n\" + JSON.stringify(pattern));\n    } else {\n        if (!(0, _micromatch.makeRe)(pattern.hostname).test(url.hostname)) {\n            return false;\n        }\n    }\n    var _pattern_pathname;\n    if (!(0, _micromatch.makeRe)((_pattern_pathname = pattern.pathname) != null ? _pattern_pathname : \"**\").test(url.pathname)) {\n        return false;\n    }\n    return true;\n}\nfunction hasMatch(domains, remotePatterns, url) {\n    return domains.some((domain)=>url.hostname === domain) || remotePatterns.some((p)=>matchRemotePattern(p, url));\n} //# sourceMappingURL=match-remote-pattern.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9tYXRjaC1yZW1vdGUtcGF0dGVybi5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU87QUFDWCxDQUFDLEVBQUM7QUFDRixLQUFNQyxDQUFBQSxDQUdOO0FBQ0EsU0FBU0csUUFBUUMsTUFBTSxFQUFFQyxHQUFHO0lBQ3hCLElBQUksSUFBSUMsUUFBUUQsSUFBSVQsT0FBT0MsY0FBYyxDQUFDTyxRQUFRRSxNQUFNO1FBQ3BEQyxZQUFZO1FBQ1pDLEtBQUtILEdBQUcsQ0FBQ0MsS0FBSztJQUNsQjtBQUNKO0FBQ0FILFFBQVFMLFNBQVM7SUFDYkcsb0JBQW9CO1FBQ2hCLE9BQU9BO0lBQ1g7SUFDQUMsVUFBVTtRQUNOLE9BQU9BO0lBQ1g7QUFDSjtBQUNBLE1BQU1PLGNBQWNDLG1CQUFPQSxDQUFDLGdIQUErQjtBQUMzRCxTQUFTVCxtQkFBbUJVLE9BQU8sRUFBRUMsR0FBRztJQUNwQyxJQUFJRCxRQUFRRSxRQUFRLEtBQUtDLFdBQVc7UUFDaEMsTUFBTUMsY0FBY0gsSUFBSUMsUUFBUSxDQUFDRyxLQUFLLENBQUMsR0FBRyxDQUFDO1FBQzNDLElBQUlMLFFBQVFFLFFBQVEsS0FBS0UsYUFBYTtZQUNsQyxPQUFPO1FBQ1g7SUFDSjtJQUNBLElBQUlKLFFBQVFNLElBQUksS0FBS0gsV0FBVztRQUM1QixJQUFJSCxRQUFRTSxJQUFJLEtBQUtMLElBQUlLLElBQUksRUFBRTtZQUMzQixPQUFPO1FBQ1g7SUFDSjtJQUNBLElBQUlOLFFBQVFPLFFBQVEsS0FBS0osV0FBVztRQUNoQyxNQUFNLElBQUlLLE1BQU0sK0NBQStDQyxLQUFLQyxTQUFTLENBQUNWO0lBQ2xGLE9BQU87UUFDSCxJQUFJLENBQUMsQ0FBQyxHQUFHRixZQUFZYSxNQUFNLEVBQUVYLFFBQVFPLFFBQVEsRUFBRUssSUFBSSxDQUFDWCxJQUFJTSxRQUFRLEdBQUc7WUFDL0QsT0FBTztRQUNYO0lBQ0o7SUFDQSxJQUFJTTtJQUNKLElBQUksQ0FBQyxDQUFDLEdBQUdmLFlBQVlhLE1BQU0sRUFBRSxDQUFDRSxvQkFBb0JiLFFBQVFjLFFBQVEsS0FBSyxPQUFPRCxvQkFBb0IsTUFBTUQsSUFBSSxDQUFDWCxJQUFJYSxRQUFRLEdBQUc7UUFDeEgsT0FBTztJQUNYO0lBQ0EsT0FBTztBQUNYO0FBQ0EsU0FBU3ZCLFNBQVN3QixPQUFPLEVBQUVDLGNBQWMsRUFBRWYsR0FBRztJQUMxQyxPQUFPYyxRQUFRRSxJQUFJLENBQUMsQ0FBQ0MsU0FBU2pCLElBQUlNLFFBQVEsS0FBS1csV0FBV0YsZUFBZUMsSUFBSSxDQUFDLENBQUNFLElBQUk3QixtQkFBbUI2QixHQUFHbEI7QUFDN0csRUFFQSxnREFBZ0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zaGFyZWQvbGliL21hdGNoLXJlbW90ZS1wYXR0ZXJuLmpzPzBjOWIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG4wICYmIChtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBtYXRjaFJlbW90ZVBhdHRlcm46IG51bGwsXG4gICAgaGFzTWF0Y2g6IG51bGxcbn0pO1xuZnVuY3Rpb24gX2V4cG9ydCh0YXJnZXQsIGFsbCkge1xuICAgIGZvcih2YXIgbmFtZSBpbiBhbGwpT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgbmFtZSwge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6IGFsbFtuYW1lXVxuICAgIH0pO1xufVxuX2V4cG9ydChleHBvcnRzLCB7XG4gICAgbWF0Y2hSZW1vdGVQYXR0ZXJuOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIG1hdGNoUmVtb3RlUGF0dGVybjtcbiAgICB9LFxuICAgIGhhc01hdGNoOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGhhc01hdGNoO1xuICAgIH1cbn0pO1xuY29uc3QgX21pY3JvbWF0Y2ggPSByZXF1aXJlKFwibmV4dC9kaXN0L2NvbXBpbGVkL21pY3JvbWF0Y2hcIik7XG5mdW5jdGlvbiBtYXRjaFJlbW90ZVBhdHRlcm4ocGF0dGVybiwgdXJsKSB7XG4gICAgaWYgKHBhdHRlcm4ucHJvdG9jb2wgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25zdCBhY3R1YWxQcm90byA9IHVybC5wcm90b2NvbC5zbGljZSgwLCAtMSk7XG4gICAgICAgIGlmIChwYXR0ZXJuLnByb3RvY29sICE9PSBhY3R1YWxQcm90bykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChwYXR0ZXJuLnBvcnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAocGF0dGVybi5wb3J0ICE9PSB1cmwucG9ydCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChwYXR0ZXJuLmhvc3RuYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUGF0dGVybiBzaG91bGQgZGVmaW5lIGhvc3RuYW1lIGJ1dCBmb3VuZFxcblwiICsgSlNPTi5zdHJpbmdpZnkocGF0dGVybikpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICghKDAsIF9taWNyb21hdGNoLm1ha2VSZSkocGF0dGVybi5ob3N0bmFtZSkudGVzdCh1cmwuaG9zdG5hbWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmFyIF9wYXR0ZXJuX3BhdGhuYW1lO1xuICAgIGlmICghKDAsIF9taWNyb21hdGNoLm1ha2VSZSkoKF9wYXR0ZXJuX3BhdGhuYW1lID0gcGF0dGVybi5wYXRobmFtZSkgIT0gbnVsbCA/IF9wYXR0ZXJuX3BhdGhuYW1lIDogXCIqKlwiKS50ZXN0KHVybC5wYXRobmFtZSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGhhc01hdGNoKGRvbWFpbnMsIHJlbW90ZVBhdHRlcm5zLCB1cmwpIHtcbiAgICByZXR1cm4gZG9tYWlucy5zb21lKChkb21haW4pPT51cmwuaG9zdG5hbWUgPT09IGRvbWFpbikgfHwgcmVtb3RlUGF0dGVybnMuc29tZSgocCk9Pm1hdGNoUmVtb3RlUGF0dGVybihwLCB1cmwpKTtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWF0Y2gtcmVtb3RlLXBhdHRlcm4uanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwibW9kdWxlIiwibWF0Y2hSZW1vdGVQYXR0ZXJuIiwiaGFzTWF0Y2giLCJfZXhwb3J0IiwidGFyZ2V0IiwiYWxsIiwibmFtZSIsImVudW1lcmFibGUiLCJnZXQiLCJfbWljcm9tYXRjaCIsInJlcXVpcmUiLCJwYXR0ZXJuIiwidXJsIiwicHJvdG9jb2wiLCJ1bmRlZmluZWQiLCJhY3R1YWxQcm90byIsInNsaWNlIiwicG9ydCIsImhvc3RuYW1lIiwiRXJyb3IiLCJKU09OIiwic3RyaW5naWZ5IiwibWFrZVJlIiwidGVzdCIsIl9wYXR0ZXJuX3BhdGhuYW1lIiwicGF0aG5hbWUiLCJkb21haW5zIiwicmVtb3RlUGF0dGVybnMiLCJzb21lIiwiZG9tYWluIiwicCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/match-remote-pattern.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/side-effect.js":
/*!**********************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/side-effect.js ***!
  \**********************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval(__webpack_require__.ts("\nvar _s = $RefreshSig$();\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"default\", ({\n    enumerable: true,\n    get: function() {\n        return SideEffect;\n    }\n}));\nconst _react = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\nconst isServer = \"object\" === \"undefined\";\nconst useClientOnlyLayoutEffect = isServer ? ()=>{} : _react.useLayoutEffect;\nconst useClientOnlyEffect = isServer ? ()=>{} : _react.useEffect;\nfunction SideEffect(props) {\n    _s();\n    const { headManager, reduceComponentsToState } = props;\n    function emitChange() {\n        if (headManager && headManager.mountedInstances) {\n            const headElements = _react.Children.toArray(Array.from(headManager.mountedInstances).filter(Boolean));\n            headManager.updateHead(reduceComponentsToState(headElements, props));\n        }\n    }\n    if (isServer) {\n        var _headManager_mountedInstances;\n        headManager == null ? void 0 : (_headManager_mountedInstances = headManager.mountedInstances) == null ? void 0 : _headManager_mountedInstances.add(props.children);\n        emitChange();\n    }\n    useClientOnlyLayoutEffect(()=>{\n        var _headManager_mountedInstances;\n        headManager == null ? void 0 : (_headManager_mountedInstances = headManager.mountedInstances) == null ? void 0 : _headManager_mountedInstances.add(props.children);\n        return ()=>{\n            var _headManager_mountedInstances;\n            headManager == null ? void 0 : (_headManager_mountedInstances = headManager.mountedInstances) == null ? void 0 : _headManager_mountedInstances.delete(props.children);\n        };\n    });\n    // We need to call `updateHead` method whenever the `SideEffect` is trigger in all\n    // life-cycles: mount, update, unmount. However, if there are multiple `SideEffect`s\n    // being rendered, we only trigger the method from the last one.\n    // This is ensured by keeping the last unflushed `updateHead` in the `_pendingUpdate`\n    // singleton in the layout effect pass, and actually trigger it in the effect pass.\n    useClientOnlyLayoutEffect(()=>{\n        if (headManager) {\n            headManager._pendingUpdate = emitChange;\n        }\n        return ()=>{\n            if (headManager) {\n                headManager._pendingUpdate = emitChange;\n            }\n        };\n    });\n    useClientOnlyEffect(()=>{\n        if (headManager && headManager._pendingUpdate) {\n            headManager._pendingUpdate();\n            headManager._pendingUpdate = null;\n        }\n        return ()=>{\n            if (headManager && headManager._pendingUpdate) {\n                headManager._pendingUpdate();\n                headManager._pendingUpdate = null;\n            }\n        };\n    });\n    return null;\n} //# sourceMappingURL=side-effect.js.map\n_s(SideEffect, \"gHVkikNHNxjVdD11eJBzaqkCiPY=\", false, function() {\n    return [\n        useClientOnlyLayoutEffect,\n        useClientOnlyLayoutEffect,\n        useClientOnlyEffect\n    ];\n});\n_c = SideEffect;\nvar _c;\n$RefreshReg$(_c, \"SideEffect\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9zaWRlLWVmZmVjdC5qcyIsIm1hcHBpbmdzIjoiOztBQUFBO0FBQ0FBLDhDQUE2QztJQUN6Q0csT0FBTztBQUNYLENBQUMsRUFBQztBQUNGSCwyQ0FBMEM7SUFDdENJLFlBQVk7SUFDWkMsS0FBSztRQUNELE9BQU9DO0lBQ1g7QUFDSixDQUFDLEVBQUM7QUFDRixNQUFNQyxTQUFTQyxtQkFBT0EsQ0FBQyxtRkFBTztBQUM5QixNQUFNQyxXQUFXLGFBQWtCO0FBQ25DLE1BQU1DLDRCQUE0QkQsV0FBVyxLQUFLLElBQUlGLE9BQU9JLGVBQWU7QUFDNUUsTUFBTUMsc0JBQXNCSCxXQUFXLEtBQUssSUFBSUYsT0FBT00sU0FBUztBQUNoRSxTQUFTUCxXQUFXUSxLQUFLOztJQUNyQixNQUFNLEVBQUVDLFdBQVcsRUFBRUMsdUJBQXVCLEVBQUUsR0FBR0Y7SUFDakQsU0FBU0c7UUFDTCxJQUFJRixlQUFlQSxZQUFZRyxnQkFBZ0IsRUFBRTtZQUM3QyxNQUFNQyxlQUFlWixPQUFPYSxRQUFRLENBQUNDLE9BQU8sQ0FBQ0MsTUFBTUMsSUFBSSxDQUFDUixZQUFZRyxnQkFBZ0IsRUFBRU0sTUFBTSxDQUFDQztZQUM3RlYsWUFBWVcsVUFBVSxDQUFDVix3QkFBd0JHLGNBQWNMO1FBQ2pFO0lBQ0o7SUFDQSxJQUFJTCxVQUFVO1FBQ1YsSUFBSWtCO1FBQ0paLGVBQWUsT0FBTyxLQUFLLElBQUksQ0FBQ1ksZ0NBQWdDWixZQUFZRyxnQkFBZ0IsS0FBSyxPQUFPLEtBQUssSUFBSVMsOEJBQThCQyxHQUFHLENBQUNkLE1BQU1lLFFBQVE7UUFDaktaO0lBQ0o7SUFDQVAsMEJBQTBCO1FBQ3RCLElBQUlpQjtRQUNKWixlQUFlLE9BQU8sS0FBSyxJQUFJLENBQUNZLGdDQUFnQ1osWUFBWUcsZ0JBQWdCLEtBQUssT0FBTyxLQUFLLElBQUlTLDhCQUE4QkMsR0FBRyxDQUFDZCxNQUFNZSxRQUFRO1FBQ2pLLE9BQU87WUFDSCxJQUFJRjtZQUNKWixlQUFlLE9BQU8sS0FBSyxJQUFJLENBQUNZLGdDQUFnQ1osWUFBWUcsZ0JBQWdCLEtBQUssT0FBTyxLQUFLLElBQUlTLDhCQUE4QkcsTUFBTSxDQUFDaEIsTUFBTWUsUUFBUTtRQUN4SztJQUNKO0lBQ0Esa0ZBQWtGO0lBQ2xGLG9GQUFvRjtJQUNwRixnRUFBZ0U7SUFDaEUscUZBQXFGO0lBQ3JGLG1GQUFtRjtJQUNuRm5CLDBCQUEwQjtRQUN0QixJQUFJSyxhQUFhO1lBQ2JBLFlBQVlnQixjQUFjLEdBQUdkO1FBQ2pDO1FBQ0EsT0FBTztZQUNILElBQUlGLGFBQWE7Z0JBQ2JBLFlBQVlnQixjQUFjLEdBQUdkO1lBQ2pDO1FBQ0o7SUFDSjtJQUNBTCxvQkFBb0I7UUFDaEIsSUFBSUcsZUFBZUEsWUFBWWdCLGNBQWMsRUFBRTtZQUMzQ2hCLFlBQVlnQixjQUFjO1lBQzFCaEIsWUFBWWdCLGNBQWMsR0FBRztRQUNqQztRQUNBLE9BQU87WUFDSCxJQUFJaEIsZUFBZUEsWUFBWWdCLGNBQWMsRUFBRTtnQkFDM0NoQixZQUFZZ0IsY0FBYztnQkFDMUJoQixZQUFZZ0IsY0FBYyxHQUFHO1lBQ2pDO1FBQ0o7SUFDSjtJQUNBLE9BQU87QUFDWCxFQUVBLHVDQUF1QztHQW5EOUJ6Qjs7UUFhTEk7UUFhQUE7UUFVQUU7OztLQXBDS04iLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zaGFyZWQvbGliL3NpZGUtZWZmZWN0LmpzPzQwOGMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJkZWZhdWx0XCIsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBTaWRlRWZmZWN0O1xuICAgIH1cbn0pO1xuY29uc3QgX3JlYWN0ID0gcmVxdWlyZShcInJlYWN0XCIpO1xuY29uc3QgaXNTZXJ2ZXIgPSB0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiO1xuY29uc3QgdXNlQ2xpZW50T25seUxheW91dEVmZmVjdCA9IGlzU2VydmVyID8gKCk9Pnt9IDogX3JlYWN0LnVzZUxheW91dEVmZmVjdDtcbmNvbnN0IHVzZUNsaWVudE9ubHlFZmZlY3QgPSBpc1NlcnZlciA/ICgpPT57fSA6IF9yZWFjdC51c2VFZmZlY3Q7XG5mdW5jdGlvbiBTaWRlRWZmZWN0KHByb3BzKSB7XG4gICAgY29uc3QgeyBoZWFkTWFuYWdlciwgcmVkdWNlQ29tcG9uZW50c1RvU3RhdGUgfSA9IHByb3BzO1xuICAgIGZ1bmN0aW9uIGVtaXRDaGFuZ2UoKSB7XG4gICAgICAgIGlmIChoZWFkTWFuYWdlciAmJiBoZWFkTWFuYWdlci5tb3VudGVkSW5zdGFuY2VzKSB7XG4gICAgICAgICAgICBjb25zdCBoZWFkRWxlbWVudHMgPSBfcmVhY3QuQ2hpbGRyZW4udG9BcnJheShBcnJheS5mcm9tKGhlYWRNYW5hZ2VyLm1vdW50ZWRJbnN0YW5jZXMpLmZpbHRlcihCb29sZWFuKSk7XG4gICAgICAgICAgICBoZWFkTWFuYWdlci51cGRhdGVIZWFkKHJlZHVjZUNvbXBvbmVudHNUb1N0YXRlKGhlYWRFbGVtZW50cywgcHJvcHMpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoaXNTZXJ2ZXIpIHtcbiAgICAgICAgdmFyIF9oZWFkTWFuYWdlcl9tb3VudGVkSW5zdGFuY2VzO1xuICAgICAgICBoZWFkTWFuYWdlciA9PSBudWxsID8gdm9pZCAwIDogKF9oZWFkTWFuYWdlcl9tb3VudGVkSW5zdGFuY2VzID0gaGVhZE1hbmFnZXIubW91bnRlZEluc3RhbmNlcykgPT0gbnVsbCA/IHZvaWQgMCA6IF9oZWFkTWFuYWdlcl9tb3VudGVkSW5zdGFuY2VzLmFkZChwcm9wcy5jaGlsZHJlbik7XG4gICAgICAgIGVtaXRDaGFuZ2UoKTtcbiAgICB9XG4gICAgdXNlQ2xpZW50T25seUxheW91dEVmZmVjdCgoKT0+e1xuICAgICAgICB2YXIgX2hlYWRNYW5hZ2VyX21vdW50ZWRJbnN0YW5jZXM7XG4gICAgICAgIGhlYWRNYW5hZ2VyID09IG51bGwgPyB2b2lkIDAgOiAoX2hlYWRNYW5hZ2VyX21vdW50ZWRJbnN0YW5jZXMgPSBoZWFkTWFuYWdlci5tb3VudGVkSW5zdGFuY2VzKSA9PSBudWxsID8gdm9pZCAwIDogX2hlYWRNYW5hZ2VyX21vdW50ZWRJbnN0YW5jZXMuYWRkKHByb3BzLmNoaWxkcmVuKTtcbiAgICAgICAgcmV0dXJuICgpPT57XG4gICAgICAgICAgICB2YXIgX2hlYWRNYW5hZ2VyX21vdW50ZWRJbnN0YW5jZXM7XG4gICAgICAgICAgICBoZWFkTWFuYWdlciA9PSBudWxsID8gdm9pZCAwIDogKF9oZWFkTWFuYWdlcl9tb3VudGVkSW5zdGFuY2VzID0gaGVhZE1hbmFnZXIubW91bnRlZEluc3RhbmNlcykgPT0gbnVsbCA/IHZvaWQgMCA6IF9oZWFkTWFuYWdlcl9tb3VudGVkSW5zdGFuY2VzLmRlbGV0ZShwcm9wcy5jaGlsZHJlbik7XG4gICAgICAgIH07XG4gICAgfSk7XG4gICAgLy8gV2UgbmVlZCB0byBjYWxsIGB1cGRhdGVIZWFkYCBtZXRob2Qgd2hlbmV2ZXIgdGhlIGBTaWRlRWZmZWN0YCBpcyB0cmlnZ2VyIGluIGFsbFxuICAgIC8vIGxpZmUtY3ljbGVzOiBtb3VudCwgdXBkYXRlLCB1bm1vdW50LiBIb3dldmVyLCBpZiB0aGVyZSBhcmUgbXVsdGlwbGUgYFNpZGVFZmZlY3Rgc1xuICAgIC8vIGJlaW5nIHJlbmRlcmVkLCB3ZSBvbmx5IHRyaWdnZXIgdGhlIG1ldGhvZCBmcm9tIHRoZSBsYXN0IG9uZS5cbiAgICAvLyBUaGlzIGlzIGVuc3VyZWQgYnkga2VlcGluZyB0aGUgbGFzdCB1bmZsdXNoZWQgYHVwZGF0ZUhlYWRgIGluIHRoZSBgX3BlbmRpbmdVcGRhdGVgXG4gICAgLy8gc2luZ2xldG9uIGluIHRoZSBsYXlvdXQgZWZmZWN0IHBhc3MsIGFuZCBhY3R1YWxseSB0cmlnZ2VyIGl0IGluIHRoZSBlZmZlY3QgcGFzcy5cbiAgICB1c2VDbGllbnRPbmx5TGF5b3V0RWZmZWN0KCgpPT57XG4gICAgICAgIGlmIChoZWFkTWFuYWdlcikge1xuICAgICAgICAgICAgaGVhZE1hbmFnZXIuX3BlbmRpbmdVcGRhdGUgPSBlbWl0Q2hhbmdlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoKT0+e1xuICAgICAgICAgICAgaWYgKGhlYWRNYW5hZ2VyKSB7XG4gICAgICAgICAgICAgICAgaGVhZE1hbmFnZXIuX3BlbmRpbmdVcGRhdGUgPSBlbWl0Q2hhbmdlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH0pO1xuICAgIHVzZUNsaWVudE9ubHlFZmZlY3QoKCk9PntcbiAgICAgICAgaWYgKGhlYWRNYW5hZ2VyICYmIGhlYWRNYW5hZ2VyLl9wZW5kaW5nVXBkYXRlKSB7XG4gICAgICAgICAgICBoZWFkTWFuYWdlci5fcGVuZGluZ1VwZGF0ZSgpO1xuICAgICAgICAgICAgaGVhZE1hbmFnZXIuX3BlbmRpbmdVcGRhdGUgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoKT0+e1xuICAgICAgICAgICAgaWYgKGhlYWRNYW5hZ2VyICYmIGhlYWRNYW5hZ2VyLl9wZW5kaW5nVXBkYXRlKSB7XG4gICAgICAgICAgICAgICAgaGVhZE1hbmFnZXIuX3BlbmRpbmdVcGRhdGUoKTtcbiAgICAgICAgICAgICAgICBoZWFkTWFuYWdlci5fcGVuZGluZ1VwZGF0ZSA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfSk7XG4gICAgcmV0dXJuIG51bGw7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNpZGUtZWZmZWN0LmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImVudW1lcmFibGUiLCJnZXQiLCJTaWRlRWZmZWN0IiwiX3JlYWN0IiwicmVxdWlyZSIsImlzU2VydmVyIiwidXNlQ2xpZW50T25seUxheW91dEVmZmVjdCIsInVzZUxheW91dEVmZmVjdCIsInVzZUNsaWVudE9ubHlFZmZlY3QiLCJ1c2VFZmZlY3QiLCJwcm9wcyIsImhlYWRNYW5hZ2VyIiwicmVkdWNlQ29tcG9uZW50c1RvU3RhdGUiLCJlbWl0Q2hhbmdlIiwibW91bnRlZEluc3RhbmNlcyIsImhlYWRFbGVtZW50cyIsIkNoaWxkcmVuIiwidG9BcnJheSIsIkFycmF5IiwiZnJvbSIsImZpbHRlciIsIkJvb2xlYW4iLCJ1cGRhdGVIZWFkIiwiX2hlYWRNYW5hZ2VyX21vdW50ZWRJbnN0YW5jZXMiLCJhZGQiLCJjaGlsZHJlbiIsImRlbGV0ZSIsIl9wZW5kaW5nVXBkYXRlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/side-effect.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/components/layout/Header.tsx":
/*!******************************************!*\
  !*** ./src/components/layout/Header.tsx ***!
  \******************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ Header; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var next_image__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/image */ \"(app-pages-browser)/./node_modules/next/dist/api/image.js\");\n/* harmony import */ var next_link__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! next/link */ \"(app-pages-browser)/./node_modules/next/dist/api/link.js\");\n/* harmony import */ var next_navigation__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! next/navigation */ \"(app-pages-browser)/./node_modules/next/dist/api/navigation.js\");\n/* harmony import */ var _barrel_optimize_names_ChevronDownIcon_EnvelopeIcon_heroicons_react_24_outline__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! __barrel_optimize__?names=ChevronDownIcon,EnvelopeIcon!=!@heroicons/react/24/outline */ \"(app-pages-browser)/./node_modules/@heroicons/react/24/outline/esm/EnvelopeIcon.js\");\n/* harmony import */ var _barrel_optimize_names_ChevronDownIcon_EnvelopeIcon_heroicons_react_24_outline__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! __barrel_optimize__?names=ChevronDownIcon,EnvelopeIcon!=!@heroicons/react/24/outline */ \"(app-pages-browser)/./node_modules/@heroicons/react/24/outline/esm/ChevronDownIcon.js\");\n/* harmony import */ var _barrel_optimize_names_Menu_Transition_headlessui_react__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! __barrel_optimize__?names=Menu,Transition!=!@headlessui/react */ \"(app-pages-browser)/../../../../node_modules/@headlessui/react/dist/components/menu/menu.js\");\n/* harmony import */ var _barrel_optimize_names_Menu_Transition_headlessui_react__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! __barrel_optimize__?names=Menu,Transition!=!@headlessui/react */ \"(app-pages-browser)/../../../../node_modules/@headlessui/react/dist/components/transition/transition.js\");\n/* harmony import */ var _messages_MessagesModal__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../messages/MessagesModal */ \"(app-pages-browser)/./src/components/messages/MessagesModal.tsx\");\n/* harmony import */ var _lib_hooks_useAuth__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @/lib/hooks/useAuth */ \"(app-pages-browser)/./src/lib/hooks/useAuth.ts\");\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\n\n\n\n\n\n\n\nfunction Header() {\n    var _user_name_, _user_name;\n    _s();\n    const pathname = (0,next_navigation__WEBPACK_IMPORTED_MODULE_4__.usePathname)();\n    const [isMessagesOpen, setIsMessagesOpen] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const { user, signOut } = (0,_lib_hooks_useAuth__WEBPACK_IMPORTED_MODULE_6__.useAuth)();\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        const handleOpenMessages = ()=>{\n            setIsMessagesOpen(true);\n        };\n        window.addEventListener(\"openMessages\", handleOpenMessages);\n        return ()=>{\n            window.removeEventListener(\"openMessages\", handleOpenMessages);\n        };\n    }, []);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"header\", {\n        className: \"bg-primary-600\",\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"nav\", {\n                className: \"max-w-7xl mx-auto px-4 sm:px-6 lg:px-8\",\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: \"flex items-center justify-between h-16\",\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: \"flex items-center\",\n                            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(next_link__WEBPACK_IMPORTED_MODULE_3__[\"default\"], {\n                                href: \"/\",\n                                className: \"flex items-center\",\n                                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                    className: \"text-2xl font-bold text-white\",\n                                    children: \"CanDo\"\n                                }, void 0, false, {\n                                    fileName: \"C:\\\\Users\\\\weazl\\\\Documents\\\\gitHub\\\\CanDoBusiness2025\\\\cando-frontend\\\\src\\\\components\\\\layout\\\\Header.tsx\",\n                                    lineNumber: 35,\n                                    columnNumber: 15\n                                }, this)\n                            }, void 0, false, {\n                                fileName: \"C:\\\\Users\\\\weazl\\\\Documents\\\\gitHub\\\\CanDoBusiness2025\\\\cando-frontend\\\\src\\\\components\\\\layout\\\\Header.tsx\",\n                                lineNumber: 34,\n                                columnNumber: 13\n                            }, this)\n                        }, void 0, false, {\n                            fileName: \"C:\\\\Users\\\\weazl\\\\Documents\\\\gitHub\\\\CanDoBusiness2025\\\\cando-frontend\\\\src\\\\components\\\\layout\\\\Header.tsx\",\n                            lineNumber: 33,\n                            columnNumber: 11\n                        }, this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: \"flex items-center space-x-8\",\n                            children: [\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(next_link__WEBPACK_IMPORTED_MODULE_3__[\"default\"], {\n                                    href: \"/\",\n                                    className: \"text-white hover:text-white/90 text-sm font-medium \".concat(pathname === \"/\" ? \"opacity-100\" : \"opacity-80\"),\n                                    children: \"Home\"\n                                }, void 0, false, {\n                                    fileName: \"C:\\\\Users\\\\weazl\\\\Documents\\\\gitHub\\\\CanDoBusiness2025\\\\cando-frontend\\\\src\\\\components\\\\layout\\\\Header.tsx\",\n                                    lineNumber: 41,\n                                    columnNumber: 13\n                                }, this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(next_link__WEBPACK_IMPORTED_MODULE_3__[\"default\"], {\n                                    href: \"/network\",\n                                    className: \"text-white hover:text-white/90 text-sm font-medium \".concat(pathname === \"/network\" ? \"opacity-100\" : \"opacity-80\"),\n                                    children: \"Network\"\n                                }, void 0, false, {\n                                    fileName: \"C:\\\\Users\\\\weazl\\\\Documents\\\\gitHub\\\\CanDoBusiness2025\\\\cando-frontend\\\\src\\\\components\\\\layout\\\\Header.tsx\",\n                                    lineNumber: 49,\n                                    columnNumber: 13\n                                }, this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                    onClick: ()=>setIsMessagesOpen(true),\n                                    className: \"text-white hover:text-white/90 text-sm font-medium relative flex items-center \".concat(isMessagesOpen ? \"opacity-100\" : \"opacity-80\"),\n                                    children: [\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_ChevronDownIcon_EnvelopeIcon_heroicons_react_24_outline__WEBPACK_IMPORTED_MODULE_7__[\"default\"], {\n                                            className: \"h-6 w-6\"\n                                        }, void 0, false, {\n                                            fileName: \"C:\\\\Users\\\\weazl\\\\Documents\\\\gitHub\\\\CanDoBusiness2025\\\\cando-frontend\\\\src\\\\components\\\\layout\\\\Header.tsx\",\n                                            lineNumber: 63,\n                                            columnNumber: 15\n                                        }, this),\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                            className: \"absolute -top-1 -right-2 h-2 w-2 bg-green-400 rounded-full\"\n                                        }, void 0, false, {\n                                            fileName: \"C:\\\\Users\\\\weazl\\\\Documents\\\\gitHub\\\\CanDoBusiness2025\\\\cando-frontend\\\\src\\\\components\\\\layout\\\\Header.tsx\",\n                                            lineNumber: 64,\n                                            columnNumber: 15\n                                        }, this)\n                                    ]\n                                }, void 0, true, {\n                                    fileName: \"C:\\\\Users\\\\weazl\\\\Documents\\\\gitHub\\\\CanDoBusiness2025\\\\cando-frontend\\\\src\\\\components\\\\layout\\\\Header.tsx\",\n                                    lineNumber: 57,\n                                    columnNumber: 13\n                                }, this)\n                            ]\n                        }, void 0, true, {\n                            fileName: \"C:\\\\Users\\\\weazl\\\\Documents\\\\gitHub\\\\CanDoBusiness2025\\\\cando-frontend\\\\src\\\\components\\\\layout\\\\Header.tsx\",\n                            lineNumber: 40,\n                            columnNumber: 11\n                        }, this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_Menu_Transition_headlessui_react__WEBPACK_IMPORTED_MODULE_8__.Menu, {\n                            as: \"div\",\n                            className: \"relative\",\n                            children: [\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_Menu_Transition_headlessui_react__WEBPACK_IMPORTED_MODULE_8__.Menu.Button, {\n                                    className: \"flex items-center space-x-3 text-white hover:text-white/90\",\n                                    children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                        className: \"flex items-center space-x-2\",\n                                        children: [\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                                className: \"relative h-8 w-8 rounded-full overflow-hidden bg-gray-200\",\n                                                children: (user === null || user === void 0 ? void 0 : user.avatar_url) ? /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(next_image__WEBPACK_IMPORTED_MODULE_2__[\"default\"], {\n                                                    src: user.avatar_url,\n                                                    alt: user.name,\n                                                    fill: true,\n                                                    className: \"object-cover\"\n                                                }, void 0, false, {\n                                                    fileName: \"C:\\\\Users\\\\weazl\\\\Documents\\\\gitHub\\\\CanDoBusiness2025\\\\cando-frontend\\\\src\\\\components\\\\layout\\\\Header.tsx\",\n                                                    lineNumber: 74,\n                                                    columnNumber: 21\n                                                }, this) : /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                                    className: \"h-full w-full flex items-center justify-center bg-primary-700 text-white\",\n                                                    children: user === null || user === void 0 ? void 0 : (_user_name = user.name) === null || _user_name === void 0 ? void 0 : (_user_name_ = _user_name[0]) === null || _user_name_ === void 0 ? void 0 : _user_name_.toUpperCase()\n                                                }, void 0, false, {\n                                                    fileName: \"C:\\\\Users\\\\weazl\\\\Documents\\\\gitHub\\\\CanDoBusiness2025\\\\cando-frontend\\\\src\\\\components\\\\layout\\\\Header.tsx\",\n                                                    lineNumber: 81,\n                                                    columnNumber: 21\n                                                }, this)\n                                            }, void 0, false, {\n                                                fileName: \"C:\\\\Users\\\\weazl\\\\Documents\\\\gitHub\\\\CanDoBusiness2025\\\\cando-frontend\\\\src\\\\components\\\\layout\\\\Header.tsx\",\n                                                lineNumber: 72,\n                                                columnNumber: 17\n                                            }, this),\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                                className: \"text-sm font-medium\",\n                                                children: (user === null || user === void 0 ? void 0 : user.name) || \"Loading...\"\n                                            }, void 0, false, {\n                                                fileName: \"C:\\\\Users\\\\weazl\\\\Documents\\\\gitHub\\\\CanDoBusiness2025\\\\cando-frontend\\\\src\\\\components\\\\layout\\\\Header.tsx\",\n                                                lineNumber: 86,\n                                                columnNumber: 17\n                                            }, this),\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_ChevronDownIcon_EnvelopeIcon_heroicons_react_24_outline__WEBPACK_IMPORTED_MODULE_9__[\"default\"], {\n                                                className: \"h-4 w-4\"\n                                            }, void 0, false, {\n                                                fileName: \"C:\\\\Users\\\\weazl\\\\Documents\\\\gitHub\\\\CanDoBusiness2025\\\\cando-frontend\\\\src\\\\components\\\\layout\\\\Header.tsx\",\n                                                lineNumber: 87,\n                                                columnNumber: 17\n                                            }, this)\n                                        ]\n                                    }, void 0, true, {\n                                        fileName: \"C:\\\\Users\\\\weazl\\\\Documents\\\\gitHub\\\\CanDoBusiness2025\\\\cando-frontend\\\\src\\\\components\\\\layout\\\\Header.tsx\",\n                                        lineNumber: 71,\n                                        columnNumber: 15\n                                    }, this)\n                                }, void 0, false, {\n                                    fileName: \"C:\\\\Users\\\\weazl\\\\Documents\\\\gitHub\\\\CanDoBusiness2025\\\\cando-frontend\\\\src\\\\components\\\\layout\\\\Header.tsx\",\n                                    lineNumber: 70,\n                                    columnNumber: 13\n                                }, this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_Menu_Transition_headlessui_react__WEBPACK_IMPORTED_MODULE_10__.Transition, {\n                                    as: react__WEBPACK_IMPORTED_MODULE_1__.Fragment,\n                                    enter: \"transition ease-out duration-100\",\n                                    enterFrom: \"transform opacity-0 scale-95\",\n                                    enterTo: \"transform opacity-100 scale-100\",\n                                    leave: \"transition ease-in duration-75\",\n                                    leaveFrom: \"transform opacity-100 scale-100\",\n                                    leaveTo: \"transform opacity-0 scale-95\",\n                                    children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_Menu_Transition_headlessui_react__WEBPACK_IMPORTED_MODULE_8__.Menu.Items, {\n                                        className: \"absolute right-0 mt-2 w-56 origin-top-right rounded-md bg-white shadow-lg ring-1 ring-black ring-opacity-5 focus:outline-none\",\n                                        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                            className: \"py-1\",\n                                            children: [\n                                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_Menu_Transition_headlessui_react__WEBPACK_IMPORTED_MODULE_8__.Menu.Item, {\n                                                    children: (param)=>{\n                                                        let { active } = param;\n                                                        return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(next_link__WEBPACK_IMPORTED_MODULE_3__[\"default\"], {\n                                                            href: \"/account\",\n                                                            className: \"\".concat(active ? \"bg-gray-100\" : \"\", \" block px-4 py-2 text-sm text-gray-700\"),\n                                                            children: \"Account Management\"\n                                                        }, void 0, false, {\n                                                            fileName: \"C:\\\\Users\\\\weazl\\\\Documents\\\\gitHub\\\\CanDoBusiness2025\\\\cando-frontend\\\\src\\\\components\\\\layout\\\\Header.tsx\",\n                                                            lineNumber: 104,\n                                                            columnNumber: 23\n                                                        }, this);\n                                                    }\n                                                }, void 0, false, {\n                                                    fileName: \"C:\\\\Users\\\\weazl\\\\Documents\\\\gitHub\\\\CanDoBusiness2025\\\\cando-frontend\\\\src\\\\components\\\\layout\\\\Header.tsx\",\n                                                    lineNumber: 102,\n                                                    columnNumber: 19\n                                                }, this),\n                                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_Menu_Transition_headlessui_react__WEBPACK_IMPORTED_MODULE_8__.Menu.Item, {\n                                                    children: (param)=>{\n                                                        let { active } = param;\n                                                        return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(next_link__WEBPACK_IMPORTED_MODULE_3__[\"default\"], {\n                                                            href: \"/company\",\n                                                            className: \"\".concat(active ? \"bg-gray-100\" : \"\", \" block px-4 py-2 text-sm text-gray-700\"),\n                                                            children: \"Company Management\"\n                                                        }, void 0, false, {\n                                                            fileName: \"C:\\\\Users\\\\weazl\\\\Documents\\\\gitHub\\\\CanDoBusiness2025\\\\cando-frontend\\\\src\\\\components\\\\layout\\\\Header.tsx\",\n                                                            lineNumber: 116,\n                                                            columnNumber: 23\n                                                        }, this);\n                                                    }\n                                                }, void 0, false, {\n                                                    fileName: \"C:\\\\Users\\\\weazl\\\\Documents\\\\gitHub\\\\CanDoBusiness2025\\\\cando-frontend\\\\src\\\\components\\\\layout\\\\Header.tsx\",\n                                                    lineNumber: 114,\n                                                    columnNumber: 19\n                                                }, this),\n                                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                                    className: \"border-t border-gray-100\",\n                                                    children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_Menu_Transition_headlessui_react__WEBPACK_IMPORTED_MODULE_8__.Menu.Item, {\n                                                        children: (param)=>{\n                                                            let { active } = param;\n                                                            return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                                                onClick: signOut,\n                                                                className: \"\".concat(active ? \"bg-gray-100\" : \"\", \" block w-full text-left px-4 py-2 text-sm text-gray-700\"),\n                                                                children: \"Sign Out\"\n                                                            }, void 0, false, {\n                                                                fileName: \"C:\\\\Users\\\\weazl\\\\Documents\\\\gitHub\\\\CanDoBusiness2025\\\\cando-frontend\\\\src\\\\components\\\\layout\\\\Header.tsx\",\n                                                                lineNumber: 129,\n                                                                columnNumber: 25\n                                                            }, this);\n                                                        }\n                                                    }, void 0, false, {\n                                                        fileName: \"C:\\\\Users\\\\weazl\\\\Documents\\\\gitHub\\\\CanDoBusiness2025\\\\cando-frontend\\\\src\\\\components\\\\layout\\\\Header.tsx\",\n                                                        lineNumber: 127,\n                                                        columnNumber: 21\n                                                    }, this)\n                                                }, void 0, false, {\n                                                    fileName: \"C:\\\\Users\\\\weazl\\\\Documents\\\\gitHub\\\\CanDoBusiness2025\\\\cando-frontend\\\\src\\\\components\\\\layout\\\\Header.tsx\",\n                                                    lineNumber: 126,\n                                                    columnNumber: 19\n                                                }, this)\n                                            ]\n                                        }, void 0, true, {\n                                            fileName: \"C:\\\\Users\\\\weazl\\\\Documents\\\\gitHub\\\\CanDoBusiness2025\\\\cando-frontend\\\\src\\\\components\\\\layout\\\\Header.tsx\",\n                                            lineNumber: 101,\n                                            columnNumber: 17\n                                        }, this)\n                                    }, void 0, false, {\n                                        fileName: \"C:\\\\Users\\\\weazl\\\\Documents\\\\gitHub\\\\CanDoBusiness2025\\\\cando-frontend\\\\src\\\\components\\\\layout\\\\Header.tsx\",\n                                        lineNumber: 100,\n                                        columnNumber: 15\n                                    }, this)\n                                }, void 0, false, {\n                                    fileName: \"C:\\\\Users\\\\weazl\\\\Documents\\\\gitHub\\\\CanDoBusiness2025\\\\cando-frontend\\\\src\\\\components\\\\layout\\\\Header.tsx\",\n                                    lineNumber: 91,\n                                    columnNumber: 13\n                                }, this)\n                            ]\n                        }, void 0, true, {\n                            fileName: \"C:\\\\Users\\\\weazl\\\\Documents\\\\gitHub\\\\CanDoBusiness2025\\\\cando-frontend\\\\src\\\\components\\\\layout\\\\Header.tsx\",\n                            lineNumber: 69,\n                            columnNumber: 11\n                        }, this)\n                    ]\n                }, void 0, true, {\n                    fileName: \"C:\\\\Users\\\\weazl\\\\Documents\\\\gitHub\\\\CanDoBusiness2025\\\\cando-frontend\\\\src\\\\components\\\\layout\\\\Header.tsx\",\n                    lineNumber: 31,\n                    columnNumber: 9\n                }, this)\n            }, void 0, false, {\n                fileName: \"C:\\\\Users\\\\weazl\\\\Documents\\\\gitHub\\\\CanDoBusiness2025\\\\cando-frontend\\\\src\\\\components\\\\layout\\\\Header.tsx\",\n                lineNumber: 30,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_messages_MessagesModal__WEBPACK_IMPORTED_MODULE_5__[\"default\"], {\n                isOpen: isMessagesOpen,\n                onClose: ()=>setIsMessagesOpen(false)\n            }, void 0, false, {\n                fileName: \"C:\\\\Users\\\\weazl\\\\Documents\\\\gitHub\\\\CanDoBusiness2025\\\\cando-frontend\\\\src\\\\components\\\\layout\\\\Header.tsx\",\n                lineNumber: 147,\n                columnNumber: 7\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"C:\\\\Users\\\\weazl\\\\Documents\\\\gitHub\\\\CanDoBusiness2025\\\\cando-frontend\\\\src\\\\components\\\\layout\\\\Header.tsx\",\n        lineNumber: 29,\n        columnNumber: 5\n    }, this);\n}\n_s(Header, \"IWwuH3CrtExW01ORMtSe4VSIhnI=\", false, function() {\n    return [\n        next_navigation__WEBPACK_IMPORTED_MODULE_4__.usePathname,\n        _lib_hooks_useAuth__WEBPACK_IMPORTED_MODULE_6__.useAuth\n    ];\n});\n_c = Header;\nvar _c;\n$RefreshReg$(_c, \"Header\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL2xheW91dC9IZWFkZXIudHN4IiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUVxRDtBQUN2QjtBQUNGO0FBQ2lCO0FBQzhCO0FBQ3ZCO0FBQ0M7QUFDUjtBQUU5QixTQUFTWTtRQXNFREMsYUFBQUE7O0lBckVyQixNQUFNQyxXQUFXVCw0REFBV0E7SUFDNUIsTUFBTSxDQUFDVSxnQkFBZ0JDLGtCQUFrQixHQUFHZiwrQ0FBUUEsQ0FBQztJQUNyRCxNQUFNLEVBQUVZLElBQUksRUFBRUksT0FBTyxFQUFFLEdBQUdOLDJEQUFPQTtJQUVqQ1gsZ0RBQVNBLENBQUM7UUFDUixNQUFNa0IscUJBQXFCO1lBQ3pCRixrQkFBa0I7UUFDcEI7UUFFQUcsT0FBT0MsZ0JBQWdCLENBQUMsZ0JBQWdCRjtRQUN4QyxPQUFPO1lBQ0xDLE9BQU9FLG1CQUFtQixDQUFDLGdCQUFnQkg7UUFDN0M7SUFDRixHQUFHLEVBQUU7SUFFTCxxQkFDRSw4REFBQ0k7UUFBT0MsV0FBVTs7MEJBQ2hCLDhEQUFDQztnQkFBSUQsV0FBVTswQkFDYiw0RUFBQ0U7b0JBQUlGLFdBQVU7O3NDQUViLDhEQUFDRTs0QkFBSUYsV0FBVTtzQ0FDYiw0RUFBQ25CLGlEQUFJQTtnQ0FBQ3NCLE1BQUs7Z0NBQUlILFdBQVU7MENBQ3ZCLDRFQUFDSTtvQ0FBS0osV0FBVTs4Q0FBZ0M7Ozs7Ozs7Ozs7Ozs7Ozs7c0NBS3BELDhEQUFDRTs0QkFBSUYsV0FBVTs7OENBQ2IsOERBQUNuQixpREFBSUE7b0NBQ0hzQixNQUFLO29DQUNMSCxXQUFXLHNEQUVWLE9BRENULGFBQWEsTUFBTSxnQkFBZ0I7OENBRXRDOzs7Ozs7OENBR0QsOERBQUNWLGlEQUFJQTtvQ0FDSHNCLE1BQUs7b0NBQ0xILFdBQVcsc0RBRVYsT0FEQ1QsYUFBYSxhQUFhLGdCQUFnQjs4Q0FFN0M7Ozs7Ozs4Q0FHRCw4REFBQ2M7b0NBQ0NDLFNBQVMsSUFBTWIsa0JBQWtCO29DQUNqQ08sV0FBVyxpRkFFVixPQURDUixpQkFBaUIsZ0JBQWdCOztzREFHbkMsOERBQUNULHNIQUFZQTs0Q0FBQ2lCLFdBQVU7Ozs7OztzREFDeEIsOERBQUNJOzRDQUFLSixXQUFVOzs7Ozs7Ozs7Ozs7Ozs7Ozs7c0NBS3BCLDhEQUFDZix5RkFBSUE7NEJBQUNzQixJQUFHOzRCQUFNUCxXQUFVOzs4Q0FDdkIsOERBQUNmLHlGQUFJQSxDQUFDdUIsTUFBTTtvQ0FBQ1IsV0FBVTs4Q0FDckIsNEVBQUNFO3dDQUFJRixXQUFVOzswREFDYiw4REFBQ0U7Z0RBQUlGLFdBQVU7MERBQ1pWLENBQUFBLGlCQUFBQSwyQkFBQUEsS0FBTW1CLFVBQVUsa0JBQ2YsOERBQUM3QixrREFBS0E7b0RBQ0o4QixLQUFLcEIsS0FBS21CLFVBQVU7b0RBQ3BCRSxLQUFLckIsS0FBS3NCLElBQUk7b0RBQ2RDLElBQUk7b0RBQ0piLFdBQVU7Ozs7O3lFQUdaLDhEQUFDRTtvREFBSUYsV0FBVTs4REFDWlYsaUJBQUFBLDRCQUFBQSxhQUFBQSxLQUFNc0IsSUFBSSxjQUFWdEIsa0NBQUFBLGNBQUFBLFVBQVksQ0FBQyxFQUFFLGNBQWZBLGtDQUFBQSxZQUFpQndCLFdBQVc7Ozs7Ozs7Ozs7OzBEQUluQyw4REFBQ1Y7Z0RBQUtKLFdBQVU7MERBQXVCVixDQUFBQSxpQkFBQUEsMkJBQUFBLEtBQU1zQixJQUFJLEtBQUk7Ozs7OzswREFDckQsOERBQUM1QixzSEFBZUE7Z0RBQUNnQixXQUFVOzs7Ozs7Ozs7Ozs7Ozs7Ozs4Q0FJL0IsOERBQUNkLGdHQUFVQTtvQ0FDVHFCLElBQUk1QiwyQ0FBUUE7b0NBQ1pvQyxPQUFNO29DQUNOQyxXQUFVO29DQUNWQyxTQUFRO29DQUNSQyxPQUFNO29DQUNOQyxXQUFVO29DQUNWQyxTQUFROzhDQUVSLDRFQUFDbkMseUZBQUlBLENBQUNvQyxLQUFLO3dDQUFDckIsV0FBVTtrREFDcEIsNEVBQUNFOzRDQUFJRixXQUFVOzs4REFDYiw4REFBQ2YseUZBQUlBLENBQUNxQyxJQUFJOzhEQUNQOzREQUFDLEVBQUVDLE1BQU0sRUFBRTs2RUFDViw4REFBQzFDLGlEQUFJQTs0REFDSHNCLE1BQUs7NERBQ0xILFdBQVcsR0FFVixPQURDdUIsU0FBUyxnQkFBZ0IsSUFDMUI7c0VBQ0Y7Ozs7Ozs7Ozs7Ozs4REFLTCw4REFBQ3RDLHlGQUFJQSxDQUFDcUMsSUFBSTs4REFDUDs0REFBQyxFQUFFQyxNQUFNLEVBQUU7NkVBQ1YsOERBQUMxQyxpREFBSUE7NERBQ0hzQixNQUFLOzREQUNMSCxXQUFXLEdBRVYsT0FEQ3VCLFNBQVMsZ0JBQWdCLElBQzFCO3NFQUNGOzs7Ozs7Ozs7Ozs7OERBS0wsOERBQUNyQjtvREFBSUYsV0FBVTs4REFDYiw0RUFBQ2YseUZBQUlBLENBQUNxQyxJQUFJO2tFQUNQO2dFQUFDLEVBQUVDLE1BQU0sRUFBRTtpRkFDViw4REFBQ2xCO2dFQUNDQyxTQUFTWjtnRUFDVE0sV0FBVyxHQUVWLE9BREN1QixTQUFTLGdCQUFnQixJQUMxQjswRUFDRjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7MEJBYW5CLDhEQUFDcEMsK0RBQWFBO2dCQUNacUMsUUFBUWhDO2dCQUNSaUMsU0FBUyxJQUFNaEMsa0JBQWtCOzs7Ozs7Ozs7Ozs7QUFJekM7R0E3SXdCSjs7UUFDTFAsd0RBQVdBO1FBRUZNLHVEQUFPQTs7O0tBSFhDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9jb21wb25lbnRzL2xheW91dC9IZWFkZXIudHN4PzA2OGIiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBjbGllbnQnXHJcblxyXG5pbXBvcnQgeyB1c2VFZmZlY3QsIHVzZVN0YXRlLCBGcmFnbWVudCB9IGZyb20gJ3JlYWN0J1xyXG5pbXBvcnQgSW1hZ2UgZnJvbSAnbmV4dC9pbWFnZSdcclxuaW1wb3J0IExpbmsgZnJvbSAnbmV4dC9saW5rJ1xyXG5pbXBvcnQgeyB1c2VQYXRobmFtZSB9IGZyb20gJ25leHQvbmF2aWdhdGlvbidcclxuaW1wb3J0IHsgRW52ZWxvcGVJY29uLCBDaGV2cm9uRG93bkljb24gfSBmcm9tICdAaGVyb2ljb25zL3JlYWN0LzI0L291dGxpbmUnXHJcbmltcG9ydCB7IE1lbnUsIFRyYW5zaXRpb24gfSBmcm9tICdAaGVhZGxlc3N1aS9yZWFjdCdcclxuaW1wb3J0IE1lc3NhZ2VzTW9kYWwgZnJvbSAnLi4vbWVzc2FnZXMvTWVzc2FnZXNNb2RhbCdcclxuaW1wb3J0IHsgdXNlQXV0aCB9IGZyb20gJ0AvbGliL2hvb2tzL3VzZUF1dGgnXHJcblxyXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBIZWFkZXIoKSB7XHJcbiAgY29uc3QgcGF0aG5hbWUgPSB1c2VQYXRobmFtZSgpXHJcbiAgY29uc3QgW2lzTWVzc2FnZXNPcGVuLCBzZXRJc01lc3NhZ2VzT3Blbl0gPSB1c2VTdGF0ZShmYWxzZSlcclxuICBjb25zdCB7IHVzZXIsIHNpZ25PdXQgfSA9IHVzZUF1dGgoKVxyXG5cclxuICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgY29uc3QgaGFuZGxlT3Blbk1lc3NhZ2VzID0gKCkgPT4ge1xyXG4gICAgICBzZXRJc01lc3NhZ2VzT3Blbih0cnVlKVxyXG4gICAgfVxyXG5cclxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdvcGVuTWVzc2FnZXMnLCBoYW5kbGVPcGVuTWVzc2FnZXMpXHJcbiAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignb3Blbk1lc3NhZ2VzJywgaGFuZGxlT3Blbk1lc3NhZ2VzKVxyXG4gICAgfVxyXG4gIH0sIFtdKVxyXG5cclxuICByZXR1cm4gKFxyXG4gICAgPGhlYWRlciBjbGFzc05hbWU9XCJiZy1wcmltYXJ5LTYwMFwiPlxyXG4gICAgICA8bmF2IGNsYXNzTmFtZT1cIm1heC13LTd4bCBteC1hdXRvIHB4LTQgc206cHgtNiBsZzpweC04XCI+XHJcbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJmbGV4IGl0ZW1zLWNlbnRlciBqdXN0aWZ5LWJldHdlZW4gaC0xNlwiPlxyXG4gICAgICAgICAgey8qIExvZ28gYW5kIEJyYW5kICovfVxyXG4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJmbGV4IGl0ZW1zLWNlbnRlclwiPlxyXG4gICAgICAgICAgICA8TGluayBocmVmPVwiL1wiIGNsYXNzTmFtZT1cImZsZXggaXRlbXMtY2VudGVyXCI+XHJcbiAgICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwidGV4dC0yeGwgZm9udC1ib2xkIHRleHQtd2hpdGVcIj5DYW5Ebzwvc3Bhbj5cclxuICAgICAgICAgICAgPC9MaW5rPlxyXG4gICAgICAgICAgPC9kaXY+XHJcblxyXG4gICAgICAgICAgey8qIE5hdmlnYXRpb24gTGlua3MgKi99XHJcbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImZsZXggaXRlbXMtY2VudGVyIHNwYWNlLXgtOFwiPlxyXG4gICAgICAgICAgICA8TGluayBcclxuICAgICAgICAgICAgICBocmVmPVwiL1wiXHJcbiAgICAgICAgICAgICAgY2xhc3NOYW1lPXtgdGV4dC13aGl0ZSBob3Zlcjp0ZXh0LXdoaXRlLzkwIHRleHQtc20gZm9udC1tZWRpdW0gJHtcclxuICAgICAgICAgICAgICAgIHBhdGhuYW1lID09PSAnLycgPyAnb3BhY2l0eS0xMDAnIDogJ29wYWNpdHktODAnXHJcbiAgICAgICAgICAgICAgfWB9XHJcbiAgICAgICAgICAgID5cclxuICAgICAgICAgICAgICBIb21lXHJcbiAgICAgICAgICAgIDwvTGluaz5cclxuICAgICAgICAgICAgPExpbmsgXHJcbiAgICAgICAgICAgICAgaHJlZj1cIi9uZXR3b3JrXCJcclxuICAgICAgICAgICAgICBjbGFzc05hbWU9e2B0ZXh0LXdoaXRlIGhvdmVyOnRleHQtd2hpdGUvOTAgdGV4dC1zbSBmb250LW1lZGl1bSAke1xyXG4gICAgICAgICAgICAgICAgcGF0aG5hbWUgPT09ICcvbmV0d29yaycgPyAnb3BhY2l0eS0xMDAnIDogJ29wYWNpdHktODAnXHJcbiAgICAgICAgICAgICAgfWB9XHJcbiAgICAgICAgICAgID5cclxuICAgICAgICAgICAgICBOZXR3b3JrXHJcbiAgICAgICAgICAgIDwvTGluaz5cclxuICAgICAgICAgICAgPGJ1dHRvbiBcclxuICAgICAgICAgICAgICBvbkNsaWNrPXsoKSA9PiBzZXRJc01lc3NhZ2VzT3Blbih0cnVlKX1cclxuICAgICAgICAgICAgICBjbGFzc05hbWU9e2B0ZXh0LXdoaXRlIGhvdmVyOnRleHQtd2hpdGUvOTAgdGV4dC1zbSBmb250LW1lZGl1bSByZWxhdGl2ZSBmbGV4IGl0ZW1zLWNlbnRlciAke1xyXG4gICAgICAgICAgICAgICAgaXNNZXNzYWdlc09wZW4gPyAnb3BhY2l0eS0xMDAnIDogJ29wYWNpdHktODAnXHJcbiAgICAgICAgICAgICAgfWB9XHJcbiAgICAgICAgICAgID5cclxuICAgICAgICAgICAgICA8RW52ZWxvcGVJY29uIGNsYXNzTmFtZT1cImgtNiB3LTZcIiAvPlxyXG4gICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cImFic29sdXRlIC10b3AtMSAtcmlnaHQtMiBoLTIgdy0yIGJnLWdyZWVuLTQwMCByb3VuZGVkLWZ1bGxcIj48L3NwYW4+XHJcbiAgICAgICAgICAgIDwvYnV0dG9uPlxyXG4gICAgICAgICAgPC9kaXY+XHJcblxyXG4gICAgICAgICAgey8qIFVzZXIgUHJvZmlsZSBEcm9wZG93biAqL31cclxuICAgICAgICAgIDxNZW51IGFzPVwiZGl2XCIgY2xhc3NOYW1lPVwicmVsYXRpdmVcIj5cclxuICAgICAgICAgICAgPE1lbnUuQnV0dG9uIGNsYXNzTmFtZT1cImZsZXggaXRlbXMtY2VudGVyIHNwYWNlLXgtMyB0ZXh0LXdoaXRlIGhvdmVyOnRleHQtd2hpdGUvOTBcIj5cclxuICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImZsZXggaXRlbXMtY2VudGVyIHNwYWNlLXgtMlwiPlxyXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJyZWxhdGl2ZSBoLTggdy04IHJvdW5kZWQtZnVsbCBvdmVyZmxvdy1oaWRkZW4gYmctZ3JheS0yMDBcIj5cclxuICAgICAgICAgICAgICAgICAge3VzZXI/LmF2YXRhcl91cmwgPyAoXHJcbiAgICAgICAgICAgICAgICAgICAgPEltYWdlXHJcbiAgICAgICAgICAgICAgICAgICAgICBzcmM9e3VzZXIuYXZhdGFyX3VybH1cclxuICAgICAgICAgICAgICAgICAgICAgIGFsdD17dXNlci5uYW1lfVxyXG4gICAgICAgICAgICAgICAgICAgICAgZmlsbFxyXG4gICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwib2JqZWN0LWNvdmVyXCJcclxuICAgICAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICAgICAgICApIDogKFxyXG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiaC1mdWxsIHctZnVsbCBmbGV4IGl0ZW1zLWNlbnRlciBqdXN0aWZ5LWNlbnRlciBiZy1wcmltYXJ5LTcwMCB0ZXh0LXdoaXRlXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICB7dXNlcj8ubmFtZT8uWzBdPy50b1VwcGVyQ2FzZSgpfVxyXG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICApfVxyXG4gICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJ0ZXh0LXNtIGZvbnQtbWVkaXVtXCI+e3VzZXI/Lm5hbWUgfHwgJ0xvYWRpbmcuLi4nfTwvc3Bhbj5cclxuICAgICAgICAgICAgICAgIDxDaGV2cm9uRG93bkljb24gY2xhc3NOYW1lPVwiaC00IHctNFwiIC8+XHJcbiAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgIDwvTWVudS5CdXR0b24+XHJcblxyXG4gICAgICAgICAgICA8VHJhbnNpdGlvblxyXG4gICAgICAgICAgICAgIGFzPXtGcmFnbWVudH1cclxuICAgICAgICAgICAgICBlbnRlcj1cInRyYW5zaXRpb24gZWFzZS1vdXQgZHVyYXRpb24tMTAwXCJcclxuICAgICAgICAgICAgICBlbnRlckZyb209XCJ0cmFuc2Zvcm0gb3BhY2l0eS0wIHNjYWxlLTk1XCJcclxuICAgICAgICAgICAgICBlbnRlclRvPVwidHJhbnNmb3JtIG9wYWNpdHktMTAwIHNjYWxlLTEwMFwiXHJcbiAgICAgICAgICAgICAgbGVhdmU9XCJ0cmFuc2l0aW9uIGVhc2UtaW4gZHVyYXRpb24tNzVcIlxyXG4gICAgICAgICAgICAgIGxlYXZlRnJvbT1cInRyYW5zZm9ybSBvcGFjaXR5LTEwMCBzY2FsZS0xMDBcIlxyXG4gICAgICAgICAgICAgIGxlYXZlVG89XCJ0cmFuc2Zvcm0gb3BhY2l0eS0wIHNjYWxlLTk1XCJcclxuICAgICAgICAgICAgPlxyXG4gICAgICAgICAgICAgIDxNZW51Lkl0ZW1zIGNsYXNzTmFtZT1cImFic29sdXRlIHJpZ2h0LTAgbXQtMiB3LTU2IG9yaWdpbi10b3AtcmlnaHQgcm91bmRlZC1tZCBiZy13aGl0ZSBzaGFkb3ctbGcgcmluZy0xIHJpbmctYmxhY2sgcmluZy1vcGFjaXR5LTUgZm9jdXM6b3V0bGluZS1ub25lXCI+XHJcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInB5LTFcIj5cclxuICAgICAgICAgICAgICAgICAgPE1lbnUuSXRlbT5cclxuICAgICAgICAgICAgICAgICAgICB7KHsgYWN0aXZlIH0pID0+IChcclxuICAgICAgICAgICAgICAgICAgICAgIDxMaW5rXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhyZWY9XCIvYWNjb3VudFwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT17YCR7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgYWN0aXZlID8gJ2JnLWdyYXktMTAwJyA6ICcnXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gYmxvY2sgcHgtNCBweS0yIHRleHQtc20gdGV4dC1ncmF5LTcwMGB9XHJcbiAgICAgICAgICAgICAgICAgICAgICA+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIEFjY291bnQgTWFuYWdlbWVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgPC9MaW5rPlxyXG4gICAgICAgICAgICAgICAgICAgICl9XHJcbiAgICAgICAgICAgICAgICAgIDwvTWVudS5JdGVtPlxyXG4gICAgICAgICAgICAgICAgICA8TWVudS5JdGVtPlxyXG4gICAgICAgICAgICAgICAgICAgIHsoeyBhY3RpdmUgfSkgPT4gKFxyXG4gICAgICAgICAgICAgICAgICAgICAgPExpbmtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaHJlZj1cIi9jb21wYW55XCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPXtgJHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICBhY3RpdmUgPyAnYmctZ3JheS0xMDAnIDogJydcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBibG9jayBweC00IHB5LTIgdGV4dC1zbSB0ZXh0LWdyYXktNzAwYH1cclxuICAgICAgICAgICAgICAgICAgICAgID5cclxuICAgICAgICAgICAgICAgICAgICAgICAgQ29tcGFueSBNYW5hZ2VtZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICA8L0xpbms+XHJcbiAgICAgICAgICAgICAgICAgICAgKX1cclxuICAgICAgICAgICAgICAgICAgPC9NZW51Lkl0ZW0+XHJcbiAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiYm9yZGVyLXQgYm9yZGVyLWdyYXktMTAwXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgPE1lbnUuSXRlbT5cclxuICAgICAgICAgICAgICAgICAgICAgIHsoeyBhY3RpdmUgfSkgPT4gKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8YnV0dG9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgb25DbGljaz17c2lnbk91dH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9e2Ake1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWN0aXZlID8gJ2JnLWdyYXktMTAwJyA6ICcnXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfSBibG9jayB3LWZ1bGwgdGV4dC1sZWZ0IHB4LTQgcHktMiB0ZXh0LXNtIHRleHQtZ3JheS03MDBgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICA+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgU2lnbiBPdXRcclxuICAgICAgICAgICAgICAgICAgICAgICAgPC9idXR0b24+XHJcbiAgICAgICAgICAgICAgICAgICAgICApfVxyXG4gICAgICAgICAgICAgICAgICAgIDwvTWVudS5JdGVtPlxyXG4gICAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgIDwvTWVudS5JdGVtcz5cclxuICAgICAgICAgICAgPC9UcmFuc2l0aW9uPlxyXG4gICAgICAgICAgPC9NZW51PlxyXG4gICAgICAgIDwvZGl2PlxyXG4gICAgICA8L25hdj5cclxuXHJcbiAgICAgIDxNZXNzYWdlc01vZGFsIFxyXG4gICAgICAgIGlzT3Blbj17aXNNZXNzYWdlc09wZW59XHJcbiAgICAgICAgb25DbG9zZT17KCkgPT4gc2V0SXNNZXNzYWdlc09wZW4oZmFsc2UpfVxyXG4gICAgICAvPlxyXG4gICAgPC9oZWFkZXI+XHJcbiAgKVxyXG59ICJdLCJuYW1lcyI6WyJ1c2VFZmZlY3QiLCJ1c2VTdGF0ZSIsIkZyYWdtZW50IiwiSW1hZ2UiLCJMaW5rIiwidXNlUGF0aG5hbWUiLCJFbnZlbG9wZUljb24iLCJDaGV2cm9uRG93bkljb24iLCJNZW51IiwiVHJhbnNpdGlvbiIsIk1lc3NhZ2VzTW9kYWwiLCJ1c2VBdXRoIiwiSGVhZGVyIiwidXNlciIsInBhdGhuYW1lIiwiaXNNZXNzYWdlc09wZW4iLCJzZXRJc01lc3NhZ2VzT3BlbiIsInNpZ25PdXQiLCJoYW5kbGVPcGVuTWVzc2FnZXMiLCJ3aW5kb3ciLCJhZGRFdmVudExpc3RlbmVyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImhlYWRlciIsImNsYXNzTmFtZSIsIm5hdiIsImRpdiIsImhyZWYiLCJzcGFuIiwiYnV0dG9uIiwib25DbGljayIsImFzIiwiQnV0dG9uIiwiYXZhdGFyX3VybCIsInNyYyIsImFsdCIsIm5hbWUiLCJmaWxsIiwidG9VcHBlckNhc2UiLCJlbnRlciIsImVudGVyRnJvbSIsImVudGVyVG8iLCJsZWF2ZSIsImxlYXZlRnJvbSIsImxlYXZlVG8iLCJJdGVtcyIsIkl0ZW0iLCJhY3RpdmUiLCJpc09wZW4iLCJvbkNsb3NlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/layout/Header.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@heroicons/react/24/outline/esm/ChevronDownIcon.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@heroicons/react/24/outline/esm/ChevronDownIcon.js ***!
  \*************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n\nfunction ChevronDownIcon(param, svgRef) {\n    let { title, titleId, ...props } = param;\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"svg\", Object.assign({\n        xmlns: \"http://www.w3.org/2000/svg\",\n        fill: \"none\",\n        viewBox: \"0 0 24 24\",\n        strokeWidth: 1.5,\n        stroke: \"currentColor\",\n        \"aria-hidden\": \"true\",\n        \"data-slot\": \"icon\",\n        ref: svgRef,\n        \"aria-labelledby\": titleId\n    }, props), title ? /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"title\", {\n        id: titleId\n    }, title) : null, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\", {\n        strokeLinecap: \"round\",\n        strokeLinejoin: \"round\",\n        d: \"m19.5 8.25-7.5 7.5-7.5-7.5\"\n    }));\n}\n_c = ChevronDownIcon;\nconst ForwardRef = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(ChevronDownIcon);\n_c1 = ForwardRef;\n/* harmony default export */ __webpack_exports__[\"default\"] = (ForwardRef);\nvar _c, _c1;\n$RefreshReg$(_c, \"ChevronDownIcon\");\n$RefreshReg$(_c1, \"ForwardRef\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AaGVyb2ljb25zL3JlYWN0LzI0L291dGxpbmUvZXNtL0NoZXZyb25Eb3duSWNvbi5qcyIsIm1hcHBpbmdzIjoiOztBQUErQjtBQUMvQixTQUFTQyxnQkFBZ0IsS0FJeEIsRUFBRUMsTUFBTTtRQUpnQixFQUN2QkMsS0FBSyxFQUNMQyxPQUFPLEVBQ1AsR0FBR0MsT0FDSixHQUp3QjtJQUt2QixPQUFPLFdBQVcsR0FBRUwsZ0RBQW1CLENBQUMsT0FBT08sT0FBT0MsTUFBTSxDQUFDO1FBQzNEQyxPQUFPO1FBQ1BDLE1BQU07UUFDTkMsU0FBUztRQUNUQyxhQUFhO1FBQ2JDLFFBQVE7UUFDUixlQUFlO1FBQ2YsYUFBYTtRQUNiQyxLQUFLWjtRQUNMLG1CQUFtQkU7SUFDckIsR0FBR0MsUUFBUUYsUUFBUSxXQUFXLEdBQUVILGdEQUFtQixDQUFDLFNBQVM7UUFDM0RlLElBQUlYO0lBQ04sR0FBR0QsU0FBUyxNQUFNLFdBQVcsR0FBRUgsZ0RBQW1CLENBQUMsUUFBUTtRQUN6RGdCLGVBQWU7UUFDZkMsZ0JBQWdCO1FBQ2hCQyxHQUFHO0lBQ0w7QUFDRjtLQXRCU2pCO0FBdUJULE1BQU1rQixhQUFhLFdBQVcsR0FBR25CLDZDQUFnQixDQUFDQzs7QUFDbEQsK0RBQWVrQixVQUFVQSxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AaGVyb2ljb25zL3JlYWN0LzI0L291dGxpbmUvZXNtL0NoZXZyb25Eb3duSWNvbi5qcz82ZjkwIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIFJlYWN0IGZyb20gXCJyZWFjdFwiO1xuZnVuY3Rpb24gQ2hldnJvbkRvd25JY29uKHtcbiAgdGl0bGUsXG4gIHRpdGxlSWQsXG4gIC4uLnByb3BzXG59LCBzdmdSZWYpIHtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwic3ZnXCIsIE9iamVjdC5hc3NpZ24oe1xuICAgIHhtbG5zOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsXG4gICAgZmlsbDogXCJub25lXCIsXG4gICAgdmlld0JveDogXCIwIDAgMjQgMjRcIixcbiAgICBzdHJva2VXaWR0aDogMS41LFxuICAgIHN0cm9rZTogXCJjdXJyZW50Q29sb3JcIixcbiAgICBcImFyaWEtaGlkZGVuXCI6IFwidHJ1ZVwiLFxuICAgIFwiZGF0YS1zbG90XCI6IFwiaWNvblwiLFxuICAgIHJlZjogc3ZnUmVmLFxuICAgIFwiYXJpYS1sYWJlbGxlZGJ5XCI6IHRpdGxlSWRcbiAgfSwgcHJvcHMpLCB0aXRsZSA/IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwidGl0bGVcIiwge1xuICAgIGlkOiB0aXRsZUlkXG4gIH0sIHRpdGxlKSA6IG51bGwsIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwicGF0aFwiLCB7XG4gICAgc3Ryb2tlTGluZWNhcDogXCJyb3VuZFwiLFxuICAgIHN0cm9rZUxpbmVqb2luOiBcInJvdW5kXCIsXG4gICAgZDogXCJtMTkuNSA4LjI1LTcuNSA3LjUtNy41LTcuNVwiXG4gIH0pKTtcbn1cbmNvbnN0IEZvcndhcmRSZWYgPSAvKiNfX1BVUkVfXyovIFJlYWN0LmZvcndhcmRSZWYoQ2hldnJvbkRvd25JY29uKTtcbmV4cG9ydCBkZWZhdWx0IEZvcndhcmRSZWY7Il0sIm5hbWVzIjpbIlJlYWN0IiwiQ2hldnJvbkRvd25JY29uIiwic3ZnUmVmIiwidGl0bGUiLCJ0aXRsZUlkIiwicHJvcHMiLCJjcmVhdGVFbGVtZW50IiwiT2JqZWN0IiwiYXNzaWduIiwieG1sbnMiLCJmaWxsIiwidmlld0JveCIsInN0cm9rZVdpZHRoIiwic3Ryb2tlIiwicmVmIiwiaWQiLCJzdHJva2VMaW5lY2FwIiwic3Ryb2tlTGluZWpvaW4iLCJkIiwiRm9yd2FyZFJlZiIsImZvcndhcmRSZWYiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@heroicons/react/24/outline/esm/ChevronDownIcon.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../../../node_modules/@floating-ui/core/dist/floating-ui.core.mjs":
/*!****************************************************************************!*\
  !*** ../../../../node_modules/@floating-ui/core/dist/floating-ui.core.mjs ***!
  \****************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   arrow: function() { return /* binding */ arrow; },\n/* harmony export */   autoPlacement: function() { return /* binding */ autoPlacement; },\n/* harmony export */   computePosition: function() { return /* binding */ computePosition; },\n/* harmony export */   detectOverflow: function() { return /* binding */ detectOverflow; },\n/* harmony export */   flip: function() { return /* binding */ flip; },\n/* harmony export */   hide: function() { return /* binding */ hide; },\n/* harmony export */   inline: function() { return /* binding */ inline; },\n/* harmony export */   limitShift: function() { return /* binding */ limitShift; },\n/* harmony export */   offset: function() { return /* binding */ offset; },\n/* harmony export */   rectToClientRect: function() { return /* reexport safe */ _floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.rectToClientRect; },\n/* harmony export */   shift: function() { return /* binding */ shift; },\n/* harmony export */   size: function() { return /* binding */ size; }\n/* harmony export */ });\n/* harmony import */ var _floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @floating-ui/utils */ \"(app-pages-browser)/../../../../node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs\");\n\n\nfunction computeCoordsFromPlacement(_ref, placement, rtl) {\n    let { reference, floating } = _ref;\n    const sideAxis = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSideAxis)(placement);\n    const alignmentAxis = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAlignmentAxis)(placement);\n    const alignLength = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAxisLength)(alignmentAxis);\n    const side = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSide)(placement);\n    const isVertical = sideAxis === \"y\";\n    const commonX = reference.x + reference.width / 2 - floating.width / 2;\n    const commonY = reference.y + reference.height / 2 - floating.height / 2;\n    const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;\n    let coords;\n    switch(side){\n        case \"top\":\n            coords = {\n                x: commonX,\n                y: reference.y - floating.height\n            };\n            break;\n        case \"bottom\":\n            coords = {\n                x: commonX,\n                y: reference.y + reference.height\n            };\n            break;\n        case \"right\":\n            coords = {\n                x: reference.x + reference.width,\n                y: commonY\n            };\n            break;\n        case \"left\":\n            coords = {\n                x: reference.x - floating.width,\n                y: commonY\n            };\n            break;\n        default:\n            coords = {\n                x: reference.x,\n                y: reference.y\n            };\n    }\n    switch((0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAlignment)(placement)){\n        case \"start\":\n            coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);\n            break;\n        case \"end\":\n            coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);\n            break;\n    }\n    return coords;\n}\n/**\n * Computes the `x` and `y` coordinates that will place the floating element\n * next to a given reference element.\n *\n * This export does not have any `platform` interface logic. You will need to\n * write one for the platform you are using Floating UI with.\n */ const computePosition = async (reference, floating, config)=>{\n    const { placement = \"bottom\", strategy = \"absolute\", middleware = [], platform } = config;\n    const validMiddleware = middleware.filter(Boolean);\n    const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(floating));\n    let rects = await platform.getElementRects({\n        reference,\n        floating,\n        strategy\n    });\n    let { x, y } = computeCoordsFromPlacement(rects, placement, rtl);\n    let statefulPlacement = placement;\n    let middlewareData = {};\n    let resetCount = 0;\n    for(let i = 0; i < validMiddleware.length; i++){\n        const { name, fn } = validMiddleware[i];\n        const { x: nextX, y: nextY, data, reset } = await fn({\n            x,\n            y,\n            initialPlacement: placement,\n            placement: statefulPlacement,\n            strategy,\n            middlewareData,\n            rects,\n            platform,\n            elements: {\n                reference,\n                floating\n            }\n        });\n        x = nextX != null ? nextX : x;\n        y = nextY != null ? nextY : y;\n        middlewareData = {\n            ...middlewareData,\n            [name]: {\n                ...middlewareData[name],\n                ...data\n            }\n        };\n        if (reset && resetCount <= 50) {\n            resetCount++;\n            if (typeof reset === \"object\") {\n                if (reset.placement) {\n                    statefulPlacement = reset.placement;\n                }\n                if (reset.rects) {\n                    rects = reset.rects === true ? await platform.getElementRects({\n                        reference,\n                        floating,\n                        strategy\n                    }) : reset.rects;\n                }\n                ({ x, y } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));\n            }\n            i = -1;\n        }\n    }\n    return {\n        x,\n        y,\n        placement: statefulPlacement,\n        strategy,\n        middlewareData\n    };\n};\n/**\n * Resolves with an object of overflow side offsets that determine how much the\n * element is overflowing a given clipping boundary on each side.\n * - positive = overflowing the boundary by that number of pixels\n * - negative = how many pixels left before it will overflow\n * - 0 = lies flush with the boundary\n * @see https://floating-ui.com/docs/detectOverflow\n */ async function detectOverflow(state, options) {\n    var _await$platform$isEle;\n    if (options === void 0) {\n        options = {};\n    }\n    const { x, y, platform, rects, elements, strategy } = state;\n    const { boundary = \"clippingAncestors\", rootBoundary = \"viewport\", elementContext = \"floating\", altBoundary = false, padding = 0 } = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.evaluate)(options, state);\n    const paddingObject = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getPaddingObject)(padding);\n    const altContext = elementContext === \"floating\" ? \"reference\" : \"floating\";\n    const element = elements[altBoundary ? altContext : elementContext];\n    const clippingClientRect = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.rectToClientRect)(await platform.getClippingRect({\n        element: ((_await$platform$isEle = await (platform.isElement == null ? void 0 : platform.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || await (platform.getDocumentElement == null ? void 0 : platform.getDocumentElement(elements.floating)),\n        boundary,\n        rootBoundary,\n        strategy\n    }));\n    const rect = elementContext === \"floating\" ? {\n        x,\n        y,\n        width: rects.floating.width,\n        height: rects.floating.height\n    } : rects.reference;\n    const offsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(elements.floating));\n    const offsetScale = await (platform.isElement == null ? void 0 : platform.isElement(offsetParent)) ? await (platform.getScale == null ? void 0 : platform.getScale(offsetParent)) || {\n        x: 1,\n        y: 1\n    } : {\n        x: 1,\n        y: 1\n    };\n    const elementClientRect = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.rectToClientRect)(platform.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform.convertOffsetParentRelativeRectToViewportRelativeRect({\n        elements,\n        rect,\n        offsetParent,\n        strategy\n    }) : rect);\n    return {\n        top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,\n        bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,\n        left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,\n        right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x\n    };\n}\n/**\n * Provides data to position an inner element of the floating element so that it\n * appears centered to the reference element.\n * @see https://floating-ui.com/docs/arrow\n */ const arrow = (options)=>({\n        name: \"arrow\",\n        options,\n        async fn (state) {\n            const { x, y, placement, rects, platform, elements, middlewareData } = state;\n            // Since `element` is required, we don't Partial<> the type.\n            const { element, padding = 0 } = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.evaluate)(options, state) || {};\n            if (element == null) {\n                return {};\n            }\n            const paddingObject = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getPaddingObject)(padding);\n            const coords = {\n                x,\n                y\n            };\n            const axis = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAlignmentAxis)(placement);\n            const length = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAxisLength)(axis);\n            const arrowDimensions = await platform.getDimensions(element);\n            const isYAxis = axis === \"y\";\n            const minProp = isYAxis ? \"top\" : \"left\";\n            const maxProp = isYAxis ? \"bottom\" : \"right\";\n            const clientProp = isYAxis ? \"clientHeight\" : \"clientWidth\";\n            const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];\n            const startDiff = coords[axis] - rects.reference[axis];\n            const arrowOffsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(element));\n            let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;\n            // DOM platform can return `window` as the `offsetParent`.\n            if (!clientSize || !await (platform.isElement == null ? void 0 : platform.isElement(arrowOffsetParent))) {\n                clientSize = elements.floating[clientProp] || rects.floating[length];\n            }\n            const centerToReference = endDiff / 2 - startDiff / 2;\n            // If the padding is large enough that it causes the arrow to no longer be\n            // centered, modify the padding so that it is centered.\n            const largestPossiblePadding = clientSize / 2 - arrowDimensions[length] / 2 - 1;\n            const minPadding = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.min)(paddingObject[minProp], largestPossiblePadding);\n            const maxPadding = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.min)(paddingObject[maxProp], largestPossiblePadding);\n            // Make sure the arrow doesn't overflow the floating element if the center\n            // point is outside the floating element's bounds.\n            const min$1 = minPadding;\n            const max = clientSize - arrowDimensions[length] - maxPadding;\n            const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;\n            const offset = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.clamp)(min$1, center, max);\n            // If the reference is small enough that the arrow's padding causes it to\n            // to point to nothing for an aligned placement, adjust the offset of the\n            // floating element itself. To ensure `shift()` continues to take action,\n            // a single reset is performed when this is true.\n            const shouldAddOffset = !middlewareData.arrow && (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAlignment)(placement) != null && center !== offset && rects.reference[length] / 2 - (center < min$1 ? minPadding : maxPadding) - arrowDimensions[length] / 2 < 0;\n            const alignmentOffset = shouldAddOffset ? center < min$1 ? center - min$1 : center - max : 0;\n            return {\n                [axis]: coords[axis] + alignmentOffset,\n                data: {\n                    [axis]: offset,\n                    centerOffset: center - offset - alignmentOffset,\n                    ...shouldAddOffset && {\n                        alignmentOffset\n                    }\n                },\n                reset: shouldAddOffset\n            };\n        }\n    });\nfunction getPlacementList(alignment, autoAlignment, allowedPlacements) {\n    const allowedPlacementsSortedByAlignment = alignment ? [\n        ...allowedPlacements.filter((placement)=>(0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAlignment)(placement) === alignment),\n        ...allowedPlacements.filter((placement)=>(0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAlignment)(placement) !== alignment)\n    ] : allowedPlacements.filter((placement)=>(0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSide)(placement) === placement);\n    return allowedPlacementsSortedByAlignment.filter((placement)=>{\n        if (alignment) {\n            return (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAlignment)(placement) === alignment || (autoAlignment ? (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getOppositeAlignmentPlacement)(placement) !== placement : false);\n        }\n        return true;\n    });\n}\n/**\n * Optimizes the visibility of the floating element by choosing the placement\n * that has the most space available automatically, without needing to specify a\n * preferred placement. Alternative to `flip`.\n * @see https://floating-ui.com/docs/autoPlacement\n */ const autoPlacement = function(options) {\n    if (options === void 0) {\n        options = {};\n    }\n    return {\n        name: \"autoPlacement\",\n        options,\n        async fn (state) {\n            var _middlewareData$autoP, _middlewareData$autoP2, _placementsThatFitOnE;\n            const { rects, middlewareData, placement, platform, elements } = state;\n            const { crossAxis = false, alignment, allowedPlacements = _floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.placements, autoAlignment = true, ...detectOverflowOptions } = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.evaluate)(options, state);\n            const placements$1 = alignment !== undefined || allowedPlacements === _floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.placements ? getPlacementList(alignment || null, autoAlignment, allowedPlacements) : allowedPlacements;\n            const overflow = await detectOverflow(state, detectOverflowOptions);\n            const currentIndex = ((_middlewareData$autoP = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP.index) || 0;\n            const currentPlacement = placements$1[currentIndex];\n            if (currentPlacement == null) {\n                return {};\n            }\n            const alignmentSides = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAlignmentSides)(currentPlacement, rects, await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating)));\n            // Make `computeCoords` start from the right place.\n            if (placement !== currentPlacement) {\n                return {\n                    reset: {\n                        placement: placements$1[0]\n                    }\n                };\n            }\n            const currentOverflows = [\n                overflow[(0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSide)(currentPlacement)],\n                overflow[alignmentSides[0]],\n                overflow[alignmentSides[1]]\n            ];\n            const allOverflows = [\n                ...((_middlewareData$autoP2 = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP2.overflows) || [],\n                {\n                    placement: currentPlacement,\n                    overflows: currentOverflows\n                }\n            ];\n            const nextPlacement = placements$1[currentIndex + 1];\n            // There are more placements to check.\n            if (nextPlacement) {\n                return {\n                    data: {\n                        index: currentIndex + 1,\n                        overflows: allOverflows\n                    },\n                    reset: {\n                        placement: nextPlacement\n                    }\n                };\n            }\n            const placementsSortedByMostSpace = allOverflows.map((d)=>{\n                const alignment = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAlignment)(d.placement);\n                return [\n                    d.placement,\n                    alignment && crossAxis ? // Check along the mainAxis and main crossAxis side.\n                    d.overflows.slice(0, 2).reduce((acc, v)=>acc + v, 0) : // Check only the mainAxis.\n                    d.overflows[0],\n                    d.overflows\n                ];\n            }).sort((a, b)=>a[1] - b[1]);\n            const placementsThatFitOnEachSide = placementsSortedByMostSpace.filter((d)=>d[2].slice(0, // Aligned placements should not check their opposite crossAxis\n                // side.\n                (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAlignment)(d[0]) ? 2 : 3).every((v)=>v <= 0));\n            const resetPlacement = ((_placementsThatFitOnE = placementsThatFitOnEachSide[0]) == null ? void 0 : _placementsThatFitOnE[0]) || placementsSortedByMostSpace[0][0];\n            if (resetPlacement !== placement) {\n                return {\n                    data: {\n                        index: currentIndex + 1,\n                        overflows: allOverflows\n                    },\n                    reset: {\n                        placement: resetPlacement\n                    }\n                };\n            }\n            return {};\n        }\n    };\n};\n/**\n * Optimizes the visibility of the floating element by flipping the `placement`\n * in order to keep it in view when the preferred placement(s) will overflow the\n * clipping boundary. Alternative to `autoPlacement`.\n * @see https://floating-ui.com/docs/flip\n */ const flip = function(options) {\n    if (options === void 0) {\n        options = {};\n    }\n    return {\n        name: \"flip\",\n        options,\n        async fn (state) {\n            var _middlewareData$arrow, _middlewareData$flip;\n            const { placement, middlewareData, rects, initialPlacement, platform, elements } = state;\n            const { mainAxis: checkMainAxis = true, crossAxis: checkCrossAxis = true, fallbackPlacements: specifiedFallbackPlacements, fallbackStrategy = \"bestFit\", fallbackAxisSideDirection = \"none\", flipAlignment = true, ...detectOverflowOptions } = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.evaluate)(options, state);\n            // If a reset by the arrow was caused due to an alignment offset being\n            // added, we should skip any logic now since `flip()` has already done its\n            // work.\n            // https://github.com/floating-ui/floating-ui/issues/2549#issuecomment-1719601643\n            if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {\n                return {};\n            }\n            const side = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSide)(placement);\n            const initialSideAxis = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSideAxis)(initialPlacement);\n            const isBasePlacement = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSide)(initialPlacement) === initialPlacement;\n            const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));\n            const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [\n                (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getOppositePlacement)(initialPlacement)\n            ] : (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getExpandedPlacements)(initialPlacement));\n            const hasFallbackAxisSideDirection = fallbackAxisSideDirection !== \"none\";\n            if (!specifiedFallbackPlacements && hasFallbackAxisSideDirection) {\n                fallbackPlacements.push(...(0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getOppositeAxisPlacements)(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));\n            }\n            const placements = [\n                initialPlacement,\n                ...fallbackPlacements\n            ];\n            const overflow = await detectOverflow(state, detectOverflowOptions);\n            const overflows = [];\n            let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];\n            if (checkMainAxis) {\n                overflows.push(overflow[side]);\n            }\n            if (checkCrossAxis) {\n                const sides = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAlignmentSides)(placement, rects, rtl);\n                overflows.push(overflow[sides[0]], overflow[sides[1]]);\n            }\n            overflowsData = [\n                ...overflowsData,\n                {\n                    placement,\n                    overflows\n                }\n            ];\n            // One or more sides is overflowing.\n            if (!overflows.every((side)=>side <= 0)) {\n                var _middlewareData$flip2, _overflowsData$filter;\n                const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;\n                const nextPlacement = placements[nextIndex];\n                if (nextPlacement) {\n                    // Try next placement and re-run the lifecycle.\n                    return {\n                        data: {\n                            index: nextIndex,\n                            overflows: overflowsData\n                        },\n                        reset: {\n                            placement: nextPlacement\n                        }\n                    };\n                }\n                // First, find the candidates that fit on the mainAxis side of overflow,\n                // then find the placement that fits the best on the main crossAxis side.\n                let resetPlacement = (_overflowsData$filter = overflowsData.filter((d)=>d.overflows[0] <= 0).sort((a, b)=>a.overflows[1] - b.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;\n                // Otherwise fallback.\n                if (!resetPlacement) {\n                    switch(fallbackStrategy){\n                        case \"bestFit\":\n                            {\n                                var _overflowsData$filter2;\n                                const placement = (_overflowsData$filter2 = overflowsData.filter((d)=>{\n                                    if (hasFallbackAxisSideDirection) {\n                                        const currentSideAxis = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSideAxis)(d.placement);\n                                        return currentSideAxis === initialSideAxis || // Create a bias to the `y` side axis due to horizontal\n                                        // reading directions favoring greater width.\n                                        currentSideAxis === \"y\";\n                                    }\n                                    return true;\n                                }).map((d)=>[\n                                        d.placement,\n                                        d.overflows.filter((overflow)=>overflow > 0).reduce((acc, overflow)=>acc + overflow, 0)\n                                    ]).sort((a, b)=>a[1] - b[1])[0]) == null ? void 0 : _overflowsData$filter2[0];\n                                if (placement) {\n                                    resetPlacement = placement;\n                                }\n                                break;\n                            }\n                        case \"initialPlacement\":\n                            resetPlacement = initialPlacement;\n                            break;\n                    }\n                }\n                if (placement !== resetPlacement) {\n                    return {\n                        reset: {\n                            placement: resetPlacement\n                        }\n                    };\n                }\n            }\n            return {};\n        }\n    };\n};\nfunction getSideOffsets(overflow, rect) {\n    return {\n        top: overflow.top - rect.height,\n        right: overflow.right - rect.width,\n        bottom: overflow.bottom - rect.height,\n        left: overflow.left - rect.width\n    };\n}\nfunction isAnySideFullyClipped(overflow) {\n    return _floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.sides.some((side)=>overflow[side] >= 0);\n}\n/**\n * Provides data to hide the floating element in applicable situations, such as\n * when it is not in the same clipping context as the reference element.\n * @see https://floating-ui.com/docs/hide\n */ const hide = function(options) {\n    if (options === void 0) {\n        options = {};\n    }\n    return {\n        name: \"hide\",\n        options,\n        async fn (state) {\n            const { rects } = state;\n            const { strategy = \"referenceHidden\", ...detectOverflowOptions } = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.evaluate)(options, state);\n            switch(strategy){\n                case \"referenceHidden\":\n                    {\n                        const overflow = await detectOverflow(state, {\n                            ...detectOverflowOptions,\n                            elementContext: \"reference\"\n                        });\n                        const offsets = getSideOffsets(overflow, rects.reference);\n                        return {\n                            data: {\n                                referenceHiddenOffsets: offsets,\n                                referenceHidden: isAnySideFullyClipped(offsets)\n                            }\n                        };\n                    }\n                case \"escaped\":\n                    {\n                        const overflow = await detectOverflow(state, {\n                            ...detectOverflowOptions,\n                            altBoundary: true\n                        });\n                        const offsets = getSideOffsets(overflow, rects.floating);\n                        return {\n                            data: {\n                                escapedOffsets: offsets,\n                                escaped: isAnySideFullyClipped(offsets)\n                            }\n                        };\n                    }\n                default:\n                    {\n                        return {};\n                    }\n            }\n        }\n    };\n};\nfunction getBoundingRect(rects) {\n    const minX = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.min)(...rects.map((rect)=>rect.left));\n    const minY = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.min)(...rects.map((rect)=>rect.top));\n    const maxX = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.max)(...rects.map((rect)=>rect.right));\n    const maxY = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.max)(...rects.map((rect)=>rect.bottom));\n    return {\n        x: minX,\n        y: minY,\n        width: maxX - minX,\n        height: maxY - minY\n    };\n}\nfunction getRectsByLine(rects) {\n    const sortedRects = rects.slice().sort((a, b)=>a.y - b.y);\n    const groups = [];\n    let prevRect = null;\n    for(let i = 0; i < sortedRects.length; i++){\n        const rect = sortedRects[i];\n        if (!prevRect || rect.y - prevRect.y > prevRect.height / 2) {\n            groups.push([\n                rect\n            ]);\n        } else {\n            groups[groups.length - 1].push(rect);\n        }\n        prevRect = rect;\n    }\n    return groups.map((rect)=>(0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.rectToClientRect)(getBoundingRect(rect)));\n}\n/**\n * Provides improved positioning for inline reference elements that can span\n * over multiple lines, such as hyperlinks or range selections.\n * @see https://floating-ui.com/docs/inline\n */ const inline = function(options) {\n    if (options === void 0) {\n        options = {};\n    }\n    return {\n        name: \"inline\",\n        options,\n        async fn (state) {\n            const { placement, elements, rects, platform, strategy } = state;\n            // A MouseEvent's client{X,Y} coords can be up to 2 pixels off a\n            // ClientRect's bounds, despite the event listener being triggered. A\n            // padding of 2 seems to handle this issue.\n            const { padding = 2, x, y } = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.evaluate)(options, state);\n            const nativeClientRects = Array.from(await (platform.getClientRects == null ? void 0 : platform.getClientRects(elements.reference)) || []);\n            const clientRects = getRectsByLine(nativeClientRects);\n            const fallback = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.rectToClientRect)(getBoundingRect(nativeClientRects));\n            const paddingObject = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getPaddingObject)(padding);\n            function getBoundingClientRect() {\n                // There are two rects and they are disjoined.\n                if (clientRects.length === 2 && clientRects[0].left > clientRects[1].right && x != null && y != null) {\n                    // Find the first rect in which the point is fully inside.\n                    return clientRects.find((rect)=>x > rect.left - paddingObject.left && x < rect.right + paddingObject.right && y > rect.top - paddingObject.top && y < rect.bottom + paddingObject.bottom) || fallback;\n                }\n                // There are 2 or more connected rects.\n                if (clientRects.length >= 2) {\n                    if ((0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSideAxis)(placement) === \"y\") {\n                        const firstRect = clientRects[0];\n                        const lastRect = clientRects[clientRects.length - 1];\n                        const isTop = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSide)(placement) === \"top\";\n                        const top = firstRect.top;\n                        const bottom = lastRect.bottom;\n                        const left = isTop ? firstRect.left : lastRect.left;\n                        const right = isTop ? firstRect.right : lastRect.right;\n                        const width = right - left;\n                        const height = bottom - top;\n                        return {\n                            top,\n                            bottom,\n                            left,\n                            right,\n                            width,\n                            height,\n                            x: left,\n                            y: top\n                        };\n                    }\n                    const isLeftSide = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSide)(placement) === \"left\";\n                    const maxRight = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.max)(...clientRects.map((rect)=>rect.right));\n                    const minLeft = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.min)(...clientRects.map((rect)=>rect.left));\n                    const measureRects = clientRects.filter((rect)=>isLeftSide ? rect.left === minLeft : rect.right === maxRight);\n                    const top = measureRects[0].top;\n                    const bottom = measureRects[measureRects.length - 1].bottom;\n                    const left = minLeft;\n                    const right = maxRight;\n                    const width = right - left;\n                    const height = bottom - top;\n                    return {\n                        top,\n                        bottom,\n                        left,\n                        right,\n                        width,\n                        height,\n                        x: left,\n                        y: top\n                    };\n                }\n                return fallback;\n            }\n            const resetRects = await platform.getElementRects({\n                reference: {\n                    getBoundingClientRect\n                },\n                floating: elements.floating,\n                strategy\n            });\n            if (rects.reference.x !== resetRects.reference.x || rects.reference.y !== resetRects.reference.y || rects.reference.width !== resetRects.reference.width || rects.reference.height !== resetRects.reference.height) {\n                return {\n                    reset: {\n                        rects: resetRects\n                    }\n                };\n            }\n            return {};\n        }\n    };\n};\n// For type backwards-compatibility, the `OffsetOptions` type was also\n// Derivable.\nasync function convertValueToCoords(state, options) {\n    const { placement, platform, elements } = state;\n    const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));\n    const side = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSide)(placement);\n    const alignment = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAlignment)(placement);\n    const isVertical = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSideAxis)(placement) === \"y\";\n    const mainAxisMulti = [\n        \"left\",\n        \"top\"\n    ].includes(side) ? -1 : 1;\n    const crossAxisMulti = rtl && isVertical ? -1 : 1;\n    const rawValue = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.evaluate)(options, state);\n    // eslint-disable-next-line prefer-const\n    let { mainAxis, crossAxis, alignmentAxis } = typeof rawValue === \"number\" ? {\n        mainAxis: rawValue,\n        crossAxis: 0,\n        alignmentAxis: null\n    } : {\n        mainAxis: rawValue.mainAxis || 0,\n        crossAxis: rawValue.crossAxis || 0,\n        alignmentAxis: rawValue.alignmentAxis\n    };\n    if (alignment && typeof alignmentAxis === \"number\") {\n        crossAxis = alignment === \"end\" ? alignmentAxis * -1 : alignmentAxis;\n    }\n    return isVertical ? {\n        x: crossAxis * crossAxisMulti,\n        y: mainAxis * mainAxisMulti\n    } : {\n        x: mainAxis * mainAxisMulti,\n        y: crossAxis * crossAxisMulti\n    };\n}\n/**\n * Modifies the placement by translating the floating element along the\n * specified axes.\n * A number (shorthand for `mainAxis` or distance), or an axes configuration\n * object may be passed.\n * @see https://floating-ui.com/docs/offset\n */ const offset = function(options) {\n    if (options === void 0) {\n        options = 0;\n    }\n    return {\n        name: \"offset\",\n        options,\n        async fn (state) {\n            var _middlewareData$offse, _middlewareData$arrow;\n            const { x, y, placement, middlewareData } = state;\n            const diffCoords = await convertValueToCoords(state, options);\n            // If the placement is the same and the arrow caused an alignment offset\n            // then we don't need to change the positioning coordinates.\n            if (placement === ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse.placement) && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {\n                return {};\n            }\n            return {\n                x: x + diffCoords.x,\n                y: y + diffCoords.y,\n                data: {\n                    ...diffCoords,\n                    placement\n                }\n            };\n        }\n    };\n};\n/**\n * Optimizes the visibility of the floating element by shifting it in order to\n * keep it in view when it will overflow the clipping boundary.\n * @see https://floating-ui.com/docs/shift\n */ const shift = function(options) {\n    if (options === void 0) {\n        options = {};\n    }\n    return {\n        name: \"shift\",\n        options,\n        async fn (state) {\n            const { x, y, placement } = state;\n            const { mainAxis: checkMainAxis = true, crossAxis: checkCrossAxis = false, limiter = {\n                fn: (_ref)=>{\n                    let { x, y } = _ref;\n                    return {\n                        x,\n                        y\n                    };\n                }\n            }, ...detectOverflowOptions } = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.evaluate)(options, state);\n            const coords = {\n                x,\n                y\n            };\n            const overflow = await detectOverflow(state, detectOverflowOptions);\n            const crossAxis = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSideAxis)((0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSide)(placement));\n            const mainAxis = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getOppositeAxis)(crossAxis);\n            let mainAxisCoord = coords[mainAxis];\n            let crossAxisCoord = coords[crossAxis];\n            if (checkMainAxis) {\n                const minSide = mainAxis === \"y\" ? \"top\" : \"left\";\n                const maxSide = mainAxis === \"y\" ? \"bottom\" : \"right\";\n                const min = mainAxisCoord + overflow[minSide];\n                const max = mainAxisCoord - overflow[maxSide];\n                mainAxisCoord = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.clamp)(min, mainAxisCoord, max);\n            }\n            if (checkCrossAxis) {\n                const minSide = crossAxis === \"y\" ? \"top\" : \"left\";\n                const maxSide = crossAxis === \"y\" ? \"bottom\" : \"right\";\n                const min = crossAxisCoord + overflow[minSide];\n                const max = crossAxisCoord - overflow[maxSide];\n                crossAxisCoord = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.clamp)(min, crossAxisCoord, max);\n            }\n            const limitedCoords = limiter.fn({\n                ...state,\n                [mainAxis]: mainAxisCoord,\n                [crossAxis]: crossAxisCoord\n            });\n            return {\n                ...limitedCoords,\n                data: {\n                    x: limitedCoords.x - x,\n                    y: limitedCoords.y - y,\n                    enabled: {\n                        [mainAxis]: checkMainAxis,\n                        [crossAxis]: checkCrossAxis\n                    }\n                }\n            };\n        }\n    };\n};\n/**\n * Built-in `limiter` that will stop `shift()` at a certain point.\n */ const limitShift = function(options) {\n    if (options === void 0) {\n        options = {};\n    }\n    return {\n        options,\n        fn (state) {\n            const { x, y, placement, rects, middlewareData } = state;\n            const { offset = 0, mainAxis: checkMainAxis = true, crossAxis: checkCrossAxis = true } = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.evaluate)(options, state);\n            const coords = {\n                x,\n                y\n            };\n            const crossAxis = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSideAxis)(placement);\n            const mainAxis = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getOppositeAxis)(crossAxis);\n            let mainAxisCoord = coords[mainAxis];\n            let crossAxisCoord = coords[crossAxis];\n            const rawOffset = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.evaluate)(offset, state);\n            const computedOffset = typeof rawOffset === \"number\" ? {\n                mainAxis: rawOffset,\n                crossAxis: 0\n            } : {\n                mainAxis: 0,\n                crossAxis: 0,\n                ...rawOffset\n            };\n            if (checkMainAxis) {\n                const len = mainAxis === \"y\" ? \"height\" : \"width\";\n                const limitMin = rects.reference[mainAxis] - rects.floating[len] + computedOffset.mainAxis;\n                const limitMax = rects.reference[mainAxis] + rects.reference[len] - computedOffset.mainAxis;\n                if (mainAxisCoord < limitMin) {\n                    mainAxisCoord = limitMin;\n                } else if (mainAxisCoord > limitMax) {\n                    mainAxisCoord = limitMax;\n                }\n            }\n            if (checkCrossAxis) {\n                var _middlewareData$offse, _middlewareData$offse2;\n                const len = mainAxis === \"y\" ? \"width\" : \"height\";\n                const isOriginSide = [\n                    \"top\",\n                    \"left\"\n                ].includes((0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSide)(placement));\n                const limitMin = rects.reference[crossAxis] - rects.floating[len] + (isOriginSide ? ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse[crossAxis]) || 0 : 0) + (isOriginSide ? 0 : computedOffset.crossAxis);\n                const limitMax = rects.reference[crossAxis] + rects.reference[len] + (isOriginSide ? 0 : ((_middlewareData$offse2 = middlewareData.offset) == null ? void 0 : _middlewareData$offse2[crossAxis]) || 0) - (isOriginSide ? computedOffset.crossAxis : 0);\n                if (crossAxisCoord < limitMin) {\n                    crossAxisCoord = limitMin;\n                } else if (crossAxisCoord > limitMax) {\n                    crossAxisCoord = limitMax;\n                }\n            }\n            return {\n                [mainAxis]: mainAxisCoord,\n                [crossAxis]: crossAxisCoord\n            };\n        }\n    };\n};\n/**\n * Provides data that allows you to change the size of the floating element \n * for instance, prevent it from overflowing the clipping boundary or match the\n * width of the reference element.\n * @see https://floating-ui.com/docs/size\n */ const size = function(options) {\n    if (options === void 0) {\n        options = {};\n    }\n    return {\n        name: \"size\",\n        options,\n        async fn (state) {\n            var _state$middlewareData, _state$middlewareData2;\n            const { placement, rects, platform, elements } = state;\n            const { apply = ()=>{}, ...detectOverflowOptions } = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.evaluate)(options, state);\n            const overflow = await detectOverflow(state, detectOverflowOptions);\n            const side = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSide)(placement);\n            const alignment = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAlignment)(placement);\n            const isYAxis = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSideAxis)(placement) === \"y\";\n            const { width, height } = rects.floating;\n            let heightSide;\n            let widthSide;\n            if (side === \"top\" || side === \"bottom\") {\n                heightSide = side;\n                widthSide = alignment === (await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating)) ? \"start\" : \"end\") ? \"left\" : \"right\";\n            } else {\n                widthSide = side;\n                heightSide = alignment === \"end\" ? \"top\" : \"bottom\";\n            }\n            const maximumClippingHeight = height - overflow.top - overflow.bottom;\n            const maximumClippingWidth = width - overflow.left - overflow.right;\n            const overflowAvailableHeight = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.min)(height - overflow[heightSide], maximumClippingHeight);\n            const overflowAvailableWidth = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.min)(width - overflow[widthSide], maximumClippingWidth);\n            const noShift = !state.middlewareData.shift;\n            let availableHeight = overflowAvailableHeight;\n            let availableWidth = overflowAvailableWidth;\n            if ((_state$middlewareData = state.middlewareData.shift) != null && _state$middlewareData.enabled.x) {\n                availableWidth = maximumClippingWidth;\n            }\n            if ((_state$middlewareData2 = state.middlewareData.shift) != null && _state$middlewareData2.enabled.y) {\n                availableHeight = maximumClippingHeight;\n            }\n            if (noShift && !alignment) {\n                const xMin = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.max)(overflow.left, 0);\n                const xMax = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.max)(overflow.right, 0);\n                const yMin = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.max)(overflow.top, 0);\n                const yMax = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.max)(overflow.bottom, 0);\n                if (isYAxis) {\n                    availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.max)(overflow.left, overflow.right));\n                } else {\n                    availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.max)(overflow.top, overflow.bottom));\n                }\n            }\n            await apply({\n                ...state,\n                availableWidth,\n                availableHeight\n            });\n            const nextDimensions = await platform.getDimensions(elements.floating);\n            if (width !== nextDimensions.width || height !== nextDimensions.height) {\n                return {\n                    reset: {\n                        rects: true\n                    }\n                };\n            }\n            return {};\n        }\n    };\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQGZsb2F0aW5nLXVpL2NvcmUvZGlzdC9mbG9hdGluZy11aS5jb3JlLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7O0FBQXNVO0FBQ2hSO0FBRXRELFNBQVNtQiwyQkFBMkJDLElBQUksRUFBRUMsU0FBUyxFQUFFQyxHQUFHO0lBQ3RELElBQUksRUFDRkMsU0FBUyxFQUNUQyxRQUFRLEVBQ1QsR0FBR0o7SUFDSixNQUFNSyxXQUFXekIsK0RBQVdBLENBQUNxQjtJQUM3QixNQUFNSyxnQkFBZ0J6QixvRUFBZ0JBLENBQUNvQjtJQUN2QyxNQUFNTSxjQUFjekIsaUVBQWFBLENBQUN3QjtJQUNsQyxNQUFNRSxPQUFPekIsMkRBQU9BLENBQUNrQjtJQUNyQixNQUFNUSxhQUFhSixhQUFhO0lBQ2hDLE1BQU1LLFVBQVVQLFVBQVVRLENBQUMsR0FBR1IsVUFBVVMsS0FBSyxHQUFHLElBQUlSLFNBQVNRLEtBQUssR0FBRztJQUNyRSxNQUFNQyxVQUFVVixVQUFVVyxDQUFDLEdBQUdYLFVBQVVZLE1BQU0sR0FBRyxJQUFJWCxTQUFTVyxNQUFNLEdBQUc7SUFDdkUsTUFBTUMsY0FBY2IsU0FBUyxDQUFDSSxZQUFZLEdBQUcsSUFBSUgsUUFBUSxDQUFDRyxZQUFZLEdBQUc7SUFDekUsSUFBSVU7SUFDSixPQUFRVDtRQUNOLEtBQUs7WUFDSFMsU0FBUztnQkFDUE4sR0FBR0Q7Z0JBQ0hJLEdBQUdYLFVBQVVXLENBQUMsR0FBR1YsU0FBU1csTUFBTTtZQUNsQztZQUNBO1FBQ0YsS0FBSztZQUNIRSxTQUFTO2dCQUNQTixHQUFHRDtnQkFDSEksR0FBR1gsVUFBVVcsQ0FBQyxHQUFHWCxVQUFVWSxNQUFNO1lBQ25DO1lBQ0E7UUFDRixLQUFLO1lBQ0hFLFNBQVM7Z0JBQ1BOLEdBQUdSLFVBQVVRLENBQUMsR0FBR1IsVUFBVVMsS0FBSztnQkFDaENFLEdBQUdEO1lBQ0w7WUFDQTtRQUNGLEtB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Q1Q7Z0JBQ0Y7WUFDRjtZQUNBLE9BQU8sQ0FBQztRQUNWO0lBQ0Y7QUFDRjtBQUVzSCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BmbG9hdGluZy11aS9jb3JlL2Rpc3QvZmxvYXRpbmctdWkuY29yZS5tanM/NTc3NCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBnZXRTaWRlQXhpcywgZ2V0QWxpZ25tZW50QXhpcywgZ2V0QXhpc0xlbmd0aCwgZ2V0U2lkZSwgZ2V0QWxpZ25tZW50LCBldmFsdWF0ZSwgZ2V0UGFkZGluZ09iamVjdCwgcmVjdFRvQ2xpZW50UmVjdCwgbWluLCBjbGFtcCwgcGxhY2VtZW50cywgZ2V0QWxpZ25tZW50U2lkZXMsIGdldE9wcG9zaXRlQWxpZ25tZW50UGxhY2VtZW50LCBnZXRPcHBvc2l0ZVBsYWNlbWVudCwgZ2V0RXhwYW5kZWRQbGFjZW1lbnRzLCBnZXRPcHBvc2l0ZUF4aXNQbGFjZW1lbnRzLCBzaWRlcywgbWF4LCBnZXRPcHBvc2l0ZUF4aXMgfSBmcm9tICdAZmxvYXRpbmctdWkvdXRpbHMnO1xuZXhwb3J0IHsgcmVjdFRvQ2xpZW50UmVjdCB9IGZyb20gJ0BmbG9hdGluZy11aS91dGlscyc7XG5cbmZ1bmN0aW9uIGNvbXB1dGVDb29yZHNGcm9tUGxhY2VtZW50KF9yZWYsIHBsYWNlbWVudCwgcnRsKSB7XG4gIGxldCB7XG4gICAgcmVmZXJlbmNlLFxuICAgIGZsb2F0aW5nXG4gIH0gPSBfcmVmO1xuICBjb25zdCBzaWRlQXhpcyA9IGdldFNpZGVBeGlzKHBsYWNlbWVudCk7XG4gIGNvbnN0IGFsaWdubWVudEF4aXMgPSBnZXRBbGlnbm1lbnRBeGlzKHBsYWNlbWVudCk7XG4gIGNvbnN0IGFsaWduTGVuZ3RoID0gZ2V0QXhpc0xlbmd0aChhbGlnbm1lbnRBeGlzKTtcbiAgY29uc3Qgc2lkZSA9IGdldFNpZGUocGxhY2VtZW50KTtcbiAgY29uc3QgaXNWZXJ0aWNhbCA9IHNpZGVBeGlzID09PSAneSc7XG4gIGNvbnN0IGNvbW1vblggPSByZWZlcmVuY2UueCArIHJlZmVyZW5jZS53aWR0aCAvIDIgLSBmbG9hdGluZy53aWR0aCAvIDI7XG4gIGNvbnN0IGNvbW1vblkgPSByZWZlcmVuY2UueSArIHJlZmVyZW5jZS5oZWlnaHQgLyAyIC0gZmxvYXRpbmcuaGVpZ2h0IC8gMjtcbiAgY29uc3QgY29tbW9uQWxpZ24gPSByZWZlcmVuY2VbYWxpZ25MZW5ndGhdIC8gMiAtIGZsb2F0aW5nW2FsaWduTGVuZ3RoXSAvIDI7XG4gIGxldCBjb29yZHM7XG4gIHN3aXRjaCAoc2lkZSkge1xuICAgIGNhc2UgJ3RvcCc6XG4gICAgICBjb29yZHMgPSB7XG4gICAgICAgIHg6IGNvbW1vblgsXG4gICAgICAgIHk6IHJlZmVyZW5jZS55IC0gZmxvYXRpbmcuaGVpZ2h0XG4gICAgICB9O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnYm90dG9tJzpcbiAgICAgIGNvb3JkcyA9IHtcbiAgICAgICAgeDogY29tbW9uWCxcbiAgICAgICAgeTogcmVmZXJlbmNlLnkgKyByZWZlcmVuY2UuaGVpZ2h0XG4gICAgICB9O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAncmlnaHQnOlxuICAgICAgY29vcmRzID0ge1xuICAgICAgICB4OiByZWZlcmVuY2UueCArIHJlZmVyZW5jZS53aWR0aCxcbiAgICAgICAgeTogY29tbW9uWVxuICAgICAgfTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2xlZnQnOlxuICAgICAgY29vcmRzID0ge1xuICAgICAgICB4OiByZWZlcmVuY2UueCAtIGZsb2F0aW5nLndpZHRoLFxuICAgICAgICB5OiBjb21tb25ZXG4gICAgICB9O1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIGNvb3JkcyA9IHtcbiAgICAgICAgeDogcmVmZXJlbmNlLngsXG4gICAgICAgIHk6IHJlZmVyZW5jZS55XG4gICAgICB9O1xuICB9XG4gIHN3aXRjaCAoZ2V0QWxpZ25tZW50KHBsYWNlbWVudCkpIHtcbiAgICBjYXNlICdzdGFydCc6XG4gICAgICBjb29yZHNbYWxpZ25tZW50QXhpc10gLT0gY29tbW9uQWxpZ24gKiAocnRsICYmIGlzVmVydGljYWwgPyAtMSA6IDEpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnZW5kJzpcbiAgICAgIGNvb3Jkc1thbGlnbm1lbnRBeGlzXSArPSBjb21tb25BbGlnbiAqIChydGwgJiYgaXNWZXJ0aWNhbCA/IC0xIDogMSk7XG4gICAgICBicmVhaztcbiAgfVxuICByZXR1cm4gY29vcmRzO1xufVxuXG4vKipcbiAqIENvbXB1dGVzIHRoZSBgeGAgYW5kIGB5YCBjb29yZGluYXRlcyB0aGF0IHdpbGwgcGxhY2UgdGhlIGZsb2F0aW5nIGVsZW1lbnRcbiAqIG5leHQgdG8gYSBnaXZlbiByZWZlcmVuY2UgZWxlbWVudC5cbiAqXG4gKiBUaGlzIGV4cG9ydCBkb2VzIG5vdCBoYXZlIGFueSBgcGxhdGZvcm1gIGludGVyZmFjZSBsb2dpYy4gWW91IHdpbGwgbmVlZCB0b1xuICogd3JpdGUgb25lIGZvciB0aGUgcGxhdGZvcm0geW91IGFyZSB1c2luZyBGbG9hdGluZyBVSSB3aXRoLlxuICovXG5jb25zdCBjb21wdXRlUG9zaXRpb24gPSBhc3luYyAocmVmZXJlbmNlLCBmbG9hdGluZywgY29uZmlnKSA9PiB7XG4gIGNvbnN0IHtcbiAgICBwbGFjZW1lbnQgPSAnYm90dG9tJyxcbiAgICBzdHJhdGVneSA9ICdhYnNvbHV0ZScsXG4gICAgbWlkZGxld2FyZSA9IFtdLFxuICAgIHBsYXRmb3JtXG4gIH0gPSBjb25maWc7XG4gIGNvbnN0IHZhbGlkTWlkZGxld2FyZSA9IG1pZGRsZXdhcmUuZmlsdGVyKEJvb2xlYW4pO1xuICBjb25zdCBydGwgPSBhd2FpdCAocGxhdGZvcm0uaXNSVEwgPT0gbnVsbCA/IHZvaWQgMCA6IHBsYXRmb3JtLmlzUlRMKGZsb2F0aW5nKSk7XG4gIGxldCByZWN0cyA9IGF3YWl0IHBsYXRmb3JtLmdldEVsZW1lbnRSZWN0cyh7XG4gICAgcmVmZXJlbmNlLFxuICAgIGZsb2F0aW5nLFxuICAgIHN0cmF0ZWd5XG4gIH0pO1xuICBsZXQge1xuICAgIHgsXG4gICAgeVxuICB9ID0gY29tcHV0ZUNvb3Jkc0Zyb21QbGFjZW1lbnQocmVjdHMsIHBsYWNlbWVudCwgcnRsKTtcbiAgbGV0IHN0YXRlZnVsUGxhY2VtZW50ID0gcGxhY2VtZW50O1xuICBsZXQgbWlkZGxld2FyZURhdGEgPSB7fTtcbiAgbGV0IHJlc2V0Q291bnQgPSAwO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbGlkTWlkZGxld2FyZS5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHtcbiAgICAgIG5hbWUsXG4gICAgICBmblxuICAgIH0gPSB2YWxpZE1pZGRsZXdhcmVbaV07XG4gICAgY29uc3Qge1xuICAgICAgeDogbmV4dFgsXG4gICAgICB5OiBuZXh0WSxcbiAgICAgIGRhdGEsXG4gICAgICByZXNldFxuICAgIH0gPSBhd2FpdCBmbih7XG4gICAgICB4LFxuICAgICAgeSxcbiAgICAgIGluaXRpYWxQbGFjZW1lbnQ6IHBsYWNlbWVudCxcbiAgICAgIHBsYWNlbWVudDogc3RhdGVmdWxQbGFjZW1lbnQsXG4gICAgICBzdHJhdGVneSxcbiAgICAgIG1pZGRsZXdhcmVEYXRhLFxuICAgICAgcmVjdHMsXG4gICAgICBwbGF0Zm9ybSxcbiAgICAgIGVsZW1lbnRzOiB7XG4gICAgICAgIHJlZmVyZW5jZSxcbiAgICAgICAgZmxvYXRpbmdcbiAgICAgIH1cbiAgICB9KTtcbiAgICB4ID0gbmV4dFggIT0gbnVsbCA/IG5leHRYIDogeDtcbiAgICB5ID0gbmV4dFkgIT0gbnVsbCA/IG5leHRZIDogeTtcbiAgICBtaWRkbGV3YXJlRGF0YSA9IHtcbiAgICAgIC4uLm1pZGRsZXdhcmVEYXRhLFxuICAgICAgW25hbWVdOiB7XG4gICAgICAgIC4uLm1pZGRsZXdhcmVEYXRhW25hbWVdLFxuICAgICAgICAuLi5kYXRhXG4gICAgICB9XG4gICAgfTtcbiAgICBpZiAocmVzZXQgJiYgcmVzZXRDb3VudCA8PSA1MCkge1xuICAgICAgcmVzZXRDb3VudCsrO1xuICAgICAgaWYgKHR5cGVvZiByZXNldCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgaWYgKHJlc2V0LnBsYWNlbWVudCkge1xuICAgICAgICAgIHN0YXRlZnVsUGxhY2VtZW50ID0gcmVzZXQucGxhY2VtZW50O1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXNldC5yZWN0cykge1xuICAgICAgICAgIHJlY3RzID0gcmVzZXQucmVjdHMgPT09IHRydWUgPyBhd2FpdCBwbGF0Zm9ybS5nZXRFbGVtZW50UmVjdHMoe1xuICAgICAgICAgICAgcmVmZXJlbmNlLFxuICAgICAgICAgICAgZmxvYXRpbmcsXG4gICAgICAgICAgICBzdHJhdGVneVxuICAgICAgICAgIH0pIDogcmVzZXQucmVjdHM7XG4gICAgICAgIH1cbiAgICAgICAgKHtcbiAgICAgICAgICB4LFxuICAgICAgICAgIHlcbiAgICAgICAgfSA9IGNvbXB1dGVDb29yZHNGcm9tUGxhY2VtZW50KHJlY3RzLCBzdGF0ZWZ1bFBsYWNlbWVudCwgcnRsKSk7XG4gICAgICB9XG4gICAgICBpID0gLTE7XG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgeCxcbiAgICB5LFxuICAgIHBsYWNlbWVudDogc3RhdGVmdWxQbGFjZW1lbnQsXG4gICAgc3RyYXRlZ3ksXG4gICAgbWlkZGxld2FyZURhdGFcbiAgfTtcbn07XG5cbi8qKlxuICogUmVzb2x2ZXMgd2l0aCBhbiBvYmplY3Qgb2Ygb3ZlcmZsb3cgc2lkZSBvZmZzZXRzIHRoYXQgZGV0ZXJtaW5lIGhvdyBtdWNoIHRoZVxuICogZWxlbWVudCBpcyBvdmVyZmxvd2luZyBhIGdpdmVuIGNsaXBwaW5nIGJvdW5kYXJ5IG9uIGVhY2ggc2lkZS5cbiAqIC0gcG9zaXRpdmUgPSBvdmVyZmxvd2luZyB0aGUgYm91bmRhcnkgYnkgdGhhdCBudW1iZXIgb2YgcGl4ZWxzXG4gKiAtIG5lZ2F0aXZlID0gaG93IG1hbnkgcGl4ZWxzIGxlZnQgYmVmb3JlIGl0IHdpbGwgb3ZlcmZsb3dcbiAqIC0gMCA9IGxpZXMgZmx1c2ggd2l0aCB0aGUgYm91bmRhcnlcbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9kZXRlY3RPdmVyZmxvd1xuICovXG5hc3luYyBmdW5jdGlvbiBkZXRlY3RPdmVyZmxvdyhzdGF0ZSwgb3B0aW9ucykge1xuICB2YXIgX2F3YWl0JHBsYXRmb3JtJGlzRWxlO1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG4gIGNvbnN0IHtcbiAgICB4LFxuICAgIHksXG4gICAgcGxhdGZvcm0sXG4gICAgcmVjdHMsXG4gICAgZWxlbWVudHMsXG4gICAgc3RyYXRlZ3lcbiAgfSA9IHN0YXRlO1xuICBjb25zdCB7XG4gICAgYm91bmRhcnkgPSAnY2xpcHBpbmdBbmNlc3RvcnMnLFxuICAgIHJvb3RCb3VuZGFyeSA9ICd2aWV3cG9ydCcsXG4gICAgZWxlbWVudENvbnRleHQgPSAnZmxvYXRpbmcnLFxuICAgIGFsdEJvdW5kYXJ5ID0gZmFsc2UsXG4gICAgcGFkZGluZyA9IDBcbiAgfSA9IGV2YWx1YXRlKG9wdGlvbnMsIHN0YXRlKTtcbiAgY29uc3QgcGFkZGluZ09iamVjdCA9IGdldFBhZGRpbmdPYmplY3QocGFkZGluZyk7XG4gIGNvbnN0IGFsdENvbnRleHQgPSBlbGVtZW50Q29udGV4dCA9PT0gJ2Zsb2F0aW5nJyA/ICdyZWZlcmVuY2UnIDogJ2Zsb2F0aW5nJztcbiAgY29uc3QgZWxlbWVudCA9IGVsZW1lbnRzW2FsdEJvdW5kYXJ5ID8gYWx0Q29udGV4dCA6IGVsZW1lbnRDb250ZXh0XTtcbiAgY29uc3QgY2xpcHBpbmdDbGllbnRSZWN0ID0gcmVjdFRvQ2xpZW50UmVjdChhd2FpdCBwbGF0Zm9ybS5nZXRDbGlwcGluZ1JlY3Qoe1xuICAgIGVsZW1lbnQ6ICgoX2F3YWl0JHBsYXRmb3JtJGlzRWxlID0gYXdhaXQgKHBsYXRmb3JtLmlzRWxlbWVudCA9PSBudWxsID8gdm9pZCAwIDogcGxhdGZvcm0uaXNFbGVtZW50KGVsZW1lbnQpKSkgIT0gbnVsbCA/IF9hd2FpdCRwbGF0Zm9ybSRpc0VsZSA6IHRydWUpID8gZWxlbWVudCA6IGVsZW1lbnQuY29udGV4dEVsZW1lbnQgfHwgKGF3YWl0IChwbGF0Zm9ybS5nZXREb2N1bWVudEVsZW1lbnQgPT0gbnVsbCA/IHZvaWQgMCA6IHBsYXRmb3JtLmdldERvY3VtZW50RWxlbWVudChlbGVtZW50cy5mbG9hdGluZykpKSxcbiAgICBib3VuZGFyeSxcbiAgICByb290Qm91bmRhcnksXG4gICAgc3RyYXRlZ3lcbiAgfSkpO1xuICBjb25zdCByZWN0ID0gZWxlbWVudENvbnRleHQgPT09ICdmbG9hdGluZycgPyB7XG4gICAgeCxcbiAgICB5LFxuICAgIHdpZHRoOiByZWN0cy5mbG9hdGluZy53aWR0aCxcbiAgICBoZWlnaHQ6IHJlY3RzLmZsb2F0aW5nLmhlaWdodFxuICB9IDogcmVjdHMucmVmZXJlbmNlO1xuICBjb25zdCBvZmZzZXRQYXJlbnQgPSBhd2FpdCAocGxhdGZvcm0uZ2V0T2Zmc2V0UGFyZW50ID09IG51bGwgPyB2b2lkIDAgOiBwbGF0Zm9ybS5nZXRPZmZzZXRQYXJlbnQoZWxlbWVudHMuZmxvYXRpbmcpKTtcbiAgY29uc3Qgb2Zmc2V0U2NhbGUgPSAoYXdhaXQgKHBsYXRmb3JtLmlzRWxlbWVudCA9PSBudWxsID8gdm9pZCAwIDogcGxhdGZvcm0uaXNFbGVtZW50KG9mZnNldFBhcmVudCkpKSA/IChhd2FpdCAocGxhdGZvcm0uZ2V0U2NhbGUgPT0gbnVsbCA/IHZvaWQgMCA6IHBsYXRmb3JtLmdldFNjYWxlKG9mZnNldFBhcmVudCkpKSB8fCB7XG4gICAgeDogMSxcbiAgICB5OiAxXG4gIH0gOiB7XG4gICAgeDogMSxcbiAgICB5OiAxXG4gIH07XG4gIGNvbnN0IGVsZW1lbnRDbGllbnRSZWN0ID0gcmVjdFRvQ2xpZW50UmVjdChwbGF0Zm9ybS5jb252ZXJ0T2Zmc2V0UGFyZW50UmVsYXRpdmVSZWN0VG9WaWV3cG9ydFJlbGF0aXZlUmVjdCA/IGF3YWl0IHBsYXRmb3JtLmNvbnZlcnRPZmZzZXRQYXJlbnRSZWxhdGl2ZVJlY3RUb1ZpZXdwb3J0UmVsYXRpdmVSZWN0KHtcbiAgICBlbGVtZW50cyxcbiAgICByZWN0LFxuICAgIG9mZnNldFBhcmVudCxcbiAgICBzdHJhdGVneVxuICB9KSA6IHJlY3QpO1xuICByZXR1cm4ge1xuICAgIHRvcDogKGNsaXBwaW5nQ2xpZW50UmVjdC50b3AgLSBlbGVtZW50Q2xpZW50UmVjdC50b3AgKyBwYWRkaW5nT2JqZWN0LnRvcCkgLyBvZmZzZXRTY2FsZS55LFxuICAgIGJvdHRvbTogKGVsZW1lbnRDbGllbnRSZWN0LmJvdHRvbSAtIGNsaXBwaW5nQ2xpZW50UmVjdC5ib3R0b20gKyBwYWRkaW5nT2JqZWN0LmJvdHRvbSkgLyBvZmZzZXRTY2FsZS55LFxuICAgIGxlZnQ6IChjbGlwcGluZ0NsaWVudFJlY3QubGVmdCAtIGVsZW1lbnRDbGllbnRSZWN0LmxlZnQgKyBwYWRkaW5nT2JqZWN0LmxlZnQpIC8gb2Zmc2V0U2NhbGUueCxcbiAgICByaWdodDogKGVsZW1lbnRDbGllbnRSZWN0LnJpZ2h0IC0gY2xpcHBpbmdDbGllbnRSZWN0LnJpZ2h0ICsgcGFkZGluZ09iamVjdC5yaWdodCkgLyBvZmZzZXRTY2FsZS54XG4gIH07XG59XG5cbi8qKlxuICogUHJvdmlkZXMgZGF0YSB0byBwb3NpdGlvbiBhbiBpbm5lciBlbGVtZW50IG9mIHRoZSBmbG9hdGluZyBlbGVtZW50IHNvIHRoYXQgaXRcbiAqIGFwcGVhcnMgY2VudGVyZWQgdG8gdGhlIHJlZmVyZW5jZSBlbGVtZW50LlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL2Fycm93XG4gKi9cbmNvbnN0IGFycm93ID0gb3B0aW9ucyA9PiAoe1xuICBuYW1lOiAnYXJyb3cnLFxuICBvcHRpb25zLFxuICBhc3luYyBmbihzdGF0ZSkge1xuICAgIGNvbnN0IHtcbiAgICAgIHgsXG4gICAgICB5LFxuICAgICAgcGxhY2VtZW50LFxuICAgICAgcmVjdHMsXG4gICAgICBwbGF0Zm9ybSxcbiAgICAgIGVsZW1lbnRzLFxuICAgICAgbWlkZGxld2FyZURhdGFcbiAgICB9ID0gc3RhdGU7XG4gICAgLy8gU2luY2UgYGVsZW1lbnRgIGlzIHJlcXVpcmVkLCB3ZSBkb24ndCBQYXJ0aWFsPD4gdGhlIHR5cGUuXG4gICAgY29uc3Qge1xuICAgICAgZWxlbWVudCxcbiAgICAgIHBhZGRpbmcgPSAwXG4gICAgfSA9IGV2YWx1YXRlKG9wdGlvbnMsIHN0YXRlKSB8fCB7fTtcbiAgICBpZiAoZWxlbWVudCA9PSBudWxsKSB7XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuICAgIGNvbnN0IHBhZGRpbmdPYmplY3QgPSBnZXRQYWRkaW5nT2JqZWN0KHBhZGRpbmcpO1xuICAgIGNvbnN0IGNvb3JkcyA9IHtcbiAgICAgIHgsXG4gICAgICB5XG4gICAgfTtcbiAgICBjb25zdCBheGlzID0gZ2V0QWxpZ25tZW50QXhpcyhwbGFjZW1lbnQpO1xuICAgIGNvbnN0IGxlbmd0aCA9IGdldEF4aXNMZW5ndGgoYXhpcyk7XG4gICAgY29uc3QgYXJyb3dEaW1lbnNpb25zID0gYXdhaXQgcGxhdGZvcm0uZ2V0RGltZW5zaW9ucyhlbGVtZW50KTtcbiAgICBjb25zdCBpc1lBeGlzID0gYXhpcyA9PT0gJ3knO1xuICAgIGNvbnN0IG1pblByb3AgPSBpc1lBeGlzID8gJ3RvcCcgOiAnbGVmdCc7XG4gICAgY29uc3QgbWF4UHJvcCA9IGlzWUF4aXMgPyAnYm90dG9tJyA6ICdyaWdodCc7XG4gICAgY29uc3QgY2xpZW50UHJvcCA9IGlzWUF4aXMgPyAnY2xpZW50SGVpZ2h0JyA6ICdjbGllbnRXaWR0aCc7XG4gICAgY29uc3QgZW5kRGlmZiA9IHJlY3RzLnJlZmVyZW5jZVtsZW5ndGhdICsgcmVjdHMucmVmZXJlbmNlW2F4aXNdIC0gY29vcmRzW2F4aXNdIC0gcmVjdHMuZmxvYXRpbmdbbGVuZ3RoXTtcbiAgICBjb25zdCBzdGFydERpZmYgPSBjb29yZHNbYXhpc10gLSByZWN0cy5yZWZlcmVuY2VbYXhpc107XG4gICAgY29uc3QgYXJyb3dPZmZzZXRQYXJlbnQgPSBhd2FpdCAocGxhdGZvcm0uZ2V0T2Zmc2V0UGFyZW50ID09IG51bGwgPyB2b2lkIDAgOiBwbGF0Zm9ybS5nZXRPZmZzZXRQYXJlbnQoZWxlbWVudCkpO1xuICAgIGxldCBjbGllbnRTaXplID0gYXJyb3dPZmZzZXRQYXJlbnQgPyBhcnJvd09mZnNldFBhcmVudFtjbGllbnRQcm9wXSA6IDA7XG5cbiAgICAvLyBET00gcGxhdGZvcm0gY2FuIHJldHVybiBgd2luZG93YCBhcyB0aGUgYG9mZnNldFBhcmVudGAuXG4gICAgaWYgKCFjbGllbnRTaXplIHx8ICEoYXdhaXQgKHBsYXRmb3JtLmlzRWxlbWVudCA9PSBudWxsID8gdm9pZCAwIDogcGxhdGZvcm0uaXNFbGVtZW50KGFycm93T2Zmc2V0UGFyZW50KSkpKSB7XG4gICAgICBjbGllbnRTaXplID0gZWxlbWVudHMuZmxvYXRpbmdbY2xpZW50UHJvcF0gfHwgcmVjdHMuZmxvYXRpbmdbbGVuZ3RoXTtcbiAgICB9XG4gICAgY29uc3QgY2VudGVyVG9SZWZlcmVuY2UgPSBlbmREaWZmIC8gMiAtIHN0YXJ0RGlmZiAvIDI7XG5cbiAgICAvLyBJZiB0aGUgcGFkZGluZyBpcyBsYXJnZSBlbm91Z2ggdGhhdCBpdCBjYXVzZXMgdGhlIGFycm93IHRvIG5vIGxvbmdlciBiZVxuICAgIC8vIGNlbnRlcmVkLCBtb2RpZnkgdGhlIHBhZGRpbmcgc28gdGhhdCBpdCBpcyBjZW50ZXJlZC5cbiAgICBjb25zdCBsYXJnZXN0UG9zc2libGVQYWRkaW5nID0gY2xpZW50U2l6ZSAvIDIgLSBhcnJvd0RpbWVuc2lvbnNbbGVuZ3RoXSAvIDIgLSAxO1xuICAgIGNvbnN0IG1pblBhZGRpbmcgPSBtaW4ocGFkZGluZ09iamVjdFttaW5Qcm9wXSwgbGFyZ2VzdFBvc3NpYmxlUGFkZGluZyk7XG4gICAgY29uc3QgbWF4UGFkZGluZyA9IG1pbihwYWRkaW5nT2JqZWN0W21heFByb3BdLCBsYXJnZXN0UG9zc2libGVQYWRkaW5nKTtcblxuICAgIC8vIE1ha2Ugc3VyZSB0aGUgYXJyb3cgZG9lc24ndCBvdmVyZmxvdyB0aGUgZmxvYXRpbmcgZWxlbWVudCBpZiB0aGUgY2VudGVyXG4gICAgLy8gcG9pbnQgaXMgb3V0c2lkZSB0aGUgZmxvYXRpbmcgZWxlbWVudCdzIGJvdW5kcy5cbiAgICBjb25zdCBtaW4kMSA9IG1pblBhZGRpbmc7XG4gICAgY29uc3QgbWF4ID0gY2xpZW50U2l6ZSAtIGFycm93RGltZW5zaW9uc1tsZW5ndGhdIC0gbWF4UGFkZGluZztcbiAgICBjb25zdCBjZW50ZXIgPSBjbGllbnRTaXplIC8gMiAtIGFycm93RGltZW5zaW9uc1tsZW5ndGhdIC8gMiArIGNlbnRlclRvUmVmZXJlbmNlO1xuICAgIGNvbnN0IG9mZnNldCA9IGNsYW1wKG1pbiQxLCBjZW50ZXIsIG1heCk7XG5cbiAgICAvLyBJZiB0aGUgcmVmZXJlbmNlIGlzIHNtYWxsIGVub3VnaCB0aGF0IHRoZSBhcnJvdydzIHBhZGRpbmcgY2F1c2VzIGl0IHRvXG4gICAgLy8gdG8gcG9pbnQgdG8gbm90aGluZyBmb3IgYW4gYWxpZ25lZCBwbGFjZW1lbnQsIGFkanVzdCB0aGUgb2Zmc2V0IG9mIHRoZVxuICAgIC8vIGZsb2F0aW5nIGVsZW1lbnQgaXRzZWxmLiBUbyBlbnN1cmUgYHNoaWZ0KClgIGNvbnRpbnVlcyB0byB0YWtlIGFjdGlvbixcbiAgICAvLyBhIHNpbmdsZSByZXNldCBpcyBwZXJmb3JtZWQgd2hlbiB0aGlzIGlzIHRydWUuXG4gICAgY29uc3Qgc2hvdWxkQWRkT2Zmc2V0ID0gIW1pZGRsZXdhcmVEYXRhLmFycm93ICYmIGdldEFsaWdubWVudChwbGFjZW1lbnQpICE9IG51bGwgJiYgY2VudGVyICE9PSBvZmZzZXQgJiYgcmVjdHMucmVmZXJlbmNlW2xlbmd0aF0gLyAyIC0gKGNlbnRlciA8IG1pbiQxID8gbWluUGFkZGluZyA6IG1heFBhZGRpbmcpIC0gYXJyb3dEaW1lbnNpb25zW2xlbmd0aF0gLyAyIDwgMDtcbiAgICBjb25zdCBhbGlnbm1lbnRPZmZzZXQgPSBzaG91bGRBZGRPZmZzZXQgPyBjZW50ZXIgPCBtaW4kMSA/IGNlbnRlciAtIG1pbiQxIDogY2VudGVyIC0gbWF4IDogMDtcbiAgICByZXR1cm4ge1xuICAgICAgW2F4aXNdOiBjb29yZHNbYXhpc10gKyBhbGlnbm1lbnRPZmZzZXQsXG4gICAgICBkYXRhOiB7XG4gICAgICAgIFtheGlzXTogb2Zmc2V0LFxuICAgICAgICBjZW50ZXJPZmZzZXQ6IGNlbnRlciAtIG9mZnNldCAtIGFsaWdubWVudE9mZnNldCxcbiAgICAgICAgLi4uKHNob3VsZEFkZE9mZnNldCAmJiB7XG4gICAgICAgICAgYWxpZ25tZW50T2Zmc2V0XG4gICAgICAgIH0pXG4gICAgICB9LFxuICAgICAgcmVzZXQ6IHNob3VsZEFkZE9mZnNldFxuICAgIH07XG4gIH1cbn0pO1xuXG5mdW5jdGlvbiBnZXRQbGFjZW1lbnRMaXN0KGFsaWdubWVudCwgYXV0b0FsaWdubWVudCwgYWxsb3dlZFBsYWNlbWVudHMpIHtcbiAgY29uc3QgYWxsb3dlZFBsYWNlbWVudHNTb3J0ZWRCeUFsaWdubWVudCA9IGFsaWdubWVudCA/IFsuLi5hbGxvd2VkUGxhY2VtZW50cy5maWx0ZXIocGxhY2VtZW50ID0+IGdldEFsaWdubWVudChwbGFjZW1lbnQpID09PSBhbGlnbm1lbnQpLCAuLi5hbGxvd2VkUGxhY2VtZW50cy5maWx0ZXIocGxhY2VtZW50ID0+IGdldEFsaWdubWVudChwbGFjZW1lbnQpICE9PSBhbGlnbm1lbnQpXSA6IGFsbG93ZWRQbGFjZW1lbnRzLmZpbHRlcihwbGFjZW1lbnQgPT4gZ2V0U2lkZShwbGFjZW1lbnQpID09PSBwbGFjZW1lbnQpO1xuICByZXR1cm4gYWxsb3dlZFBsYWNlbWVudHNTb3J0ZWRCeUFsaWdubWVudC5maWx0ZXIocGxhY2VtZW50ID0+IHtcbiAgICBpZiAoYWxpZ25tZW50KSB7XG4gICAgICByZXR1cm4gZ2V0QWxpZ25tZW50KHBsYWNlbWVudCkgPT09IGFsaWdubWVudCB8fCAoYXV0b0FsaWdubWVudCA/IGdldE9wcG9zaXRlQWxpZ25tZW50UGxhY2VtZW50KHBsYWNlbWVudCkgIT09IHBsYWNlbWVudCA6IGZhbHNlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH0pO1xufVxuLyoqXG4gKiBPcHRpbWl6ZXMgdGhlIHZpc2liaWxpdHkgb2YgdGhlIGZsb2F0aW5nIGVsZW1lbnQgYnkgY2hvb3NpbmcgdGhlIHBsYWNlbWVudFxuICogdGhhdCBoYXMgdGhlIG1vc3Qgc3BhY2UgYXZhaWxhYmxlIGF1dG9tYXRpY2FsbHksIHdpdGhvdXQgbmVlZGluZyB0byBzcGVjaWZ5IGFcbiAqIHByZWZlcnJlZCBwbGFjZW1lbnQuIEFsdGVybmF0aXZlIHRvIGBmbGlwYC5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9hdXRvUGxhY2VtZW50XG4gKi9cbmNvbnN0IGF1dG9QbGFjZW1lbnQgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG4gIHJldHVybiB7XG4gICAgbmFtZTogJ2F1dG9QbGFjZW1lbnQnLFxuICAgIG9wdGlvbnMsXG4gICAgYXN5bmMgZm4oc3RhdGUpIHtcbiAgICAgIHZhciBfbWlkZGxld2FyZURhdGEkYXV0b1AsIF9taWRkbGV3YXJlRGF0YSRhdXRvUDIsIF9wbGFjZW1lbnRzVGhhdEZpdE9uRTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgcmVjdHMsXG4gICAgICAgIG1pZGRsZXdhcmVEYXRhLFxuICAgICAgICBwbGFjZW1lbnQsXG4gICAgICAgIHBsYXRmb3JtLFxuICAgICAgICBlbGVtZW50c1xuICAgICAgfSA9IHN0YXRlO1xuICAgICAgY29uc3Qge1xuICAgICAgICBjcm9zc0F4aXMgPSBmYWxzZSxcbiAgICAgICAgYWxpZ25tZW50LFxuICAgICAgICBhbGxvd2VkUGxhY2VtZW50cyA9IHBsYWNlbWVudHMsXG4gICAgICAgIGF1dG9BbGlnbm1lbnQgPSB0cnVlLFxuICAgICAgICAuLi5kZXRlY3RPdmVyZmxvd09wdGlvbnNcbiAgICAgIH0gPSBldmFsdWF0ZShvcHRpb25zLCBzdGF0ZSk7XG4gICAgICBjb25zdCBwbGFjZW1lbnRzJDEgPSBhbGlnbm1lbnQgIT09IHVuZGVmaW5lZCB8fCBhbGxvd2VkUGxhY2VtZW50cyA9PT0gcGxhY2VtZW50cyA/IGdldFBsYWNlbWVudExpc3QoYWxpZ25tZW50IHx8IG51bGwsIGF1dG9BbGlnbm1lbnQsIGFsbG93ZWRQbGFjZW1lbnRzKSA6IGFsbG93ZWRQbGFjZW1lbnRzO1xuICAgICAgY29uc3Qgb3ZlcmZsb3cgPSBhd2FpdCBkZXRlY3RPdmVyZmxvdyhzdGF0ZSwgZGV0ZWN0T3ZlcmZsb3dPcHRpb25zKTtcbiAgICAgIGNvbnN0IGN1cnJlbnRJbmRleCA9ICgoX21pZGRsZXdhcmVEYXRhJGF1dG9QID0gbWlkZGxld2FyZURhdGEuYXV0b1BsYWNlbWVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9taWRkbGV3YXJlRGF0YSRhdXRvUC5pbmRleCkgfHwgMDtcbiAgICAgIGNvbnN0IGN1cnJlbnRQbGFjZW1lbnQgPSBwbGFjZW1lbnRzJDFbY3VycmVudEluZGV4XTtcbiAgICAgIGlmIChjdXJyZW50UGxhY2VtZW50ID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgfVxuICAgICAgY29uc3QgYWxpZ25tZW50U2lkZXMgPSBnZXRBbGlnbm1lbnRTaWRlcyhjdXJyZW50UGxhY2VtZW50LCByZWN0cywgYXdhaXQgKHBsYXRmb3JtLmlzUlRMID09IG51bGwgPyB2b2lkIDAgOiBwbGF0Zm9ybS5pc1JUTChlbGVtZW50cy5mbG9hdGluZykpKTtcblxuICAgICAgLy8gTWFrZSBgY29tcHV0ZUNvb3Jkc2Agc3RhcnQgZnJvbSB0aGUgcmlnaHQgcGxhY2UuXG4gICAgICBpZiAocGxhY2VtZW50ICE9PSBjdXJyZW50UGxhY2VtZW50KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcmVzZXQ6IHtcbiAgICAgICAgICAgIHBsYWNlbWVudDogcGxhY2VtZW50cyQxWzBdXG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgY29uc3QgY3VycmVudE92ZXJmbG93cyA9IFtvdmVyZmxvd1tnZXRTaWRlKGN1cnJlbnRQbGFjZW1lbnQpXSwgb3ZlcmZsb3dbYWxpZ25tZW50U2lkZXNbMF1dLCBvdmVyZmxvd1thbGlnbm1lbnRTaWRlc1sxXV1dO1xuICAgICAgY29uc3QgYWxsT3ZlcmZsb3dzID0gWy4uLigoKF9taWRkbGV3YXJlRGF0YSRhdXRvUDIgPSBtaWRkbGV3YXJlRGF0YS5hdXRvUGxhY2VtZW50KSA9PSBudWxsID8gdm9pZCAwIDogX21pZGRsZXdhcmVEYXRhJGF1dG9QMi5vdmVyZmxvd3MpIHx8IFtdKSwge1xuICAgICAgICBwbGFjZW1lbnQ6IGN1cnJlbnRQbGFjZW1lbnQsXG4gICAgICAgIG92ZXJmbG93czogY3VycmVudE92ZXJmbG93c1xuICAgICAgfV07XG4gICAgICBjb25zdCBuZXh0UGxhY2VtZW50ID0gcGxhY2VtZW50cyQxW2N1cnJlbnRJbmRleCArIDFdO1xuXG4gICAgICAvLyBUaGVyZSBhcmUgbW9yZSBwbGFjZW1lbnRzIHRvIGNoZWNrLlxuICAgICAgaWYgKG5leHRQbGFjZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICBpbmRleDogY3VycmVudEluZGV4ICsgMSxcbiAgICAgICAgICAgIG92ZXJmbG93czogYWxsT3ZlcmZsb3dzXG4gICAgICAgICAgfSxcbiAgICAgICAgICByZXNldDoge1xuICAgICAgICAgICAgcGxhY2VtZW50OiBuZXh0UGxhY2VtZW50XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgY29uc3QgcGxhY2VtZW50c1NvcnRlZEJ5TW9zdFNwYWNlID0gYWxsT3ZlcmZsb3dzLm1hcChkID0+IHtcbiAgICAgICAgY29uc3QgYWxpZ25tZW50ID0gZ2V0QWxpZ25tZW50KGQucGxhY2VtZW50KTtcbiAgICAgICAgcmV0dXJuIFtkLnBsYWNlbWVudCwgYWxpZ25tZW50ICYmIGNyb3NzQXhpcyA/XG4gICAgICAgIC8vIENoZWNrIGFsb25nIHRoZSBtYWluQXhpcyBhbmQgbWFpbiBjcm9zc0F4aXMgc2lkZS5cbiAgICAgICAgZC5vdmVyZmxvd3Muc2xpY2UoMCwgMikucmVkdWNlKChhY2MsIHYpID0+IGFjYyArIHYsIDApIDpcbiAgICAgICAgLy8gQ2hlY2sgb25seSB0aGUgbWFpbkF4aXMuXG4gICAgICAgIGQub3ZlcmZsb3dzWzBdLCBkLm92ZXJmbG93c107XG4gICAgICB9KS5zb3J0KChhLCBiKSA9PiBhWzFdIC0gYlsxXSk7XG4gICAgICBjb25zdCBwbGFjZW1lbnRzVGhhdEZpdE9uRWFjaFNpZGUgPSBwbGFjZW1lbnRzU29ydGVkQnlNb3N0U3BhY2UuZmlsdGVyKGQgPT4gZFsyXS5zbGljZSgwLFxuICAgICAgLy8gQWxpZ25lZCBwbGFjZW1lbnRzIHNob3VsZCBub3QgY2hlY2sgdGhlaXIgb3Bwb3NpdGUgY3Jvc3NBeGlzXG4gICAgICAvLyBzaWRlLlxuICAgICAgZ2V0QWxpZ25tZW50KGRbMF0pID8gMiA6IDMpLmV2ZXJ5KHYgPT4gdiA8PSAwKSk7XG4gICAgICBjb25zdCByZXNldFBsYWNlbWVudCA9ICgoX3BsYWNlbWVudHNUaGF0Rml0T25FID0gcGxhY2VtZW50c1RoYXRGaXRPbkVhY2hTaWRlWzBdKSA9PSBudWxsID8gdm9pZCAwIDogX3BsYWNlbWVudHNUaGF0Rml0T25FWzBdKSB8fCBwbGFjZW1lbnRzU29ydGVkQnlNb3N0U3BhY2VbMF1bMF07XG4gICAgICBpZiAocmVzZXRQbGFjZW1lbnQgIT09IHBsYWNlbWVudCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgIGluZGV4OiBjdXJyZW50SW5kZXggKyAxLFxuICAgICAgICAgICAgb3ZlcmZsb3dzOiBhbGxPdmVyZmxvd3NcbiAgICAgICAgICB9LFxuICAgICAgICAgIHJlc2V0OiB7XG4gICAgICAgICAgICBwbGFjZW1lbnQ6IHJlc2V0UGxhY2VtZW50XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgfTtcbn07XG5cbi8qKlxuICogT3B0aW1pemVzIHRoZSB2aXNpYmlsaXR5IG9mIHRoZSBmbG9hdGluZyBlbGVtZW50IGJ5IGZsaXBwaW5nIHRoZSBgcGxhY2VtZW50YFxuICogaW4gb3JkZXIgdG8ga2VlcCBpdCBpbiB2aWV3IHdoZW4gdGhlIHByZWZlcnJlZCBwbGFjZW1lbnQocykgd2lsbCBvdmVyZmxvdyB0aGVcbiAqIGNsaXBwaW5nIGJvdW5kYXJ5LiBBbHRlcm5hdGl2ZSB0byBgYXV0b1BsYWNlbWVudGAuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvZmxpcFxuICovXG5jb25zdCBmbGlwID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuICByZXR1cm4ge1xuICAgIG5hbWU6ICdmbGlwJyxcbiAgICBvcHRpb25zLFxuICAgIGFzeW5jIGZuKHN0YXRlKSB7XG4gICAgICB2YXIgX21pZGRsZXdhcmVEYXRhJGFycm93LCBfbWlkZGxld2FyZURhdGEkZmxpcDtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgcGxhY2VtZW50LFxuICAgICAgICBtaWRkbGV3YXJlRGF0YSxcbiAgICAgICAgcmVjdHMsXG4gICAgICAgIGluaXRpYWxQbGFjZW1lbnQsXG4gICAgICAgIHBsYXRmb3JtLFxuICAgICAgICBlbGVtZW50c1xuICAgICAgfSA9IHN0YXRlO1xuICAgICAgY29uc3Qge1xuICAgICAgICBtYWluQXhpczogY2hlY2tNYWluQXhpcyA9IHRydWUsXG4gICAgICAgIGNyb3NzQXhpczogY2hlY2tDcm9zc0F4aXMgPSB0cnVlLFxuICAgICAgICBmYWxsYmFja1BsYWNlbWVudHM6IHNwZWNpZmllZEZhbGxiYWNrUGxhY2VtZW50cyxcbiAgICAgICAgZmFsbGJhY2tTdHJhdGVneSA9ICdiZXN0Rml0JyxcbiAgICAgICAgZmFsbGJhY2tBeGlzU2lkZURpcmVjdGlvbiA9ICdub25lJyxcbiAgICAgICAgZmxpcEFsaWdubWVudCA9IHRydWUsXG4gICAgICAgIC4uLmRldGVjdE92ZXJmbG93T3B0aW9uc1xuICAgICAgfSA9IGV2YWx1YXRlKG9wdGlvbnMsIHN0YXRlKTtcblxuICAgICAgLy8gSWYgYSByZXNldCBieSB0aGUgYXJyb3cgd2FzIGNhdXNlZCBkdWUgdG8gYW4gYWxpZ25tZW50IG9mZnNldCBiZWluZ1xuICAgICAgLy8gYWRkZWQsIHdlIHNob3VsZCBza2lwIGFueSBsb2dpYyBub3cgc2luY2UgYGZsaXAoKWAgaGFzIGFscmVhZHkgZG9uZSBpdHNcbiAgICAgIC8vIHdvcmsuXG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmxvYXRpbmctdWkvZmxvYXRpbmctdWkvaXNzdWVzLzI1NDkjaXNzdWVjb21tZW50LTE3MTk2MDE2NDNcbiAgICAgIGlmICgoX21pZGRsZXdhcmVEYXRhJGFycm93ID0gbWlkZGxld2FyZURhdGEuYXJyb3cpICE9IG51bGwgJiYgX21pZGRsZXdhcmVEYXRhJGFycm93LmFsaWdubWVudE9mZnNldCkge1xuICAgICAgICByZXR1cm4ge307XG4gICAgICB9XG4gICAgICBjb25zdCBzaWRlID0gZ2V0U2lkZShwbGFjZW1lbnQpO1xuICAgICAgY29uc3QgaW5pdGlhbFNpZGVBeGlzID0gZ2V0U2lkZUF4aXMoaW5pdGlhbFBsYWNlbWVudCk7XG4gICAgICBjb25zdCBpc0Jhc2VQbGFjZW1lbnQgPSBnZXRTaWRlKGluaXRpYWxQbGFjZW1lbnQpID09PSBpbml0aWFsUGxhY2VtZW50O1xuICAgICAgY29uc3QgcnRsID0gYXdhaXQgKHBsYXRmb3JtLmlzUlRMID09IG51bGwgPyB2b2lkIDAgOiBwbGF0Zm9ybS5pc1JUTChlbGVtZW50cy5mbG9hdGluZykpO1xuICAgICAgY29uc3QgZmFsbGJhY2tQbGFjZW1lbnRzID0gc3BlY2lmaWVkRmFsbGJhY2tQbGFjZW1lbnRzIHx8IChpc0Jhc2VQbGFjZW1lbnQgfHwgIWZsaXBBbGlnbm1lbnQgPyBbZ2V0T3Bwb3NpdGVQbGFjZW1lbnQoaW5pdGlhbFBsYWNlbWVudCldIDogZ2V0RXhwYW5kZWRQbGFjZW1lbnRzKGluaXRpYWxQbGFjZW1lbnQpKTtcbiAgICAgIGNvbnN0IGhhc0ZhbGxiYWNrQXhpc1NpZGVEaXJlY3Rpb24gPSBmYWxsYmFja0F4aXNTaWRlRGlyZWN0aW9uICE9PSAnbm9uZSc7XG4gICAgICBpZiAoIXNwZWNpZmllZEZhbGxiYWNrUGxhY2VtZW50cyAmJiBoYXNGYWxsYmFja0F4aXNTaWRlRGlyZWN0aW9uKSB7XG4gICAgICAgIGZhbGxiYWNrUGxhY2VtZW50cy5wdXNoKC4uLmdldE9wcG9zaXRlQXhpc1BsYWNlbWVudHMoaW5pdGlhbFBsYWNlbWVudCwgZmxpcEFsaWdubWVudCwgZmFsbGJhY2tBeGlzU2lkZURpcmVjdGlvbiwgcnRsKSk7XG4gICAgICB9XG4gICAgICBjb25zdCBwbGFjZW1lbnRzID0gW2luaXRpYWxQbGFjZW1lbnQsIC4uLmZhbGxiYWNrUGxhY2VtZW50c107XG4gICAgICBjb25zdCBvdmVyZmxvdyA9IGF3YWl0IGRldGVjdE92ZXJmbG93KHN0YXRlLCBkZXRlY3RPdmVyZmxvd09wdGlvbnMpO1xuICAgICAgY29uc3Qgb3ZlcmZsb3dzID0gW107XG4gICAgICBsZXQgb3ZlcmZsb3dzRGF0YSA9ICgoX21pZGRsZXdhcmVEYXRhJGZsaXAgPSBtaWRkbGV3YXJlRGF0YS5mbGlwKSA9PSBudWxsID8gdm9pZCAwIDogX21pZGRsZXdhcmVEYXRhJGZsaXAub3ZlcmZsb3dzKSB8fCBbXTtcbiAgICAgIGlmIChjaGVja01haW5BeGlzKSB7XG4gICAgICAgIG92ZXJmbG93cy5wdXNoKG92ZXJmbG93W3NpZGVdKTtcbiAgICAgIH1cbiAgICAgIGlmIChjaGVja0Nyb3NzQXhpcykge1xuICAgICAgICBjb25zdCBzaWRlcyA9IGdldEFsaWdubWVudFNpZGVzKHBsYWNlbWVudCwgcmVjdHMsIHJ0bCk7XG4gICAgICAgIG92ZXJmbG93cy5wdXNoKG92ZXJmbG93W3NpZGVzWzBdXSwgb3ZlcmZsb3dbc2lkZXNbMV1dKTtcbiAgICAgIH1cbiAgICAgIG92ZXJmbG93c0RhdGEgPSBbLi4ub3ZlcmZsb3dzRGF0YSwge1xuICAgICAgICBwbGFjZW1lbnQsXG4gICAgICAgIG92ZXJmbG93c1xuICAgICAgfV07XG5cbiAgICAgIC8vIE9uZSBvciBtb3JlIHNpZGVzIGlzIG92ZXJmbG93aW5nLlxuICAgICAgaWYgKCFvdmVyZmxvd3MuZXZlcnkoc2lkZSA9PiBzaWRlIDw9IDApKSB7XG4gICAgICAgIHZhciBfbWlkZGxld2FyZURhdGEkZmxpcDIsIF9vdmVyZmxvd3NEYXRhJGZpbHRlcjtcbiAgICAgICAgY29uc3QgbmV4dEluZGV4ID0gKCgoX21pZGRsZXdhcmVEYXRhJGZsaXAyID0gbWlkZGxld2FyZURhdGEuZmxpcCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9taWRkbGV3YXJlRGF0YSRmbGlwMi5pbmRleCkgfHwgMCkgKyAxO1xuICAgICAgICBjb25zdCBuZXh0UGxhY2VtZW50ID0gcGxhY2VtZW50c1tuZXh0SW5kZXhdO1xuICAgICAgICBpZiAobmV4dFBsYWNlbWVudCkge1xuICAgICAgICAgIC8vIFRyeSBuZXh0IHBsYWNlbWVudCBhbmQgcmUtcnVuIHRoZSBsaWZlY3ljbGUuXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgaW5kZXg6IG5leHRJbmRleCxcbiAgICAgICAgICAgICAgb3ZlcmZsb3dzOiBvdmVyZmxvd3NEYXRhXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmVzZXQ6IHtcbiAgICAgICAgICAgICAgcGxhY2VtZW50OiBuZXh0UGxhY2VtZW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEZpcnN0LCBmaW5kIHRoZSBjYW5kaWRhdGVzIHRoYXQgZml0IG9uIHRoZSBtYWluQXhpcyBzaWRlIG9mIG92ZXJmbG93LFxuICAgICAgICAvLyB0aGVuIGZpbmQgdGhlIHBsYWNlbWVudCB0aGF0IGZpdHMgdGhlIGJlc3Qgb24gdGhlIG1haW4gY3Jvc3NBeGlzIHNpZGUuXG4gICAgICAgIGxldCByZXNldFBsYWNlbWVudCA9IChfb3ZlcmZsb3dzRGF0YSRmaWx0ZXIgPSBvdmVyZmxvd3NEYXRhLmZpbHRlcihkID0+IGQub3ZlcmZsb3dzWzBdIDw9IDApLnNvcnQoKGEsIGIpID0+IGEub3ZlcmZsb3dzWzFdIC0gYi5vdmVyZmxvd3NbMV0pWzBdKSA9PSBudWxsID8gdm9pZCAwIDogX292ZXJmbG93c0RhdGEkZmlsdGVyLnBsYWNlbWVudDtcblxuICAgICAgICAvLyBPdGhlcndpc2UgZmFsbGJhY2suXG4gICAgICAgIGlmICghcmVzZXRQbGFjZW1lbnQpIHtcbiAgICAgICAgICBzd2l0Y2ggKGZhbGxiYWNrU3RyYXRlZ3kpIHtcbiAgICAgICAgICAgIGNhc2UgJ2Jlc3RGaXQnOlxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdmFyIF9vdmVyZmxvd3NEYXRhJGZpbHRlcjI7XG4gICAgICAgICAgICAgICAgY29uc3QgcGxhY2VtZW50ID0gKF9vdmVyZmxvd3NEYXRhJGZpbHRlcjIgPSBvdmVyZmxvd3NEYXRhLmZpbHRlcihkID0+IHtcbiAgICAgICAgICAgICAgICAgIGlmIChoYXNGYWxsYmFja0F4aXNTaWRlRGlyZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRTaWRlQXhpcyA9IGdldFNpZGVBeGlzKGQucGxhY2VtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnRTaWRlQXhpcyA9PT0gaW5pdGlhbFNpZGVBeGlzIHx8XG4gICAgICAgICAgICAgICAgICAgIC8vIENyZWF0ZSBhIGJpYXMgdG8gdGhlIGB5YCBzaWRlIGF4aXMgZHVlIHRvIGhvcml6b250YWxcbiAgICAgICAgICAgICAgICAgICAgLy8gcmVhZGluZyBkaXJlY3Rpb25zIGZhdm9yaW5nIGdyZWF0ZXIgd2lkdGguXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRTaWRlQXhpcyA9PT0gJ3knO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfSkubWFwKGQgPT4gW2QucGxhY2VtZW50LCBkLm92ZXJmbG93cy5maWx0ZXIob3ZlcmZsb3cgPT4gb3ZlcmZsb3cgPiAwKS5yZWR1Y2UoKGFjYywgb3ZlcmZsb3cpID0+IGFjYyArIG92ZXJmbG93LCAwKV0pLnNvcnQoKGEsIGIpID0+IGFbMV0gLSBiWzFdKVswXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9vdmVyZmxvd3NEYXRhJGZpbHRlcjJbMF07XG4gICAgICAgICAgICAgICAgaWYgKHBsYWNlbWVudCkge1xuICAgICAgICAgICAgICAgICAgcmVzZXRQbGFjZW1lbnQgPSBwbGFjZW1lbnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICdpbml0aWFsUGxhY2VtZW50JzpcbiAgICAgICAgICAgICAgcmVzZXRQbGFjZW1lbnQgPSBpbml0aWFsUGxhY2VtZW50O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBsYWNlbWVudCAhPT0gcmVzZXRQbGFjZW1lbnQpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmVzZXQ6IHtcbiAgICAgICAgICAgICAgcGxhY2VtZW50OiByZXNldFBsYWNlbWVudFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gIH07XG59O1xuXG5mdW5jdGlvbiBnZXRTaWRlT2Zmc2V0cyhvdmVyZmxvdywgcmVjdCkge1xuICByZXR1cm4ge1xuICAgIHRvcDogb3ZlcmZsb3cudG9wIC0gcmVjdC5oZWlnaHQsXG4gICAgcmlnaHQ6IG92ZXJmbG93LnJpZ2h0IC0gcmVjdC53aWR0aCxcbiAgICBib3R0b206IG92ZXJmbG93LmJvdHRvbSAtIHJlY3QuaGVpZ2h0LFxuICAgIGxlZnQ6IG92ZXJmbG93LmxlZnQgLSByZWN0LndpZHRoXG4gIH07XG59XG5mdW5jdGlvbiBpc0FueVNpZGVGdWxseUNsaXBwZWQob3ZlcmZsb3cpIHtcbiAgcmV0dXJuIHNpZGVzLnNvbWUoc2lkZSA9PiBvdmVyZmxvd1tzaWRlXSA+PSAwKTtcbn1cbi8qKlxuICogUHJvdmlkZXMgZGF0YSB0byBoaWRlIHRoZSBmbG9hdGluZyBlbGVtZW50IGluIGFwcGxpY2FibGUgc2l0dWF0aW9ucywgc3VjaCBhc1xuICogd2hlbiBpdCBpcyBub3QgaW4gdGhlIHNhbWUgY2xpcHBpbmcgY29udGV4dCBhcyB0aGUgcmVmZXJlbmNlIGVsZW1lbnQuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvaGlkZVxuICovXG5jb25zdCBoaWRlID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuICByZXR1cm4ge1xuICAgIG5hbWU6ICdoaWRlJyxcbiAgICBvcHRpb25zLFxuICAgIGFzeW5jIGZuKHN0YXRlKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHJlY3RzXG4gICAgICB9ID0gc3RhdGU7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHN0cmF0ZWd5ID0gJ3JlZmVyZW5jZUhpZGRlbicsXG4gICAgICAgIC4uLmRldGVjdE92ZXJmbG93T3B0aW9uc1xuICAgICAgfSA9IGV2YWx1YXRlKG9wdGlvbnMsIHN0YXRlKTtcbiAgICAgIHN3aXRjaCAoc3RyYXRlZ3kpIHtcbiAgICAgICAgY2FzZSAncmVmZXJlbmNlSGlkZGVuJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBjb25zdCBvdmVyZmxvdyA9IGF3YWl0IGRldGVjdE92ZXJmbG93KHN0YXRlLCB7XG4gICAgICAgICAgICAgIC4uLmRldGVjdE92ZXJmbG93T3B0aW9ucyxcbiAgICAgICAgICAgICAgZWxlbWVudENvbnRleHQ6ICdyZWZlcmVuY2UnXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IG9mZnNldHMgPSBnZXRTaWRlT2Zmc2V0cyhvdmVyZmxvdywgcmVjdHMucmVmZXJlbmNlKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICByZWZlcmVuY2VIaWRkZW5PZmZzZXRzOiBvZmZzZXRzLFxuICAgICAgICAgICAgICAgIHJlZmVyZW5jZUhpZGRlbjogaXNBbnlTaWRlRnVsbHlDbGlwcGVkKG9mZnNldHMpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICBjYXNlICdlc2NhcGVkJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBjb25zdCBvdmVyZmxvdyA9IGF3YWl0IGRldGVjdE92ZXJmbG93KHN0YXRlLCB7XG4gICAgICAgICAgICAgIC4uLmRldGVjdE92ZXJmbG93T3B0aW9ucyxcbiAgICAgICAgICAgICAgYWx0Qm91bmRhcnk6IHRydWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3Qgb2Zmc2V0cyA9IGdldFNpZGVPZmZzZXRzKG92ZXJmbG93LCByZWN0cy5mbG9hdGluZyk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgZXNjYXBlZE9mZnNldHM6IG9mZnNldHMsXG4gICAgICAgICAgICAgICAgZXNjYXBlZDogaXNBbnlTaWRlRnVsbHlDbGlwcGVkKG9mZnNldHMpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiB7fTtcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xufTtcblxuZnVuY3Rpb24gZ2V0Qm91bmRpbmdSZWN0KHJlY3RzKSB7XG4gIGNvbnN0IG1pblggPSBtaW4oLi4ucmVjdHMubWFwKHJlY3QgPT4gcmVjdC5sZWZ0KSk7XG4gIGNvbnN0IG1pblkgPSBtaW4oLi4ucmVjdHMubWFwKHJlY3QgPT4gcmVjdC50b3ApKTtcbiAgY29uc3QgbWF4WCA9IG1heCguLi5yZWN0cy5tYXAocmVjdCA9PiByZWN0LnJpZ2h0KSk7XG4gIGNvbnN0IG1heFkgPSBtYXgoLi4ucmVjdHMubWFwKHJlY3QgPT4gcmVjdC5ib3R0b20pKTtcbiAgcmV0dXJuIHtcbiAgICB4OiBtaW5YLFxuICAgIHk6IG1pblksXG4gICAgd2lkdGg6IG1heFggLSBtaW5YLFxuICAgIGhlaWdodDogbWF4WSAtIG1pbllcbiAgfTtcbn1cbmZ1bmN0aW9uIGdldFJlY3RzQnlMaW5lKHJlY3RzKSB7XG4gIGNvbnN0IHNvcnRlZFJlY3RzID0gcmVjdHMuc2xpY2UoKS5zb3J0KChhLCBiKSA9PiBhLnkgLSBiLnkpO1xuICBjb25zdCBncm91cHMgPSBbXTtcbiAgbGV0IHByZXZSZWN0ID0gbnVsbDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzb3J0ZWRSZWN0cy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHJlY3QgPSBzb3J0ZWRSZWN0c1tpXTtcbiAgICBpZiAoIXByZXZSZWN0IHx8IHJlY3QueSAtIHByZXZSZWN0LnkgPiBwcmV2UmVjdC5oZWlnaHQgLyAyKSB7XG4gICAgICBncm91cHMucHVzaChbcmVjdF0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBncm91cHNbZ3JvdXBzLmxlbmd0aCAtIDFdLnB1c2gocmVjdCk7XG4gICAgfVxuICAgIHByZXZSZWN0ID0gcmVjdDtcbiAgfVxuICByZXR1cm4gZ3JvdXBzLm1hcChyZWN0ID0+IHJlY3RUb0NsaWVudFJlY3QoZ2V0Qm91bmRpbmdSZWN0KHJlY3QpKSk7XG59XG4vKipcbiAqIFByb3ZpZGVzIGltcHJvdmVkIHBvc2l0aW9uaW5nIGZvciBpbmxpbmUgcmVmZXJlbmNlIGVsZW1lbnRzIHRoYXQgY2FuIHNwYW5cbiAqIG92ZXIgbXVsdGlwbGUgbGluZXMsIHN1Y2ggYXMgaHlwZXJsaW5rcyBvciByYW5nZSBzZWxlY3Rpb25zLlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL2lubGluZVxuICovXG5jb25zdCBpbmxpbmUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG4gIHJldHVybiB7XG4gICAgbmFtZTogJ2lubGluZScsXG4gICAgb3B0aW9ucyxcbiAgICBhc3luYyBmbihzdGF0ZSkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBwbGFjZW1lbnQsXG4gICAgICAgIGVsZW1lbnRzLFxuICAgICAgICByZWN0cyxcbiAgICAgICAgcGxhdGZvcm0sXG4gICAgICAgIHN0cmF0ZWd5XG4gICAgICB9ID0gc3RhdGU7XG4gICAgICAvLyBBIE1vdXNlRXZlbnQncyBjbGllbnR7WCxZfSBjb29yZHMgY2FuIGJlIHVwIHRvIDIgcGl4ZWxzIG9mZiBhXG4gICAgICAvLyBDbGllbnRSZWN0J3MgYm91bmRzLCBkZXNwaXRlIHRoZSBldmVudCBsaXN0ZW5lciBiZWluZyB0cmlnZ2VyZWQuIEFcbiAgICAgIC8vIHBhZGRpbmcgb2YgMiBzZWVtcyB0byBoYW5kbGUgdGhpcyBpc3N1ZS5cbiAgICAgIGNvbnN0IHtcbiAgICAgICAgcGFkZGluZyA9IDIsXG4gICAgICAgIHgsXG4gICAgICAgIHlcbiAgICAgIH0gPSBldmFsdWF0ZShvcHRpb25zLCBzdGF0ZSk7XG4gICAgICBjb25zdCBuYXRpdmVDbGllbnRSZWN0cyA9IEFycmF5LmZyb20oKGF3YWl0IChwbGF0Zm9ybS5nZXRDbGllbnRSZWN0cyA9PSBudWxsID8gdm9pZCAwIDogcGxhdGZvcm0uZ2V0Q2xpZW50UmVjdHMoZWxlbWVudHMucmVmZXJlbmNlKSkpIHx8IFtdKTtcbiAgICAgIGNvbnN0IGNsaWVudFJlY3RzID0gZ2V0UmVjdHNCeUxpbmUobmF0aXZlQ2xpZW50UmVjdHMpO1xuICAgICAgY29uc3QgZmFsbGJhY2sgPSByZWN0VG9DbGllbnRSZWN0KGdldEJvdW5kaW5nUmVjdChuYXRpdmVDbGllbnRSZWN0cykpO1xuICAgICAgY29uc3QgcGFkZGluZ09iamVjdCA9IGdldFBhZGRpbmdPYmplY3QocGFkZGluZyk7XG4gICAgICBmdW5jdGlvbiBnZXRCb3VuZGluZ0NsaWVudFJlY3QoKSB7XG4gICAgICAgIC8vIFRoZXJlIGFyZSB0d28gcmVjdHMgYW5kIHRoZXkgYXJlIGRpc2pvaW5lZC5cbiAgICAgICAgaWYgKGNsaWVudFJlY3RzLmxlbmd0aCA9PT0gMiAmJiBjbGllbnRSZWN0c1swXS5sZWZ0ID4gY2xpZW50UmVjdHNbMV0ucmlnaHQgJiYgeCAhPSBudWxsICYmIHkgIT0gbnVsbCkge1xuICAgICAgICAgIC8vIEZpbmQgdGhlIGZpcnN0IHJlY3QgaW4gd2hpY2ggdGhlIHBvaW50IGlzIGZ1bGx5IGluc2lkZS5cbiAgICAgICAgICByZXR1cm4gY2xpZW50UmVjdHMuZmluZChyZWN0ID0+IHggPiByZWN0LmxlZnQgLSBwYWRkaW5nT2JqZWN0LmxlZnQgJiYgeCA8IHJlY3QucmlnaHQgKyBwYWRkaW5nT2JqZWN0LnJpZ2h0ICYmIHkgPiByZWN0LnRvcCAtIHBhZGRpbmdPYmplY3QudG9wICYmIHkgPCByZWN0LmJvdHRvbSArIHBhZGRpbmdPYmplY3QuYm90dG9tKSB8fCBmYWxsYmFjaztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRoZXJlIGFyZSAyIG9yIG1vcmUgY29ubmVjdGVkIHJlY3RzLlxuICAgICAgICBpZiAoY2xpZW50UmVjdHMubGVuZ3RoID49IDIpIHtcbiAgICAgICAgICBpZiAoZ2V0U2lkZUF4aXMocGxhY2VtZW50KSA9PT0gJ3knKSB7XG4gICAgICAgICAgICBjb25zdCBmaXJzdFJlY3QgPSBjbGllbnRSZWN0c1swXTtcbiAgICAgICAgICAgIGNvbnN0IGxhc3RSZWN0ID0gY2xpZW50UmVjdHNbY2xpZW50UmVjdHMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICBjb25zdCBpc1RvcCA9IGdldFNpZGUocGxhY2VtZW50KSA9PT0gJ3RvcCc7XG4gICAgICAgICAgICBjb25zdCB0b3AgPSBmaXJzdFJlY3QudG9wO1xuICAgICAgICAgICAgY29uc3QgYm90dG9tID0gbGFzdFJlY3QuYm90dG9tO1xuICAgICAgICAgICAgY29uc3QgbGVmdCA9IGlzVG9wID8gZmlyc3RSZWN0LmxlZnQgOiBsYXN0UmVjdC5sZWZ0O1xuICAgICAgICAgICAgY29uc3QgcmlnaHQgPSBpc1RvcCA/IGZpcnN0UmVjdC5yaWdodCA6IGxhc3RSZWN0LnJpZ2h0O1xuICAgICAgICAgICAgY29uc3Qgd2lkdGggPSByaWdodCAtIGxlZnQ7XG4gICAgICAgICAgICBjb25zdCBoZWlnaHQgPSBib3R0b20gLSB0b3A7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICB0b3AsXG4gICAgICAgICAgICAgIGJvdHRvbSxcbiAgICAgICAgICAgICAgbGVmdCxcbiAgICAgICAgICAgICAgcmlnaHQsXG4gICAgICAgICAgICAgIHdpZHRoLFxuICAgICAgICAgICAgICBoZWlnaHQsXG4gICAgICAgICAgICAgIHg6IGxlZnQsXG4gICAgICAgICAgICAgIHk6IHRvcFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgaXNMZWZ0U2lkZSA9IGdldFNpZGUocGxhY2VtZW50KSA9PT0gJ2xlZnQnO1xuICAgICAgICAgIGNvbnN0IG1heFJpZ2h0ID0gbWF4KC4uLmNsaWVudFJlY3RzLm1hcChyZWN0ID0+IHJlY3QucmlnaHQpKTtcbiAgICAgICAgICBjb25zdCBtaW5MZWZ0ID0gbWluKC4uLmNsaWVudFJlY3RzLm1hcChyZWN0ID0+IHJlY3QubGVmdCkpO1xuICAgICAgICAgIGNvbnN0IG1lYXN1cmVSZWN0cyA9IGNsaWVudFJlY3RzLmZpbHRlcihyZWN0ID0+IGlzTGVmdFNpZGUgPyByZWN0LmxlZnQgPT09IG1pbkxlZnQgOiByZWN0LnJpZ2h0ID09PSBtYXhSaWdodCk7XG4gICAgICAgICAgY29uc3QgdG9wID0gbWVhc3VyZVJlY3RzWzBdLnRvcDtcbiAgICAgICAgICBjb25zdCBib3R0b20gPSBtZWFzdXJlUmVjdHNbbWVhc3VyZVJlY3RzLmxlbmd0aCAtIDFdLmJvdHRvbTtcbiAgICAgICAgICBjb25zdCBsZWZ0ID0gbWluTGVmdDtcbiAgICAgICAgICBjb25zdCByaWdodCA9IG1heFJpZ2h0O1xuICAgICAgICAgIGNvbnN0IHdpZHRoID0gcmlnaHQgLSBsZWZ0O1xuICAgICAgICAgIGNvbnN0IGhlaWdodCA9IGJvdHRvbSAtIHRvcDtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdG9wLFxuICAgICAgICAgICAgYm90dG9tLFxuICAgICAgICAgICAgbGVmdCxcbiAgICAgICAgICAgIHJpZ2h0LFxuICAgICAgICAgICAgd2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQsXG4gICAgICAgICAgICB4OiBsZWZ0LFxuICAgICAgICAgICAgeTogdG9wXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsbGJhY2s7XG4gICAgICB9XG4gICAgICBjb25zdCByZXNldFJlY3RzID0gYXdhaXQgcGxhdGZvcm0uZ2V0RWxlbWVudFJlY3RzKHtcbiAgICAgICAgcmVmZXJlbmNlOiB7XG4gICAgICAgICAgZ2V0Qm91bmRpbmdDbGllbnRSZWN0XG4gICAgICAgIH0sXG4gICAgICAgIGZsb2F0aW5nOiBlbGVtZW50cy5mbG9hdGluZyxcbiAgICAgICAgc3RyYXRlZ3lcbiAgICAgIH0pO1xuICAgICAgaWYgKHJlY3RzLnJlZmVyZW5jZS54ICE9PSByZXNldFJlY3RzLnJlZmVyZW5jZS54IHx8IHJlY3RzLnJlZmVyZW5jZS55ICE9PSByZXNldFJlY3RzLnJlZmVyZW5jZS55IHx8IHJlY3RzLnJlZmVyZW5jZS53aWR0aCAhPT0gcmVzZXRSZWN0cy5yZWZlcmVuY2Uud2lkdGggfHwgcmVjdHMucmVmZXJlbmNlLmhlaWdodCAhPT0gcmVzZXRSZWN0cy5yZWZlcmVuY2UuaGVpZ2h0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcmVzZXQ6IHtcbiAgICAgICAgICAgIHJlY3RzOiByZXNldFJlY3RzXG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgfTtcbn07XG5cbi8vIEZvciB0eXBlIGJhY2t3YXJkcy1jb21wYXRpYmlsaXR5LCB0aGUgYE9mZnNldE9wdGlvbnNgIHR5cGUgd2FzIGFsc29cbi8vIERlcml2YWJsZS5cblxuYXN5bmMgZnVuY3Rpb24gY29udmVydFZhbHVlVG9Db29yZHMoc3RhdGUsIG9wdGlvbnMpIHtcbiAgY29uc3Qge1xuICAgIHBsYWNlbWVudCxcbiAgICBwbGF0Zm9ybSxcbiAgICBlbGVtZW50c1xuICB9ID0gc3RhdGU7XG4gIGNvbnN0IHJ0bCA9IGF3YWl0IChwbGF0Zm9ybS5pc1JUTCA9PSBudWxsID8gdm9pZCAwIDogcGxhdGZvcm0uaXNSVEwoZWxlbWVudHMuZmxvYXRpbmcpKTtcbiAgY29uc3Qgc2lkZSA9IGdldFNpZGUocGxhY2VtZW50KTtcbiAgY29uc3QgYWxpZ25tZW50ID0gZ2V0QWxpZ25tZW50KHBsYWNlbWVudCk7XG4gIGNvbnN0IGlzVmVydGljYWwgPSBnZXRTaWRlQXhpcyhwbGFjZW1lbnQpID09PSAneSc7XG4gIGNvbnN0IG1haW5BeGlzTXVsdGkgPSBbJ2xlZnQnLCAndG9wJ10uaW5jbHVkZXMoc2lkZSkgPyAtMSA6IDE7XG4gIGNvbnN0IGNyb3NzQXhpc011bHRpID0gcnRsICYmIGlzVmVydGljYWwgPyAtMSA6IDE7XG4gIGNvbnN0IHJhd1ZhbHVlID0gZXZhbHVhdGUob3B0aW9ucywgc3RhdGUpO1xuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItY29uc3RcbiAgbGV0IHtcbiAgICBtYWluQXhpcyxcbiAgICBjcm9zc0F4aXMsXG4gICAgYWxpZ25tZW50QXhpc1xuICB9ID0gdHlwZW9mIHJhd1ZhbHVlID09PSAnbnVtYmVyJyA/IHtcbiAgICBtYWluQXhpczogcmF3VmFsdWUsXG4gICAgY3Jvc3NBeGlzOiAwLFxuICAgIGFsaWdubWVudEF4aXM6IG51bGxcbiAgfSA6IHtcbiAgICBtYWluQXhpczogcmF3VmFsdWUubWFpbkF4aXMgfHwgMCxcbiAgICBjcm9zc0F4aXM6IHJhd1ZhbHVlLmNyb3NzQXhpcyB8fCAwLFxuICAgIGFsaWdubWVudEF4aXM6IHJhd1ZhbHVlLmFsaWdubWVudEF4aXNcbiAgfTtcbiAgaWYgKGFsaWdubWVudCAmJiB0eXBlb2YgYWxpZ25tZW50QXhpcyA9PT0gJ251bWJlcicpIHtcbiAgICBjcm9zc0F4aXMgPSBhbGlnbm1lbnQgPT09ICdlbmQnID8gYWxpZ25tZW50QXhpcyAqIC0xIDogYWxpZ25tZW50QXhpcztcbiAgfVxuICByZXR1cm4gaXNWZXJ0aWNhbCA/IHtcbiAgICB4OiBjcm9zc0F4aXMgKiBjcm9zc0F4aXNNdWx0aSxcbiAgICB5OiBtYWluQXhpcyAqIG1haW5BeGlzTXVsdGlcbiAgfSA6IHtcbiAgICB4OiBtYWluQXhpcyAqIG1haW5BeGlzTXVsdGksXG4gICAgeTogY3Jvc3NBeGlzICogY3Jvc3NBeGlzTXVsdGlcbiAgfTtcbn1cblxuLyoqXG4gKiBNb2RpZmllcyB0aGUgcGxhY2VtZW50IGJ5IHRyYW5zbGF0aW5nIHRoZSBmbG9hdGluZyBlbGVtZW50IGFsb25nIHRoZVxuICogc3BlY2lmaWVkIGF4ZXMuXG4gKiBBIG51bWJlciAoc2hvcnRoYW5kIGZvciBgbWFpbkF4aXNgIG9yIGRpc3RhbmNlKSwgb3IgYW4gYXhlcyBjb25maWd1cmF0aW9uXG4gKiBvYmplY3QgbWF5IGJlIHBhc3NlZC5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9vZmZzZXRcbiAqL1xuY29uc3Qgb2Zmc2V0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIG9wdGlvbnMgPSAwO1xuICB9XG4gIHJldHVybiB7XG4gICAgbmFtZTogJ29mZnNldCcsXG4gICAgb3B0aW9ucyxcbiAgICBhc3luYyBmbihzdGF0ZSkge1xuICAgICAgdmFyIF9taWRkbGV3YXJlRGF0YSRvZmZzZSwgX21pZGRsZXdhcmVEYXRhJGFycm93O1xuICAgICAgY29uc3Qge1xuICAgICAgICB4LFxuICAgICAgICB5LFxuICAgICAgICBwbGFjZW1lbnQsXG4gICAgICAgIG1pZGRsZXdhcmVEYXRhXG4gICAgICB9ID0gc3RhdGU7XG4gICAgICBjb25zdCBkaWZmQ29vcmRzID0gYXdhaXQgY29udmVydFZhbHVlVG9Db29yZHMoc3RhdGUsIG9wdGlvbnMpO1xuXG4gICAgICAvLyBJZiB0aGUgcGxhY2VtZW50IGlzIHRoZSBzYW1lIGFuZCB0aGUgYXJyb3cgY2F1c2VkIGFuIGFsaWdubWVudCBvZmZzZXRcbiAgICAgIC8vIHRoZW4gd2UgZG9uJ3QgbmVlZCB0byBjaGFuZ2UgdGhlIHBvc2l0aW9uaW5nIGNvb3JkaW5hdGVzLlxuICAgICAgaWYgKHBsYWNlbWVudCA9PT0gKChfbWlkZGxld2FyZURhdGEkb2Zmc2UgPSBtaWRkbGV3YXJlRGF0YS5vZmZzZXQpID09IG51bGwgPyB2b2lkIDAgOiBfbWlkZGxld2FyZURhdGEkb2Zmc2UucGxhY2VtZW50KSAmJiAoX21pZGRsZXdhcmVEYXRhJGFycm93ID0gbWlkZGxld2FyZURhdGEuYXJyb3cpICE9IG51bGwgJiYgX21pZGRsZXdhcmVEYXRhJGFycm93LmFsaWdubWVudE9mZnNldCkge1xuICAgICAgICByZXR1cm4ge307XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiB4ICsgZGlmZkNvb3Jkcy54LFxuICAgICAgICB5OiB5ICsgZGlmZkNvb3Jkcy55LFxuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgLi4uZGlmZkNvb3JkcyxcbiAgICAgICAgICBwbGFjZW1lbnRcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gIH07XG59O1xuXG4vKipcbiAqIE9wdGltaXplcyB0aGUgdmlzaWJpbGl0eSBvZiB0aGUgZmxvYXRpbmcgZWxlbWVudCBieSBzaGlmdGluZyBpdCBpbiBvcmRlciB0b1xuICoga2VlcCBpdCBpbiB2aWV3IHdoZW4gaXQgd2lsbCBvdmVyZmxvdyB0aGUgY2xpcHBpbmcgYm91bmRhcnkuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3Mvc2hpZnRcbiAqL1xuY29uc3Qgc2hpZnQgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG4gIHJldHVybiB7XG4gICAgbmFtZTogJ3NoaWZ0JyxcbiAgICBvcHRpb25zLFxuICAgIGFzeW5jIGZuKHN0YXRlKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHgsXG4gICAgICAgIHksXG4gICAgICAgIHBsYWNlbWVudFxuICAgICAgfSA9IHN0YXRlO1xuICAgICAgY29uc3Qge1xuICAgICAgICBtYWluQXhpczogY2hlY2tNYWluQXhpcyA9IHRydWUsXG4gICAgICAgIGNyb3NzQXhpczogY2hlY2tDcm9zc0F4aXMgPSBmYWxzZSxcbiAgICAgICAgbGltaXRlciA9IHtcbiAgICAgICAgICBmbjogX3JlZiA9PiB7XG4gICAgICAgICAgICBsZXQge1xuICAgICAgICAgICAgICB4LFxuICAgICAgICAgICAgICB5XG4gICAgICAgICAgICB9ID0gX3JlZjtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHgsXG4gICAgICAgICAgICAgIHlcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAuLi5kZXRlY3RPdmVyZmxvd09wdGlvbnNcbiAgICAgIH0gPSBldmFsdWF0ZShvcHRpb25zLCBzdGF0ZSk7XG4gICAgICBjb25zdCBjb29yZHMgPSB7XG4gICAgICAgIHgsXG4gICAgICAgIHlcbiAgICAgIH07XG4gICAgICBjb25zdCBvdmVyZmxvdyA9IGF3YWl0IGRldGVjdE92ZXJmbG93KHN0YXRlLCBkZXRlY3RPdmVyZmxvd09wdGlvbnMpO1xuICAgICAgY29uc3QgY3Jvc3NBeGlzID0gZ2V0U2lkZUF4aXMoZ2V0U2lkZShwbGFjZW1lbnQpKTtcbiAgICAgIGNvbnN0IG1haW5BeGlzID0gZ2V0T3Bwb3NpdGVBeGlzKGNyb3NzQXhpcyk7XG4gICAgICBsZXQgbWFpbkF4aXNDb29yZCA9IGNvb3Jkc1ttYWluQXhpc107XG4gICAgICBsZXQgY3Jvc3NBeGlzQ29vcmQgPSBjb29yZHNbY3Jvc3NBeGlzXTtcbiAgICAgIGlmIChjaGVja01haW5BeGlzKSB7XG4gICAgICAgIGNvbnN0IG1pblNpZGUgPSBtYWluQXhpcyA9PT0gJ3knID8gJ3RvcCcgOiAnbGVmdCc7XG4gICAgICAgIGNvbnN0IG1heFNpZGUgPSBtYWluQXhpcyA9PT0gJ3knID8gJ2JvdHRvbScgOiAncmlnaHQnO1xuICAgICAgICBjb25zdCBtaW4gPSBtYWluQXhpc0Nvb3JkICsgb3ZlcmZsb3dbbWluU2lkZV07XG4gICAgICAgIGNvbnN0IG1heCA9IG1haW5BeGlzQ29vcmQgLSBvdmVyZmxvd1ttYXhTaWRlXTtcbiAgICAgICAgbWFpbkF4aXNDb29yZCA9IGNsYW1wKG1pbiwgbWFpbkF4aXNDb29yZCwgbWF4KTtcbiAgICAgIH1cbiAgICAgIGlmIChjaGVja0Nyb3NzQXhpcykge1xuICAgICAgICBjb25zdCBtaW5TaWRlID0gY3Jvc3NBeGlzID09PSAneScgPyAndG9wJyA6ICdsZWZ0JztcbiAgICAgICAgY29uc3QgbWF4U2lkZSA9IGNyb3NzQXhpcyA9PT0gJ3knID8gJ2JvdHRvbScgOiAncmlnaHQnO1xuICAgICAgICBjb25zdCBtaW4gPSBjcm9zc0F4aXNDb29yZCArIG92ZXJmbG93W21pblNpZGVdO1xuICAgICAgICBjb25zdCBtYXggPSBjcm9zc0F4aXNDb29yZCAtIG92ZXJmbG93W21heFNpZGVdO1xuICAgICAgICBjcm9zc0F4aXNDb29yZCA9IGNsYW1wKG1pbiwgY3Jvc3NBeGlzQ29vcmQsIG1heCk7XG4gICAgICB9XG4gICAgICBjb25zdCBsaW1pdGVkQ29vcmRzID0gbGltaXRlci5mbih7XG4gICAgICAgIC4uLnN0YXRlLFxuICAgICAgICBbbWFpbkF4aXNdOiBtYWluQXhpc0Nvb3JkLFxuICAgICAgICBbY3Jvc3NBeGlzXTogY3Jvc3NBeGlzQ29vcmRcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4ubGltaXRlZENvb3JkcyxcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgIHg6IGxpbWl0ZWRDb29yZHMueCAtIHgsXG4gICAgICAgICAgeTogbGltaXRlZENvb3Jkcy55IC0geSxcbiAgICAgICAgICBlbmFibGVkOiB7XG4gICAgICAgICAgICBbbWFpbkF4aXNdOiBjaGVja01haW5BeGlzLFxuICAgICAgICAgICAgW2Nyb3NzQXhpc106IGNoZWNrQ3Jvc3NBeGlzXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgfTtcbn07XG4vKipcbiAqIEJ1aWx0LWluIGBsaW1pdGVyYCB0aGF0IHdpbGwgc3RvcCBgc2hpZnQoKWAgYXQgYSBjZXJ0YWluIHBvaW50LlxuICovXG5jb25zdCBsaW1pdFNoaWZ0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuICByZXR1cm4ge1xuICAgIG9wdGlvbnMsXG4gICAgZm4oc3RhdGUpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgeCxcbiAgICAgICAgeSxcbiAgICAgICAgcGxhY2VtZW50LFxuICAgICAgICByZWN0cyxcbiAgICAgICAgbWlkZGxld2FyZURhdGFcbiAgICAgIH0gPSBzdGF0ZTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgb2Zmc2V0ID0gMCxcbiAgICAgICAgbWFpbkF4aXM6IGNoZWNrTWFpbkF4aXMgPSB0cnVlLFxuICAgICAgICBjcm9zc0F4aXM6IGNoZWNrQ3Jvc3NBeGlzID0gdHJ1ZVxuICAgICAgfSA9IGV2YWx1YXRlKG9wdGlvbnMsIHN0YXRlKTtcbiAgICAgIGNvbnN0IGNvb3JkcyA9IHtcbiAgICAgICAgeCxcbiAgICAgICAgeVxuICAgICAgfTtcbiAgICAgIGNvbnN0IGNyb3NzQXhpcyA9IGdldFNpZGVBeGlzKHBsYWNlbWVudCk7XG4gICAgICBjb25zdCBtYWluQXhpcyA9IGdldE9wcG9zaXRlQXhpcyhjcm9zc0F4aXMpO1xuICAgICAgbGV0IG1haW5BeGlzQ29vcmQgPSBjb29yZHNbbWFpbkF4aXNdO1xuICAgICAgbGV0IGNyb3NzQXhpc0Nvb3JkID0gY29vcmRzW2Nyb3NzQXhpc107XG4gICAgICBjb25zdCByYXdPZmZzZXQgPSBldmFsdWF0ZShvZmZzZXQsIHN0YXRlKTtcbiAgICAgIGNvbnN0IGNvbXB1dGVkT2Zmc2V0ID0gdHlwZW9mIHJhd09mZnNldCA9PT0gJ251bWJlcicgPyB7XG4gICAgICAgIG1haW5BeGlzOiByYXdPZmZzZXQsXG4gICAgICAgIGNyb3NzQXhpczogMFxuICAgICAgfSA6IHtcbiAgICAgICAgbWFpbkF4aXM6IDAsXG4gICAgICAgIGNyb3NzQXhpczogMCxcbiAgICAgICAgLi4ucmF3T2Zmc2V0XG4gICAgICB9O1xuICAgICAgaWYgKGNoZWNrTWFpbkF4aXMpIHtcbiAgICAgICAgY29uc3QgbGVuID0gbWFpbkF4aXMgPT09ICd5JyA/ICdoZWlnaHQnIDogJ3dpZHRoJztcbiAgICAgICAgY29uc3QgbGltaXRNaW4gPSByZWN0cy5yZWZlcmVuY2VbbWFpbkF4aXNdIC0gcmVjdHMuZmxvYXRpbmdbbGVuXSArIGNvbXB1dGVkT2Zmc2V0Lm1haW5BeGlzO1xuICAgICAgICBjb25zdCBsaW1pdE1heCA9IHJlY3RzLnJlZmVyZW5jZVttYWluQXhpc10gKyByZWN0cy5yZWZlcmVuY2VbbGVuXSAtIGNvbXB1dGVkT2Zmc2V0Lm1haW5BeGlzO1xuICAgICAgICBpZiAobWFpbkF4aXNDb29yZCA8IGxpbWl0TWluKSB7XG4gICAgICAgICAgbWFpbkF4aXNDb29yZCA9IGxpbWl0TWluO1xuICAgICAgICB9IGVsc2UgaWYgKG1haW5BeGlzQ29vcmQgPiBsaW1pdE1heCkge1xuICAgICAgICAgIG1haW5BeGlzQ29vcmQgPSBsaW1pdE1heDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGNoZWNrQ3Jvc3NBeGlzKSB7XG4gICAgICAgIHZhciBfbWlkZGxld2FyZURhdGEkb2Zmc2UsIF9taWRkbGV3YXJlRGF0YSRvZmZzZTI7XG4gICAgICAgIGNvbnN0IGxlbiA9IG1haW5BeGlzID09PSAneScgPyAnd2lkdGgnIDogJ2hlaWdodCc7XG4gICAgICAgIGNvbnN0IGlzT3JpZ2luU2lkZSA9IFsndG9wJywgJ2xlZnQnXS5pbmNsdWRlcyhnZXRTaWRlKHBsYWNlbWVudCkpO1xuICAgICAgICBjb25zdCBsaW1pdE1pbiA9IHJlY3RzLnJlZmVyZW5jZVtjcm9zc0F4aXNdIC0gcmVjdHMuZmxvYXRpbmdbbGVuXSArIChpc09yaWdpblNpZGUgPyAoKF9taWRkbGV3YXJlRGF0YSRvZmZzZSA9IG1pZGRsZXdhcmVEYXRhLm9mZnNldCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9taWRkbGV3YXJlRGF0YSRvZmZzZVtjcm9zc0F4aXNdKSB8fCAwIDogMCkgKyAoaXNPcmlnaW5TaWRlID8gMCA6IGNvbXB1dGVkT2Zmc2V0LmNyb3NzQXhpcyk7XG4gICAgICAgIGNvbnN0IGxpbWl0TWF4ID0gcmVjdHMucmVmZXJlbmNlW2Nyb3NzQXhpc10gKyByZWN0cy5yZWZlcmVuY2VbbGVuXSArIChpc09yaWdpblNpZGUgPyAwIDogKChfbWlkZGxld2FyZURhdGEkb2Zmc2UyID0gbWlkZGxld2FyZURhdGEub2Zmc2V0KSA9PSBudWxsID8gdm9pZCAwIDogX21pZGRsZXdhcmVEYXRhJG9mZnNlMltjcm9zc0F4aXNdKSB8fCAwKSAtIChpc09yaWdpblNpZGUgPyBjb21wdXRlZE9mZnNldC5jcm9zc0F4aXMgOiAwKTtcbiAgICAgICAgaWYgKGNyb3NzQXhpc0Nvb3JkIDwgbGltaXRNaW4pIHtcbiAgICAgICAgICBjcm9zc0F4aXNDb29yZCA9IGxpbWl0TWluO1xuICAgICAgICB9IGVsc2UgaWYgKGNyb3NzQXhpc0Nvb3JkID4gbGltaXRNYXgpIHtcbiAgICAgICAgICBjcm9zc0F4aXNDb29yZCA9IGxpbWl0TWF4O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBbbWFpbkF4aXNdOiBtYWluQXhpc0Nvb3JkLFxuICAgICAgICBbY3Jvc3NBeGlzXTogY3Jvc3NBeGlzQ29vcmRcbiAgICAgIH07XG4gICAgfVxuICB9O1xufTtcblxuLyoqXG4gKiBQcm92aWRlcyBkYXRhIHRoYXQgYWxsb3dzIHlvdSB0byBjaGFuZ2UgdGhlIHNpemUgb2YgdGhlIGZsb2F0aW5nIGVsZW1lbnQg4oCUXG4gKiBmb3IgaW5zdGFuY2UsIHByZXZlbnQgaXQgZnJvbSBvdmVyZmxvd2luZyB0aGUgY2xpcHBpbmcgYm91bmRhcnkgb3IgbWF0Y2ggdGhlXG4gKiB3aWR0aCBvZiB0aGUgcmVmZXJlbmNlIGVsZW1lbnQuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3Mvc2l6ZVxuICovXG5jb25zdCBzaXplID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuICByZXR1cm4ge1xuICAgIG5hbWU6ICdzaXplJyxcbiAgICBvcHRpb25zLFxuICAgIGFzeW5jIGZuKHN0YXRlKSB7XG4gICAgICB2YXIgX3N0YXRlJG1pZGRsZXdhcmVEYXRhLCBfc3RhdGUkbWlkZGxld2FyZURhdGEyO1xuICAgICAgY29uc3Qge1xuICAgICAgICBwbGFjZW1lbnQsXG4gICAgICAgIHJlY3RzLFxuICAgICAgICBwbGF0Zm9ybSxcbiAgICAgICAgZWxlbWVudHNcbiAgICAgIH0gPSBzdGF0ZTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgYXBwbHkgPSAoKSA9PiB7fSxcbiAgICAgICAgLi4uZGV0ZWN0T3ZlcmZsb3dPcHRpb25zXG4gICAgICB9ID0gZXZhbHVhdGUob3B0aW9ucywgc3RhdGUpO1xuICAgICAgY29uc3Qgb3ZlcmZsb3cgPSBhd2FpdCBkZXRlY3RPdmVyZmxvdyhzdGF0ZSwgZGV0ZWN0T3ZlcmZsb3dPcHRpb25zKTtcbiAgICAgIGNvbnN0IHNpZGUgPSBnZXRTaWRlKHBsYWNlbWVudCk7XG4gICAgICBjb25zdCBhbGlnbm1lbnQgPSBnZXRBbGlnbm1lbnQocGxhY2VtZW50KTtcbiAgICAgIGNvbnN0IGlzWUF4aXMgPSBnZXRTaWRlQXhpcyhwbGFjZW1lbnQpID09PSAneSc7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHdpZHRoLFxuICAgICAgICBoZWlnaHRcbiAgICAgIH0gPSByZWN0cy5mbG9hdGluZztcbiAgICAgIGxldCBoZWlnaHRTaWRlO1xuICAgICAgbGV0IHdpZHRoU2lkZTtcbiAgICAgIGlmIChzaWRlID09PSAndG9wJyB8fCBzaWRlID09PSAnYm90dG9tJykge1xuICAgICAgICBoZWlnaHRTaWRlID0gc2lkZTtcbiAgICAgICAgd2lkdGhTaWRlID0gYWxpZ25tZW50ID09PSAoKGF3YWl0IChwbGF0Zm9ybS5pc1JUTCA9PSBudWxsID8gdm9pZCAwIDogcGxhdGZvcm0uaXNSVEwoZWxlbWVudHMuZmxvYXRpbmcpKSkgPyAnc3RhcnQnIDogJ2VuZCcpID8gJ2xlZnQnIDogJ3JpZ2h0JztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdpZHRoU2lkZSA9IHNpZGU7XG4gICAgICAgIGhlaWdodFNpZGUgPSBhbGlnbm1lbnQgPT09ICdlbmQnID8gJ3RvcCcgOiAnYm90dG9tJztcbiAgICAgIH1cbiAgICAgIGNvbnN0IG1heGltdW1DbGlwcGluZ0hlaWdodCA9IGhlaWdodCAtIG92ZXJmbG93LnRvcCAtIG92ZXJmbG93LmJvdHRvbTtcbiAgICAgIGNvbnN0IG1heGltdW1DbGlwcGluZ1dpZHRoID0gd2lkdGggLSBvdmVyZmxvdy5sZWZ0IC0gb3ZlcmZsb3cucmlnaHQ7XG4gICAgICBjb25zdCBvdmVyZmxvd0F2YWlsYWJsZUhlaWdodCA9IG1pbihoZWlnaHQgLSBvdmVyZmxvd1toZWlnaHRTaWRlXSwgbWF4aW11bUNsaXBwaW5nSGVpZ2h0KTtcbiAgICAgIGNvbnN0IG92ZXJmbG93QXZhaWxhYmxlV2lkdGggPSBtaW4od2lkdGggLSBvdmVyZmxvd1t3aWR0aFNpZGVdLCBtYXhpbXVtQ2xpcHBpbmdXaWR0aCk7XG4gICAgICBjb25zdCBub1NoaWZ0ID0gIXN0YXRlLm1pZGRsZXdhcmVEYXRhLnNoaWZ0O1xuICAgICAgbGV0IGF2YWlsYWJsZUhlaWdodCA9IG92ZXJmbG93QXZhaWxhYmxlSGVpZ2h0O1xuICAgICAgbGV0IGF2YWlsYWJsZVdpZHRoID0gb3ZlcmZsb3dBdmFpbGFibGVXaWR0aDtcbiAgICAgIGlmICgoX3N0YXRlJG1pZGRsZXdhcmVEYXRhID0gc3RhdGUubWlkZGxld2FyZURhdGEuc2hpZnQpICE9IG51bGwgJiYgX3N0YXRlJG1pZGRsZXdhcmVEYXRhLmVuYWJsZWQueCkge1xuICAgICAgICBhdmFpbGFibGVXaWR0aCA9IG1heGltdW1DbGlwcGluZ1dpZHRoO1xuICAgICAgfVxuICAgICAgaWYgKChfc3RhdGUkbWlkZGxld2FyZURhdGEyID0gc3RhdGUubWlkZGxld2FyZURhdGEuc2hpZnQpICE9IG51bGwgJiYgX3N0YXRlJG1pZGRsZXdhcmVEYXRhMi5lbmFibGVkLnkpIHtcbiAgICAgICAgYXZhaWxhYmxlSGVpZ2h0ID0gbWF4aW11bUNsaXBwaW5nSGVpZ2h0O1xuICAgICAgfVxuICAgICAgaWYgKG5vU2hpZnQgJiYgIWFsaWdubWVudCkge1xuICAgICAgICBjb25zdCB4TWluID0gbWF4KG92ZXJmbG93LmxlZnQsIDApO1xuICAgICAgICBjb25zdCB4TWF4ID0gbWF4KG92ZXJmbG93LnJpZ2h0LCAwKTtcbiAgICAgICAgY29uc3QgeU1pbiA9IG1heChvdmVyZmxvdy50b3AsIDApO1xuICAgICAgICBjb25zdCB5TWF4ID0gbWF4KG92ZXJmbG93LmJvdHRvbSwgMCk7XG4gICAgICAgIGlmIChpc1lBeGlzKSB7XG4gICAgICAgICAgYXZhaWxhYmxlV2lkdGggPSB3aWR0aCAtIDIgKiAoeE1pbiAhPT0gMCB8fCB4TWF4ICE9PSAwID8geE1pbiArIHhNYXggOiBtYXgob3ZlcmZsb3cubGVmdCwgb3ZlcmZsb3cucmlnaHQpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhdmFpbGFibGVIZWlnaHQgPSBoZWlnaHQgLSAyICogKHlNaW4gIT09IDAgfHwgeU1heCAhPT0gMCA/IHlNaW4gKyB5TWF4IDogbWF4KG92ZXJmbG93LnRvcCwgb3ZlcmZsb3cuYm90dG9tKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGF3YWl0IGFwcGx5KHtcbiAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgIGF2YWlsYWJsZVdpZHRoLFxuICAgICAgICBhdmFpbGFibGVIZWlnaHRcbiAgICAgIH0pO1xuICAgICAgY29uc3QgbmV4dERpbWVuc2lvbnMgPSBhd2FpdCBwbGF0Zm9ybS5nZXREaW1lbnNpb25zKGVsZW1lbnRzLmZsb2F0aW5nKTtcbiAgICAgIGlmICh3aWR0aCAhPT0gbmV4dERpbWVuc2lvbnMud2lkdGggfHwgaGVpZ2h0ICE9PSBuZXh0RGltZW5zaW9ucy5oZWlnaHQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICByZXNldDoge1xuICAgICAgICAgICAgcmVjdHM6IHRydWVcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuICB9O1xufTtcblxuZXhwb3J0IHsgYXJyb3csIGF1dG9QbGFjZW1lbnQsIGNvbXB1dGVQb3NpdGlvbiwgZGV0ZWN0T3ZlcmZsb3csIGZsaXAsIGhpZGUsIGlubGluZSwgbGltaXRTaGlmdCwgb2Zmc2V0LCBzaGlmdCwgc2l6ZSB9O1xuIl0sIm5hbWVzIjpbImdldFNpZGVBeGlzIiwiZ2V0QWxpZ25tZW50QXhpcyIsImdldEF4aXNMZW5ndGgiLCJnZXRTaWRlIiwiZ2V0QWxpZ25tZW50IiwiZXZhbHVhdGUiLCJnZXRQYWRkaW5nT2JqZWN0IiwicmVjdFRvQ2xpZW50UmVjdCIsIm1pbiIsImNsYW1wIiwicGxhY2VtZW50cyIsImdldEFsaWdubWVudFNpZGVzIiwiZ2V0T3Bwb3NpdGVBbGlnbm1lbnRQbGFjZW1lbnQiLCJnZXRPcHBvc2l0ZVBsYWNlbWVudCIsImdldEV4cGFuZGVkUGxhY2VtZW50cyIsImdldE9wcG9zaXRlQXhpc1BsYWNlbWVudHMiLCJzaWRlcyIsIm1heCIsImdldE9wcG9zaXRlQXhpcyIsImNvbXB1dGVDb29yZHNGcm9tUGxhY2VtZW50IiwiX3JlZiIsInBsYWNlbWVudCIsInJ0bCIsInJlZmVyZW5jZSIsImZsb2F0aW5nIiwic2lkZUF4aXMiLCJhbGlnbm1lbnRBeGlzIiwiYWxpZ25MZW5ndGgiLCJzaWRlIiwiaXNWZXJ0aWNhbCIsImNvbW1vblgiLCJ4Iiwid2lkdGgiLCJjb21tb25ZIiwieSIsImhlaWdodCIsImNvbW1vbkFsaWduIiwiY29vcmRzIiwiY29tcHV0ZVBvc2l0aW9uIiwiY29uZmlnIiwic3RyYXRlZ3kiLCJtaWRkbGV3YXJlIiwicGxhdGZvcm0iLCJ2YWxpZE1pZGRsZXdhcmUiLCJmaWx0ZXIiLCJCb29sZWFuIiwiaXNSVEwiLCJyZWN0cyIsImdldEVsZW1lbnRSZWN0cyIsInN0YXRlZnVsUGxhY2VtZW50IiwibWlkZGxld2FyZURhdGEiLCJyZXNldENvdW50IiwiaSIsImxlbmd0aCIsIm5hbWUiLCJmbiIsIm5leHRYIiwibmV4dFkiLCJkYXRhIiwicmVzZXQiLCJpbml0aWFsUGxhY2VtZW50IiwiZWxlbWVudHMiLCJkZXRlY3RPdmVyZmxvdyIsInN0YXRlIiwib3B0aW9ucyIsIl9hd2FpdCRwbGF0Zm9ybSRpc0VsZSIsImJvdW5kYXJ5Iiwicm9vdEJvdW5kYXJ5IiwiZWxlbWVudENvbnRleHQiLCJhbHRCb3VuZGFyeSIsInBhZGRpbmciLCJwYWRkaW5nT2JqZWN0IiwiYWx0Q29udGV4dCIsImVsZW1lbnQiLCJjbGlwcGluZ0NsaWVudFJlY3QiLCJnZXRDbGlwcGluZ1JlY3QiLCJpc0VsZW1lbnQiLCJjb250ZXh0RWxlbWVudCIsImdldERvY3VtZW50RWxlbWVudCIsInJlY3QiLCJvZmZzZXRQYXJlbnQiLCJnZXRPZmZzZXRQYXJlbnQiLCJvZmZzZXRTY2FsZSIsImdldFNjYWxlIiwiZWxlbWVudENsaWVudFJlY3QiLCJjb252ZXJ0T2Zmc2V0UGFyZW50UmVsYXRpdmVSZWN0VG9WaWV3cG9ydFJlbGF0aXZlUmVjdCIsInRvcCIsImJvdHRvbSIsImxlZnQiLCJyaWdodCIsImFycm93IiwiYXhpcyIsImFycm93RGltZW5zaW9ucyIsImdldERpbWVuc2lvbnMiLCJpc1lBeGlzIiwibWluUHJvcCIsIm1heFByb3AiLCJjbGllbnRQcm9wIiwiZW5kRGlmZiIsInN0YXJ0RGlmZiIsImFycm93T2Zmc2V0UGFyZW50IiwiY2xpZW50U2l6ZSIsImNlbnRlclRvUmVmZXJlbmNlIiwibGFyZ2VzdFBvc3NpYmxlUGFkZGluZyIsIm1pblBhZGRpbmciLCJtYXhQYWRkaW5nIiwibWluJDEiLCJjZW50ZXIiLCJvZmZzZXQiLCJzaG91bGRBZGRPZmZzZXQiLCJhbGlnbm1lbnRPZmZzZXQiLCJjZW50ZXJPZmZzZXQiLCJnZXRQbGFjZW1lbnRMaXN0IiwiYWxpZ25tZW50IiwiYXV0b0FsaWdubWVudCIsImFsbG93ZWRQbGFjZW1lbnRzIiwiYWxsb3dlZFBsYWNlbWVudHNTb3J0ZWRCeUFsaWdubWVudCIsImF1dG9QbGFjZW1lbnQiLCJfbWlkZGxld2FyZURhdGEkYXV0b1AiLCJfbWlkZGxld2FyZURhdGEkYXV0b1AyIiwiX3BsYWNlbWVudHNUaGF0Rml0T25FIiwiY3Jvc3NBeGlzIiwiZGV0ZWN0T3ZlcmZsb3dPcHRpb25zIiwicGxhY2VtZW50cyQxIiwidW5kZWZpbmVkIiwib3ZlcmZsb3ciLCJjdXJyZW50SW5kZXgiLCJpbmRleCIsImN1cnJlbnRQbGFjZW1lbnQiLCJhbGlnbm1lbnRTaWRlcyIsImN1cnJlbnRPdmVyZmxvd3MiLCJhbGxPdmVyZmxvd3MiLCJvdmVyZmxvd3MiLCJuZXh0UGxhY2VtZW50IiwicGxhY2VtZW50c1NvcnRlZEJ5TW9zdFNwYWNlIiwibWFwIiwiZCIsInNsaWNlIiwicmVkdWNlIiwiYWNjIiwidiIsInNvcnQiLCJhIiwiYiIsInBsYWNlbWVudHNUaGF0Rml0T25FYWNoU2lkZSIsImV2ZXJ5IiwicmVzZXRQbGFjZW1lbnQiLCJmbGlwIiwiX21pZGRsZXdhcmVEYXRhJGFycm93IiwiX21pZGRsZXdhcmVEYXRhJGZsaXAiLCJtYWluQXhpcyIsImNoZWNrTWFpbkF4aXMiLCJjaGVja0Nyb3NzQXhpcyIsImZhbGxiYWNrUGxhY2VtZW50cyIsInNwZWNpZmllZEZhbGxiYWNrUGxhY2VtZW50cyIsImZhbGxiYWNrU3RyYXRlZ3kiLCJmYWxsYmFja0F4aXNTaWRlRGlyZWN0aW9uIiwiZmxpcEFsaWdubWVudCIsImluaXRpYWxTaWRlQXhpcyIsImlzQmFzZVBsYWNlbWVudCIsImhhc0ZhbGxiYWNrQXhpc1NpZGVEaXJlY3Rpb24iLCJwdXNoIiwib3ZlcmZsb3dzRGF0YSIsIl9taWRkbGV3YXJlRGF0YSRmbGlwMiIsIl9vdmVyZmxvd3NEYXRhJGZpbHRlciIsIm5leHRJbmRleCIsIl9vdmVyZmxvd3NEYXRhJGZpbHRlcjIiLCJjdXJyZW50U2lkZUF4aXMiLCJnZXRTaWRlT2Zmc2V0cyIsImlzQW55U2lkZUZ1bGx5Q2xpcHBlZCIsInNvbWUiLCJoaWRlIiwib2Zmc2V0cyIsInJlZmVyZW5jZUhpZGRlbk9mZnNldHMiLCJyZWZlcmVuY2VIaWRkZW4iLCJlc2NhcGVkT2Zmc2V0cyIsImVzY2FwZWQiLCJnZXRCb3VuZGluZ1JlY3QiLCJtaW5YIiwibWluWSIsIm1heFgiLCJtYXhZIiwiZ2V0UmVjdHNCeUxpbmUiLCJzb3J0ZWRSZWN0cyIsImdyb3VwcyIsInByZXZSZWN0IiwiaW5saW5lIiwibmF0aXZlQ2xpZW50UmVjdHMiLCJBcnJheSIsImZyb20iLCJnZXRDbGllbnRSZWN0cyIsImNsaWVudFJlY3RzIiwiZmFsbGJhY2siLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJmaW5kIiwiZmlyc3RSZWN0IiwibGFzdFJlY3QiLCJpc1RvcCIsImlzTGVmdFNpZGUiLCJtYXhSaWdodCIsIm1pbkxlZnQiLCJtZWFzdXJlUmVjdHMiLCJyZXNldFJlY3RzIiwiY29udmVydFZhbHVlVG9Db29yZHMiLCJtYWluQXhpc011bHRpIiwiaW5jbHVkZXMiLCJjcm9zc0F4aXNNdWx0aSIsInJhd1ZhbHVlIiwiX21pZGRsZXdhcmVEYXRhJG9mZnNlIiwiZGlmZkNvb3JkcyIsInNoaWZ0IiwibGltaXRlciIsIm1haW5BeGlzQ29vcmQiLCJjcm9zc0F4aXNDb29yZCIsIm1pblNpZGUiLCJtYXhTaWRlIiwibGltaXRlZENvb3JkcyIsImVuYWJsZWQiLCJsaW1pdFNoaWZ0IiwicmF3T2Zmc2V0IiwiY29tcHV0ZWRPZmZzZXQiLCJsZW4iLCJsaW1pdE1pbiIsImxpbWl0TWF4IiwiX21pZGRsZXdhcmVEYXRhJG9mZnNlMiIsImlzT3JpZ2luU2lkZSIsInNpemUiLCJfc3RhdGUkbWlkZGxld2FyZURhdGEiLCJfc3RhdGUkbWlkZGxld2FyZURhdGEyIiwiYXBwbHkiLCJoZWlnaHRTaWRlIiwid2lkdGhTaWRlIiwibWF4aW11bUNsaXBwaW5nSGVpZ2h0IiwibWF4aW11bUNsaXBwaW5nV2lkdGgiLCJvdmVyZmxvd0F2YWlsYWJsZUhlaWdodCIsIm92ZXJmbG93QXZhaWxhYmxlV2lkdGgiLCJub1NoaWZ0IiwiYXZhaWxhYmxlSGVpZ2h0IiwiYXZhaWxhYmxlV2lkdGgiLCJ4TWluIiwieE1heCIsInlNaW4iLCJ5TWF4IiwibmV4dERpbWVuc2lvbnMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../../../node_modules/@floating-ui/core/dist/floating-ui.core.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/../../../../node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs":
/*!**************************************************************************!*\
  !*** ../../../../node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs ***!
  \**************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   arrow: function() { return /* binding */ arrow; },\n/* harmony export */   autoPlacement: function() { return /* binding */ autoPlacement; },\n/* harmony export */   autoUpdate: function() { return /* binding */ autoUpdate; },\n/* harmony export */   computePosition: function() { return /* binding */ computePosition; },\n/* harmony export */   detectOverflow: function() { return /* binding */ detectOverflow; },\n/* harmony export */   flip: function() { return /* binding */ flip; },\n/* harmony export */   getOverflowAncestors: function() { return /* reexport safe */ _floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getOverflowAncestors; },\n/* harmony export */   hide: function() { return /* binding */ hide; },\n/* harmony export */   inline: function() { return /* binding */ inline; },\n/* harmony export */   limitShift: function() { return /* binding */ limitShift; },\n/* harmony export */   offset: function() { return /* binding */ offset; },\n/* harmony export */   platform: function() { return /* binding */ platform; },\n/* harmony export */   shift: function() { return /* binding */ shift; },\n/* harmony export */   size: function() { return /* binding */ size; }\n/* harmony export */ });\n/* harmony import */ var _floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @floating-ui/utils */ \"(app-pages-browser)/../../../../node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs\");\n/* harmony import */ var _floating_ui_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @floating-ui/core */ \"(app-pages-browser)/../../../../node_modules/@floating-ui/core/dist/floating-ui.core.mjs\");\n/* harmony import */ var _floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @floating-ui/utils/dom */ \"(app-pages-browser)/../../../../node_modules/@floating-ui/utils/dist/floating-ui.utils.dom.mjs\");\n\n\n\n\nfunction getCssDimensions(element) {\n    const css = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getComputedStyle)(element);\n    // In testing environments, the `width` and `height` properties are empty\n    // strings for SVG elements, returning NaN. Fallback to `0` in this case.\n    let width = parseFloat(css.width) || 0;\n    let height = parseFloat(css.height) || 0;\n    const hasOffset = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isHTMLElement)(element);\n    const offsetWidth = hasOffset ? element.offsetWidth : width;\n    const offsetHeight = hasOffset ? element.offsetHeight : height;\n    const shouldFallback = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.round)(width) !== offsetWidth || (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.round)(height) !== offsetHeight;\n    if (shouldFallback) {\n        width = offsetWidth;\n        height = offsetHeight;\n    }\n    return {\n        width,\n        height,\n        $: shouldFallback\n    };\n}\nfunction unwrapElement(element) {\n    return !(0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isElement)(element) ? element.contextElement : element;\n}\nfunction getScale(element) {\n    const domElement = unwrapElement(element);\n    if (!(0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isHTMLElement)(domElement)) {\n        return (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.createCoords)(1);\n    }\n    const rect = domElement.getBoundingClientRect();\n    const { width, height, $ } = getCssDimensions(domElement);\n    let x = ($ ? (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.round)(rect.width) : rect.width) / width;\n    let y = ($ ? (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.round)(rect.height) : rect.height) / height;\n    // 0, NaN, or Infinity should always fallback to 1.\n    if (!x || !Number.isFinite(x)) {\n        x = 1;\n    }\n    if (!y || !Number.isFinite(y)) {\n        y = 1;\n    }\n    return {\n        x,\n        y\n    };\n}\nconst noOffsets = /*#__PURE__*/ (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.createCoords)(0);\nfunction getVisualOffsets(element) {\n    const win = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getWindow)(element);\n    if (!(0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isWebKit)() || !win.visualViewport) {\n        return noOffsets;\n    }\n    return {\n        x: win.visualViewport.offsetLeft,\n        y: win.visualViewport.offsetTop\n    };\n}\nfunction shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {\n    if (isFixed === void 0) {\n        isFixed = false;\n    }\n    if (!floatingOffsetParent || isFixed && floatingOffsetParent !== (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getWindow)(element)) {\n        return false;\n    }\n    return isFixed;\n}\nfunction getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {\n    if (includeScale === void 0) {\n        includeScale = false;\n    }\n    if (isFixedStrategy === void 0) {\n        isFixedStrategy = false;\n    }\n    const clientRect = element.getBoundingClientRect();\n    const domElement = unwrapElement(element);\n    let scale = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.createCoords)(1);\n    if (includeScale) {\n        if (offsetParent) {\n            if ((0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isElement)(offsetParent)) {\n                scale = getScale(offsetParent);\n            }\n        } else {\n            scale = getScale(element);\n        }\n    }\n    const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.createCoords)(0);\n    let x = (clientRect.left + visualOffsets.x) / scale.x;\n    let y = (clientRect.top + visualOffsets.y) / scale.y;\n    let width = clientRect.width / scale.x;\n    let height = clientRect.height / scale.y;\n    if (domElement) {\n        const win = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getWindow)(domElement);\n        const offsetWin = offsetParent && (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isElement)(offsetParent) ? (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getWindow)(offsetParent) : offsetParent;\n        let currentWin = win;\n        let currentIFrame = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getFrameElement)(currentWin);\n        while(currentIFrame && offsetParent && offsetWin !== currentWin){\n            const iframeScale = getScale(currentIFrame);\n            const iframeRect = currentIFrame.getBoundingClientRect();\n            const css = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getComputedStyle)(currentIFrame);\n            const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;\n            const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;\n            x *= iframeScale.x;\n            y *= iframeScale.y;\n            width *= iframeScale.x;\n            height *= iframeScale.y;\n            x += left;\n            y += top;\n            currentWin = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getWindow)(currentIFrame);\n            currentIFrame = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getFrameElement)(currentWin);\n        }\n    }\n    return (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.rectToClientRect)({\n        width,\n        height,\n        x,\n        y\n    });\n}\n// If <html> has a CSS width greater than the viewport, then this will be\n// incorrect for RTL.\nfunction getWindowScrollBarX(element, rect) {\n    const leftScroll = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getNodeScroll)(element).scrollLeft;\n    if (!rect) {\n        return getBoundingClientRect((0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getDocumentElement)(element)).left + leftScroll;\n    }\n    return rect.left + leftScroll;\n}\nfunction getHTMLOffset(documentElement, scroll, ignoreScrollbarX) {\n    if (ignoreScrollbarX === void 0) {\n        ignoreScrollbarX = false;\n    }\n    const htmlRect = documentElement.getBoundingClientRect();\n    const x = htmlRect.left + scroll.scrollLeft - (ignoreScrollbarX ? 0 : // RTL <body> scrollbar.\n    getWindowScrollBarX(documentElement, htmlRect));\n    const y = htmlRect.top + scroll.scrollTop;\n    return {\n        x,\n        y\n    };\n}\nfunction convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {\n    let { elements, rect, offsetParent, strategy } = _ref;\n    const isFixed = strategy === \"fixed\";\n    const documentElement = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getDocumentElement)(offsetParent);\n    const topLayer = elements ? (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isTopLayer)(elements.floating) : false;\n    if (offsetParent === documentElement || topLayer && isFixed) {\n        return rect;\n    }\n    let scroll = {\n        scrollLeft: 0,\n        scrollTop: 0\n    };\n    let scale = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.createCoords)(1);\n    const offsets = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.createCoords)(0);\n    const isOffsetParentAnElement = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isHTMLElement)(offsetParent);\n    if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {\n        if ((0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getNodeName)(offsetParent) !== \"body\" || (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isOverflowElement)(documentElement)) {\n            scroll = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getNodeScroll)(offsetParent);\n        }\n        if ((0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isHTMLElement)(offsetParent)) {\n            const offsetRect = getBoundingClientRect(offsetParent);\n            scale = getScale(offsetParent);\n            offsets.x = offsetRect.x + offsetParent.clientLeft;\n            offsets.y = offsetRect.y + offsetParent.clientTop;\n        }\n    }\n    const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll, true) : (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.createCoords)(0);\n    return {\n        width: rect.width * scale.x,\n        height: rect.height * scale.y,\n        x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x + htmlOffset.x,\n        y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y + htmlOffset.y\n    };\n}\nfunction getClientRects(element) {\n    return Array.from(element.getClientRects());\n}\n// Gets the entire size of the scrollable document area, even extending outside\n// of the `<html>` and `<body>` rect bounds if horizontally scrollable.\nfunction getDocumentRect(element) {\n    const html = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getDocumentElement)(element);\n    const scroll = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getNodeScroll)(element);\n    const body = element.ownerDocument.body;\n    const width = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.max)(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);\n    const height = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.max)(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);\n    let x = -scroll.scrollLeft + getWindowScrollBarX(element);\n    const y = -scroll.scrollTop;\n    if ((0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getComputedStyle)(body).direction === \"rtl\") {\n        x += (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.max)(html.clientWidth, body.clientWidth) - width;\n    }\n    return {\n        width,\n        height,\n        x,\n        y\n    };\n}\nfunction getViewportRect(element, strategy) {\n    const win = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getWindow)(element);\n    const html = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getDocumentElement)(element);\n    const visualViewport = win.visualViewport;\n    let width = html.clientWidth;\n    let height = html.clientHeight;\n    let x = 0;\n    let y = 0;\n    if (visualViewport) {\n        width = visualViewport.width;\n        height = visualViewport.height;\n        const visualViewportBased = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isWebKit)();\n        if (!visualViewportBased || visualViewportBased && strategy === \"fixed\") {\n            x = visualViewport.offsetLeft;\n            y = visualViewport.offsetTop;\n        }\n    }\n    return {\n        width,\n        height,\n        x,\n        y\n    };\n}\n// Returns the inner client rect, subtracting scrollbars if present.\nfunction getInnerBoundingClientRect(element, strategy) {\n    const clientRect = getBoundingClientRect(element, true, strategy === \"fixed\");\n    const top = clientRect.top + element.clientTop;\n    const left = clientRect.left + element.clientLeft;\n    const scale = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isHTMLElement)(element) ? getScale(element) : (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.createCoords)(1);\n    const width = element.clientWidth * scale.x;\n    const height = element.clientHeight * scale.y;\n    const x = left * scale.x;\n    const y = top * scale.y;\n    return {\n        width,\n        height,\n        x,\n        y\n    };\n}\nfunction getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {\n    let rect;\n    if (clippingAncestor === \"viewport\") {\n        rect = getViewportRect(element, strategy);\n    } else if (clippingAncestor === \"document\") {\n        rect = getDocumentRect((0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getDocumentElement)(element));\n    } else if ((0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isElement)(clippingAncestor)) {\n        rect = getInnerBoundingClientRect(clippingAncestor, strategy);\n    } else {\n        const visualOffsets = getVisualOffsets(element);\n        rect = {\n            x: clippingAncestor.x - visualOffsets.x,\n            y: clippingAncestor.y - visualOffsets.y,\n            width: clippingAncestor.width,\n            height: clippingAncestor.height\n        };\n    }\n    return (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.rectToClientRect)(rect);\n}\nfunction hasFixedPositionAncestor(element, stopNode) {\n    const parentNode = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getParentNode)(element);\n    if (parentNode === stopNode || !(0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isElement)(parentNode) || (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isLastTraversableNode)(parentNode)) {\n        return false;\n    }\n    return (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getComputedStyle)(parentNode).position === \"fixed\" || hasFixedPositionAncestor(parentNode, stopNode);\n}\n// A \"clipping ancestor\" is an `overflow` element with the characteristic of\n// clipping (or hiding) child elements. This returns all clipping ancestors\n// of the given element up the tree.\nfunction getClippingElementAncestors(element, cache) {\n    const cachedResult = cache.get(element);\n    if (cachedResult) {\n        return cachedResult;\n    }\n    let result = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getOverflowAncestors)(element, [], false).filter((el)=>(0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isElement)(el) && (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getNodeName)(el) !== \"body\");\n    let currentContainingBlockComputedStyle = null;\n    const elementIsFixed = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getComputedStyle)(element).position === \"fixed\";\n    let currentNode = elementIsFixed ? (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getParentNode)(element) : element;\n    // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n    while((0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isElement)(currentNode) && !(0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isLastTraversableNode)(currentNode)){\n        const computedStyle = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getComputedStyle)(currentNode);\n        const currentNodeIsContaining = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isContainingBlock)(currentNode);\n        if (!currentNodeIsContaining && computedStyle.position === \"fixed\") {\n            currentContainingBlockComputedStyle = null;\n        }\n        const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === \"static\" && !!currentContainingBlockComputedStyle && [\n            \"absolute\",\n            \"fixed\"\n        ].includes(currentContainingBlockComputedStyle.position) || (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isOverflowElement)(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);\n        if (shouldDropCurrentNode) {\n            // Drop non-containing blocks.\n            result = result.filter((ancestor)=>ancestor !== currentNode);\n        } else {\n            // Record last containing block for next iteration.\n            currentContainingBlockComputedStyle = computedStyle;\n        }\n        currentNode = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getParentNode)(currentNode);\n    }\n    cache.set(element, result);\n    return result;\n}\n// Gets the maximum area that the element is visible in due to any number of\n// clipping ancestors.\nfunction getClippingRect(_ref) {\n    let { element, boundary, rootBoundary, strategy } = _ref;\n    const elementClippingAncestors = boundary === \"clippingAncestors\" ? (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isTopLayer)(element) ? [] : getClippingElementAncestors(element, this._c) : [].concat(boundary);\n    const clippingAncestors = [\n        ...elementClippingAncestors,\n        rootBoundary\n    ];\n    const firstClippingAncestor = clippingAncestors[0];\n    const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor)=>{\n        const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);\n        accRect.top = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.max)(rect.top, accRect.top);\n        accRect.right = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.min)(rect.right, accRect.right);\n        accRect.bottom = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.min)(rect.bottom, accRect.bottom);\n        accRect.left = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.max)(rect.left, accRect.left);\n        return accRect;\n    }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));\n    return {\n        width: clippingRect.right - clippingRect.left,\n        height: clippingRect.bottom - clippingRect.top,\n        x: clippingRect.left,\n        y: clippingRect.top\n    };\n}\nfunction getDimensions(element) {\n    const { width, height } = getCssDimensions(element);\n    return {\n        width,\n        height\n    };\n}\nfunction getRectRelativeToOffsetParent(element, offsetParent, strategy) {\n    const isOffsetParentAnElement = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isHTMLElement)(offsetParent);\n    const documentElement = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getDocumentElement)(offsetParent);\n    const isFixed = strategy === \"fixed\";\n    const rect = getBoundingClientRect(element, true, isFixed, offsetParent);\n    let scroll = {\n        scrollLeft: 0,\n        scrollTop: 0\n    };\n    const offsets = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.createCoords)(0);\n    if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {\n        if ((0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getNodeName)(offsetParent) !== \"body\" || (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isOverflowElement)(documentElement)) {\n            scroll = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getNodeScroll)(offsetParent);\n        }\n        if (isOffsetParentAnElement) {\n            const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);\n            offsets.x = offsetRect.x + offsetParent.clientLeft;\n            offsets.y = offsetRect.y + offsetParent.clientTop;\n        } else if (documentElement) {\n            // If the <body> scrollbar appears on the left (e.g. RTL systems). Use\n            // Firefox with layout.scrollbar.side = 3 in about:config to test this.\n            offsets.x = getWindowScrollBarX(documentElement);\n        }\n    }\n    const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll) : (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.createCoords)(0);\n    const x = rect.left + scroll.scrollLeft - offsets.x - htmlOffset.x;\n    const y = rect.top + scroll.scrollTop - offsets.y - htmlOffset.y;\n    return {\n        x,\n        y,\n        width: rect.width,\n        height: rect.height\n    };\n}\nfunction isStaticPositioned(element) {\n    return (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getComputedStyle)(element).position === \"static\";\n}\nfunction getTrueOffsetParent(element, polyfill) {\n    if (!(0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isHTMLElement)(element) || (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getComputedStyle)(element).position === \"fixed\") {\n        return null;\n    }\n    if (polyfill) {\n        return polyfill(element);\n    }\n    let rawOffsetParent = element.offsetParent;\n    // Firefox returns the <html> element as the offsetParent if it's non-static,\n    // while Chrome and Safari return the <body> element. The <body> element must\n    // be used to perform the correct calculations even if the <html> element is\n    // non-static.\n    if ((0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getDocumentElement)(element) === rawOffsetParent) {\n        rawOffsetParent = rawOffsetParent.ownerDocument.body;\n    }\n    return rawOffsetParent;\n}\n// Gets the closest ancestor positioned element. Handles some edge cases,\n// such as table ancestors and cross browser bugs.\nfunction getOffsetParent(element, polyfill) {\n    const win = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getWindow)(element);\n    if ((0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isTopLayer)(element)) {\n        return win;\n    }\n    if (!(0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isHTMLElement)(element)) {\n        let svgOffsetParent = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getParentNode)(element);\n        while(svgOffsetParent && !(0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isLastTraversableNode)(svgOffsetParent)){\n            if ((0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isElement)(svgOffsetParent) && !isStaticPositioned(svgOffsetParent)) {\n                return svgOffsetParent;\n            }\n            svgOffsetParent = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getParentNode)(svgOffsetParent);\n        }\n        return win;\n    }\n    let offsetParent = getTrueOffsetParent(element, polyfill);\n    while(offsetParent && (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isTableElement)(offsetParent) && isStaticPositioned(offsetParent)){\n        offsetParent = getTrueOffsetParent(offsetParent, polyfill);\n    }\n    if (offsetParent && (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isLastTraversableNode)(offsetParent) && isStaticPositioned(offsetParent) && !(0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isContainingBlock)(offsetParent)) {\n        return win;\n    }\n    return offsetParent || (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getContainingBlock)(element) || win;\n}\nconst getElementRects = async function(data) {\n    const getOffsetParentFn = this.getOffsetParent || getOffsetParent;\n    const getDimensionsFn = this.getDimensions;\n    const floatingDimensions = await getDimensionsFn(data.floating);\n    return {\n        reference: getRectRelativeToOffsetParent(data.reference, await getOffsetParentFn(data.floating), data.strategy),\n        floating: {\n            x: 0,\n            y: 0,\n            width: floatingDimensions.width,\n            height: floatingDimensions.height\n        }\n    };\n};\nfunction isRTL(element) {\n    return (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getComputedStyle)(element).direction === \"rtl\";\n}\nconst platform = {\n    convertOffsetParentRelativeRectToViewportRelativeRect,\n    getDocumentElement: _floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getDocumentElement,\n    getClippingRect,\n    getOffsetParent,\n    getElementRects,\n    getClientRects,\n    getDimensions,\n    getScale,\n    isElement: _floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isElement,\n    isRTL\n};\nfunction rectsAreEqual(a, b) {\n    return a.x === b.x && a.y === b.y && a.width === b.width && a.height === b.height;\n}\n// https://samthor.au/2021/observing-dom/\nfunction observeMove(element, onMove) {\n    let io = null;\n    let timeoutId;\n    const root = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getDocumentElement)(element);\n    function cleanup() {\n        var _io;\n        clearTimeout(timeoutId);\n        (_io = io) == null || _io.disconnect();\n        io = null;\n    }\n    function refresh(skip, threshold) {\n        if (skip === void 0) {\n            skip = false;\n        }\n        if (threshold === void 0) {\n            threshold = 1;\n        }\n        cleanup();\n        const elementRectForRootMargin = element.getBoundingClientRect();\n        const { left, top, width, height } = elementRectForRootMargin;\n        if (!skip) {\n            onMove();\n        }\n        if (!width || !height) {\n            return;\n        }\n        const insetTop = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.floor)(top);\n        const insetRight = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.floor)(root.clientWidth - (left + width));\n        const insetBottom = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.floor)(root.clientHeight - (top + height));\n        const insetLeft = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.floor)(left);\n        const rootMargin = -insetTop + \"px \" + -insetRight + \"px \" + -insetBottom + \"px \" + -insetLeft + \"px\";\n        const options = {\n            rootMargin,\n            threshold: (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.max)(0, (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.min)(1, threshold)) || 1\n        };\n        let isFirstUpdate = true;\n        function handleObserve(entries) {\n            const ratio = entries[0].intersectionRatio;\n            if (ratio !== threshold) {\n                if (!isFirstUpdate) {\n                    return refresh();\n                }\n                if (!ratio) {\n                    // If the reference is clipped, the ratio is 0. Throttle the refresh\n                    // to prevent an infinite loop of updates.\n                    timeoutId = setTimeout(()=>{\n                        refresh(false, 1e-7);\n                    }, 1000);\n                } else {\n                    refresh(false, ratio);\n                }\n            }\n            if (ratio === 1 && !rectsAreEqual(elementRectForRootMargin, element.getBoundingClientRect())) {\n                // It's possible that even though the ratio is reported as 1, the\n                // element is not actually fully within the IntersectionObserver's root\n                // area anymore. This can happen under performance constraints. This may\n                // be a bug in the browser's IntersectionObserver implementation. To\n                // work around this, we compare the element's bounding rect now with\n                // what it was at the time we created the IntersectionObserver. If they\n                // are not equal then the element moved, so we refresh.\n                refresh();\n            }\n            isFirstUpdate = false;\n        }\n        // Older browsers don't support a `document` as the root and will throw an\n        // error.\n        try {\n            io = new IntersectionObserver(handleObserve, {\n                ...options,\n                // Handle <iframe>s\n                root: root.ownerDocument\n            });\n        } catch (e) {\n            io = new IntersectionObserver(handleObserve, options);\n        }\n        io.observe(element);\n    }\n    refresh(true);\n    return cleanup;\n}\n/**\n * Automatically updates the position of the floating element when necessary.\n * Should only be called when the floating element is mounted on the DOM or\n * visible on the screen.\n * @returns cleanup function that should be invoked when the floating element is\n * removed from the DOM or hidden from the screen.\n * @see https://floating-ui.com/docs/autoUpdate\n */ function autoUpdate(reference, floating, update, options) {\n    if (options === void 0) {\n        options = {};\n    }\n    const { ancestorScroll = true, ancestorResize = true, elementResize = typeof ResizeObserver === \"function\", layoutShift = typeof IntersectionObserver === \"function\", animationFrame = false } = options;\n    const referenceEl = unwrapElement(reference);\n    const ancestors = ancestorScroll || ancestorResize ? [\n        ...referenceEl ? (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getOverflowAncestors)(referenceEl) : [],\n        ...(0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getOverflowAncestors)(floating)\n    ] : [];\n    ancestors.forEach((ancestor)=>{\n        ancestorScroll && ancestor.addEventListener(\"scroll\", update, {\n            passive: true\n        });\n        ancestorResize && ancestor.addEventListener(\"resize\", update);\n    });\n    const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;\n    let reobserveFrame = -1;\n    let resizeObserver = null;\n    if (elementResize) {\n        resizeObserver = new ResizeObserver((_ref)=>{\n            let [firstEntry] = _ref;\n            if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {\n                // Prevent update loops when using the `size` middleware.\n                // https://github.com/floating-ui/floating-ui/issues/1740\n                resizeObserver.unobserve(floating);\n                cancelAnimationFrame(reobserveFrame);\n                reobserveFrame = requestAnimationFrame(()=>{\n                    var _resizeObserver;\n                    (_resizeObserver = resizeObserver) == null || _resizeObserver.observe(floating);\n                });\n            }\n            update();\n        });\n        if (referenceEl && !animationFrame) {\n            resizeObserver.observe(referenceEl);\n        }\n        resizeObserver.observe(floating);\n    }\n    let frameId;\n    let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;\n    if (animationFrame) {\n        frameLoop();\n    }\n    function frameLoop() {\n        const nextRefRect = getBoundingClientRect(reference);\n        if (prevRefRect && !rectsAreEqual(prevRefRect, nextRefRect)) {\n            update();\n        }\n        prevRefRect = nextRefRect;\n        frameId = requestAnimationFrame(frameLoop);\n    }\n    update();\n    return ()=>{\n        var _resizeObserver2;\n        ancestors.forEach((ancestor)=>{\n            ancestorScroll && ancestor.removeEventListener(\"scroll\", update);\n            ancestorResize && ancestor.removeEventListener(\"resize\", update);\n        });\n        cleanupIo == null || cleanupIo();\n        (_resizeObserver2 = resizeObserver) == null || _resizeObserver2.disconnect();\n        resizeObserver = null;\n        if (animationFrame) {\n            cancelAnimationFrame(frameId);\n        }\n    };\n}\n/**\n * Resolves with an object of overflow side offsets that determine how much the\n * element is overflowing a given clipping boundary on each side.\n * - positive = overflowing the boundary by that number of pixels\n * - negative = how many pixels left before it will overflow\n * - 0 = lies flush with the boundary\n * @see https://floating-ui.com/docs/detectOverflow\n */ const detectOverflow = _floating_ui_core__WEBPACK_IMPORTED_MODULE_2__.detectOverflow;\n/**\n * Modifies the placement by translating the floating element along the\n * specified axes.\n * A number (shorthand for `mainAxis` or distance), or an axes configuration\n * object may be passed.\n * @see https://floating-ui.com/docs/offset\n */ const offset = _floating_ui_core__WEBPACK_IMPORTED_MODULE_2__.offset;\n/**\n * Optimizes the visibility of the floating element by choosing the placement\n * that has the most space available automatically, without needing to specify a\n * preferred placement. Alternative to `flip`.\n * @see https://floating-ui.com/docs/autoPlacement\n */ const autoPlacement = _floating_ui_core__WEBPACK_IMPORTED_MODULE_2__.autoPlacement;\n/**\n * Optimizes the visibility of the floating element by shifting it in order to\n * keep it in view when it will overflow the clipping boundary.\n * @see https://floating-ui.com/docs/shift\n */ const shift = _floating_ui_core__WEBPACK_IMPORTED_MODULE_2__.shift;\n/**\n * Optimizes the visibility of the floating element by flipping the `placement`\n * in order to keep it in view when the preferred placement(s) will overflow the\n * clipping boundary. Alternative to `autoPlacement`.\n * @see https://floating-ui.com/docs/flip\n */ const flip = _floating_ui_core__WEBPACK_IMPORTED_MODULE_2__.flip;\n/**\n * Provides data that allows you to change the size of the floating element \n * for instance, prevent it from overflowing the clipping boundary or match the\n * width of the reference element.\n * @see https://floating-ui.com/docs/size\n */ const size = _floating_ui_core__WEBPACK_IMPORTED_MODULE_2__.size;\n/**\n * Provides data to hide the floating element in applicable situations, such as\n * when it is not in the same clipping context as the reference element.\n * @see https://floating-ui.com/docs/hide\n */ const hide = _floating_ui_core__WEBPACK_IMPORTED_MODULE_2__.hide;\n/**\n * Provides data to position an inner element of the floating element so that it\n * appears centered to the reference element.\n * @see https://floating-ui.com/docs/arrow\n */ const arrow = _floating_ui_core__WEBPACK_IMPORTED_MODULE_2__.arrow;\n/**\n * Provides improved positioning for inline reference elements that can span\n * over multiple lines, such as hyperlinks or range selections.\n * @see https://floating-ui.com/docs/inline\n */ const inline = _floating_ui_core__WEBPACK_IMPORTED_MODULE_2__.inline;\n/**\n * Built-in `limiter` that will stop `shift()` at a certain point.\n */ const limitShift = _floating_ui_core__WEBPACK_IMPORTED_MODULE_2__.limitShift;\n/**\n * Computes the `x` and `y` coordinates that will place the floating element\n * next to a given reference element.\n */ const computePosition = (reference, floating, options)=>{\n    // This caches the expensive `getClippingElementAncestors` function so that\n    // multiple lifecycle resets re-use the same result. It only lives for a\n    // single call. If other functions become expensive, we can add them as well.\n    const cache = new Map();\n    const mergedOptions = {\n        platform,\n        ...options\n    };\n    const platformWithCache = {\n        ...mergedOptions.platform,\n        _c: cache\n    };\n    return (0,_floating_ui_core__WEBPACK_IMPORTED_MODULE_2__.computePosition)(reference, floating, {\n        ...mergedOptions,\n        platform: platformWithCache\n    });\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQGZsb2F0aW5nLXVpL2RvbS9kaXN0L2Zsb2F0aW5nLXVpLmRvbS5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBeVQ7QUFDL087QUFDa1A7QUFDOVA7QUFFOUQsU0FBUzZDLGlCQUFpQkMsT0FBTztJQUMvQixNQUFNQyxNQUFNbkIsd0VBQWdCQSxDQUFDa0I7SUFDN0IseUVBQXlFO0lBQ3pFLHlFQUF5RTtJQUN6RSxJQUFJRSxRQUFRQyxXQUFXRixJQUFJQyxLQUFLLEtBQUs7SUFDckMsSUFBSUUsU0FBU0QsV0FBV0YsSUFBSUcsTUFBTSxLQUFLO0lBQ3ZDLE1BQU1DLFlBQVl0QixxRUFBYUEsQ0FBQ2lCO0lBQ2hDLE1BQU1NLGNBQWNELFlBQVlMLFFBQVFNLFdBQVcsR0FBR0o7SUFDdEQsTUFBTUssZUFBZUYsWUFBWUwsUUFBUU8sWUFBWSxHQUFHSDtJQUN4RCxNQUFNSSxpQkFBaUIvQix5REFBS0EsQ0FBQ3lCLFdBQVdJLGVBQWU3Qix5REFBS0EsQ0FBQzJCLFlBQVlHO0lBQ3pFLElBQUlDLGdCQUFnQjtRQUNsQk4sUUFBUUk7UUFDUkYsU0FBU0c7SUFDWDtJQUNBLE9BQU87UUFDTEw7UUFDQUU7UUFDQUssR0FBR0Q7SUFDTDtBQUNGO0FBRUEsU0FBU0UsY0FBY1YsT0FBTztJQUM1QixPQUFPLENBQUNoQixpRUFBU0EsQ0FBQ2dCLFdBQVdBLFFBQVFXLGNBQWMsR0FBR1g7QUFDeEQ7QUFFQSxTQUFTWSxTQUFTWixPQUFPO0lBQ3ZCLE1BQU1hLGFBQWFILGNBQWNWO0lBQ2pDLElBQUksQ0FBQ2pCLHFFQUFhQSxDQUFDOEIsYUFBYTtRQUM5QixPQUFPbkMsZ0VBQVlBLENBQUM7SUFDdEI7SUFDQSxNQUFNb0MsT0FBT0QsV0FBV0UscUJBQXFCO0lBQzdDLE1BQU0sRUFDSmIsS0FBSyxFQUNMRSxNQUFNLEVBQ05LLENBQUMsRUFDRixHQUFHVixpQkFBaUJjO0lBQ3JCLElBQUlHLElBQUksQ0FBQ1AsSUFBSWhDLHlEQUFLQSxDQUFDcUMsS0FBS1osS0FBSyxJQUFJWSxLQUFLWixLQUFLLElBQUlBO0lBQy9DLElBQUllLElBQUksQ0FBQ1IsSUFBSWhDLHlEQUFLQSxDQUFDcUMsS0FBS1YsTUFBTSxJQUFJVSxLQUFLVixNQUFNLElBQUlBO0lBRWpELG1EQUFtRDtJQUVuRCxJQUFJLENBQUNZLEtBQUssQ0FBQ0UsT0FBT0MsUUFBUSxDQUFDSCxJQUFJO1FBQzdCQSxJQUFJO0lBQ047SUFDQSxJQUFJLENBQUNDLEtBQUssQ0FBQ0MsT0FBT0MsUUFBUSxDQUFDRixJQUFJO1FBQzdCQSxJQUFJO0lBQ047SUFDQSxPQUFPO1FBQ0xEO1FBQ0FDO0lBQ0Y7QUFDRjtBQUVBLE1BQU1HLFlBQVksV0FBVyxHQUFFMUMsZ0VBQVlBLENBQUM7QUFDNUMsU0FBUzJDLGlCQUFpQnJCLE9BQU87SUFDL0IsTUFBTXNCLE1BQU1yQyxpRUFBU0EsQ0FBQ2U7SUFDdEIsSUFBSSxDQUFDZCxnRUFBUUEsTUFBTSxDQUFDb0MsSUFBSUMsY0FBYyxFQUFFO1FBQ3RDLE9BQU9IO0lBQ1Q7SUFDQSxPQUFPO1FBQ0xKLEdBQUdNLElBQUlDLGNBQWMsQ0FBQ0MsVUFBVTtRQUNoQ1AsR0FBR0ssSUFBSUMsY0FBYyxDQUFDRSxTQUFTO0lBQ2pDO0FBQ0Y7QUFDQSxTQUFTQyx1QkFBdUIxQixPQUFPLEVBQUUyQixPQUFPLEVBQUVDLG9CQUFvQjtJQUNwRSxJQUFJRCxZQUFZLEtBQUssR0FBRztRQUN0QkEsVUFBVTtJQUNaO0lBQ0EsSUFBSSxDQUFDQyx3QkFBd0JELFdBQVdDLHlCQUF5QjNDLGlFQUFTQSxDQUFDZSxVQUFVO1FBQ25GLE9BQU87SUFDVDtJQUNBLE9BQU8yQjtBQUNUO0FBRUEsU0FBU1osc0JBQXNCZixPQUFPLEVBQUU2QixZQUFZLEVBQUVDLGVBQWUsRUFBRUMsWUFBWTtJQUNqRixJQUFJRixpQkFBaUIsS0FBSyxHQUFHO1FBQzNCQSxlQUFlO0lBQ2pCO0lBQ0EsSUFBSUMsb0JBQW9CLEtBQUssR0FBRztRQUM5QkEsa0JBQWtCO0lBQ3BCO0lBQ0EsTUFBTUUsYUFBYWhDLFFBQVFlLHFCQUFxQjtJQUNoRCxNQUFNRixhQUFhSCxjQUFjVjtJQUNqQyxJQUFJaUMsUUFBUXZELGdFQUFZQSxDQUFDO0lBQ3pCLElBQUltRCxjQUFjO1FBQ2hCLElBQUlFLGNBQWM7WUFDaEIsSUFBSS9DLGlFQUFTQSxDQUFDK0MsZUFBZTtnQkFDM0JFLFFBQVFyQixTQUFTbUI7WUFDbkI7UUFDRixPQUFPO1lBQ0xFLFFBQVFyQixTQUFTWjtRQUNuQjtJQUNGO0lBQ0EsTUFBTWtDLGdCQUFnQlIsdUJBQXVCYixZQUFZaUIsaUJBQWlCQyxnQkFBZ0JWLGlCQUFpQlIsY0FBY25DLGdFQUFZQSxDQUFDO0lBQ3RJLElBQUlzQyxJQUFJLENBQUNnQixXQUFXRyxJQUFJLEdBQUdELGNBQWNsQixDQUFDLElBQUlpQixNQUFNakIsQ0FBQztJQUNyRCxJQUFJQyxJQUFJLENBQUNlLFdBQVdJLEdBQUcsR0FBR0YsY0FBY2pCLENBQUMsSUFBSWdCLE1BQU1oQixDQUFDO0lBQ3BELElBQUlmLFFBQVE4QixXQUFXOUIsS0FBSyxHQUFHK0IsTUFBTWpCLENBQUM7SUFDdEMsSUFBSVosU0FBUzRCLFdBQVc1QixNQUFNLEdBQUc2QixNQUFNaEIsQ0FBQztJQUN4QyxJQUFJSixZQUFZO1FBQ2QsTUFBTVMsTUFBTXJDLGlFQUFTQSxDQUFDNEI7UUFDdEIsTUFBTXdCLFlBQVlOLGdCQUFnQi9DLGlFQUFTQSxDQUFDK0MsZ0JBQWdCOUMsaUVBQVNBLENBQUM4QyxnQkFBZ0JBO1FBQ3RGLElBQUlPLGFBQWFoQjtRQUNqQixJQUFJaUIsZ0JBQWdCcEQsdUVBQWVBLENBQUNtRDtRQUNwQyxNQUFPQyxpQkFBaUJSLGdCQUFnQk0sY0FBY0MsV0FBWTtZQUNoRSxNQUFNRSxjQUFjNUIsU0FBUzJCO1lBQzdCLE1BQU1FLGFBQWFGLGNBQWN4QixxQkFBcUI7WUFDdEQsTUFBTWQsTUFBTW5CLHdFQUFnQkEsQ0FBQ3lEO1lBQzdCLE1BQU1KLE9BQU9NLFdBQVdOLElBQUksR0FBRyxDQUFDSSxjQUFjRyxVQUFVLEdBQUd2QyxXQUFXRixJQUFJMEMsV0FBVyxLQUFLSCxZQUFZeEIsQ0FBQztZQUN2RyxNQUFNb0IsTUFBTUssV0FBV0wsR0FBRyxHQUFHLENBQUNHLGNBQWNLLFNBQVMsR0FBR3pDLFdBQVdGLElBQUk0QyxVQUFVLEtBQUtMLFlBQVl2QixDQUFDO1lBQ25HRCxLQUFLd0IsWUFBWXhCLENBQUM7WUFDbEJDLEtBQUt1QixZQUFZdkIsQ0FBQztZQUNsQmYsU0FBU3NDLFlBQVl4QixDQUFDO1lBQ3RCWixVQUFVb0MsWUFBWXZCLENBQUM7WUFDdkJELEtBQUttQjtZQUNMbEIsS0FBS21CO1lBQ0xFLGFBQWFyRCxpRUFBU0EsQ0FBQ3NEO1lBQ3ZCQSxnQkFBZ0JwRCx1RUFBZUEsQ0FBQ21EO1FBQ2xDO0lBQ0Y7SUFDQSxPQUFPcEYsb0VBQWdCQSxDQUFDO1FBQ3RCZ0Q7UUFDQUU7UUFDQVk7UUFDQUM7SUFDRjtBQUNGO0FBRUEseUVBQXlFO0FBQ3pFLHFCQUFxQjtBQUNyQixTQUFTNkIsb0JBQW9COUMsT0FBTyxFQUFFYyxJQUFJO0lBQ3hDLE1BQU1pQyxhQUFhM0QscUVBQWFBLENBQUNZLFNBQVNnRCxVQUFVO0lBQ3BELElBQUksQ0FBQ2xDLE1BQU07UUFDVCxPQUFPQyxzQkFBc0IxQiwwRUFBa0JBLENBQUNXLFVBQVVtQyxJQUFJLEdBQUdZO0lBQ25FO0lBQ0EsT0FBT2pDLEtBQUtxQixJQUFJLEdBQUdZO0FBQ3JCO0FBRUEsU0FBU0UsY0FBY0MsZUFBZSxFQUFFQyxNQUFNLEVBQUVDLGdCQUFnQjtJQUM5RCxJQUFJQSxxQkFBcUIsS0FBSyxHQUFHO1FBQy9CQSxtQkFBbUI7SUFDckI7SUFDQSxNQUFNQyxXQUFXSCxnQkFBZ0JuQyxxQkFBcUI7SUFDdEQsTUFBTUMsSUFBSXFDLFNBQVNsQixJQUFJLEdBQUdnQixPQUFPSCxVQUFVLEdBQUlJLENBQUFBLG1CQUFtQixJQUNsRSx3QkFBd0I7SUFDeEJOLG9CQUFvQkksaUJBQWlCRyxTQUFRO0lBQzdDLE1BQU1wQyxJQUFJb0MsU0FBU2pCLEdBQUcsR0FBR2UsT0FBT0csU0FBUztJQUN6QyxPQUFPO1FBQ0x0QztRQUNBQztJQUNGO0FBQ0Y7QUFFQSxTQUFTc0Msc0RBQXNEQyxJQUFJO0lBQ2pFLElBQUksRUFDRkMsUUFBUSxFQUNSM0MsSUFBSSxFQUNKaUIsWUFBWSxFQUNaMkIsUUFBUSxFQUNULEdBQUdGO0lBQ0osTUFBTTdCLFVBQVUrQixhQUFhO0lBQzdCLE1BQU1SLGtCQUFrQjdELDBFQUFrQkEsQ0FBQzBDO0lBQzNDLE1BQU00QixXQUFXRixXQUFXbkUsa0VBQVVBLENBQUNtRSxTQUFTRyxRQUFRLElBQUk7SUFDNUQsSUFBSTdCLGlCQUFpQm1CLG1CQUFtQlMsWUFBWWhDLFNBQVM7UUFDM0QsT0FBT2I7SUFDVDtJQUNBLElBQUlxQyxTQUFTO1FBQ1hILFlBQVk7UUFDWk0sV0FBVztJQUNiO0lBQ0EsSUFBSXJCLFFBQVF2RCxnRUFBWUEsQ0FBQztJQUN6QixNQUFNbUYsVUFBVW5GLGdFQUFZQSxDQUFDO0lBQzdCLE1BQU1vRiwwQkFBMEIvRSxxRUFBYUEsQ0FBQ2dEO0lBQzlDLElBQUkrQiwyQkFBMkIsQ0FBQ0EsMkJBQTJCLENBQUNuQyxTQUFTO1FBQ25FLElBQUlwQyxtRUFBV0EsQ0FBQ3dDLGtCQUFrQixVQUFVdkMseUVBQWlCQSxDQUFDMEQsa0JBQWtCO1lBQzlFQyxTQUFTL0QscUVBQWFBLENBQUMyQztRQUN6QjtRQUNBLElBQUloRCxxRUFBYUEsQ0FBQ2dELGVBQWU7WUFDL0IsTUFBTWdDLGFBQWFoRCxzQkFBc0JnQjtZQUN6Q0UsUUFBUXJCLFNBQVNtQjtZQUNqQjhCLFFBQVE3QyxDQUFDLEdBQUcrQyxXQUFXL0MsQ0FBQyxHQUFHZSxhQUFhVyxVQUFVO1lBQ2xEbUIsUUFBUTVDLENBQUMsR0FBRzhDLFdBQVc5QyxDQUFDLEdBQUdjLGFBQWFhLFNBQVM7UUFDbkQ7SUFDRjtJQUNBLE1BQU1vQixhQUFhZCxtQkFBbUIsQ0FBQ1ksMkJBQTJCLENBQUNuQyxVQUFVc0IsY0FBY0MsaUJBQWlCQyxRQUFRLFFBQVF6RSxnRUFBWUEsQ0FBQztJQUN6SSxPQUFPO1FBQ0x3QixPQUFPWSxLQUFLWixLQUFLLEdBQUcrQixNQUFNakIsQ0FBQztRQUMzQlosUUFBUVUsS0FBS1YsTUFBTSxHQUFHNkIsTUFBTWhCLENBQUM7UUFDN0JELEdBQUdGLEtBQUtFLENBQUMsR0FBR2lCLE1BQU1qQixDQUFDLEdBQUdtQyxPQUFPSCxVQUFVLEdBQUdmLE1BQU1qQixDQUFDLEdBQUc2QyxRQUFRN0MsQ0FBQyxHQUFHZ0QsV0FBV2hELENBQUM7UUFDNUVDLEdBQUdILEtBQUtHLENBQUMsR0FBR2dCLE1BQU1oQixDQUFDLEdBQUdrQyxPQUFPRyxTQUFTLEdBQUdyQixNQUFNaEIsQ0FBQyxHQUFHNEMsUUFBUTVDLENBQUMsR0FBRytDLFdBQVcvQyxDQUFDO0lBQzdFO0FBQ0Y7QUFFQSxTQUFTZ0QsZUFBZWpFLE9BQU87SUFDN0IsT0FBT2tFLE1BQU1DLElBQUksQ0FBQ25FLFFBQVFpRSxjQUFjO0FBQzFDO0FBRUEsK0VBQStFO0FBQy9FLHVFQUF1RTtBQUN2RSxTQUFTRyxnQkFBZ0JwRSxPQUFPO0lBQzlCLE1BQU1xRSxPQUFPaEYsMEVBQWtCQSxDQUFDVztJQUNoQyxNQUFNbUQsU0FBUy9ELHFFQUFhQSxDQUFDWTtJQUM3QixNQUFNc0UsT0FBT3RFLFFBQVF1RSxhQUFhLENBQUNELElBQUk7SUFDdkMsTUFBTXBFLFFBQVF2Qix1REFBR0EsQ0FBQzBGLEtBQUtHLFdBQVcsRUFBRUgsS0FBS0ksV0FBVyxFQUFFSCxLQUFLRSxXQUFXLEVBQUVGLEtBQUtHLFdBQVc7SUFDeEYsTUFBTXJFLFNBQVN6Qix1REFBR0EsQ0FBQzBGLEtBQUtLLFlBQVksRUFBRUwsS0FBS00sWUFBWSxFQUFFTCxLQUFLSSxZQUFZLEVBQUVKLEtBQUtLLFlBQVk7SUFDN0YsSUFBSTNELElBQUksQ0FBQ21DLE9BQU9ILFVBQVUsR0FBR0Ysb0JBQW9COUM7SUFDakQsTUFBTWlCLElBQUksQ0FBQ2tDLE9BQU9HLFNBQVM7SUFDM0IsSUFBSXhFLHdFQUFnQkEsQ0FBQ3dGLE1BQU1NLFNBQVMsS0FBSyxPQUFPO1FBQzlDNUQsS0FBS3JDLHVEQUFHQSxDQUFDMEYsS0FBS0ksV0FBVyxFQUFFSCxLQUFLRyxXQUFXLElBQUl2RTtJQUNqRDtJQUNBLE9BQU87UUFDTEE7UUFDQUU7UUFDQVk7UUFDQUM7SUFDRjtBQUNGO0FBRUEsU0FBUzRELGdCQUFnQjdFLE9BQU8sRUFBRTBELFFBQVE7SUFDeEMsTUFBTXBDLE1BQU1yQyxpRUFBU0EsQ0FBQ2U7SUFDdEIsTUFBTXFFLE9BQU9oRiwwRUFBa0JBLENBQUNXO0lBQ2hDLE1BQU11QixpQkFBaUJELElBQUlDLGNBQWM7SUFDekMsSUFBSXJCLFFBQVFtRSxLQUFLSSxXQUFXO0lBQzVCLElBQUlyRSxTQUFTaUUsS0FBS00sWUFBWTtJQUM5QixJQUFJM0QsSUFBSTtJQUNSLElBQUlDLElBQUk7SUFDUixJQUFJTSxnQkFBZ0I7UUFDbEJyQixRQUFRcUIsZUFBZXJCLEtBQUs7UUFDNUJFLFNBQVNtQixlQUFlbkIsTUFBTTtRQUM5QixNQUFNMEUsc0JBQXNCNUYsZ0VBQVFBO1FBQ3BDLElBQUksQ0FBQzRGLHVCQUF1QkEsdUJBQXVCcEIsYUFBYSxTQUFTO1lBQ3ZFMUMsSUFBSU8sZUFBZUMsVUFBVTtZQUM3QlAsSUFBSU0sZUFBZUUsU0FBUztRQUM5QjtJQUNGO0lBQ0EsT0FBTztRQUNMdkI7UUFDQUU7UUFDQVk7UUFDQUM7SUFDRjtBQUNGO0FBRUEsb0VBQW9FO0FBQ3BFLFNBQVM4RCwyQkFBMkIvRSxPQUFPLEVBQUUwRCxRQUFRO0lBQ25ELE1BQU0xQixhQUFhakIsc0JBQXNCZixTQUFTLE1BQU0wRCxhQUFhO0lBQ3JFLE1BQU10QixNQUFNSixXQUFXSSxHQUFHLEdBQUdwQyxRQUFRNEMsU0FBUztJQUM5QyxNQUFNVCxPQUFPSCxXQUFXRyxJQUFJLEdBQUduQyxRQUFRMEMsVUFBVTtJQUNqRCxNQUFNVCxRQUFRbEQscUVBQWFBLENBQUNpQixXQUFXWSxTQUFTWixXQUFXdEIsZ0VBQVlBLENBQUM7SUFDeEUsTUFBTXdCLFFBQVFGLFFBQVF5RSxXQUFXLEdBQUd4QyxNQUFNakIsQ0FBQztJQUMzQyxNQUFNWixTQUFTSixRQUFRMkUsWUFBWSxHQUFHMUMsTUFBTWhCLENBQUM7SUFDN0MsTUFBTUQsSUFBSW1CLE9BQU9GLE1BQU1qQixDQUFDO0lBQ3hCLE1BQU1DLElBQUltQixNQUFNSCxNQUFNaEIsQ0FBQztJQUN2QixPQUFPO1FBQ0xmO1FBQ0FFO1FBQ0FZO1FBQ0FDO0lBQ0Y7QUFDRjtBQUNBLFNBQVMrRCxrQ0FBa0NoRixPQUFPLEVBQUVpRixnQkFBZ0IsRUFBRXZCLFFBQVE7SUFDNUUsSUFBSTVDO0lBQ0osSUFBSW1FLHFCQUFxQixZQUFZO1FBQ25DbkUsT0FBTytELGdCQUFnQjdFLFNBQVMwRDtJQUNsQyxPQUFPLElBQUl1QixxQkFBcUIsWUFBWTtRQUMxQ25FLE9BQU9zRCxnQkFBZ0IvRSwwRUFBa0JBLENBQUNXO0lBQzVDLE9BQU8sSUFBSWhCLGlFQUFTQSxDQUFDaUcsbUJBQW1CO1FBQ3RDbkUsT0FBT2lFLDJCQUEyQkUsa0JBQWtCdkI7SUFDdEQsT0FBTztRQUNMLE1BQU14QixnQkFBZ0JiLGlCQUFpQnJCO1FBQ3ZDYyxPQUFPO1lBQ0xFLEdBQUdpRSxpQkFBaUJqRSxDQUFDLEdBQUdrQixjQUFjbEIsQ0FBQztZQUN2Q0MsR0FBR2dFLGlCQUFpQmhFLENBQUMsR0FBR2lCLGNBQWNqQixDQUFDO1lBQ3ZDZixPQUFPK0UsaUJBQWlCL0UsS0FBSztZQUM3QkUsUUFBUTZFLGlCQUFpQjdFLE1BQU07UUFDakM7SUFDRjtJQUNBLE9BQU9sRCxvRUFBZ0JBLENBQUM0RDtBQUMxQjtBQUNBLFNBQVNvRSx5QkFBeUJsRixPQUFPLEVBQUVtRixRQUFRO0lBQ2pELE1BQU1DLGFBQWExRixxRUFBYUEsQ0FBQ007SUFDakMsSUFBSW9GLGVBQWVELFlBQVksQ0FBQ25HLGlFQUFTQSxDQUFDb0csZUFBZXpGLDZFQUFxQkEsQ0FBQ3lGLGFBQWE7UUFDMUYsT0FBTztJQUNUO0lBQ0EsT0FBT3RHLHdFQUFnQkEsQ0FBQ3NHLFlBQVlDLFFBQVEsS0FBSyxXQUFXSCx5QkFBeUJFLFlBQVlEO0FBQ25HO0FBRUEsNEVBQTRFO0FBQzVFLDJFQUEyRTtBQUMzRSxvQ0FBb0M7QUFDcEMsU0FBU0csNEJBQTRCdEYsT0FBTyxFQUFFdUYsS0FBSztJQUNqRCxNQUFNQyxlQUFlRCxNQUFNRSxHQUFHLENBQUN6RjtJQUMvQixJQUFJd0YsY0FBYztRQUNoQixPQUFPQTtJQUNUO0lBQ0EsSUFBSUUsU0FBU2pHLDRFQUFvQkEsQ0FBQ08sU0FBUyxFQUFFLEVBQUUsT0FBTzJGLE1BQU0sQ0FBQ0MsQ0FBQUEsS0FBTTVHLGlFQUFTQSxDQUFDNEcsT0FBT3JHLG1FQUFXQSxDQUFDcUcsUUFBUTtJQUN4RyxJQUFJQyxzQ0FBc0M7SUFDMUMsTUFBTUMsaUJBQWlCaEgsd0VBQWdCQSxDQUFDa0IsU0FBU3FGLFFBQVEsS0FBSztJQUM5RCxJQUFJVSxjQUFjRCxpQkFBaUJwRyxxRUFBYUEsQ0FBQ00sV0FBV0E7SUFFNUQscUdBQXFHO0lBQ3JHLE1BQU9oQixpRUFBU0EsQ0FBQytHLGdCQUFnQixDQUFDcEcsNkVBQXFCQSxDQUFDb0csYUFBYztRQUNwRSxNQUFNQyxnQkFBZ0JsSCx3RUFBZ0JBLENBQUNpSDtRQUN2QyxNQUFNRSwwQkFBMEJyRyx5RUFBaUJBLENBQUNtRztRQUNsRCxJQUFJLENBQUNFLDJCQUEyQkQsY0FBY1gsUUFBUSxLQUFLLFNBQVM7WUFDbEVRLHNDQUFzQztRQUN4QztRQUNBLE1BQU1LLHdCQUF3QkosaUJBQWlCLENBQUNHLDJCQUEyQixDQUFDSixzQ0FBc0MsQ0FBQ0ksMkJBQTJCRCxjQUFjWCxRQUFRLEtBQUssWUFBWSxDQUFDLENBQUNRLHVDQUF1QztZQUFDO1lBQVk7U0FBUSxDQUFDTSxRQUFRLENBQUNOLG9DQUFvQ1IsUUFBUSxLQUFLN0YseUVBQWlCQSxDQUFDdUcsZ0JBQWdCLENBQUNFLDJCQUEyQmYseUJBQXlCbEYsU0FBUytGO1FBQzlZLElBQUlHLHVCQUF1QjtZQUN6Qiw4QkFBOEI7WUFDOUJSLFNBQVNBLE9BQU9DLE1BQU0sQ0FBQ1MsQ0FBQUEsV0FBWUEsYUFBYUw7UUFDbEQsT0FBTztZQUNMLG1EQUFtRDtZQUNuREYsc0NBQXNDRztRQUN4QztRQUNBRCxjQUFjckcscUVBQWFBLENBQUNxRztJQUM5QjtJQUNBUixNQUFNYyxHQUFHLENBQUNyRyxTQUFTMEY7SUFDbkIsT0FBT0E7QUFDVDtBQUVBLDRFQUE0RTtBQUM1RSxzQkFBc0I7QUFDdEIsU0FBU1ksZ0JBQWdCOUMsSUFBSTtJQUMzQixJQUFJLEVBQ0Z4RCxPQUFPLEVBQ1B1RyxRQUFRLEVBQ1JDLFlBQVksRUFDWjlDLFFBQVEsRUFDVCxHQUFHRjtJQUNKLE1BQU1pRCwyQkFBMkJGLGFBQWEsc0JBQXNCakgsa0VBQVVBLENBQUNVLFdBQVcsRUFBRSxHQUFHc0YsNEJBQTRCdEYsU0FBUyxJQUFJLENBQUMwRyxFQUFFLElBQUksRUFBRSxDQUFDQyxNQUFNLENBQUNKO0lBQ3pKLE1BQU1LLG9CQUFvQjtXQUFJSDtRQUEwQkQ7S0FBYTtJQUNyRSxNQUFNSyx3QkFBd0JELGlCQUFpQixDQUFDLEVBQUU7SUFDbEQsTUFBTUUsZUFBZUYsa0JBQWtCRyxNQUFNLENBQUMsQ0FBQ0MsU0FBUy9CO1FBQ3RELE1BQU1uRSxPQUFPa0Usa0NBQWtDaEYsU0FBU2lGLGtCQUFrQnZCO1FBQzFFc0QsUUFBUTVFLEdBQUcsR0FBR3pELHVEQUFHQSxDQUFDbUMsS0FBS3NCLEdBQUcsRUFBRTRFLFFBQVE1RSxHQUFHO1FBQ3ZDNEUsUUFBUUMsS0FBSyxHQUFHckksdURBQUdBLENBQUNrQyxLQUFLbUcsS0FBSyxFQUFFRCxRQUFRQyxLQUFLO1FBQzdDRCxRQUFRRSxNQUFNLEdBQUd0SSx1REFBR0EsQ0FBQ2tDLEtBQUtvRyxNQUFNLEVBQUVGLFFBQVFFLE1BQU07UUFDaERGLFFBQVE3RSxJQUFJLEdBQUd4RCx1REFBR0EsQ0FBQ21DLEtBQUtxQixJQUFJLEVBQUU2RSxRQUFRN0UsSUFBSTtRQUMxQyxPQUFPNkU7SUFDVCxHQUFHaEMsa0NBQWtDaEYsU0FBUzZHLHVCQUF1Qm5EO0lBQ3JFLE9BQU87UUFDTHhELE9BQU80RyxhQUFhRyxLQUFLLEdBQUdILGFBQWEzRSxJQUFJO1FBQzdDL0IsUUFBUTBHLGFBQWFJLE1BQU0sR0FBR0osYUFBYTFFLEdBQUc7UUFDOUNwQixHQUFHOEYsYUFBYTNFLElBQUk7UUFDcEJsQixHQUFHNkYsYUFBYTFFLEdBQUc7SUFDckI7QUFDRjtBQUVBLFNBQVMrRSxjQUFjbkgsT0FBTztJQUM1QixNQUFNLEVBQ0pFLEtBQUssRUFDTEUsTUFBTSxFQUNQLEdBQUdMLGlCQUFpQkM7SUFDckIsT0FBTztRQUNMRTtRQUNBRTtJQUNGO0FBQ0Y7QUFFQSxTQUFTZ0gsOEJBQThCcEgsT0FBTyxFQUFFK0IsWUFBWSxFQUFFMkIsUUFBUTtJQUNwRSxNQUFNSSwwQkFBMEIvRSxxRUFBYUEsQ0FBQ2dEO0lBQzlDLE1BQU1tQixrQkFBa0I3RCwwRUFBa0JBLENBQUMwQztJQUMzQyxNQUFNSixVQUFVK0IsYUFBYTtJQUM3QixNQUFNNUMsT0FBT0Msc0JBQXNCZixTQUFTLE1BQU0yQixTQUFTSTtJQUMzRCxJQUFJb0IsU0FBUztRQUNYSCxZQUFZO1FBQ1pNLFdBQVc7SUFDYjtJQUNBLE1BQU1PLFVBQVVuRixnRUFBWUEsQ0FBQztJQUM3QixJQUFJb0YsMkJBQTJCLENBQUNBLDJCQUEyQixDQUFDbkMsU0FBUztRQUNuRSxJQUFJcEMsbUVBQVdBLENBQUN3QyxrQkFBa0IsVUFBVXZDLHlFQUFpQkEsQ0FBQzBELGtCQUFrQjtZQUM5RUMsU0FBUy9ELHFFQUFhQSxDQUFDMkM7UUFDekI7UUFDQSxJQUFJK0IseUJBQXlCO1lBQzNCLE1BQU1DLGFBQWFoRCxzQkFBc0JnQixjQUFjLE1BQU1KLFNBQVNJO1lBQ3RFOEIsUUFBUTdDLENBQUMsR0FBRytDLFdBQVcvQyxDQUFDLEdBQUdlLGFBQWFXLFVBQVU7WUFDbERtQixRQUFRNUMsQ0FBQyxHQUFHOEMsV0FBVzlDLENBQUMsR0FBR2MsYUFBYWEsU0FBUztRQUNuRCxPQUFPLElBQUlNLGlCQUFpQjtZQUMxQixzRUFBc0U7WUFDdEUsdUVBQXVFO1lBQ3ZFVyxRQUFRN0MsQ0FBQyxHQUFHOEIsb0JBQW9CSTtRQUNsQztJQUNGO0lBQ0EsTUFBTWMsYUFBYWQsbUJBQW1CLENBQUNZLDJCQUEyQixDQUFDbkMsVUFBVXNCLGNBQWNDLGlCQUFpQkMsVUFBVXpFLGdFQUFZQSxDQUFDO0lBQ25JLE1BQU1zQyxJQUFJRixLQUFLcUIsSUFBSSxHQUFHZ0IsT0FBT0gsVUFBVSxHQUFHYSxRQUFRN0MsQ0FBQyxHQUFHZ0QsV0FBV2hELENBQUM7SUFDbEUsTUFBTUMsSUFBSUgsS0FBS3NCLEdBQUcsR0FBR2UsT0FBT0csU0FBUyxHQUFHTyxRQUFRNUMsQ0FBQyxHQUFHK0MsV0FBVy9DLENBQUM7SUFDaEUsT0FBTztRQUNMRDtRQUNBQztRQUNBZixPQUFPWSxLQUFLWixLQUFLO1FBQ2pCRSxRQUFRVSxLQUFLVixNQUFNO0lBQ3JCO0FBQ0Y7QUFFQSxTQUFTaUgsbUJBQW1CckgsT0FBTztJQUNqQyxPQUFPbEIsd0VBQWdCQSxDQUFDa0IsU0FBU3FGLFFBQVEsS0FBSztBQUNoRDtBQUVBLFNBQVNpQyxvQkFBb0J0SCxPQUFPLEVBQUV1SCxRQUFRO0lBQzVDLElBQUksQ0FBQ3hJLHFFQUFhQSxDQUFDaUIsWUFBWWxCLHdFQUFnQkEsQ0FBQ2tCLFNBQVNxRixRQUFRLEtBQUssU0FBUztRQUM3RSxPQUFPO0lBQ1Q7SUFDQSxJQUFJa0MsVUFBVTtRQUNaLE9BQU9BLFNBQVN2SDtJQUNsQjtJQUNBLElBQUl3SCxrQkFBa0J4SCxRQUFRK0IsWUFBWTtJQUUxQyw2RUFBNkU7SUFDN0UsNkVBQTZFO0lBQzdFLDRFQUE0RTtJQUM1RSxjQUFjO0lBQ2QsSUFBSTFDLDBFQUFrQkEsQ0FBQ1csYUFBYXdILGlCQUFpQjtRQUNuREEsa0JBQWtCQSxnQkFBZ0JqRCxhQUFhLENBQUNELElBQUk7SUFDdEQ7SUFDQSxPQUFPa0Q7QUFDVDtBQUVBLHlFQUF5RTtBQUN6RSxrREFBa0Q7QUFDbEQsU0FBU0MsZ0JBQWdCekgsT0FBTyxFQUFFdUgsUUFBUTtJQUN4QyxNQUFNakcsTUFBTXJDLGlFQUFTQSxDQUFDZTtJQUN0QixJQUFJVixrRUFBVUEsQ0FBQ1UsVUFBVTtRQUN2QixPQUFPc0I7SUFDVDtJQUNBLElBQUksQ0FBQ3ZDLHFFQUFhQSxDQUFDaUIsVUFBVTtRQUMzQixJQUFJMEgsa0JBQWtCaEkscUVBQWFBLENBQUNNO1FBQ3BDLE1BQU8wSCxtQkFBbUIsQ0FBQy9ILDZFQUFxQkEsQ0FBQytILGlCQUFrQjtZQUNqRSxJQUFJMUksaUVBQVNBLENBQUMwSSxvQkFBb0IsQ0FBQ0wsbUJBQW1CSyxrQkFBa0I7Z0JBQ3RFLE9BQU9BO1lBQ1Q7WUFDQUEsa0JBQWtCaEkscUVBQWFBLENBQUNnSTtRQUNsQztRQUNBLE9BQU9wRztJQUNUO0lBQ0EsSUFBSVMsZUFBZXVGLG9CQUFvQnRILFNBQVN1SDtJQUNoRCxNQUFPeEYsZ0JBQWdCbEMsc0VBQWNBLENBQUNrQyxpQkFBaUJzRixtQkFBbUJ0RixjQUFlO1FBQ3ZGQSxlQUFldUYsb0JBQW9CdkYsY0FBY3dGO0lBQ25EO0lBQ0EsSUFBSXhGLGdCQUFnQnBDLDZFQUFxQkEsQ0FBQ29DLGlCQUFpQnNGLG1CQUFtQnRGLGlCQUFpQixDQUFDbkMseUVBQWlCQSxDQUFDbUMsZUFBZTtRQUMvSCxPQUFPVDtJQUNUO0lBQ0EsT0FBT1MsZ0JBQWdCakMsMEVBQWtCQSxDQUFDRSxZQUFZc0I7QUFDeEQ7QUFFQSxNQUFNcUcsa0JBQWtCLGVBQWdCQyxJQUFJO0lBQzFDLE1BQU1DLG9CQUFvQixJQUFJLENBQUNKLGVBQWUsSUFBSUE7SUFDbEQsTUFBTUssa0JBQWtCLElBQUksQ0FBQ1gsYUFBYTtJQUMxQyxNQUFNWSxxQkFBcUIsTUFBTUQsZ0JBQWdCRixLQUFLaEUsUUFBUTtJQUM5RCxPQUFPO1FBQ0xvRSxXQUFXWiw4QkFBOEJRLEtBQUtJLFNBQVMsRUFBRSxNQUFNSCxrQkFBa0JELEtBQUtoRSxRQUFRLEdBQUdnRSxLQUFLbEUsUUFBUTtRQUM5R0UsVUFBVTtZQUNSNUMsR0FBRztZQUNIQyxHQUFHO1lBQ0hmLE9BQU82SCxtQkFBbUI3SCxLQUFLO1lBQy9CRSxRQUFRMkgsbUJBQW1CM0gsTUFBTTtRQUNuQztJQUNGO0FBQ0Y7QUFFQSxTQUFTNkgsTUFBTWpJLE9BQU87SUFDcEIsT0FBT2xCLHdFQUFnQkEsQ0FBQ2tCLFNBQVM0RSxTQUFTLEtBQUs7QUFDakQ7QUFFQSxNQUFNc0QsV0FBVztJQUNmM0U7SUFDQWxFLGtCQUFrQkEsd0VBQUFBO0lBQ2xCaUg7SUFDQW1CO0lBQ0FFO0lBQ0ExRDtJQUNBa0Q7SUFDQXZHO0lBQ0E1QixTQUFTQSwrREFBQUE7SUFDVGlKO0FBQ0Y7QUFFQSxTQUFTRSxjQUFjQyxDQUFDLEVBQUVDLENBQUM7SUFDekIsT0FBT0QsRUFBRXBILENBQUMsS0FBS3FILEVBQUVySCxDQUFDLElBQUlvSCxFQUFFbkgsQ0FBQyxLQUFLb0gsRUFBRXBILENBQUMsSUFBSW1ILEVBQUVsSSxLQUFLLEtBQUttSSxFQUFFbkksS0FBSyxJQUFJa0ksRUFBRWhJLE1BQU0sS0FBS2lJLEVBQUVqSSxNQUFNO0FBQ25GO0FBRUEseUNBQXlDO0FBQ3pDLFNBQVNrSSxZQUFZdEksT0FBTyxFQUFFdUksTUFBTTtJQUNsQyxJQUFJQyxLQUFLO0lBQ1QsSUFBSUM7SUFDSixNQUFNQyxPQUFPckosMEVBQWtCQSxDQUFDVztJQUNoQyxTQUFTMkk7UUFDUCxJQUFJQztRQUNKQyxhQUFhSjtRQUNaRyxDQUFBQSxNQUFNSixFQUFDLEtBQU0sUUFBUUksSUFBSUUsVUFBVTtRQUNwQ04sS0FBSztJQUNQO0lBQ0EsU0FBU08sUUFBUUMsSUFBSSxFQUFFQyxTQUFTO1FBQzlCLElBQUlELFNBQVMsS0FBSyxHQUFHO1lBQ25CQSxPQUFPO1FBQ1Q7UUFDQSxJQUFJQyxjQUFjLEtBQUssR0FBRztZQUN4QkEsWUFBWTtRQUNkO1FBQ0FOO1FBQ0EsTUFBTU8sMkJBQTJCbEosUUFBUWUscUJBQXFCO1FBQzlELE1BQU0sRUFDSm9CLElBQUksRUFDSkMsR0FBRyxFQUNIbEMsS0FBSyxFQUNMRSxNQUFNLEVBQ1AsR0FBRzhJO1FBQ0osSUFBSSxDQUFDRixNQUFNO1lBQ1RUO1FBQ0Y7UUFDQSxJQUFJLENBQUNySSxTQUFTLENBQUNFLFFBQVE7WUFDckI7UUFDRjtRQUNBLE1BQU0rSSxXQUFXdEsseURBQUtBLENBQUN1RDtRQUN2QixNQUFNZ0gsYUFBYXZLLHlEQUFLQSxDQUFDNkosS0FBS2pFLFdBQVcsR0FBSXRDLENBQUFBLE9BQU9qQyxLQUFJO1FBQ3hELE1BQU1tSixjQUFjeEsseURBQUtBLENBQUM2SixLQUFLL0QsWUFBWSxHQUFJdkMsQ0FBQUEsTUFBTWhDLE1BQUs7UUFDMUQsTUFBTWtKLFlBQVl6Syx5REFBS0EsQ0FBQ3NEO1FBQ3hCLE1BQU1vSCxhQUFhLENBQUNKLFdBQVcsUUFBUSxDQUFDQyxhQUFhLFFBQVEsQ0FBQ0MsY0FBYyxRQUFRLENBQUNDLFlBQVk7UUFDakcsTUFBTUUsVUFBVTtZQUNkRDtZQUNBTixXQUFXdEssdURBQUdBLENBQUMsR0FBR0MsdURBQUdBLENBQUMsR0FBR3FLLGVBQWU7UUFDMUM7UUFDQSxJQUFJUSxnQkFBZ0I7UUFDcEIsU0FBU0MsY0FBY0MsT0FBTztZQUM1QixNQUFNQyxRQUFRRCxPQUFPLENBQUMsRUFBRSxDQUFDRSxpQkFBaUI7WUFDMUMsSUFBSUQsVUFBVVgsV0FBVztnQkFDdkIsSUFBSSxDQUFDUSxlQUFlO29CQUNsQixPQUFPVjtnQkFDVDtnQkFDQSxJQUFJLENBQUNhLE9BQU87b0JBQ1Ysb0VBQW9FO29CQUNwRSwwQ0FBMEM7b0JBQzFDbkIsWUFBWXFCLFdBQVc7d0JBQ3JCZixRQUFRLE9BQU87b0JBQ2pCLEdBQUc7Z0JBQ0wsT0FBTztvQkFDTEEsUUFBUSxPQUFPYTtnQkFDakI7WUFDRjtZQUNBLElBQUlBLFVBQVUsS0FBSyxDQUFDekIsY0FBY2UsMEJBQTBCbEosUUFBUWUscUJBQXFCLEtBQUs7Z0JBQzVGLGlFQUFpRTtnQkFDakUsdUVBQXVFO2dCQUN2RSx3RUFBd0U7Z0JBQ3hFLG9FQUFvRTtnQkFDcEUsb0VBQW9FO2dCQUNwRSx1RUFBdUU7Z0JBQ3ZFLHVEQUF1RDtnQkFDdkRnSTtZQUNGO1lBQ0FVLGdCQUFnQjtRQUNsQjtRQUVBLDBFQUEwRTtRQUMxRSxTQUFTO1FBQ1QsSUFBSTtZQUNGakIsS0FBSyxJQUFJdUIscUJBQXFCTCxlQUFlO2dCQUMzQyxHQUFHRixPQUFPO2dCQUNWLG1CQUFtQjtnQkFDbkJkLE1BQU1BLEtBQUtuRSxhQUFhO1lBQzFCO1FBQ0YsRUFBRSxPQUFPeUYsR0FBRztZQUNWeEIsS0FBSyxJQUFJdUIscUJBQXFCTCxlQUFlRjtRQUMvQztRQUNBaEIsR0FBR3lCLE9BQU8sQ0FBQ2pLO0lBQ2I7SUFDQStJLFFBQVE7SUFDUixPQUFPSjtBQUNUO0FBRUE7Ozs7Ozs7Q0FPQyxHQUNELFNBQVN1QixXQUFXbEMsU0FBUyxFQUFFcEUsUUFBUSxFQUFFdUcsTUFBTSxFQUFFWCxPQUFPO0lBQ3RELElBQUlBLFlBQVksS0FBSyxHQUFHO1FBQ3RCQSxVQUFVLENBQUM7SUFDYjtJQUNBLE1BQU0sRUFDSlksaUJBQWlCLElBQUksRUFDckJDLGlCQUFpQixJQUFJLEVBQ3JCQyxnQkFBZ0IsT0FBT0MsbUJBQW1CLFVBQVUsRUFDcERDLGNBQWMsT0FBT1QseUJBQXlCLFVBQVUsRUFDeERVLGlCQUFpQixLQUFLLEVBQ3ZCLEdBQUdqQjtJQUNKLE1BQU1rQixjQUFjaEssY0FBY3NIO0lBQ2xDLE1BQU0yQyxZQUFZUCxrQkFBa0JDLGlCQUFpQjtXQUFLSyxjQUFjakwsNEVBQW9CQSxDQUFDaUwsZUFBZSxFQUFFO1dBQU1qTCw0RUFBb0JBLENBQUNtRTtLQUFVLEdBQUcsRUFBRTtJQUN4SitHLFVBQVVDLE9BQU8sQ0FBQ3hFLENBQUFBO1FBQ2hCZ0Usa0JBQWtCaEUsU0FBU3lFLGdCQUFnQixDQUFDLFVBQVVWLFFBQVE7WUFDNURXLFNBQVM7UUFDWDtRQUNBVCxrQkFBa0JqRSxTQUFTeUUsZ0JBQWdCLENBQUMsVUFBVVY7SUFDeEQ7SUFDQSxNQUFNWSxZQUFZTCxlQUFlRixjQUFjbEMsWUFBWW9DLGFBQWFQLFVBQVU7SUFDbEYsSUFBSWEsaUJBQWlCLENBQUM7SUFDdEIsSUFBSUMsaUJBQWlCO0lBQ3JCLElBQUlYLGVBQWU7UUFDakJXLGlCQUFpQixJQUFJVixlQUFlL0csQ0FBQUE7WUFDbEMsSUFBSSxDQUFDMEgsV0FBVyxHQUFHMUg7WUFDbkIsSUFBSTBILGNBQWNBLFdBQVdDLE1BQU0sS0FBS1QsZUFBZU8sZ0JBQWdCO2dCQUNyRSx5REFBeUQ7Z0JBQ3pELHlEQUF5RDtnQkFDekRBLGVBQWVHLFNBQVMsQ0FBQ3hIO2dCQUN6QnlILHFCQUFxQkw7Z0JBQ3JCQSxpQkFBaUJNLHNCQUFzQjtvQkFDckMsSUFBSUM7b0JBQ0hBLENBQUFBLGtCQUFrQk4sY0FBYSxLQUFNLFFBQVFNLGdCQUFnQnRCLE9BQU8sQ0FBQ3JHO2dCQUN4RTtZQUNGO1lBQ0F1RztRQUNGO1FBQ0EsSUFBSU8sZUFBZSxDQUFDRCxnQkFBZ0I7WUFDbENRLGVBQWVoQixPQUFPLENBQUNTO1FBQ3pCO1FBQ0FPLGVBQWVoQixPQUFPLENBQUNyRztJQUN6QjtJQUNBLElBQUk0SDtJQUNKLElBQUlDLGNBQWNoQixpQkFBaUIxSixzQkFBc0JpSCxhQUFhO0lBQ3RFLElBQUl5QyxnQkFBZ0I7UUFDbEJpQjtJQUNGO0lBQ0EsU0FBU0E7UUFDUCxNQUFNQyxjQUFjNUssc0JBQXNCaUg7UUFDMUMsSUFBSXlELGVBQWUsQ0FBQ3RELGNBQWNzRCxhQUFhRSxjQUFjO1lBQzNEeEI7UUFDRjtRQUNBc0IsY0FBY0U7UUFDZEgsVUFBVUYsc0JBQXNCSTtJQUNsQztJQUNBdkI7SUFDQSxPQUFPO1FBQ0wsSUFBSXlCO1FBQ0pqQixVQUFVQyxPQUFPLENBQUN4RSxDQUFBQTtZQUNoQmdFLGtCQUFrQmhFLFNBQVN5RixtQkFBbUIsQ0FBQyxVQUFVMUI7WUFDekRFLGtCQUFrQmpFLFNBQVN5RixtQkFBbUIsQ0FBQyxVQUFVMUI7UUFDM0Q7UUFDQVksYUFBYSxRQUFRQTtRQUNwQmEsQ0FBQUEsbUJBQW1CWCxjQUFhLEtBQU0sUUFBUVcsaUJBQWlCOUMsVUFBVTtRQUMxRW1DLGlCQUFpQjtRQUNqQixJQUFJUixnQkFBZ0I7WUFDbEJZLHFCQUFxQkc7UUFDdkI7SUFDRjtBQUNGO0FBRUE7Ozs7Ozs7Q0FPQyxHQUNELE1BQU1yTyxpQkFBaUJDLDZEQUFnQkE7QUFFdkM7Ozs7OztDQU1DLEdBQ0QsTUFBTUMsU0FBU0MscURBQVFBO0FBRXZCOzs7OztDQUtDLEdBQ0QsTUFBTUMsZ0JBQWdCQyw0REFBZUE7QUFFckM7Ozs7Q0FJQyxHQUNELE1BQU1DLFFBQVFDLG9EQUFPQTtBQUVyQjs7Ozs7Q0FLQyxHQUNELE1BQU1DLE9BQU9DLG1EQUFNQTtBQUVuQjs7Ozs7Q0FLQyxHQUNELE1BQU1DLE9BQU9DLG1EQUFNQTtBQUVuQjs7OztDQUlDLEdBQ0QsTUFBTUMsT0FBT0MsbURBQU1BO0FBRW5COzs7O0NBSUMsR0FDRCxNQUFNQyxRQUFRQyxvREFBT0E7QUFFckI7Ozs7Q0FJQyxHQUNELE1BQU1DLFNBQVNDLHFEQUFRQTtBQUV2Qjs7Q0FFQyxHQUNELE1BQU1DLGFBQWFDLHlEQUFZQTtBQUUvQjs7O0NBR0MsR0FDRCxNQUFNQyxrQkFBa0IsQ0FBQ3lKLFdBQVdwRSxVQUFVNEY7SUFDNUMsMkVBQTJFO0lBQzNFLHdFQUF3RTtJQUN4RSw2RUFBNkU7SUFDN0UsTUFBTWpFLFFBQVEsSUFBSXVHO0lBQ2xCLE1BQU1DLGdCQUFnQjtRQUNwQjdEO1FBQ0EsR0FBR3NCLE9BQU87SUFDWjtJQUNBLE1BQU13QyxvQkFBb0I7UUFDeEIsR0FBR0QsY0FBYzdELFFBQVE7UUFDekJ4QixJQUFJbkI7SUFDTjtJQUNBLE9BQU8vRyxrRUFBaUJBLENBQUN3SixXQUFXcEUsVUFBVTtRQUM1QyxHQUFHbUksYUFBYTtRQUNoQjdELFVBQVU4RDtJQUNaO0FBQ0Y7QUFFNEkiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AZmxvYXRpbmctdWkvZG9tL2Rpc3QvZmxvYXRpbmctdWkuZG9tLm1qcz83N2MxIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHJlY3RUb0NsaWVudFJlY3QsIGRldGVjdE92ZXJmbG93IGFzIGRldGVjdE92ZXJmbG93JDEsIG9mZnNldCBhcyBvZmZzZXQkMSwgYXV0b1BsYWNlbWVudCBhcyBhdXRvUGxhY2VtZW50JDEsIHNoaWZ0IGFzIHNoaWZ0JDEsIGZsaXAgYXMgZmxpcCQxLCBzaXplIGFzIHNpemUkMSwgaGlkZSBhcyBoaWRlJDEsIGFycm93IGFzIGFycm93JDEsIGlubGluZSBhcyBpbmxpbmUkMSwgbGltaXRTaGlmdCBhcyBsaW1pdFNoaWZ0JDEsIGNvbXB1dGVQb3NpdGlvbiBhcyBjb21wdXRlUG9zaXRpb24kMSB9IGZyb20gJ0BmbG9hdGluZy11aS9jb3JlJztcbmltcG9ydCB7IHJvdW5kLCBjcmVhdGVDb29yZHMsIG1heCwgbWluLCBmbG9vciB9IGZyb20gJ0BmbG9hdGluZy11aS91dGlscyc7XG5pbXBvcnQgeyBnZXRDb21wdXRlZFN0eWxlLCBpc0hUTUxFbGVtZW50LCBpc0VsZW1lbnQsIGdldFdpbmRvdywgaXNXZWJLaXQsIGdldEZyYW1lRWxlbWVudCwgZ2V0Tm9kZVNjcm9sbCwgZ2V0RG9jdW1lbnRFbGVtZW50LCBpc1RvcExheWVyLCBnZXROb2RlTmFtZSwgaXNPdmVyZmxvd0VsZW1lbnQsIGdldE92ZXJmbG93QW5jZXN0b3JzLCBnZXRQYXJlbnROb2RlLCBpc0xhc3RUcmF2ZXJzYWJsZU5vZGUsIGlzQ29udGFpbmluZ0Jsb2NrLCBpc1RhYmxlRWxlbWVudCwgZ2V0Q29udGFpbmluZ0Jsb2NrIH0gZnJvbSAnQGZsb2F0aW5nLXVpL3V0aWxzL2RvbSc7XG5leHBvcnQgeyBnZXRPdmVyZmxvd0FuY2VzdG9ycyB9IGZyb20gJ0BmbG9hdGluZy11aS91dGlscy9kb20nO1xuXG5mdW5jdGlvbiBnZXRDc3NEaW1lbnNpb25zKGVsZW1lbnQpIHtcbiAgY29uc3QgY3NzID0gZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KTtcbiAgLy8gSW4gdGVzdGluZyBlbnZpcm9ubWVudHMsIHRoZSBgd2lkdGhgIGFuZCBgaGVpZ2h0YCBwcm9wZXJ0aWVzIGFyZSBlbXB0eVxuICAvLyBzdHJpbmdzIGZvciBTVkcgZWxlbWVudHMsIHJldHVybmluZyBOYU4uIEZhbGxiYWNrIHRvIGAwYCBpbiB0aGlzIGNhc2UuXG4gIGxldCB3aWR0aCA9IHBhcnNlRmxvYXQoY3NzLndpZHRoKSB8fCAwO1xuICBsZXQgaGVpZ2h0ID0gcGFyc2VGbG9hdChjc3MuaGVpZ2h0KSB8fCAwO1xuICBjb25zdCBoYXNPZmZzZXQgPSBpc0hUTUxFbGVtZW50KGVsZW1lbnQpO1xuICBjb25zdCBvZmZzZXRXaWR0aCA9IGhhc09mZnNldCA/IGVsZW1lbnQub2Zmc2V0V2lkdGggOiB3aWR0aDtcbiAgY29uc3Qgb2Zmc2V0SGVpZ2h0ID0gaGFzT2Zmc2V0ID8gZWxlbWVudC5vZmZzZXRIZWlnaHQgOiBoZWlnaHQ7XG4gIGNvbnN0IHNob3VsZEZhbGxiYWNrID0gcm91bmQod2lkdGgpICE9PSBvZmZzZXRXaWR0aCB8fCByb3VuZChoZWlnaHQpICE9PSBvZmZzZXRIZWlnaHQ7XG4gIGlmIChzaG91bGRGYWxsYmFjaykge1xuICAgIHdpZHRoID0gb2Zmc2V0V2lkdGg7XG4gICAgaGVpZ2h0ID0gb2Zmc2V0SGVpZ2h0O1xuICB9XG4gIHJldHVybiB7XG4gICAgd2lkdGgsXG4gICAgaGVpZ2h0LFxuICAgICQ6IHNob3VsZEZhbGxiYWNrXG4gIH07XG59XG5cbmZ1bmN0aW9uIHVud3JhcEVsZW1lbnQoZWxlbWVudCkge1xuICByZXR1cm4gIWlzRWxlbWVudChlbGVtZW50KSA/IGVsZW1lbnQuY29udGV4dEVsZW1lbnQgOiBlbGVtZW50O1xufVxuXG5mdW5jdGlvbiBnZXRTY2FsZShlbGVtZW50KSB7XG4gIGNvbnN0IGRvbUVsZW1lbnQgPSB1bndyYXBFbGVtZW50KGVsZW1lbnQpO1xuICBpZiAoIWlzSFRNTEVsZW1lbnQoZG9tRWxlbWVudCkpIHtcbiAgICByZXR1cm4gY3JlYXRlQ29vcmRzKDEpO1xuICB9XG4gIGNvbnN0IHJlY3QgPSBkb21FbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICBjb25zdCB7XG4gICAgd2lkdGgsXG4gICAgaGVpZ2h0LFxuICAgICRcbiAgfSA9IGdldENzc0RpbWVuc2lvbnMoZG9tRWxlbWVudCk7XG4gIGxldCB4ID0gKCQgPyByb3VuZChyZWN0LndpZHRoKSA6IHJlY3Qud2lkdGgpIC8gd2lkdGg7XG4gIGxldCB5ID0gKCQgPyByb3VuZChyZWN0LmhlaWdodCkgOiByZWN0LmhlaWdodCkgLyBoZWlnaHQ7XG5cbiAgLy8gMCwgTmFOLCBvciBJbmZpbml0eSBzaG91bGQgYWx3YXlzIGZhbGxiYWNrIHRvIDEuXG5cbiAgaWYgKCF4IHx8ICFOdW1iZXIuaXNGaW5pdGUoeCkpIHtcbiAgICB4ID0gMTtcbiAgfVxuICBpZiAoIXkgfHwgIU51bWJlci5pc0Zpbml0ZSh5KSkge1xuICAgIHkgPSAxO1xuICB9XG4gIHJldHVybiB7XG4gICAgeCxcbiAgICB5XG4gIH07XG59XG5cbmNvbnN0IG5vT2Zmc2V0cyA9IC8qI19fUFVSRV9fKi9jcmVhdGVDb29yZHMoMCk7XG5mdW5jdGlvbiBnZXRWaXN1YWxPZmZzZXRzKGVsZW1lbnQpIHtcbiAgY29uc3Qgd2luID0gZ2V0V2luZG93KGVsZW1lbnQpO1xuICBpZiAoIWlzV2ViS2l0KCkgfHwgIXdpbi52aXN1YWxWaWV3cG9ydCkge1xuICAgIHJldHVybiBub09mZnNldHM7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB4OiB3aW4udmlzdWFsVmlld3BvcnQub2Zmc2V0TGVmdCxcbiAgICB5OiB3aW4udmlzdWFsVmlld3BvcnQub2Zmc2V0VG9wXG4gIH07XG59XG5mdW5jdGlvbiBzaG91bGRBZGRWaXN1YWxPZmZzZXRzKGVsZW1lbnQsIGlzRml4ZWQsIGZsb2F0aW5nT2Zmc2V0UGFyZW50KSB7XG4gIGlmIChpc0ZpeGVkID09PSB2b2lkIDApIHtcbiAgICBpc0ZpeGVkID0gZmFsc2U7XG4gIH1cbiAgaWYgKCFmbG9hdGluZ09mZnNldFBhcmVudCB8fCBpc0ZpeGVkICYmIGZsb2F0aW5nT2Zmc2V0UGFyZW50ICE9PSBnZXRXaW5kb3coZWxlbWVudCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIGlzRml4ZWQ7XG59XG5cbmZ1bmN0aW9uIGdldEJvdW5kaW5nQ2xpZW50UmVjdChlbGVtZW50LCBpbmNsdWRlU2NhbGUsIGlzRml4ZWRTdHJhdGVneSwgb2Zmc2V0UGFyZW50KSB7XG4gIGlmIChpbmNsdWRlU2NhbGUgPT09IHZvaWQgMCkge1xuICAgIGluY2x1ZGVTY2FsZSA9IGZhbHNlO1xuICB9XG4gIGlmIChpc0ZpeGVkU3RyYXRlZ3kgPT09IHZvaWQgMCkge1xuICAgIGlzRml4ZWRTdHJhdGVneSA9IGZhbHNlO1xuICB9XG4gIGNvbnN0IGNsaWVudFJlY3QgPSBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICBjb25zdCBkb21FbGVtZW50ID0gdW53cmFwRWxlbWVudChlbGVtZW50KTtcbiAgbGV0IHNjYWxlID0gY3JlYXRlQ29vcmRzKDEpO1xuICBpZiAoaW5jbHVkZVNjYWxlKSB7XG4gICAgaWYgKG9mZnNldFBhcmVudCkge1xuICAgICAgaWYgKGlzRWxlbWVudChvZmZzZXRQYXJlbnQpKSB7XG4gICAgICAgIHNjYWxlID0gZ2V0U2NhbGUob2Zmc2V0UGFyZW50KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc2NhbGUgPSBnZXRTY2FsZShlbGVtZW50KTtcbiAgICB9XG4gIH1cbiAgY29uc3QgdmlzdWFsT2Zmc2V0cyA9IHNob3VsZEFkZFZpc3VhbE9mZnNldHMoZG9tRWxlbWVudCwgaXNGaXhlZFN0cmF0ZWd5LCBvZmZzZXRQYXJlbnQpID8gZ2V0VmlzdWFsT2Zmc2V0cyhkb21FbGVtZW50KSA6IGNyZWF0ZUNvb3JkcygwKTtcbiAgbGV0IHggPSAoY2xpZW50UmVjdC5sZWZ0ICsgdmlzdWFsT2Zmc2V0cy54KSAvIHNjYWxlLng7XG4gIGxldCB5ID0gKGNsaWVudFJlY3QudG9wICsgdmlzdWFsT2Zmc2V0cy55KSAvIHNjYWxlLnk7XG4gIGxldCB3aWR0aCA9IGNsaWVudFJlY3Qud2lkdGggLyBzY2FsZS54O1xuICBsZXQgaGVpZ2h0ID0gY2xpZW50UmVjdC5oZWlnaHQgLyBzY2FsZS55O1xuICBpZiAoZG9tRWxlbWVudCkge1xuICAgIGNvbnN0IHdpbiA9IGdldFdpbmRvdyhkb21FbGVtZW50KTtcbiAgICBjb25zdCBvZmZzZXRXaW4gPSBvZmZzZXRQYXJlbnQgJiYgaXNFbGVtZW50KG9mZnNldFBhcmVudCkgPyBnZXRXaW5kb3cob2Zmc2V0UGFyZW50KSA6IG9mZnNldFBhcmVudDtcbiAgICBsZXQgY3VycmVudFdpbiA9IHdpbjtcbiAgICBsZXQgY3VycmVudElGcmFtZSA9IGdldEZyYW1lRWxlbWVudChjdXJyZW50V2luKTtcbiAgICB3aGlsZSAoY3VycmVudElGcmFtZSAmJiBvZmZzZXRQYXJlbnQgJiYgb2Zmc2V0V2luICE9PSBjdXJyZW50V2luKSB7XG4gICAgICBjb25zdCBpZnJhbWVTY2FsZSA9IGdldFNjYWxlKGN1cnJlbnRJRnJhbWUpO1xuICAgICAgY29uc3QgaWZyYW1lUmVjdCA9IGN1cnJlbnRJRnJhbWUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICBjb25zdCBjc3MgPSBnZXRDb21wdXRlZFN0eWxlKGN1cnJlbnRJRnJhbWUpO1xuICAgICAgY29uc3QgbGVmdCA9IGlmcmFtZVJlY3QubGVmdCArIChjdXJyZW50SUZyYW1lLmNsaWVudExlZnQgKyBwYXJzZUZsb2F0KGNzcy5wYWRkaW5nTGVmdCkpICogaWZyYW1lU2NhbGUueDtcbiAgICAgIGNvbnN0IHRvcCA9IGlmcmFtZVJlY3QudG9wICsgKGN1cnJlbnRJRnJhbWUuY2xpZW50VG9wICsgcGFyc2VGbG9hdChjc3MucGFkZGluZ1RvcCkpICogaWZyYW1lU2NhbGUueTtcbiAgICAgIHggKj0gaWZyYW1lU2NhbGUueDtcbiAgICAgIHkgKj0gaWZyYW1lU2NhbGUueTtcbiAgICAgIHdpZHRoICo9IGlmcmFtZVNjYWxlLng7XG4gICAgICBoZWlnaHQgKj0gaWZyYW1lU2NhbGUueTtcbiAgICAgIHggKz0gbGVmdDtcbiAgICAgIHkgKz0gdG9wO1xuICAgICAgY3VycmVudFdpbiA9IGdldFdpbmRvdyhjdXJyZW50SUZyYW1lKTtcbiAgICAgIGN1cnJlbnRJRnJhbWUgPSBnZXRGcmFtZUVsZW1lbnQoY3VycmVudFdpbik7XG4gICAgfVxuICB9XG4gIHJldHVybiByZWN0VG9DbGllbnRSZWN0KHtcbiAgICB3aWR0aCxcbiAgICBoZWlnaHQsXG4gICAgeCxcbiAgICB5XG4gIH0pO1xufVxuXG4vLyBJZiA8aHRtbD4gaGFzIGEgQ1NTIHdpZHRoIGdyZWF0ZXIgdGhhbiB0aGUgdmlld3BvcnQsIHRoZW4gdGhpcyB3aWxsIGJlXG4vLyBpbmNvcnJlY3QgZm9yIFJUTC5cbmZ1bmN0aW9uIGdldFdpbmRvd1Njcm9sbEJhclgoZWxlbWVudCwgcmVjdCkge1xuICBjb25zdCBsZWZ0U2Nyb2xsID0gZ2V0Tm9kZVNjcm9sbChlbGVtZW50KS5zY3JvbGxMZWZ0O1xuICBpZiAoIXJlY3QpIHtcbiAgICByZXR1cm4gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KGdldERvY3VtZW50RWxlbWVudChlbGVtZW50KSkubGVmdCArIGxlZnRTY3JvbGw7XG4gIH1cbiAgcmV0dXJuIHJlY3QubGVmdCArIGxlZnRTY3JvbGw7XG59XG5cbmZ1bmN0aW9uIGdldEhUTUxPZmZzZXQoZG9jdW1lbnRFbGVtZW50LCBzY3JvbGwsIGlnbm9yZVNjcm9sbGJhclgpIHtcbiAgaWYgKGlnbm9yZVNjcm9sbGJhclggPT09IHZvaWQgMCkge1xuICAgIGlnbm9yZVNjcm9sbGJhclggPSBmYWxzZTtcbiAgfVxuICBjb25zdCBodG1sUmVjdCA9IGRvY3VtZW50RWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgY29uc3QgeCA9IGh0bWxSZWN0LmxlZnQgKyBzY3JvbGwuc2Nyb2xsTGVmdCAtIChpZ25vcmVTY3JvbGxiYXJYID8gMCA6XG4gIC8vIFJUTCA8Ym9keT4gc2Nyb2xsYmFyLlxuICBnZXRXaW5kb3dTY3JvbGxCYXJYKGRvY3VtZW50RWxlbWVudCwgaHRtbFJlY3QpKTtcbiAgY29uc3QgeSA9IGh0bWxSZWN0LnRvcCArIHNjcm9sbC5zY3JvbGxUb3A7XG4gIHJldHVybiB7XG4gICAgeCxcbiAgICB5XG4gIH07XG59XG5cbmZ1bmN0aW9uIGNvbnZlcnRPZmZzZXRQYXJlbnRSZWxhdGl2ZVJlY3RUb1ZpZXdwb3J0UmVsYXRpdmVSZWN0KF9yZWYpIHtcbiAgbGV0IHtcbiAgICBlbGVtZW50cyxcbiAgICByZWN0LFxuICAgIG9mZnNldFBhcmVudCxcbiAgICBzdHJhdGVneVxuICB9ID0gX3JlZjtcbiAgY29uc3QgaXNGaXhlZCA9IHN0cmF0ZWd5ID09PSAnZml4ZWQnO1xuICBjb25zdCBkb2N1bWVudEVsZW1lbnQgPSBnZXREb2N1bWVudEVsZW1lbnQob2Zmc2V0UGFyZW50KTtcbiAgY29uc3QgdG9wTGF5ZXIgPSBlbGVtZW50cyA/IGlzVG9wTGF5ZXIoZWxlbWVudHMuZmxvYXRpbmcpIDogZmFsc2U7XG4gIGlmIChvZmZzZXRQYXJlbnQgPT09IGRvY3VtZW50RWxlbWVudCB8fCB0b3BMYXllciAmJiBpc0ZpeGVkKSB7XG4gICAgcmV0dXJuIHJlY3Q7XG4gIH1cbiAgbGV0IHNjcm9sbCA9IHtcbiAgICBzY3JvbGxMZWZ0OiAwLFxuICAgIHNjcm9sbFRvcDogMFxuICB9O1xuICBsZXQgc2NhbGUgPSBjcmVhdGVDb29yZHMoMSk7XG4gIGNvbnN0IG9mZnNldHMgPSBjcmVhdGVDb29yZHMoMCk7XG4gIGNvbnN0IGlzT2Zmc2V0UGFyZW50QW5FbGVtZW50ID0gaXNIVE1MRWxlbWVudChvZmZzZXRQYXJlbnQpO1xuICBpZiAoaXNPZmZzZXRQYXJlbnRBbkVsZW1lbnQgfHwgIWlzT2Zmc2V0UGFyZW50QW5FbGVtZW50ICYmICFpc0ZpeGVkKSB7XG4gICAgaWYgKGdldE5vZGVOYW1lKG9mZnNldFBhcmVudCkgIT09ICdib2R5JyB8fCBpc092ZXJmbG93RWxlbWVudChkb2N1bWVudEVsZW1lbnQpKSB7XG4gICAgICBzY3JvbGwgPSBnZXROb2RlU2Nyb2xsKG9mZnNldFBhcmVudCk7XG4gICAgfVxuICAgIGlmIChpc0hUTUxFbGVtZW50KG9mZnNldFBhcmVudCkpIHtcbiAgICAgIGNvbnN0IG9mZnNldFJlY3QgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3Qob2Zmc2V0UGFyZW50KTtcbiAgICAgIHNjYWxlID0gZ2V0U2NhbGUob2Zmc2V0UGFyZW50KTtcbiAgICAgIG9mZnNldHMueCA9IG9mZnNldFJlY3QueCArIG9mZnNldFBhcmVudC5jbGllbnRMZWZ0O1xuICAgICAgb2Zmc2V0cy55ID0gb2Zmc2V0UmVjdC55ICsgb2Zmc2V0UGFyZW50LmNsaWVudFRvcDtcbiAgICB9XG4gIH1cbiAgY29uc3QgaHRtbE9mZnNldCA9IGRvY3VtZW50RWxlbWVudCAmJiAhaXNPZmZzZXRQYXJlbnRBbkVsZW1lbnQgJiYgIWlzRml4ZWQgPyBnZXRIVE1MT2Zmc2V0KGRvY3VtZW50RWxlbWVudCwgc2Nyb2xsLCB0cnVlKSA6IGNyZWF0ZUNvb3JkcygwKTtcbiAgcmV0dXJuIHtcbiAgICB3aWR0aDogcmVjdC53aWR0aCAqIHNjYWxlLngsXG4gICAgaGVpZ2h0OiByZWN0LmhlaWdodCAqIHNjYWxlLnksXG4gICAgeDogcmVjdC54ICogc2NhbGUueCAtIHNjcm9sbC5zY3JvbGxMZWZ0ICogc2NhbGUueCArIG9mZnNldHMueCArIGh0bWxPZmZzZXQueCxcbiAgICB5OiByZWN0LnkgKiBzY2FsZS55IC0gc2Nyb2xsLnNjcm9sbFRvcCAqIHNjYWxlLnkgKyBvZmZzZXRzLnkgKyBodG1sT2Zmc2V0LnlcbiAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0Q2xpZW50UmVjdHMoZWxlbWVudCkge1xuICByZXR1cm4gQXJyYXkuZnJvbShlbGVtZW50LmdldENsaWVudFJlY3RzKCkpO1xufVxuXG4vLyBHZXRzIHRoZSBlbnRpcmUgc2l6ZSBvZiB0aGUgc2Nyb2xsYWJsZSBkb2N1bWVudCBhcmVhLCBldmVuIGV4dGVuZGluZyBvdXRzaWRlXG4vLyBvZiB0aGUgYDxodG1sPmAgYW5kIGA8Ym9keT5gIHJlY3QgYm91bmRzIGlmIGhvcml6b250YWxseSBzY3JvbGxhYmxlLlxuZnVuY3Rpb24gZ2V0RG9jdW1lbnRSZWN0KGVsZW1lbnQpIHtcbiAgY29uc3QgaHRtbCA9IGdldERvY3VtZW50RWxlbWVudChlbGVtZW50KTtcbiAgY29uc3Qgc2Nyb2xsID0gZ2V0Tm9kZVNjcm9sbChlbGVtZW50KTtcbiAgY29uc3QgYm9keSA9IGVsZW1lbnQub3duZXJEb2N1bWVudC5ib2R5O1xuICBjb25zdCB3aWR0aCA9IG1heChodG1sLnNjcm9sbFdpZHRoLCBodG1sLmNsaWVudFdpZHRoLCBib2R5LnNjcm9sbFdpZHRoLCBib2R5LmNsaWVudFdpZHRoKTtcbiAgY29uc3QgaGVpZ2h0ID0gbWF4KGh0bWwuc2Nyb2xsSGVpZ2h0LCBodG1sLmNsaWVudEhlaWdodCwgYm9keS5zY3JvbGxIZWlnaHQsIGJvZHkuY2xpZW50SGVpZ2h0KTtcbiAgbGV0IHggPSAtc2Nyb2xsLnNjcm9sbExlZnQgKyBnZXRXaW5kb3dTY3JvbGxCYXJYKGVsZW1lbnQpO1xuICBjb25zdCB5ID0gLXNjcm9sbC5zY3JvbGxUb3A7XG4gIGlmIChnZXRDb21wdXRlZFN0eWxlKGJvZHkpLmRpcmVjdGlvbiA9PT0gJ3J0bCcpIHtcbiAgICB4ICs9IG1heChodG1sLmNsaWVudFdpZHRoLCBib2R5LmNsaWVudFdpZHRoKSAtIHdpZHRoO1xuICB9XG4gIHJldHVybiB7XG4gICAgd2lkdGgsXG4gICAgaGVpZ2h0LFxuICAgIHgsXG4gICAgeVxuICB9O1xufVxuXG5mdW5jdGlvbiBnZXRWaWV3cG9ydFJlY3QoZWxlbWVudCwgc3RyYXRlZ3kpIHtcbiAgY29uc3Qgd2luID0gZ2V0V2luZG93KGVsZW1lbnQpO1xuICBjb25zdCBodG1sID0gZ2V0RG9jdW1lbnRFbGVtZW50KGVsZW1lbnQpO1xuICBjb25zdCB2aXN1YWxWaWV3cG9ydCA9IHdpbi52aXN1YWxWaWV3cG9ydDtcbiAgbGV0IHdpZHRoID0gaHRtbC5jbGllbnRXaWR0aDtcbiAgbGV0IGhlaWdodCA9IGh0bWwuY2xpZW50SGVpZ2h0O1xuICBsZXQgeCA9IDA7XG4gIGxldCB5ID0gMDtcbiAgaWYgKHZpc3VhbFZpZXdwb3J0KSB7XG4gICAgd2lkdGggPSB2aXN1YWxWaWV3cG9ydC53aWR0aDtcbiAgICBoZWlnaHQgPSB2aXN1YWxWaWV3cG9ydC5oZWlnaHQ7XG4gICAgY29uc3QgdmlzdWFsVmlld3BvcnRCYXNlZCA9IGlzV2ViS2l0KCk7XG4gICAgaWYgKCF2aXN1YWxWaWV3cG9ydEJhc2VkIHx8IHZpc3VhbFZpZXdwb3J0QmFzZWQgJiYgc3RyYXRlZ3kgPT09ICdmaXhlZCcpIHtcbiAgICAgIHggPSB2aXN1YWxWaWV3cG9ydC5vZmZzZXRMZWZ0O1xuICAgICAgeSA9IHZpc3VhbFZpZXdwb3J0Lm9mZnNldFRvcDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB3aWR0aCxcbiAgICBoZWlnaHQsXG4gICAgeCxcbiAgICB5XG4gIH07XG59XG5cbi8vIFJldHVybnMgdGhlIGlubmVyIGNsaWVudCByZWN0LCBzdWJ0cmFjdGluZyBzY3JvbGxiYXJzIGlmIHByZXNlbnQuXG5mdW5jdGlvbiBnZXRJbm5lckJvdW5kaW5nQ2xpZW50UmVjdChlbGVtZW50LCBzdHJhdGVneSkge1xuICBjb25zdCBjbGllbnRSZWN0ID0gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KGVsZW1lbnQsIHRydWUsIHN0cmF0ZWd5ID09PSAnZml4ZWQnKTtcbiAgY29uc3QgdG9wID0gY2xpZW50UmVjdC50b3AgKyBlbGVtZW50LmNsaWVudFRvcDtcbiAgY29uc3QgbGVmdCA9IGNsaWVudFJlY3QubGVmdCArIGVsZW1lbnQuY2xpZW50TGVmdDtcbiAgY29uc3Qgc2NhbGUgPSBpc0hUTUxFbGVtZW50KGVsZW1lbnQpID8gZ2V0U2NhbGUoZWxlbWVudCkgOiBjcmVhdGVDb29yZHMoMSk7XG4gIGNvbnN0IHdpZHRoID0gZWxlbWVudC5jbGllbnRXaWR0aCAqIHNjYWxlLng7XG4gIGNvbnN0IGhlaWdodCA9IGVsZW1lbnQuY2xpZW50SGVpZ2h0ICogc2NhbGUueTtcbiAgY29uc3QgeCA9IGxlZnQgKiBzY2FsZS54O1xuICBjb25zdCB5ID0gdG9wICogc2NhbGUueTtcbiAgcmV0dXJuIHtcbiAgICB3aWR0aCxcbiAgICBoZWlnaHQsXG4gICAgeCxcbiAgICB5XG4gIH07XG59XG5mdW5jdGlvbiBnZXRDbGllbnRSZWN0RnJvbUNsaXBwaW5nQW5jZXN0b3IoZWxlbWVudCwgY2xpcHBpbmdBbmNlc3Rvciwgc3RyYXRlZ3kpIHtcbiAgbGV0IHJlY3Q7XG4gIGlmIChjbGlwcGluZ0FuY2VzdG9yID09PSAndmlld3BvcnQnKSB7XG4gICAgcmVjdCA9IGdldFZpZXdwb3J0UmVjdChlbGVtZW50LCBzdHJhdGVneSk7XG4gIH0gZWxzZSBpZiAoY2xpcHBpbmdBbmNlc3RvciA9PT0gJ2RvY3VtZW50Jykge1xuICAgIHJlY3QgPSBnZXREb2N1bWVudFJlY3QoZ2V0RG9jdW1lbnRFbGVtZW50KGVsZW1lbnQpKTtcbiAgfSBlbHNlIGlmIChpc0VsZW1lbnQoY2xpcHBpbmdBbmNlc3RvcikpIHtcbiAgICByZWN0ID0gZ2V0SW5uZXJCb3VuZGluZ0NsaWVudFJlY3QoY2xpcHBpbmdBbmNlc3Rvciwgc3RyYXRlZ3kpO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IHZpc3VhbE9mZnNldHMgPSBnZXRWaXN1YWxPZmZzZXRzKGVsZW1lbnQpO1xuICAgIHJlY3QgPSB7XG4gICAgICB4OiBjbGlwcGluZ0FuY2VzdG9yLnggLSB2aXN1YWxPZmZzZXRzLngsXG4gICAgICB5OiBjbGlwcGluZ0FuY2VzdG9yLnkgLSB2aXN1YWxPZmZzZXRzLnksXG4gICAgICB3aWR0aDogY2xpcHBpbmdBbmNlc3Rvci53aWR0aCxcbiAgICAgIGhlaWdodDogY2xpcHBpbmdBbmNlc3Rvci5oZWlnaHRcbiAgICB9O1xuICB9XG4gIHJldHVybiByZWN0VG9DbGllbnRSZWN0KHJlY3QpO1xufVxuZnVuY3Rpb24gaGFzRml4ZWRQb3NpdGlvbkFuY2VzdG9yKGVsZW1lbnQsIHN0b3BOb2RlKSB7XG4gIGNvbnN0IHBhcmVudE5vZGUgPSBnZXRQYXJlbnROb2RlKGVsZW1lbnQpO1xuICBpZiAocGFyZW50Tm9kZSA9PT0gc3RvcE5vZGUgfHwgIWlzRWxlbWVudChwYXJlbnROb2RlKSB8fCBpc0xhc3RUcmF2ZXJzYWJsZU5vZGUocGFyZW50Tm9kZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIGdldENvbXB1dGVkU3R5bGUocGFyZW50Tm9kZSkucG9zaXRpb24gPT09ICdmaXhlZCcgfHwgaGFzRml4ZWRQb3NpdGlvbkFuY2VzdG9yKHBhcmVudE5vZGUsIHN0b3BOb2RlKTtcbn1cblxuLy8gQSBcImNsaXBwaW5nIGFuY2VzdG9yXCIgaXMgYW4gYG92ZXJmbG93YCBlbGVtZW50IHdpdGggdGhlIGNoYXJhY3RlcmlzdGljIG9mXG4vLyBjbGlwcGluZyAob3IgaGlkaW5nKSBjaGlsZCBlbGVtZW50cy4gVGhpcyByZXR1cm5zIGFsbCBjbGlwcGluZyBhbmNlc3RvcnNcbi8vIG9mIHRoZSBnaXZlbiBlbGVtZW50IHVwIHRoZSB0cmVlLlxuZnVuY3Rpb24gZ2V0Q2xpcHBpbmdFbGVtZW50QW5jZXN0b3JzKGVsZW1lbnQsIGNhY2hlKSB7XG4gIGNvbnN0IGNhY2hlZFJlc3VsdCA9IGNhY2hlLmdldChlbGVtZW50KTtcbiAgaWYgKGNhY2hlZFJlc3VsdCkge1xuICAgIHJldHVybiBjYWNoZWRSZXN1bHQ7XG4gIH1cbiAgbGV0IHJlc3VsdCA9IGdldE92ZXJmbG93QW5jZXN0b3JzKGVsZW1lbnQsIFtdLCBmYWxzZSkuZmlsdGVyKGVsID0+IGlzRWxlbWVudChlbCkgJiYgZ2V0Tm9kZU5hbWUoZWwpICE9PSAnYm9keScpO1xuICBsZXQgY3VycmVudENvbnRhaW5pbmdCbG9ja0NvbXB1dGVkU3R5bGUgPSBudWxsO1xuICBjb25zdCBlbGVtZW50SXNGaXhlZCA9IGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCkucG9zaXRpb24gPT09ICdmaXhlZCc7XG4gIGxldCBjdXJyZW50Tm9kZSA9IGVsZW1lbnRJc0ZpeGVkID8gZ2V0UGFyZW50Tm9kZShlbGVtZW50KSA6IGVsZW1lbnQ7XG5cbiAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQ1NTL0NvbnRhaW5pbmdfYmxvY2sjaWRlbnRpZnlpbmdfdGhlX2NvbnRhaW5pbmdfYmxvY2tcbiAgd2hpbGUgKGlzRWxlbWVudChjdXJyZW50Tm9kZSkgJiYgIWlzTGFzdFRyYXZlcnNhYmxlTm9kZShjdXJyZW50Tm9kZSkpIHtcbiAgICBjb25zdCBjb21wdXRlZFN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShjdXJyZW50Tm9kZSk7XG4gICAgY29uc3QgY3VycmVudE5vZGVJc0NvbnRhaW5pbmcgPSBpc0NvbnRhaW5pbmdCbG9jayhjdXJyZW50Tm9kZSk7XG4gICAgaWYgKCFjdXJyZW50Tm9kZUlzQ29udGFpbmluZyAmJiBjb21wdXRlZFN0eWxlLnBvc2l0aW9uID09PSAnZml4ZWQnKSB7XG4gICAgICBjdXJyZW50Q29udGFpbmluZ0Jsb2NrQ29tcHV0ZWRTdHlsZSA9IG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHNob3VsZERyb3BDdXJyZW50Tm9kZSA9IGVsZW1lbnRJc0ZpeGVkID8gIWN1cnJlbnROb2RlSXNDb250YWluaW5nICYmICFjdXJyZW50Q29udGFpbmluZ0Jsb2NrQ29tcHV0ZWRTdHlsZSA6ICFjdXJyZW50Tm9kZUlzQ29udGFpbmluZyAmJiBjb21wdXRlZFN0eWxlLnBvc2l0aW9uID09PSAnc3RhdGljJyAmJiAhIWN1cnJlbnRDb250YWluaW5nQmxvY2tDb21wdXRlZFN0eWxlICYmIFsnYWJzb2x1dGUnLCAnZml4ZWQnXS5pbmNsdWRlcyhjdXJyZW50Q29udGFpbmluZ0Jsb2NrQ29tcHV0ZWRTdHlsZS5wb3NpdGlvbikgfHwgaXNPdmVyZmxvd0VsZW1lbnQoY3VycmVudE5vZGUpICYmICFjdXJyZW50Tm9kZUlzQ29udGFpbmluZyAmJiBoYXNGaXhlZFBvc2l0aW9uQW5jZXN0b3IoZWxlbWVudCwgY3VycmVudE5vZGUpO1xuICAgIGlmIChzaG91bGREcm9wQ3VycmVudE5vZGUpIHtcbiAgICAgIC8vIERyb3Agbm9uLWNvbnRhaW5pbmcgYmxvY2tzLlxuICAgICAgcmVzdWx0ID0gcmVzdWx0LmZpbHRlcihhbmNlc3RvciA9PiBhbmNlc3RvciAhPT0gY3VycmVudE5vZGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBSZWNvcmQgbGFzdCBjb250YWluaW5nIGJsb2NrIGZvciBuZXh0IGl0ZXJhdGlvbi5cbiAgICAgIGN1cnJlbnRDb250YWluaW5nQmxvY2tDb21wdXRlZFN0eWxlID0gY29tcHV0ZWRTdHlsZTtcbiAgICB9XG4gICAgY3VycmVudE5vZGUgPSBnZXRQYXJlbnROb2RlKGN1cnJlbnROb2RlKTtcbiAgfVxuICBjYWNoZS5zZXQoZWxlbWVudCwgcmVzdWx0KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLy8gR2V0cyB0aGUgbWF4aW11bSBhcmVhIHRoYXQgdGhlIGVsZW1lbnQgaXMgdmlzaWJsZSBpbiBkdWUgdG8gYW55IG51bWJlciBvZlxuLy8gY2xpcHBpbmcgYW5jZXN0b3JzLlxuZnVuY3Rpb24gZ2V0Q2xpcHBpbmdSZWN0KF9yZWYpIHtcbiAgbGV0IHtcbiAgICBlbGVtZW50LFxuICAgIGJvdW5kYXJ5LFxuICAgIHJvb3RCb3VuZGFyeSxcbiAgICBzdHJhdGVneVxuICB9ID0gX3JlZjtcbiAgY29uc3QgZWxlbWVudENsaXBwaW5nQW5jZXN0b3JzID0gYm91bmRhcnkgPT09ICdjbGlwcGluZ0FuY2VzdG9ycycgPyBpc1RvcExheWVyKGVsZW1lbnQpID8gW10gOiBnZXRDbGlwcGluZ0VsZW1lbnRBbmNlc3RvcnMoZWxlbWVudCwgdGhpcy5fYykgOiBbXS5jb25jYXQoYm91bmRhcnkpO1xuICBjb25zdCBjbGlwcGluZ0FuY2VzdG9ycyA9IFsuLi5lbGVtZW50Q2xpcHBpbmdBbmNlc3RvcnMsIHJvb3RCb3VuZGFyeV07XG4gIGNvbnN0IGZpcnN0Q2xpcHBpbmdBbmNlc3RvciA9IGNsaXBwaW5nQW5jZXN0b3JzWzBdO1xuICBjb25zdCBjbGlwcGluZ1JlY3QgPSBjbGlwcGluZ0FuY2VzdG9ycy5yZWR1Y2UoKGFjY1JlY3QsIGNsaXBwaW5nQW5jZXN0b3IpID0+IHtcbiAgICBjb25zdCByZWN0ID0gZ2V0Q2xpZW50UmVjdEZyb21DbGlwcGluZ0FuY2VzdG9yKGVsZW1lbnQsIGNsaXBwaW5nQW5jZXN0b3IsIHN0cmF0ZWd5KTtcbiAgICBhY2NSZWN0LnRvcCA9IG1heChyZWN0LnRvcCwgYWNjUmVjdC50b3ApO1xuICAgIGFjY1JlY3QucmlnaHQgPSBtaW4ocmVjdC5yaWdodCwgYWNjUmVjdC5yaWdodCk7XG4gICAgYWNjUmVjdC5ib3R0b20gPSBtaW4ocmVjdC5ib3R0b20sIGFjY1JlY3QuYm90dG9tKTtcbiAgICBhY2NSZWN0LmxlZnQgPSBtYXgocmVjdC5sZWZ0LCBhY2NSZWN0LmxlZnQpO1xuICAgIHJldHVybiBhY2NSZWN0O1xuICB9LCBnZXRDbGllbnRSZWN0RnJvbUNsaXBwaW5nQW5jZXN0b3IoZWxlbWVudCwgZmlyc3RDbGlwcGluZ0FuY2VzdG9yLCBzdHJhdGVneSkpO1xuICByZXR1cm4ge1xuICAgIHdpZHRoOiBjbGlwcGluZ1JlY3QucmlnaHQgLSBjbGlwcGluZ1JlY3QubGVmdCxcbiAgICBoZWlnaHQ6IGNsaXBwaW5nUmVjdC5ib3R0b20gLSBjbGlwcGluZ1JlY3QudG9wLFxuICAgIHg6IGNsaXBwaW5nUmVjdC5sZWZ0LFxuICAgIHk6IGNsaXBwaW5nUmVjdC50b3BcbiAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0RGltZW5zaW9ucyhlbGVtZW50KSB7XG4gIGNvbnN0IHtcbiAgICB3aWR0aCxcbiAgICBoZWlnaHRcbiAgfSA9IGdldENzc0RpbWVuc2lvbnMoZWxlbWVudCk7XG4gIHJldHVybiB7XG4gICAgd2lkdGgsXG4gICAgaGVpZ2h0XG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldFJlY3RSZWxhdGl2ZVRvT2Zmc2V0UGFyZW50KGVsZW1lbnQsIG9mZnNldFBhcmVudCwgc3RyYXRlZ3kpIHtcbiAgY29uc3QgaXNPZmZzZXRQYXJlbnRBbkVsZW1lbnQgPSBpc0hUTUxFbGVtZW50KG9mZnNldFBhcmVudCk7XG4gIGNvbnN0IGRvY3VtZW50RWxlbWVudCA9IGdldERvY3VtZW50RWxlbWVudChvZmZzZXRQYXJlbnQpO1xuICBjb25zdCBpc0ZpeGVkID0gc3RyYXRlZ3kgPT09ICdmaXhlZCc7XG4gIGNvbnN0IHJlY3QgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3QoZWxlbWVudCwgdHJ1ZSwgaXNGaXhlZCwgb2Zmc2V0UGFyZW50KTtcbiAgbGV0IHNjcm9sbCA9IHtcbiAgICBzY3JvbGxMZWZ0OiAwLFxuICAgIHNjcm9sbFRvcDogMFxuICB9O1xuICBjb25zdCBvZmZzZXRzID0gY3JlYXRlQ29vcmRzKDApO1xuICBpZiAoaXNPZmZzZXRQYXJlbnRBbkVsZW1lbnQgfHwgIWlzT2Zmc2V0UGFyZW50QW5FbGVtZW50ICYmICFpc0ZpeGVkKSB7XG4gICAgaWYgKGdldE5vZGVOYW1lKG9mZnNldFBhcmVudCkgIT09ICdib2R5JyB8fCBpc092ZXJmbG93RWxlbWVudChkb2N1bWVudEVsZW1lbnQpKSB7XG4gICAgICBzY3JvbGwgPSBnZXROb2RlU2Nyb2xsKG9mZnNldFBhcmVudCk7XG4gICAgfVxuICAgIGlmIChpc09mZnNldFBhcmVudEFuRWxlbWVudCkge1xuICAgICAgY29uc3Qgb2Zmc2V0UmVjdCA9IGdldEJvdW5kaW5nQ2xpZW50UmVjdChvZmZzZXRQYXJlbnQsIHRydWUsIGlzRml4ZWQsIG9mZnNldFBhcmVudCk7XG4gICAgICBvZmZzZXRzLnggPSBvZmZzZXRSZWN0LnggKyBvZmZzZXRQYXJlbnQuY2xpZW50TGVmdDtcbiAgICAgIG9mZnNldHMueSA9IG9mZnNldFJlY3QueSArIG9mZnNldFBhcmVudC5jbGllbnRUb3A7XG4gICAgfSBlbHNlIGlmIChkb2N1bWVudEVsZW1lbnQpIHtcbiAgICAgIC8vIElmIHRoZSA8Ym9keT4gc2Nyb2xsYmFyIGFwcGVhcnMgb24gdGhlIGxlZnQgKGUuZy4gUlRMIHN5c3RlbXMpLiBVc2VcbiAgICAgIC8vIEZpcmVmb3ggd2l0aCBsYXlvdXQuc2Nyb2xsYmFyLnNpZGUgPSAzIGluIGFib3V0OmNvbmZpZyB0byB0ZXN0IHRoaXMuXG4gICAgICBvZmZzZXRzLnggPSBnZXRXaW5kb3dTY3JvbGxCYXJYKGRvY3VtZW50RWxlbWVudCk7XG4gICAgfVxuICB9XG4gIGNvbnN0IGh0bWxPZmZzZXQgPSBkb2N1bWVudEVsZW1lbnQgJiYgIWlzT2Zmc2V0UGFyZW50QW5FbGVtZW50ICYmICFpc0ZpeGVkID8gZ2V0SFRNTE9mZnNldChkb2N1bWVudEVsZW1lbnQsIHNjcm9sbCkgOiBjcmVhdGVDb29yZHMoMCk7XG4gIGNvbnN0IHggPSByZWN0LmxlZnQgKyBzY3JvbGwuc2Nyb2xsTGVmdCAtIG9mZnNldHMueCAtIGh0bWxPZmZzZXQueDtcbiAgY29uc3QgeSA9IHJlY3QudG9wICsgc2Nyb2xsLnNjcm9sbFRvcCAtIG9mZnNldHMueSAtIGh0bWxPZmZzZXQueTtcbiAgcmV0dXJuIHtcbiAgICB4LFxuICAgIHksXG4gICAgd2lkdGg6IHJlY3Qud2lkdGgsXG4gICAgaGVpZ2h0OiByZWN0LmhlaWdodFxuICB9O1xufVxuXG5mdW5jdGlvbiBpc1N0YXRpY1Bvc2l0aW9uZWQoZWxlbWVudCkge1xuICByZXR1cm4gZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KS5wb3NpdGlvbiA9PT0gJ3N0YXRpYyc7XG59XG5cbmZ1bmN0aW9uIGdldFRydWVPZmZzZXRQYXJlbnQoZWxlbWVudCwgcG9seWZpbGwpIHtcbiAgaWYgKCFpc0hUTUxFbGVtZW50KGVsZW1lbnQpIHx8IGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCkucG9zaXRpb24gPT09ICdmaXhlZCcpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBpZiAocG9seWZpbGwpIHtcbiAgICByZXR1cm4gcG9seWZpbGwoZWxlbWVudCk7XG4gIH1cbiAgbGV0IHJhd09mZnNldFBhcmVudCA9IGVsZW1lbnQub2Zmc2V0UGFyZW50O1xuXG4gIC8vIEZpcmVmb3ggcmV0dXJucyB0aGUgPGh0bWw+IGVsZW1lbnQgYXMgdGhlIG9mZnNldFBhcmVudCBpZiBpdCdzIG5vbi1zdGF0aWMsXG4gIC8vIHdoaWxlIENocm9tZSBhbmQgU2FmYXJpIHJldHVybiB0aGUgPGJvZHk+IGVsZW1lbnQuIFRoZSA8Ym9keT4gZWxlbWVudCBtdXN0XG4gIC8vIGJlIHVzZWQgdG8gcGVyZm9ybSB0aGUgY29ycmVjdCBjYWxjdWxhdGlvbnMgZXZlbiBpZiB0aGUgPGh0bWw+IGVsZW1lbnQgaXNcbiAgLy8gbm9uLXN0YXRpYy5cbiAgaWYgKGdldERvY3VtZW50RWxlbWVudChlbGVtZW50KSA9PT0gcmF3T2Zmc2V0UGFyZW50KSB7XG4gICAgcmF3T2Zmc2V0UGFyZW50ID0gcmF3T2Zmc2V0UGFyZW50Lm93bmVyRG9jdW1lbnQuYm9keTtcbiAgfVxuICByZXR1cm4gcmF3T2Zmc2V0UGFyZW50O1xufVxuXG4vLyBHZXRzIHRoZSBjbG9zZXN0IGFuY2VzdG9yIHBvc2l0aW9uZWQgZWxlbWVudC4gSGFuZGxlcyBzb21lIGVkZ2UgY2FzZXMsXG4vLyBzdWNoIGFzIHRhYmxlIGFuY2VzdG9ycyBhbmQgY3Jvc3MgYnJvd3NlciBidWdzLlxuZnVuY3Rpb24gZ2V0T2Zmc2V0UGFyZW50KGVsZW1lbnQsIHBvbHlmaWxsKSB7XG4gIGNvbnN0IHdpbiA9IGdldFdpbmRvdyhlbGVtZW50KTtcbiAgaWYgKGlzVG9wTGF5ZXIoZWxlbWVudCkpIHtcbiAgICByZXR1cm4gd2luO1xuICB9XG4gIGlmICghaXNIVE1MRWxlbWVudChlbGVtZW50KSkge1xuICAgIGxldCBzdmdPZmZzZXRQYXJlbnQgPSBnZXRQYXJlbnROb2RlKGVsZW1lbnQpO1xuICAgIHdoaWxlIChzdmdPZmZzZXRQYXJlbnQgJiYgIWlzTGFzdFRyYXZlcnNhYmxlTm9kZShzdmdPZmZzZXRQYXJlbnQpKSB7XG4gICAgICBpZiAoaXNFbGVtZW50KHN2Z09mZnNldFBhcmVudCkgJiYgIWlzU3RhdGljUG9zaXRpb25lZChzdmdPZmZzZXRQYXJlbnQpKSB7XG4gICAgICAgIHJldHVybiBzdmdPZmZzZXRQYXJlbnQ7XG4gICAgICB9XG4gICAgICBzdmdPZmZzZXRQYXJlbnQgPSBnZXRQYXJlbnROb2RlKHN2Z09mZnNldFBhcmVudCk7XG4gICAgfVxuICAgIHJldHVybiB3aW47XG4gIH1cbiAgbGV0IG9mZnNldFBhcmVudCA9IGdldFRydWVPZmZzZXRQYXJlbnQoZWxlbWVudCwgcG9seWZpbGwpO1xuICB3aGlsZSAob2Zmc2V0UGFyZW50ICYmIGlzVGFibGVFbGVtZW50KG9mZnNldFBhcmVudCkgJiYgaXNTdGF0aWNQb3NpdGlvbmVkKG9mZnNldFBhcmVudCkpIHtcbiAgICBvZmZzZXRQYXJlbnQgPSBnZXRUcnVlT2Zmc2V0UGFyZW50KG9mZnNldFBhcmVudCwgcG9seWZpbGwpO1xuICB9XG4gIGlmIChvZmZzZXRQYXJlbnQgJiYgaXNMYXN0VHJhdmVyc2FibGVOb2RlKG9mZnNldFBhcmVudCkgJiYgaXNTdGF0aWNQb3NpdGlvbmVkKG9mZnNldFBhcmVudCkgJiYgIWlzQ29udGFpbmluZ0Jsb2NrKG9mZnNldFBhcmVudCkpIHtcbiAgICByZXR1cm4gd2luO1xuICB9XG4gIHJldHVybiBvZmZzZXRQYXJlbnQgfHwgZ2V0Q29udGFpbmluZ0Jsb2NrKGVsZW1lbnQpIHx8IHdpbjtcbn1cblxuY29uc3QgZ2V0RWxlbWVudFJlY3RzID0gYXN5bmMgZnVuY3Rpb24gKGRhdGEpIHtcbiAgY29uc3QgZ2V0T2Zmc2V0UGFyZW50Rm4gPSB0aGlzLmdldE9mZnNldFBhcmVudCB8fCBnZXRPZmZzZXRQYXJlbnQ7XG4gIGNvbnN0IGdldERpbWVuc2lvbnNGbiA9IHRoaXMuZ2V0RGltZW5zaW9ucztcbiAgY29uc3QgZmxvYXRpbmdEaW1lbnNpb25zID0gYXdhaXQgZ2V0RGltZW5zaW9uc0ZuKGRhdGEuZmxvYXRpbmcpO1xuICByZXR1cm4ge1xuICAgIHJlZmVyZW5jZTogZ2V0UmVjdFJlbGF0aXZlVG9PZmZzZXRQYXJlbnQoZGF0YS5yZWZlcmVuY2UsIGF3YWl0IGdldE9mZnNldFBhcmVudEZuKGRhdGEuZmxvYXRpbmcpLCBkYXRhLnN0cmF0ZWd5KSxcbiAgICBmbG9hdGluZzoge1xuICAgICAgeDogMCxcbiAgICAgIHk6IDAsXG4gICAgICB3aWR0aDogZmxvYXRpbmdEaW1lbnNpb25zLndpZHRoLFxuICAgICAgaGVpZ2h0OiBmbG9hdGluZ0RpbWVuc2lvbnMuaGVpZ2h0XG4gICAgfVxuICB9O1xufTtcblxuZnVuY3Rpb24gaXNSVEwoZWxlbWVudCkge1xuICByZXR1cm4gZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KS5kaXJlY3Rpb24gPT09ICdydGwnO1xufVxuXG5jb25zdCBwbGF0Zm9ybSA9IHtcbiAgY29udmVydE9mZnNldFBhcmVudFJlbGF0aXZlUmVjdFRvVmlld3BvcnRSZWxhdGl2ZVJlY3QsXG4gIGdldERvY3VtZW50RWxlbWVudCxcbiAgZ2V0Q2xpcHBpbmdSZWN0LFxuICBnZXRPZmZzZXRQYXJlbnQsXG4gIGdldEVsZW1lbnRSZWN0cyxcbiAgZ2V0Q2xpZW50UmVjdHMsXG4gIGdldERpbWVuc2lvbnMsXG4gIGdldFNjYWxlLFxuICBpc0VsZW1lbnQsXG4gIGlzUlRMXG59O1xuXG5mdW5jdGlvbiByZWN0c0FyZUVxdWFsKGEsIGIpIHtcbiAgcmV0dXJuIGEueCA9PT0gYi54ICYmIGEueSA9PT0gYi55ICYmIGEud2lkdGggPT09IGIud2lkdGggJiYgYS5oZWlnaHQgPT09IGIuaGVpZ2h0O1xufVxuXG4vLyBodHRwczovL3NhbXRob3IuYXUvMjAyMS9vYnNlcnZpbmctZG9tL1xuZnVuY3Rpb24gb2JzZXJ2ZU1vdmUoZWxlbWVudCwgb25Nb3ZlKSB7XG4gIGxldCBpbyA9IG51bGw7XG4gIGxldCB0aW1lb3V0SWQ7XG4gIGNvbnN0IHJvb3QgPSBnZXREb2N1bWVudEVsZW1lbnQoZWxlbWVudCk7XG4gIGZ1bmN0aW9uIGNsZWFudXAoKSB7XG4gICAgdmFyIF9pbztcbiAgICBjbGVhclRpbWVvdXQodGltZW91dElkKTtcbiAgICAoX2lvID0gaW8pID09IG51bGwgfHwgX2lvLmRpc2Nvbm5lY3QoKTtcbiAgICBpbyA9IG51bGw7XG4gIH1cbiAgZnVuY3Rpb24gcmVmcmVzaChza2lwLCB0aHJlc2hvbGQpIHtcbiAgICBpZiAoc2tpcCA9PT0gdm9pZCAwKSB7XG4gICAgICBza2lwID0gZmFsc2U7XG4gICAgfVxuICAgIGlmICh0aHJlc2hvbGQgPT09IHZvaWQgMCkge1xuICAgICAgdGhyZXNob2xkID0gMTtcbiAgICB9XG4gICAgY2xlYW51cCgpO1xuICAgIGNvbnN0IGVsZW1lbnRSZWN0Rm9yUm9vdE1hcmdpbiA9IGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgY29uc3Qge1xuICAgICAgbGVmdCxcbiAgICAgIHRvcCxcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0XG4gICAgfSA9IGVsZW1lbnRSZWN0Rm9yUm9vdE1hcmdpbjtcbiAgICBpZiAoIXNraXApIHtcbiAgICAgIG9uTW92ZSgpO1xuICAgIH1cbiAgICBpZiAoIXdpZHRoIHx8ICFoZWlnaHQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgaW5zZXRUb3AgPSBmbG9vcih0b3ApO1xuICAgIGNvbnN0IGluc2V0UmlnaHQgPSBmbG9vcihyb290LmNsaWVudFdpZHRoIC0gKGxlZnQgKyB3aWR0aCkpO1xuICAgIGNvbnN0IGluc2V0Qm90dG9tID0gZmxvb3Iocm9vdC5jbGllbnRIZWlnaHQgLSAodG9wICsgaGVpZ2h0KSk7XG4gICAgY29uc3QgaW5zZXRMZWZ0ID0gZmxvb3IobGVmdCk7XG4gICAgY29uc3Qgcm9vdE1hcmdpbiA9IC1pbnNldFRvcCArIFwicHggXCIgKyAtaW5zZXRSaWdodCArIFwicHggXCIgKyAtaW5zZXRCb3R0b20gKyBcInB4IFwiICsgLWluc2V0TGVmdCArIFwicHhcIjtcbiAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgcm9vdE1hcmdpbixcbiAgICAgIHRocmVzaG9sZDogbWF4KDAsIG1pbigxLCB0aHJlc2hvbGQpKSB8fCAxXG4gICAgfTtcbiAgICBsZXQgaXNGaXJzdFVwZGF0ZSA9IHRydWU7XG4gICAgZnVuY3Rpb24gaGFuZGxlT2JzZXJ2ZShlbnRyaWVzKSB7XG4gICAgICBjb25zdCByYXRpbyA9IGVudHJpZXNbMF0uaW50ZXJzZWN0aW9uUmF0aW87XG4gICAgICBpZiAocmF0aW8gIT09IHRocmVzaG9sZCkge1xuICAgICAgICBpZiAoIWlzRmlyc3RVcGRhdGUpIHtcbiAgICAgICAgICByZXR1cm4gcmVmcmVzaCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcmF0aW8pIHtcbiAgICAgICAgICAvLyBJZiB0aGUgcmVmZXJlbmNlIGlzIGNsaXBwZWQsIHRoZSByYXRpbyBpcyAwLiBUaHJvdHRsZSB0aGUgcmVmcmVzaFxuICAgICAgICAgIC8vIHRvIHByZXZlbnQgYW4gaW5maW5pdGUgbG9vcCBvZiB1cGRhdGVzLlxuICAgICAgICAgIHRpbWVvdXRJZCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgcmVmcmVzaChmYWxzZSwgMWUtNyk7XG4gICAgICAgICAgfSwgMTAwMCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVmcmVzaChmYWxzZSwgcmF0aW8pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocmF0aW8gPT09IDEgJiYgIXJlY3RzQXJlRXF1YWwoZWxlbWVudFJlY3RGb3JSb290TWFyZ2luLCBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpKSkge1xuICAgICAgICAvLyBJdCdzIHBvc3NpYmxlIHRoYXQgZXZlbiB0aG91Z2ggdGhlIHJhdGlvIGlzIHJlcG9ydGVkIGFzIDEsIHRoZVxuICAgICAgICAvLyBlbGVtZW50IGlzIG5vdCBhY3R1YWxseSBmdWxseSB3aXRoaW4gdGhlIEludGVyc2VjdGlvbk9ic2VydmVyJ3Mgcm9vdFxuICAgICAgICAvLyBhcmVhIGFueW1vcmUuIFRoaXMgY2FuIGhhcHBlbiB1bmRlciBwZXJmb3JtYW5jZSBjb25zdHJhaW50cy4gVGhpcyBtYXlcbiAgICAgICAgLy8gYmUgYSBidWcgaW4gdGhlIGJyb3dzZXIncyBJbnRlcnNlY3Rpb25PYnNlcnZlciBpbXBsZW1lbnRhdGlvbi4gVG9cbiAgICAgICAgLy8gd29yayBhcm91bmQgdGhpcywgd2UgY29tcGFyZSB0aGUgZWxlbWVudCdzIGJvdW5kaW5nIHJlY3Qgbm93IHdpdGhcbiAgICAgICAgLy8gd2hhdCBpdCB3YXMgYXQgdGhlIHRpbWUgd2UgY3JlYXRlZCB0aGUgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIuIElmIHRoZXlcbiAgICAgICAgLy8gYXJlIG5vdCBlcXVhbCB0aGVuIHRoZSBlbGVtZW50IG1vdmVkLCBzbyB3ZSByZWZyZXNoLlxuICAgICAgICByZWZyZXNoKCk7XG4gICAgICB9XG4gICAgICBpc0ZpcnN0VXBkYXRlID0gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gT2xkZXIgYnJvd3NlcnMgZG9uJ3Qgc3VwcG9ydCBhIGBkb2N1bWVudGAgYXMgdGhlIHJvb3QgYW5kIHdpbGwgdGhyb3cgYW5cbiAgICAvLyBlcnJvci5cbiAgICB0cnkge1xuICAgICAgaW8gPSBuZXcgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIoaGFuZGxlT2JzZXJ2ZSwge1xuICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAvLyBIYW5kbGUgPGlmcmFtZT5zXG4gICAgICAgIHJvb3Q6IHJvb3Qub3duZXJEb2N1bWVudFxuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaW8gPSBuZXcgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIoaGFuZGxlT2JzZXJ2ZSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGlvLm9ic2VydmUoZWxlbWVudCk7XG4gIH1cbiAgcmVmcmVzaCh0cnVlKTtcbiAgcmV0dXJuIGNsZWFudXA7XG59XG5cbi8qKlxuICogQXV0b21hdGljYWxseSB1cGRhdGVzIHRoZSBwb3NpdGlvbiBvZiB0aGUgZmxvYXRpbmcgZWxlbWVudCB3aGVuIG5lY2Vzc2FyeS5cbiAqIFNob3VsZCBvbmx5IGJlIGNhbGxlZCB3aGVuIHRoZSBmbG9hdGluZyBlbGVtZW50IGlzIG1vdW50ZWQgb24gdGhlIERPTSBvclxuICogdmlzaWJsZSBvbiB0aGUgc2NyZWVuLlxuICogQHJldHVybnMgY2xlYW51cCBmdW5jdGlvbiB0aGF0IHNob3VsZCBiZSBpbnZva2VkIHdoZW4gdGhlIGZsb2F0aW5nIGVsZW1lbnQgaXNcbiAqIHJlbW92ZWQgZnJvbSB0aGUgRE9NIG9yIGhpZGRlbiBmcm9tIHRoZSBzY3JlZW4uXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvYXV0b1VwZGF0ZVxuICovXG5mdW5jdGlvbiBhdXRvVXBkYXRlKHJlZmVyZW5jZSwgZmxvYXRpbmcsIHVwZGF0ZSwgb3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG4gIGNvbnN0IHtcbiAgICBhbmNlc3RvclNjcm9sbCA9IHRydWUsXG4gICAgYW5jZXN0b3JSZXNpemUgPSB0cnVlLFxuICAgIGVsZW1lbnRSZXNpemUgPSB0eXBlb2YgUmVzaXplT2JzZXJ2ZXIgPT09ICdmdW5jdGlvbicsXG4gICAgbGF5b3V0U2hpZnQgPSB0eXBlb2YgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIgPT09ICdmdW5jdGlvbicsXG4gICAgYW5pbWF0aW9uRnJhbWUgPSBmYWxzZVxuICB9ID0gb3B0aW9ucztcbiAgY29uc3QgcmVmZXJlbmNlRWwgPSB1bndyYXBFbGVtZW50KHJlZmVyZW5jZSk7XG4gIGNvbnN0IGFuY2VzdG9ycyA9IGFuY2VzdG9yU2Nyb2xsIHx8IGFuY2VzdG9yUmVzaXplID8gWy4uLihyZWZlcmVuY2VFbCA/IGdldE92ZXJmbG93QW5jZXN0b3JzKHJlZmVyZW5jZUVsKSA6IFtdKSwgLi4uZ2V0T3ZlcmZsb3dBbmNlc3RvcnMoZmxvYXRpbmcpXSA6IFtdO1xuICBhbmNlc3RvcnMuZm9yRWFjaChhbmNlc3RvciA9PiB7XG4gICAgYW5jZXN0b3JTY3JvbGwgJiYgYW5jZXN0b3IuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgdXBkYXRlLCB7XG4gICAgICBwYXNzaXZlOiB0cnVlXG4gICAgfSk7XG4gICAgYW5jZXN0b3JSZXNpemUgJiYgYW5jZXN0b3IuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdXBkYXRlKTtcbiAgfSk7XG4gIGNvbnN0IGNsZWFudXBJbyA9IHJlZmVyZW5jZUVsICYmIGxheW91dFNoaWZ0ID8gb2JzZXJ2ZU1vdmUocmVmZXJlbmNlRWwsIHVwZGF0ZSkgOiBudWxsO1xuICBsZXQgcmVvYnNlcnZlRnJhbWUgPSAtMTtcbiAgbGV0IHJlc2l6ZU9ic2VydmVyID0gbnVsbDtcbiAgaWYgKGVsZW1lbnRSZXNpemUpIHtcbiAgICByZXNpemVPYnNlcnZlciA9IG5ldyBSZXNpemVPYnNlcnZlcihfcmVmID0+IHtcbiAgICAgIGxldCBbZmlyc3RFbnRyeV0gPSBfcmVmO1xuICAgICAgaWYgKGZpcnN0RW50cnkgJiYgZmlyc3RFbnRyeS50YXJnZXQgPT09IHJlZmVyZW5jZUVsICYmIHJlc2l6ZU9ic2VydmVyKSB7XG4gICAgICAgIC8vIFByZXZlbnQgdXBkYXRlIGxvb3BzIHdoZW4gdXNpbmcgdGhlIGBzaXplYCBtaWRkbGV3YXJlLlxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmxvYXRpbmctdWkvZmxvYXRpbmctdWkvaXNzdWVzLzE3NDBcbiAgICAgICAgcmVzaXplT2JzZXJ2ZXIudW5vYnNlcnZlKGZsb2F0aW5nKTtcbiAgICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUocmVvYnNlcnZlRnJhbWUpO1xuICAgICAgICByZW9ic2VydmVGcmFtZSA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAgICAgdmFyIF9yZXNpemVPYnNlcnZlcjtcbiAgICAgICAgICAoX3Jlc2l6ZU9ic2VydmVyID0gcmVzaXplT2JzZXJ2ZXIpID09IG51bGwgfHwgX3Jlc2l6ZU9ic2VydmVyLm9ic2VydmUoZmxvYXRpbmcpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHVwZGF0ZSgpO1xuICAgIH0pO1xuICAgIGlmIChyZWZlcmVuY2VFbCAmJiAhYW5pbWF0aW9uRnJhbWUpIHtcbiAgICAgIHJlc2l6ZU9ic2VydmVyLm9ic2VydmUocmVmZXJlbmNlRWwpO1xuICAgIH1cbiAgICByZXNpemVPYnNlcnZlci5vYnNlcnZlKGZsb2F0aW5nKTtcbiAgfVxuICBsZXQgZnJhbWVJZDtcbiAgbGV0IHByZXZSZWZSZWN0ID0gYW5pbWF0aW9uRnJhbWUgPyBnZXRCb3VuZGluZ0NsaWVudFJlY3QocmVmZXJlbmNlKSA6IG51bGw7XG4gIGlmIChhbmltYXRpb25GcmFtZSkge1xuICAgIGZyYW1lTG9vcCgpO1xuICB9XG4gIGZ1bmN0aW9uIGZyYW1lTG9vcCgpIHtcbiAgICBjb25zdCBuZXh0UmVmUmVjdCA9IGdldEJvdW5kaW5nQ2xpZW50UmVjdChyZWZlcmVuY2UpO1xuICAgIGlmIChwcmV2UmVmUmVjdCAmJiAhcmVjdHNBcmVFcXVhbChwcmV2UmVmUmVjdCwgbmV4dFJlZlJlY3QpKSB7XG4gICAgICB1cGRhdGUoKTtcbiAgICB9XG4gICAgcHJldlJlZlJlY3QgPSBuZXh0UmVmUmVjdDtcbiAgICBmcmFtZUlkID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZyYW1lTG9vcCk7XG4gIH1cbiAgdXBkYXRlKCk7XG4gIHJldHVybiAoKSA9PiB7XG4gICAgdmFyIF9yZXNpemVPYnNlcnZlcjI7XG4gICAgYW5jZXN0b3JzLmZvckVhY2goYW5jZXN0b3IgPT4ge1xuICAgICAgYW5jZXN0b3JTY3JvbGwgJiYgYW5jZXN0b3IucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgdXBkYXRlKTtcbiAgICAgIGFuY2VzdG9yUmVzaXplICYmIGFuY2VzdG9yLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHVwZGF0ZSk7XG4gICAgfSk7XG4gICAgY2xlYW51cElvID09IG51bGwgfHwgY2xlYW51cElvKCk7XG4gICAgKF9yZXNpemVPYnNlcnZlcjIgPSByZXNpemVPYnNlcnZlcikgPT0gbnVsbCB8fCBfcmVzaXplT2JzZXJ2ZXIyLmRpc2Nvbm5lY3QoKTtcbiAgICByZXNpemVPYnNlcnZlciA9IG51bGw7XG4gICAgaWYgKGFuaW1hdGlvbkZyYW1lKSB7XG4gICAgICBjYW5jZWxBbmltYXRpb25GcmFtZShmcmFtZUlkKTtcbiAgICB9XG4gIH07XG59XG5cbi8qKlxuICogUmVzb2x2ZXMgd2l0aCBhbiBvYmplY3Qgb2Ygb3ZlcmZsb3cgc2lkZSBvZmZzZXRzIHRoYXQgZGV0ZXJtaW5lIGhvdyBtdWNoIHRoZVxuICogZWxlbWVudCBpcyBvdmVyZmxvd2luZyBhIGdpdmVuIGNsaXBwaW5nIGJvdW5kYXJ5IG9uIGVhY2ggc2lkZS5cbiAqIC0gcG9zaXRpdmUgPSBvdmVyZmxvd2luZyB0aGUgYm91bmRhcnkgYnkgdGhhdCBudW1iZXIgb2YgcGl4ZWxzXG4gKiAtIG5lZ2F0aXZlID0gaG93IG1hbnkgcGl4ZWxzIGxlZnQgYmVmb3JlIGl0IHdpbGwgb3ZlcmZsb3dcbiAqIC0gMCA9IGxpZXMgZmx1c2ggd2l0aCB0aGUgYm91bmRhcnlcbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9kZXRlY3RPdmVyZmxvd1xuICovXG5jb25zdCBkZXRlY3RPdmVyZmxvdyA9IGRldGVjdE92ZXJmbG93JDE7XG5cbi8qKlxuICogTW9kaWZpZXMgdGhlIHBsYWNlbWVudCBieSB0cmFuc2xhdGluZyB0aGUgZmxvYXRpbmcgZWxlbWVudCBhbG9uZyB0aGVcbiAqIHNwZWNpZmllZCBheGVzLlxuICogQSBudW1iZXIgKHNob3J0aGFuZCBmb3IgYG1haW5BeGlzYCBvciBkaXN0YW5jZSksIG9yIGFuIGF4ZXMgY29uZmlndXJhdGlvblxuICogb2JqZWN0IG1heSBiZSBwYXNzZWQuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3Mvb2Zmc2V0XG4gKi9cbmNvbnN0IG9mZnNldCA9IG9mZnNldCQxO1xuXG4vKipcbiAqIE9wdGltaXplcyB0aGUgdmlzaWJpbGl0eSBvZiB0aGUgZmxvYXRpbmcgZWxlbWVudCBieSBjaG9vc2luZyB0aGUgcGxhY2VtZW50XG4gKiB0aGF0IGhhcyB0aGUgbW9zdCBzcGFjZSBhdmFpbGFibGUgYXV0b21hdGljYWxseSwgd2l0aG91dCBuZWVkaW5nIHRvIHNwZWNpZnkgYVxuICogcHJlZmVycmVkIHBsYWNlbWVudC4gQWx0ZXJuYXRpdmUgdG8gYGZsaXBgLlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL2F1dG9QbGFjZW1lbnRcbiAqL1xuY29uc3QgYXV0b1BsYWNlbWVudCA9IGF1dG9QbGFjZW1lbnQkMTtcblxuLyoqXG4gKiBPcHRpbWl6ZXMgdGhlIHZpc2liaWxpdHkgb2YgdGhlIGZsb2F0aW5nIGVsZW1lbnQgYnkgc2hpZnRpbmcgaXQgaW4gb3JkZXIgdG9cbiAqIGtlZXAgaXQgaW4gdmlldyB3aGVuIGl0IHdpbGwgb3ZlcmZsb3cgdGhlIGNsaXBwaW5nIGJvdW5kYXJ5LlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL3NoaWZ0XG4gKi9cbmNvbnN0IHNoaWZ0ID0gc2hpZnQkMTtcblxuLyoqXG4gKiBPcHRpbWl6ZXMgdGhlIHZpc2liaWxpdHkgb2YgdGhlIGZsb2F0aW5nIGVsZW1lbnQgYnkgZmxpcHBpbmcgdGhlIGBwbGFjZW1lbnRgXG4gKiBpbiBvcmRlciB0byBrZWVwIGl0IGluIHZpZXcgd2hlbiB0aGUgcHJlZmVycmVkIHBsYWNlbWVudChzKSB3aWxsIG92ZXJmbG93IHRoZVxuICogY2xpcHBpbmcgYm91bmRhcnkuIEFsdGVybmF0aXZlIHRvIGBhdXRvUGxhY2VtZW50YC5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9mbGlwXG4gKi9cbmNvbnN0IGZsaXAgPSBmbGlwJDE7XG5cbi8qKlxuICogUHJvdmlkZXMgZGF0YSB0aGF0IGFsbG93cyB5b3UgdG8gY2hhbmdlIHRoZSBzaXplIG9mIHRoZSBmbG9hdGluZyBlbGVtZW50IOKAlFxuICogZm9yIGluc3RhbmNlLCBwcmV2ZW50IGl0IGZyb20gb3ZlcmZsb3dpbmcgdGhlIGNsaXBwaW5nIGJvdW5kYXJ5IG9yIG1hdGNoIHRoZVxuICogd2lkdGggb2YgdGhlIHJlZmVyZW5jZSBlbGVtZW50LlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL3NpemVcbiAqL1xuY29uc3Qgc2l6ZSA9IHNpemUkMTtcblxuLyoqXG4gKiBQcm92aWRlcyBkYXRhIHRvIGhpZGUgdGhlIGZsb2F0aW5nIGVsZW1lbnQgaW4gYXBwbGljYWJsZSBzaXR1YXRpb25zLCBzdWNoIGFzXG4gKiB3aGVuIGl0IGlzIG5vdCBpbiB0aGUgc2FtZSBjbGlwcGluZyBjb250ZXh0IGFzIHRoZSByZWZlcmVuY2UgZWxlbWVudC5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9oaWRlXG4gKi9cbmNvbnN0IGhpZGUgPSBoaWRlJDE7XG5cbi8qKlxuICogUHJvdmlkZXMgZGF0YSB0byBwb3NpdGlvbiBhbiBpbm5lciBlbGVtZW50IG9mIHRoZSBmbG9hdGluZyBlbGVtZW50IHNvIHRoYXQgaXRcbiAqIGFwcGVhcnMgY2VudGVyZWQgdG8gdGhlIHJlZmVyZW5jZSBlbGVtZW50LlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL2Fycm93XG4gKi9cbmNvbnN0IGFycm93ID0gYXJyb3ckMTtcblxuLyoqXG4gKiBQcm92aWRlcyBpbXByb3ZlZCBwb3NpdGlvbmluZyBmb3IgaW5saW5lIHJlZmVyZW5jZSBlbGVtZW50cyB0aGF0IGNhbiBzcGFuXG4gKiBvdmVyIG11bHRpcGxlIGxpbmVzLCBzdWNoIGFzIGh5cGVybGlua3Mgb3IgcmFuZ2Ugc2VsZWN0aW9ucy5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9pbmxpbmVcbiAqL1xuY29uc3QgaW5saW5lID0gaW5saW5lJDE7XG5cbi8qKlxuICogQnVpbHQtaW4gYGxpbWl0ZXJgIHRoYXQgd2lsbCBzdG9wIGBzaGlmdCgpYCBhdCBhIGNlcnRhaW4gcG9pbnQuXG4gKi9cbmNvbnN0IGxpbWl0U2hpZnQgPSBsaW1pdFNoaWZ0JDE7XG5cbi8qKlxuICogQ29tcHV0ZXMgdGhlIGB4YCBhbmQgYHlgIGNvb3JkaW5hdGVzIHRoYXQgd2lsbCBwbGFjZSB0aGUgZmxvYXRpbmcgZWxlbWVudFxuICogbmV4dCB0byBhIGdpdmVuIHJlZmVyZW5jZSBlbGVtZW50LlxuICovXG5jb25zdCBjb21wdXRlUG9zaXRpb24gPSAocmVmZXJlbmNlLCBmbG9hdGluZywgb3B0aW9ucykgPT4ge1xuICAvLyBUaGlzIGNhY2hlcyB0aGUgZXhwZW5zaXZlIGBnZXRDbGlwcGluZ0VsZW1lbnRBbmNlc3RvcnNgIGZ1bmN0aW9uIHNvIHRoYXRcbiAgLy8gbXVsdGlwbGUgbGlmZWN5Y2xlIHJlc2V0cyByZS11c2UgdGhlIHNhbWUgcmVzdWx0LiBJdCBvbmx5IGxpdmVzIGZvciBhXG4gIC8vIHNpbmdsZSBjYWxsLiBJZiBvdGhlciBmdW5jdGlvbnMgYmVjb21lIGV4cGVuc2l2ZSwgd2UgY2FuIGFkZCB0aGVtIGFzIHdlbGwuXG4gIGNvbnN0IGNhY2hlID0gbmV3IE1hcCgpO1xuICBjb25zdCBtZXJnZWRPcHRpb25zID0ge1xuICAgIHBsYXRmb3JtLFxuICAgIC4uLm9wdGlvbnNcbiAgfTtcbiAgY29uc3QgcGxhdGZvcm1XaXRoQ2FjaGUgPSB7XG4gICAgLi4ubWVyZ2VkT3B0aW9ucy5wbGF0Zm9ybSxcbiAgICBfYzogY2FjaGVcbiAgfTtcbiAgcmV0dXJuIGNvbXB1dGVQb3NpdGlvbiQxKHJlZmVyZW5jZSwgZmxvYXRpbmcsIHtcbiAgICAuLi5tZXJnZWRPcHRpb25zLFxuICAgIHBsYXRmb3JtOiBwbGF0Zm9ybVdpdGhDYWNoZVxuICB9KTtcbn07XG5cbmV4cG9ydCB7IGFycm93LCBhdXRvUGxhY2VtZW50LCBhdXRvVXBkYXRlLCBjb21wdXRlUG9zaXRpb24sIGRldGVjdE92ZXJmbG93LCBmbGlwLCBoaWRlLCBpbmxpbmUsIGxpbWl0U2hpZnQsIG9mZnNldCwgcGxhdGZvcm0sIHNoaWZ0LCBzaXplIH07XG4iXSwibmFtZXMiOlsicmVjdFRvQ2xpZW50UmVjdCIsImRldGVjdE92ZXJmbG93IiwiZGV0ZWN0T3ZlcmZsb3ckMSIsIm9mZnNldCIsIm9mZnNldCQxIiwiYXV0b1BsYWNlbWVudCIsImF1dG9QbGFjZW1lbnQkMSIsInNoaWZ0Iiwic2hpZnQkMSIsImZsaXAiLCJmbGlwJDEiLCJzaXplIiwic2l6ZSQxIiwiaGlkZSIsImhpZGUkMSIsImFycm93IiwiYXJyb3ckMSIsImlubGluZSIsImlubGluZSQxIiwibGltaXRTaGlmdCIsImxpbWl0U2hpZnQkMSIsImNvbXB1dGVQb3NpdGlvbiIsImNvbXB1dGVQb3NpdGlvbiQxIiwicm91bmQiLCJjcmVhdGVDb29yZHMiLCJtYXgiLCJtaW4iLCJmbG9vciIsImdldENvbXB1dGVkU3R5bGUiLCJpc0hUTUxFbGVtZW50IiwiaXNFbGVtZW50IiwiZ2V0V2luZG93IiwiaXNXZWJLaXQiLCJnZXRGcmFtZUVsZW1lbnQiLCJnZXROb2RlU2Nyb2xsIiwiZ2V0RG9jdW1lbnRFbGVtZW50IiwiaXNUb3BMYXllciIsImdldE5vZGVOYW1lIiwiaXNPdmVyZmxvd0VsZW1lbnQiLCJnZXRPdmVyZmxvd0FuY2VzdG9ycyIsImdldFBhcmVudE5vZGUiLCJpc0xhc3RUcmF2ZXJzYWJsZU5vZGUiLCJpc0NvbnRhaW5pbmdCbG9jayIsImlzVGFibGVFbGVtZW50IiwiZ2V0Q29udGFpbmluZ0Jsb2NrIiwiZ2V0Q3NzRGltZW5zaW9ucyIsImVsZW1lbnQiLCJjc3MiLCJ3aWR0aCIsInBhcnNlRmxvYXQiLCJoZWlnaHQiLCJoYXNPZmZzZXQiLCJvZmZzZXRXaWR0aCIsIm9mZnNldEhlaWdodCIsInNob3VsZEZhbGxiYWNrIiwiJCIsInVud3JhcEVsZW1lbnQiLCJjb250ZXh0RWxlbWVudCIsImdldFNjYWxlIiwiZG9tRWxlbWVudCIsInJlY3QiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJ4IiwieSIsIk51bWJlciIsImlzRmluaXRlIiwibm9PZmZzZXRzIiwiZ2V0VmlzdWFsT2Zmc2V0cyIsIndpbiIsInZpc3VhbFZpZXdwb3J0Iiwib2Zmc2V0TGVmdCIsIm9mZnNldFRvcCIsInNob3VsZEFkZFZpc3VhbE9mZnNldHMiLCJpc0ZpeGVkIiwiZmxvYXRpbmdPZmZzZXRQYXJlbnQiLCJpbmNsdWRlU2NhbGUiLCJpc0ZpeGVkU3RyYXRlZ3kiLCJvZmZzZXRQYXJlbnQiLCJjbGllbnRSZWN0Iiwic2NhbGUiLCJ2aXN1YWxPZmZzZXRzIiwibGVmdCIsInRvcCIsIm9mZnNldFdpbiIsImN1cnJlbnRXaW4iLCJjdXJyZW50SUZyYW1lIiwiaWZyYW1lU2NhbGUiLCJpZnJhbWVSZWN0IiwiY2xpZW50TGVmdCIsInBhZGRpbmdMZWZ0IiwiY2xpZW50VG9wIiwicGFkZGluZ1RvcCIsImdldFdpbmRvd1Njcm9sbEJhclgiLCJsZWZ0U2Nyb2xsIiwic2Nyb2xsTGVmdCIsImdldEhUTUxPZmZzZXQiLCJkb2N1bWVudEVsZW1lbnQiLCJzY3JvbGwiLCJpZ25vcmVTY3JvbGxiYXJYIiwiaHRtbFJlY3QiLCJzY3JvbGxUb3AiLCJjb252ZXJ0T2Zmc2V0UGFyZW50UmVsYXRpdmVSZWN0VG9WaWV3cG9ydFJlbGF0aXZlUmVjdCIsIl9yZWYiLCJlbGVtZW50cyIsInN0cmF0ZWd5IiwidG9wTGF5ZXIiLCJmbG9hdGluZyIsIm9mZnNldHMiLCJpc09mZnNldFBhcmVudEFuRWxlbWVudCIsIm9mZnNldFJlY3QiLCJodG1sT2Zmc2V0IiwiZ2V0Q2xpZW50UmVjdHMiLCJBcnJheSIsImZyb20iLCJnZXREb2N1bWVudFJlY3QiLCJodG1sIiwiYm9keSIsIm93bmVyRG9jdW1lbnQiLCJzY3JvbGxXaWR0aCIsImNsaWVudFdpZHRoIiwic2Nyb2xsSGVpZ2h0IiwiY2xpZW50SGVpZ2h0IiwiZGlyZWN0aW9uIiwiZ2V0Vmlld3BvcnRSZWN0IiwidmlzdWFsVmlld3BvcnRCYXNlZCIsImdldElubmVyQm91bmRpbmdDbGllbnRSZWN0IiwiZ2V0Q2xpZW50UmVjdEZyb21DbGlwcGluZ0FuY2VzdG9yIiwiY2xpcHBpbmdBbmNlc3RvciIsImhhc0ZpeGVkUG9zaXRpb25BbmNlc3RvciIsInN0b3BOb2RlIiwicGFyZW50Tm9kZSIsInBvc2l0aW9uIiwiZ2V0Q2xpcHBpbmdFbGVtZW50QW5jZXN0b3JzIiwiY2FjaGUiLCJjYWNoZWRSZXN1bHQiLCJnZXQiLCJyZXN1bHQiLCJmaWx0ZXIiLCJlbCIsImN1cnJlbnRDb250YWluaW5nQmxvY2tDb21wdXRlZFN0eWxlIiwiZWxlbWVudElzRml4ZWQiLCJjdXJyZW50Tm9kZSIsImNvbXB1dGVkU3R5bGUiLCJjdXJyZW50Tm9kZUlzQ29udGFpbmluZyIsInNob3VsZERyb3BDdXJyZW50Tm9kZSIsImluY2x1ZGVzIiwiYW5jZXN0b3IiLCJzZXQiLCJnZXRDbGlwcGluZ1JlY3QiLCJib3VuZGFyeSIsInJvb3RCb3VuZGFyeSIsImVsZW1lbnRDbGlwcGluZ0FuY2VzdG9ycyIsIl9jIiwiY29uY2F0IiwiY2xpcHBpbmdBbmNlc3RvcnMiLCJmaXJzdENsaXBwaW5nQW5jZXN0b3IiLCJjbGlwcGluZ1JlY3QiLCJyZWR1Y2UiLCJhY2NSZWN0IiwicmlnaHQiLCJib3R0b20iLCJnZXREaW1lbnNpb25zIiwiZ2V0UmVjdFJlbGF0aXZlVG9PZmZzZXRQYXJlbnQiLCJpc1N0YXRpY1Bvc2l0aW9uZWQiLCJnZXRUcnVlT2Zmc2V0UGFyZW50IiwicG9seWZpbGwiLCJyYXdPZmZzZXRQYXJlbnQiLCJnZXRPZmZzZXRQYXJlbnQiLCJzdmdPZmZzZXRQYXJlbnQiLCJnZXRFbGVtZW50UmVjdHMiLCJkYXRhIiwiZ2V0T2Zmc2V0UGFyZW50Rm4iLCJnZXREaW1lbnNpb25zRm4iLCJmbG9hdGluZ0RpbWVuc2lvbnMiLCJyZWZlcmVuY2UiLCJpc1JUTCIsInBsYXRmb3JtIiwicmVjdHNBcmVFcXVhbCIsImEiLCJiIiwib2JzZXJ2ZU1vdmUiLCJvbk1vdmUiLCJpbyIsInRpbWVvdXRJZCIsInJvb3QiLCJjbGVhbnVwIiwiX2lvIiwiY2xlYXJUaW1lb3V0IiwiZGlzY29ubmVjdCIsInJlZnJlc2giLCJza2lwIiwidGhyZXNob2xkIiwiZWxlbWVudFJlY3RGb3JSb290TWFyZ2luIiwiaW5zZXRUb3AiLCJpbnNldFJpZ2h0IiwiaW5zZXRCb3R0b20iLCJpbnNldExlZnQiLCJyb290TWFyZ2luIiwib3B0aW9ucyIsImlzRmlyc3RVcGRhdGUiLCJoYW5kbGVPYnNlcnZlIiwiZW50cmllcyIsInJhdGlvIiwiaW50ZXJzZWN0aW9uUmF0aW8iLCJzZXRUaW1lb3V0IiwiSW50ZXJzZWN0aW9uT2JzZXJ2ZXIiLCJlIiwib2JzZXJ2ZSIsImF1dG9VcGRhdGUiLCJ1cGRhdGUiLCJhbmNlc3RvclNjcm9sbCIsImFuY2VzdG9yUmVzaXplIiwiZWxlbWVudFJlc2l6ZSIsIlJlc2l6ZU9ic2VydmVyIiwibGF5b3V0U2hpZnQiLCJhbmltYXRpb25GcmFtZSIsInJlZmVyZW5jZUVsIiwiYW5jZXN0b3JzIiwiZm9yRWFjaCIsImFkZEV2ZW50TGlzdGVuZXIiLCJwYXNzaXZlIiwiY2xlYW51cElvIiwicmVvYnNlcnZlRnJhbWUiLCJyZXNpemVPYnNlcnZlciIsImZpcnN0RW50cnkiLCJ0YXJnZXQiLCJ1bm9ic2VydmUiLCJjYW5jZWxBbmltYXRpb25GcmFtZSIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsIl9yZXNpemVPYnNlcnZlciIsImZyYW1lSWQiLCJwcmV2UmVmUmVjdCIsImZyYW1lTG9vcCIsIm5leHRSZWZSZWN0IiwiX3Jlc2l6ZU9ic2VydmVyMiIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJNYXAiLCJtZXJnZWRPcHRpb25zIiwicGxhdGZvcm1XaXRoQ2FjaGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../../../node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/../../../../node_modules/@floating-ui/react-dom/dist/floating-ui.react-dom.mjs":
/*!**************************************************************************************!*\
  !*** ../../../../node_modules/@floating-ui/react-dom/dist/floating-ui.react-dom.mjs ***!
  \**************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   arrow: function() { return /* binding */ arrow; },\n/* harmony export */   autoPlacement: function() { return /* binding */ autoPlacement; },\n/* harmony export */   autoUpdate: function() { return /* reexport safe */ _floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__.autoUpdate; },\n/* harmony export */   computePosition: function() { return /* reexport safe */ _floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__.computePosition; },\n/* harmony export */   detectOverflow: function() { return /* reexport safe */ _floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__.detectOverflow; },\n/* harmony export */   flip: function() { return /* binding */ flip; },\n/* harmony export */   getOverflowAncestors: function() { return /* reexport safe */ _floating_ui_dom__WEBPACK_IMPORTED_MODULE_1__.getOverflowAncestors; },\n/* harmony export */   hide: function() { return /* binding */ hide; },\n/* harmony export */   inline: function() { return /* binding */ inline; },\n/* harmony export */   limitShift: function() { return /* binding */ limitShift; },\n/* harmony export */   offset: function() { return /* binding */ offset; },\n/* harmony export */   platform: function() { return /* reexport safe */ _floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__.platform; },\n/* harmony export */   shift: function() { return /* binding */ shift; },\n/* harmony export */   size: function() { return /* binding */ size; },\n/* harmony export */   useFloating: function() { return /* binding */ useFloating; }\n/* harmony export */ });\n/* harmony import */ var _floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @floating-ui/dom */ \"(app-pages-browser)/../../../../node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs\");\n/* harmony import */ var _floating_ui_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @floating-ui/dom */ \"(app-pages-browser)/../../../../node_modules/@floating-ui/utils/dist/floating-ui.utils.dom.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react-dom */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react-dom/index.js\");\nvar _s = $RefreshSig$(), _s1 = $RefreshSig$();\n\n\n\n\n\nvar index = typeof document !== \"undefined\" ? react__WEBPACK_IMPORTED_MODULE_2__.useLayoutEffect : react__WEBPACK_IMPORTED_MODULE_2__.useEffect;\n// Fork of `fast-deep-equal` that only does the comparisons we need and compares\n// functions\nfunction deepEqual(a, b) {\n    if (a === b) {\n        return true;\n    }\n    if (typeof a !== typeof b) {\n        return false;\n    }\n    if (typeof a === \"function\" && a.toString() === b.toString()) {\n        return true;\n    }\n    let length;\n    let i;\n    let keys;\n    if (a && b && typeof a === \"object\") {\n        if (Array.isArray(a)) {\n            length = a.length;\n            if (length !== b.length) return false;\n            for(i = length; i-- !== 0;){\n                if (!deepEqual(a[i], b[i])) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        keys = Object.keys(a);\n        length = keys.length;\n        if (length !== Object.keys(b).length) {\n            return false;\n        }\n        for(i = length; i-- !== 0;){\n            if (!({}).hasOwnProperty.call(b, keys[i])) {\n                return false;\n            }\n        }\n        for(i = length; i-- !== 0;){\n            const key = keys[i];\n            if (key === \"_owner\" && a.$$typeof) {\n                continue;\n            }\n            if (!deepEqual(a[key], b[key])) {\n                return false;\n            }\n        }\n        return true;\n    }\n    return a !== a && b !== b;\n}\nfunction getDPR(element) {\n    if (false) {}\n    const win = element.ownerDocument.defaultView || window;\n    return win.devicePixelRatio || 1;\n}\nfunction roundByDPR(element, value) {\n    const dpr = getDPR(element);\n    return Math.round(value * dpr) / dpr;\n}\nfunction useLatestRef(value) {\n    _s();\n    const ref = react__WEBPACK_IMPORTED_MODULE_2__.useRef(value);\n    index(()=>{\n        ref.current = value;\n    });\n    return ref;\n}\n_s(useLatestRef, \"QMBuJFIdzLIeqBcFwhMf246mjOM=\");\n/**\n * Provides data to position a floating element.\n * @see https://floating-ui.com/docs/useFloating\n */ function useFloating(options) {\n    _s1();\n    if (options === void 0) {\n        options = {};\n    }\n    const { placement = \"bottom\", strategy = \"absolute\", middleware = [], platform, elements: { reference: externalReference, floating: externalFloating } = {}, transform = true, whileElementsMounted, open } = options;\n    const [data, setData] = react__WEBPACK_IMPORTED_MODULE_2__.useState({\n        x: 0,\n        y: 0,\n        strategy,\n        placement,\n        middlewareData: {},\n        isPositioned: false\n    });\n    const [latestMiddleware, setLatestMiddleware] = react__WEBPACK_IMPORTED_MODULE_2__.useState(middleware);\n    if (!deepEqual(latestMiddleware, middleware)) {\n        setLatestMiddleware(middleware);\n    }\n    const [_reference, _setReference] = react__WEBPACK_IMPORTED_MODULE_2__.useState(null);\n    const [_floating, _setFloating] = react__WEBPACK_IMPORTED_MODULE_2__.useState(null);\n    const setReference = react__WEBPACK_IMPORTED_MODULE_2__.useCallback((node)=>{\n        if (node !== referenceRef.current) {\n            referenceRef.current = node;\n            _setReference(node);\n        }\n    }, []);\n    const setFloating = react__WEBPACK_IMPORTED_MODULE_2__.useCallback((node)=>{\n        if (node !== floatingRef.current) {\n            floatingRef.current = node;\n            _setFloating(node);\n        }\n    }, []);\n    const referenceEl = externalReference || _reference;\n    const floatingEl = externalFloating || _floating;\n    const referenceRef = react__WEBPACK_IMPORTED_MODULE_2__.useRef(null);\n    const floatingRef = react__WEBPACK_IMPORTED_MODULE_2__.useRef(null);\n    const dataRef = react__WEBPACK_IMPORTED_MODULE_2__.useRef(data);\n    const hasWhileElementsMounted = whileElementsMounted != null;\n    const whileElementsMountedRef = useLatestRef(whileElementsMounted);\n    const platformRef = useLatestRef(platform);\n    const openRef = useLatestRef(open);\n    const update = react__WEBPACK_IMPORTED_MODULE_2__.useCallback(()=>{\n        if (!referenceRef.current || !floatingRef.current) {\n            return;\n        }\n        const config = {\n            placement,\n            strategy,\n            middleware: latestMiddleware\n        };\n        if (platformRef.current) {\n            config.platform = platformRef.current;\n        }\n        (0,_floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__.computePosition)(referenceRef.current, floatingRef.current, config).then((data)=>{\n            const fullData = {\n                ...data,\n                // The floating element's position may be recomputed while it's closed\n                // but still mounted (such as when transitioning out). To ensure\n                // `isPositioned` will be `false` initially on the next open, avoid\n                // setting it to `true` when `open === false` (must be specified).\n                isPositioned: openRef.current !== false\n            };\n            if (isMountedRef.current && !deepEqual(dataRef.current, fullData)) {\n                dataRef.current = fullData;\n                react_dom__WEBPACK_IMPORTED_MODULE_3__.flushSync(()=>{\n                    setData(fullData);\n                });\n            }\n        });\n    }, [\n        latestMiddleware,\n        placement,\n        strategy,\n        platformRef,\n        openRef\n    ]);\n    index(()=>{\n        if (open === false && dataRef.current.isPositioned) {\n            dataRef.current.isPositioned = false;\n            setData((data)=>({\n                    ...data,\n                    isPositioned: false\n                }));\n        }\n    }, [\n        open\n    ]);\n    const isMountedRef = react__WEBPACK_IMPORTED_MODULE_2__.useRef(false);\n    index(()=>{\n        isMountedRef.current = true;\n        return ()=>{\n            isMountedRef.current = false;\n        };\n    }, []);\n    index(()=>{\n        if (referenceEl) referenceRef.current = referenceEl;\n        if (floatingEl) floatingRef.current = floatingEl;\n        if (referenceEl && floatingEl) {\n            if (whileElementsMountedRef.current) {\n                return whileElementsMountedRef.current(referenceEl, floatingEl, update);\n            }\n            update();\n        }\n    }, [\n        referenceEl,\n        floatingEl,\n        update,\n        whileElementsMountedRef,\n        hasWhileElementsMounted\n    ]);\n    const refs = react__WEBPACK_IMPORTED_MODULE_2__.useMemo(()=>({\n            reference: referenceRef,\n            floating: floatingRef,\n            setReference,\n            setFloating\n        }), [\n        setReference,\n        setFloating\n    ]);\n    const elements = react__WEBPACK_IMPORTED_MODULE_2__.useMemo(()=>({\n            reference: referenceEl,\n            floating: floatingEl\n        }), [\n        referenceEl,\n        floatingEl\n    ]);\n    const floatingStyles = react__WEBPACK_IMPORTED_MODULE_2__.useMemo(()=>{\n        const initialStyles = {\n            position: strategy,\n            left: 0,\n            top: 0\n        };\n        if (!elements.floating) {\n            return initialStyles;\n        }\n        const x = roundByDPR(elements.floating, data.x);\n        const y = roundByDPR(elements.floating, data.y);\n        if (transform) {\n            return {\n                ...initialStyles,\n                transform: \"translate(\" + x + \"px, \" + y + \"px)\",\n                ...getDPR(elements.floating) >= 1.5 && {\n                    willChange: \"transform\"\n                }\n            };\n        }\n        return {\n            position: strategy,\n            left: x,\n            top: y\n        };\n    }, [\n        strategy,\n        transform,\n        elements.floating,\n        data.x,\n        data.y\n    ]);\n    return react__WEBPACK_IMPORTED_MODULE_2__.useMemo(()=>({\n            ...data,\n            update,\n            refs,\n            elements,\n            floatingStyles\n        }), [\n        data,\n        update,\n        refs,\n        elements,\n        floatingStyles\n    ]);\n}\n_s1(useFloating, \"XAHTmgTUxWuleeuSZsrxFzZS2ho=\", false, function() {\n    return [\n        useLatestRef,\n        useLatestRef,\n        useLatestRef\n    ];\n});\n/**\n * Provides data to position an inner element of the floating element so that it\n * appears centered to the reference element.\n * This wraps the core `arrow` middleware to allow React refs as the element.\n * @see https://floating-ui.com/docs/arrow\n */ const arrow$1 = (options)=>{\n    function isRef(value) {\n        return ({}).hasOwnProperty.call(value, \"current\");\n    }\n    return {\n        name: \"arrow\",\n        options,\n        fn (state) {\n            const { element, padding } = typeof options === \"function\" ? options(state) : options;\n            if (element && isRef(element)) {\n                if (element.current != null) {\n                    return (0,_floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__.arrow)({\n                        element: element.current,\n                        padding\n                    }).fn(state);\n                }\n                return {};\n            }\n            if (element) {\n                return (0,_floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__.arrow)({\n                    element,\n                    padding\n                }).fn(state);\n            }\n            return {};\n        }\n    };\n};\n/**\n * Modifies the placement by translating the floating element along the\n * specified axes.\n * A number (shorthand for `mainAxis` or distance), or an axes configuration\n * object may be passed.\n * @see https://floating-ui.com/docs/offset\n */ const offset = (options, deps)=>({\n        ...(0,_floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__.offset)(options),\n        options: [\n            options,\n            deps\n        ]\n    });\n/**\n * Optimizes the visibility of the floating element by shifting it in order to\n * keep it in view when it will overflow the clipping boundary.\n * @see https://floating-ui.com/docs/shift\n */ const shift = (options, deps)=>({\n        ...(0,_floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__.shift)(options),\n        options: [\n            options,\n            deps\n        ]\n    });\n/**\n * Built-in `limiter` that will stop `shift()` at a certain point.\n */ const limitShift = (options, deps)=>({\n        ...(0,_floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__.limitShift)(options),\n        options: [\n            options,\n            deps\n        ]\n    });\n/**\n * Optimizes the visibility of the floating element by flipping the `placement`\n * in order to keep it in view when the preferred placement(s) will overflow the\n * clipping boundary. Alternative to `autoPlacement`.\n * @see https://floating-ui.com/docs/flip\n */ const flip = (options, deps)=>({\n        ...(0,_floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__.flip)(options),\n        options: [\n            options,\n            deps\n        ]\n    });\n/**\n * Provides data that allows you to change the size of the floating element \n * for instance, prevent it from overflowing the clipping boundary or match the\n * width of the reference element.\n * @see https://floating-ui.com/docs/size\n */ const size = (options, deps)=>({\n        ...(0,_floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__.size)(options),\n        options: [\n            options,\n            deps\n        ]\n    });\n/**\n * Optimizes the visibility of the floating element by choosing the placement\n * that has the most space available automatically, without needing to specify a\n * preferred placement. Alternative to `flip`.\n * @see https://floating-ui.com/docs/autoPlacement\n */ const autoPlacement = (options, deps)=>({\n        ...(0,_floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__.autoPlacement)(options),\n        options: [\n            options,\n            deps\n        ]\n    });\n/**\n * Provides data to hide the floating element in applicable situations, such as\n * when it is not in the same clipping context as the reference element.\n * @see https://floating-ui.com/docs/hide\n */ const hide = (options, deps)=>({\n        ...(0,_floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__.hide)(options),\n        options: [\n            options,\n            deps\n        ]\n    });\n/**\n * Provides improved positioning for inline reference elements that can span\n * over multiple lines, such as hyperlinks or range selections.\n * @see https://floating-ui.com/docs/inline\n */ const inline = (options, deps)=>({\n        ...(0,_floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__.inline)(options),\n        options: [\n            options,\n            deps\n        ]\n    });\n/**\n * Provides data to position an inner element of the floating element so that it\n * appears centered to the reference element.\n * This wraps the core `arrow` middleware to allow React refs as the element.\n * @see https://floating-ui.com/docs/arrow\n */ const arrow = (options, deps)=>({\n        ...arrow$1(options),\n        options: [\n            options,\n            deps\n        ]\n    });\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQGZsb2F0aW5nLXVpL3JlYWN0LWRvbS9kaXN0L2Zsb2F0aW5nLXVpLnJlYWN0LWRvbS5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBNk87QUFDOUg7QUFDaEY7QUFDb0I7QUFDYjtBQUV0QyxJQUFJMkIsUUFBUSxPQUFPQyxhQUFhLGNBQWNKLGtEQUFlQSxHQUFHQyw0Q0FBU0E7QUFFekUsZ0ZBQWdGO0FBQ2hGLFlBQVk7QUFDWixTQUFTSSxVQUFVQyxDQUFDLEVBQUVDLENBQUM7SUFDckIsSUFBSUQsTUFBTUMsR0FBRztRQUNYLE9BQU87SUFDVDtJQUNBLElBQUksT0FBT0QsTUFBTSxPQUFPQyxHQUFHO1FBQ3pCLE9BQU87SUFDVDtJQUNBLElBQUksT0FBT0QsTUFBTSxjQUFjQSxFQUFFRSxRQUFRLE9BQU9ELEVBQUVDLFFBQVEsSUFBSTtRQUM1RCxPQUFPO0lBQ1Q7SUFDQSxJQUFJQztJQUNKLElBQUlDO0lBQ0osSUFBSUM7SUFDSixJQUFJTCxLQUFLQyxLQUFLLE9BQU9ELE1BQU0sVUFBVTtRQUNuQyxJQUFJTSxNQUFNQyxPQUFPLENBQUNQLElBQUk7WUFDcEJHLFNBQVNILEVBQUVHLE1BQU07WUFDakIsSUFBSUEsV0FBV0YsRUFBRUUsTUFBTSxFQUFFLE9BQU87WUFDaEMsSUFBS0MsSUFBSUQsUUFBUUMsUUFBUSxHQUFJO2dCQUMzQixJQUFJLENBQUNMLFVBQVVDLENBQUMsQ0FBQ0ksRUFBRSxFQUFFSCxDQUFDLENBQUNHLEVBQUUsR0FBRztvQkFDMUIsT0FBTztnQkFDVDtZQUNGO1lBQ0EsT0FBTztRQUNUO1FBQ0FDLE9BQU9HLE9BQU9ILElBQUksQ0FBQ0w7UUFDbkJHLFNBQVNFLEtBQUtGLE1BQU07UUFDcEIsSUFBSUEsV0FBV0ssT0FBT0gsSUFBSSxDQUFDSixHQUFHRSxNQUFNLEVBQUU7WUFDcEMsT0FBTztRQUNUO1FBQ0EsSUFBS0MsSUFB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UztZQUFDQTtZQUFTMEQ7U0FBSztJQUMxQjtBQUVBOzs7OztDQUtDLEdBQ0QsTUFBTXJILFFBQVEsQ0FBQzJELFNBQVMwRCxPQUFVO1FBQ2hDLEdBQUdOLFFBQVFwRCxRQUFRO1FBQ25CQSxTQUFTO1lBQUNBO1lBQVMwRDtTQUFLO0lBQzFCO0FBRWtHIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQGZsb2F0aW5nLXVpL3JlYWN0LWRvbS9kaXN0L2Zsb2F0aW5nLXVpLnJlYWN0LWRvbS5tanM/NDk4OCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBjb21wdXRlUG9zaXRpb24sIGFycm93IGFzIGFycm93JDIsIG9mZnNldCBhcyBvZmZzZXQkMSwgc2hpZnQgYXMgc2hpZnQkMSwgbGltaXRTaGlmdCBhcyBsaW1pdFNoaWZ0JDEsIGZsaXAgYXMgZmxpcCQxLCBzaXplIGFzIHNpemUkMSwgYXV0b1BsYWNlbWVudCBhcyBhdXRvUGxhY2VtZW50JDEsIGhpZGUgYXMgaGlkZSQxLCBpbmxpbmUgYXMgaW5saW5lJDEgfSBmcm9tICdAZmxvYXRpbmctdWkvZG9tJztcbmV4cG9ydCB7IGF1dG9VcGRhdGUsIGNvbXB1dGVQb3NpdGlvbiwgZGV0ZWN0T3ZlcmZsb3csIGdldE92ZXJmbG93QW5jZXN0b3JzLCBwbGF0Zm9ybSB9IGZyb20gJ0BmbG9hdGluZy11aS9kb20nO1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgdXNlTGF5b3V0RWZmZWN0LCB1c2VFZmZlY3QgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgKiBhcyBSZWFjdERPTSBmcm9tICdyZWFjdC1kb20nO1xuXG52YXIgaW5kZXggPSB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnID8gdXNlTGF5b3V0RWZmZWN0IDogdXNlRWZmZWN0O1xuXG4vLyBGb3JrIG9mIGBmYXN0LWRlZXAtZXF1YWxgIHRoYXQgb25seSBkb2VzIHRoZSBjb21wYXJpc29ucyB3ZSBuZWVkIGFuZCBjb21wYXJlc1xuLy8gZnVuY3Rpb25zXG5mdW5jdGlvbiBkZWVwRXF1YWwoYSwgYikge1xuICBpZiAoYSA9PT0gYikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmICh0eXBlb2YgYSAhPT0gdHlwZW9mIGIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKHR5cGVvZiBhID09PSAnZnVuY3Rpb24nICYmIGEudG9TdHJpbmcoKSA9PT0gYi50b1N0cmluZygpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgbGV0IGxlbmd0aDtcbiAgbGV0IGk7XG4gIGxldCBrZXlzO1xuICBpZiAoYSAmJiBiICYmIHR5cGVvZiBhID09PSAnb2JqZWN0Jykge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGEpKSB7XG4gICAgICBsZW5ndGggPSBhLmxlbmd0aDtcbiAgICAgIGlmIChsZW5ndGggIT09IGIubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG4gICAgICBmb3IgKGkgPSBsZW5ndGg7IGktLSAhPT0gMDspIHtcbiAgICAgICAgaWYgKCFkZWVwRXF1YWwoYVtpXSwgYltpXSkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBrZXlzID0gT2JqZWN0LmtleXMoYSk7XG4gICAgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gICAgaWYgKGxlbmd0aCAhPT0gT2JqZWN0LmtleXMoYikubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGZvciAoaSA9IGxlbmd0aDsgaS0tICE9PSAwOykge1xuICAgICAgaWYgKCF7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIGtleXNbaV0pKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChpID0gbGVuZ3RoOyBpLS0gIT09IDA7KSB7XG4gICAgICBjb25zdCBrZXkgPSBrZXlzW2ldO1xuICAgICAgaWYgKGtleSA9PT0gJ19vd25lcicgJiYgYS4kJHR5cGVvZikge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmICghZGVlcEVxdWFsKGFba2V5XSwgYltrZXldKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBhICE9PSBhICYmIGIgIT09IGI7XG59XG5cbmZ1bmN0aW9uIGdldERQUihlbGVtZW50KSB7XG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiAxO1xuICB9XG4gIGNvbnN0IHdpbiA9IGVsZW1lbnQub3duZXJEb2N1bWVudC5kZWZhdWx0VmlldyB8fCB3aW5kb3c7XG4gIHJldHVybiB3aW4uZGV2aWNlUGl4ZWxSYXRpbyB8fCAxO1xufVxuXG5mdW5jdGlvbiByb3VuZEJ5RFBSKGVsZW1lbnQsIHZhbHVlKSB7XG4gIGNvbnN0IGRwciA9IGdldERQUihlbGVtZW50KTtcbiAgcmV0dXJuIE1hdGgucm91bmQodmFsdWUgKiBkcHIpIC8gZHByO1xufVxuXG5mdW5jdGlvbiB1c2VMYXRlc3RSZWYodmFsdWUpIHtcbiAgY29uc3QgcmVmID0gUmVhY3QudXNlUmVmKHZhbHVlKTtcbiAgaW5kZXgoKCkgPT4ge1xuICAgIHJlZi5jdXJyZW50ID0gdmFsdWU7XG4gIH0pO1xuICByZXR1cm4gcmVmO1xufVxuXG4vKipcbiAqIFByb3ZpZGVzIGRhdGEgdG8gcG9zaXRpb24gYSBmbG9hdGluZyBlbGVtZW50LlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL3VzZUZsb2F0aW5nXG4gKi9cbmZ1bmN0aW9uIHVzZUZsb2F0aW5nKG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuICBjb25zdCB7XG4gICAgcGxhY2VtZW50ID0gJ2JvdHRvbScsXG4gICAgc3RyYXRlZ3kgPSAnYWJzb2x1dGUnLFxuICAgIG1pZGRsZXdhcmUgPSBbXSxcbiAgICBwbGF0Zm9ybSxcbiAgICBlbGVtZW50czoge1xuICAgICAgcmVmZXJlbmNlOiBleHRlcm5hbFJlZmVyZW5jZSxcbiAgICAgIGZsb2F0aW5nOiBleHRlcm5hbEZsb2F0aW5nXG4gICAgfSA9IHt9LFxuICAgIHRyYW5zZm9ybSA9IHRydWUsXG4gICAgd2hpbGVFbGVtZW50c01vdW50ZWQsXG4gICAgb3BlblxuICB9ID0gb3B0aW9ucztcbiAgY29uc3QgW2RhdGEsIHNldERhdGFdID0gUmVhY3QudXNlU3RhdGUoe1xuICAgIHg6IDAsXG4gICAgeTogMCxcbiAgICBzdHJhdGVneSxcbiAgICBwbGFjZW1lbnQsXG4gICAgbWlkZGxld2FyZURhdGE6IHt9LFxuICAgIGlzUG9zaXRpb25lZDogZmFsc2VcbiAgfSk7XG4gIGNvbnN0IFtsYXRlc3RNaWRkbGV3YXJlLCBzZXRMYXRlc3RNaWRkbGV3YXJlXSA9IFJlYWN0LnVzZVN0YXRlKG1pZGRsZXdhcmUpO1xuICBpZiAoIWRlZXBFcXVhbChsYXRlc3RNaWRkbGV3YXJlLCBtaWRkbGV3YXJlKSkge1xuICAgIHNldExhdGVzdE1pZGRsZXdhcmUobWlkZGxld2FyZSk7XG4gIH1cbiAgY29uc3QgW19yZWZlcmVuY2UsIF9zZXRSZWZlcmVuY2VdID0gUmVhY3QudXNlU3RhdGUobnVsbCk7XG4gIGNvbnN0IFtfZmxvYXRpbmcsIF9zZXRGbG9hdGluZ10gPSBSZWFjdC51c2VTdGF0ZShudWxsKTtcbiAgY29uc3Qgc2V0UmVmZXJlbmNlID0gUmVhY3QudXNlQ2FsbGJhY2sobm9kZSA9PiB7XG4gICAgaWYgKG5vZGUgIT09IHJlZmVyZW5jZVJlZi5jdXJyZW50KSB7XG4gICAgICByZWZlcmVuY2VSZWYuY3VycmVudCA9IG5vZGU7XG4gICAgICBfc2V0UmVmZXJlbmNlKG5vZGUpO1xuICAgIH1cbiAgfSwgW10pO1xuICBjb25zdCBzZXRGbG9hdGluZyA9IFJlYWN0LnVzZUNhbGxiYWNrKG5vZGUgPT4ge1xuICAgIGlmIChub2RlICE9PSBmbG9hdGluZ1JlZi5jdXJyZW50KSB7XG4gICAgICBmbG9hdGluZ1JlZi5jdXJyZW50ID0gbm9kZTtcbiAgICAgIF9zZXRGbG9hdGluZyhub2RlKTtcbiAgICB9XG4gIH0sIFtdKTtcbiAgY29uc3QgcmVmZXJlbmNlRWwgPSBleHRlcm5hbFJlZmVyZW5jZSB8fCBfcmVmZXJlbmNlO1xuICBjb25zdCBmbG9hdGluZ0VsID0gZXh0ZXJuYWxGbG9hdGluZyB8fCBfZmxvYXRpbmc7XG4gIGNvbnN0IHJlZmVyZW5jZVJlZiA9IFJlYWN0LnVzZVJlZihudWxsKTtcbiAgY29uc3QgZmxvYXRpbmdSZWYgPSBSZWFjdC51c2VSZWYobnVsbCk7XG4gIGNvbnN0IGRhdGFSZWYgPSBSZWFjdC51c2VSZWYoZGF0YSk7XG4gIGNvbnN0IGhhc1doaWxlRWxlbWVudHNNb3VudGVkID0gd2hpbGVFbGVtZW50c01vdW50ZWQgIT0gbnVsbDtcbiAgY29uc3Qgd2hpbGVFbGVtZW50c01vdW50ZWRSZWYgPSB1c2VMYXRlc3RSZWYod2hpbGVFbGVtZW50c01vdW50ZWQpO1xuICBjb25zdCBwbGF0Zm9ybVJlZiA9IHVzZUxhdGVzdFJlZihwbGF0Zm9ybSk7XG4gIGNvbnN0IG9wZW5SZWYgPSB1c2VMYXRlc3RSZWYob3Blbik7XG4gIGNvbnN0IHVwZGF0ZSA9IFJlYWN0LnVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBpZiAoIXJlZmVyZW5jZVJlZi5jdXJyZW50IHx8ICFmbG9hdGluZ1JlZi5jdXJyZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGNvbmZpZyA9IHtcbiAgICAgIHBsYWNlbWVudCxcbiAgICAgIHN0cmF0ZWd5LFxuICAgICAgbWlkZGxld2FyZTogbGF0ZXN0TWlkZGxld2FyZVxuICAgIH07XG4gICAgaWYgKHBsYXRmb3JtUmVmLmN1cnJlbnQpIHtcbiAgICAgIGNvbmZpZy5wbGF0Zm9ybSA9IHBsYXRmb3JtUmVmLmN1cnJlbnQ7XG4gICAgfVxuICAgIGNvbXB1dGVQb3NpdGlvbihyZWZlcmVuY2VSZWYuY3VycmVudCwgZmxvYXRpbmdSZWYuY3VycmVudCwgY29uZmlnKS50aGVuKGRhdGEgPT4ge1xuICAgICAgY29uc3QgZnVsbERhdGEgPSB7XG4gICAgICAgIC4uLmRhdGEsXG4gICAgICAgIC8vIFRoZSBmbG9hdGluZyBlbGVtZW50J3MgcG9zaXRpb24gbWF5IGJlIHJlY29tcHV0ZWQgd2hpbGUgaXQncyBjbG9zZWRcbiAgICAgICAgLy8gYnV0IHN0aWxsIG1vdW50ZWQgKHN1Y2ggYXMgd2hlbiB0cmFuc2l0aW9uaW5nIG91dCkuIFRvIGVuc3VyZVxuICAgICAgICAvLyBgaXNQb3NpdGlvbmVkYCB3aWxsIGJlIGBmYWxzZWAgaW5pdGlhbGx5IG9uIHRoZSBuZXh0IG9wZW4sIGF2b2lkXG4gICAgICAgIC8vIHNldHRpbmcgaXQgdG8gYHRydWVgIHdoZW4gYG9wZW4gPT09IGZhbHNlYCAobXVzdCBiZSBzcGVjaWZpZWQpLlxuICAgICAgICBpc1Bvc2l0aW9uZWQ6IG9wZW5SZWYuY3VycmVudCAhPT0gZmFsc2VcbiAgICAgIH07XG4gICAgICBpZiAoaXNNb3VudGVkUmVmLmN1cnJlbnQgJiYgIWRlZXBFcXVhbChkYXRhUmVmLmN1cnJlbnQsIGZ1bGxEYXRhKSkge1xuICAgICAgICBkYXRhUmVmLmN1cnJlbnQgPSBmdWxsRGF0YTtcbiAgICAgICAgUmVhY3RET00uZmx1c2hTeW5jKCgpID0+IHtcbiAgICAgICAgICBzZXREYXRhKGZ1bGxEYXRhKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0sIFtsYXRlc3RNaWRkbGV3YXJlLCBwbGFjZW1lbnQsIHN0cmF0ZWd5LCBwbGF0Zm9ybVJlZiwgb3BlblJlZl0pO1xuICBpbmRleCgoKSA9PiB7XG4gICAgaWYgKG9wZW4gPT09IGZhbHNlICYmIGRhdGFSZWYuY3VycmVudC5pc1Bvc2l0aW9uZWQpIHtcbiAgICAgIGRhdGFSZWYuY3VycmVudC5pc1Bvc2l0aW9uZWQgPSBmYWxzZTtcbiAgICAgIHNldERhdGEoZGF0YSA9PiAoe1xuICAgICAgICAuLi5kYXRhLFxuICAgICAgICBpc1Bvc2l0aW9uZWQ6IGZhbHNlXG4gICAgICB9KSk7XG4gICAgfVxuICB9LCBbb3Blbl0pO1xuICBjb25zdCBpc01vdW50ZWRSZWYgPSBSZWFjdC51c2VSZWYoZmFsc2UpO1xuICBpbmRleCgoKSA9PiB7XG4gICAgaXNNb3VudGVkUmVmLmN1cnJlbnQgPSB0cnVlO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBpc01vdW50ZWRSZWYuY3VycmVudCA9IGZhbHNlO1xuICAgIH07XG4gIH0sIFtdKTtcbiAgaW5kZXgoKCkgPT4ge1xuICAgIGlmIChyZWZlcmVuY2VFbCkgcmVmZXJlbmNlUmVmLmN1cnJlbnQgPSByZWZlcmVuY2VFbDtcbiAgICBpZiAoZmxvYXRpbmdFbCkgZmxvYXRpbmdSZWYuY3VycmVudCA9IGZsb2F0aW5nRWw7XG4gICAgaWYgKHJlZmVyZW5jZUVsICYmIGZsb2F0aW5nRWwpIHtcbiAgICAgIGlmICh3aGlsZUVsZW1lbnRzTW91bnRlZFJlZi5jdXJyZW50KSB7XG4gICAgICAgIHJldHVybiB3aGlsZUVsZW1lbnRzTW91bnRlZFJlZi5jdXJyZW50KHJlZmVyZW5jZUVsLCBmbG9hdGluZ0VsLCB1cGRhdGUpO1xuICAgICAgfVxuICAgICAgdXBkYXRlKCk7XG4gICAgfVxuICB9LCBbcmVmZXJlbmNlRWwsIGZsb2F0aW5nRWwsIHVwZGF0ZSwgd2hpbGVFbGVtZW50c01vdW50ZWRSZWYsIGhhc1doaWxlRWxlbWVudHNNb3VudGVkXSk7XG4gIGNvbnN0IHJlZnMgPSBSZWFjdC51c2VNZW1vKCgpID0+ICh7XG4gICAgcmVmZXJlbmNlOiByZWZlcmVuY2VSZWYsXG4gICAgZmxvYXRpbmc6IGZsb2F0aW5nUmVmLFxuICAgIHNldFJlZmVyZW5jZSxcbiAgICBzZXRGbG9hdGluZ1xuICB9KSwgW3NldFJlZmVyZW5jZSwgc2V0RmxvYXRpbmddKTtcbiAgY29uc3QgZWxlbWVudHMgPSBSZWFjdC51c2VNZW1vKCgpID0+ICh7XG4gICAgcmVmZXJlbmNlOiByZWZlcmVuY2VFbCxcbiAgICBmbG9hdGluZzogZmxvYXRpbmdFbFxuICB9KSwgW3JlZmVyZW5jZUVsLCBmbG9hdGluZ0VsXSk7XG4gIGNvbnN0IGZsb2F0aW5nU3R5bGVzID0gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgY29uc3QgaW5pdGlhbFN0eWxlcyA9IHtcbiAgICAgIHBvc2l0aW9uOiBzdHJhdGVneSxcbiAgICAgIGxlZnQ6IDAsXG4gICAgICB0b3A6IDBcbiAgICB9O1xuICAgIGlmICghZWxlbWVudHMuZmxvYXRpbmcpIHtcbiAgICAgIHJldHVybiBpbml0aWFsU3R5bGVzO1xuICAgIH1cbiAgICBjb25zdCB4ID0gcm91bmRCeURQUihlbGVtZW50cy5mbG9hdGluZywgZGF0YS54KTtcbiAgICBjb25zdCB5ID0gcm91bmRCeURQUihlbGVtZW50cy5mbG9hdGluZywgZGF0YS55KTtcbiAgICBpZiAodHJhbnNmb3JtKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5pbml0aWFsU3R5bGVzLFxuICAgICAgICB0cmFuc2Zvcm06IFwidHJhbnNsYXRlKFwiICsgeCArIFwicHgsIFwiICsgeSArIFwicHgpXCIsXG4gICAgICAgIC4uLihnZXREUFIoZWxlbWVudHMuZmxvYXRpbmcpID49IDEuNSAmJiB7XG4gICAgICAgICAgd2lsbENoYW5nZTogJ3RyYW5zZm9ybSdcbiAgICAgICAgfSlcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBwb3NpdGlvbjogc3RyYXRlZ3ksXG4gICAgICBsZWZ0OiB4LFxuICAgICAgdG9wOiB5XG4gICAgfTtcbiAgfSwgW3N0cmF0ZWd5LCB0cmFuc2Zvcm0sIGVsZW1lbnRzLmZsb2F0aW5nLCBkYXRhLngsIGRhdGEueV0pO1xuICByZXR1cm4gUmVhY3QudXNlTWVtbygoKSA9PiAoe1xuICAgIC4uLmRhdGEsXG4gICAgdXBkYXRlLFxuICAgIHJlZnMsXG4gICAgZWxlbWVudHMsXG4gICAgZmxvYXRpbmdTdHlsZXNcbiAgfSksIFtkYXRhLCB1cGRhdGUsIHJlZnMsIGVsZW1lbnRzLCBmbG9hdGluZ1N0eWxlc10pO1xufVxuXG4vKipcbiAqIFByb3ZpZGVzIGRhdGEgdG8gcG9zaXRpb24gYW4gaW5uZXIgZWxlbWVudCBvZiB0aGUgZmxvYXRpbmcgZWxlbWVudCBzbyB0aGF0IGl0XG4gKiBhcHBlYXJzIGNlbnRlcmVkIHRvIHRoZSByZWZlcmVuY2UgZWxlbWVudC5cbiAqIFRoaXMgd3JhcHMgdGhlIGNvcmUgYGFycm93YCBtaWRkbGV3YXJlIHRvIGFsbG93IFJlYWN0IHJlZnMgYXMgdGhlIGVsZW1lbnQuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvYXJyb3dcbiAqL1xuY29uc3QgYXJyb3ckMSA9IG9wdGlvbnMgPT4ge1xuICBmdW5jdGlvbiBpc1JlZih2YWx1ZSkge1xuICAgIHJldHVybiB7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCAnY3VycmVudCcpO1xuICB9XG4gIHJldHVybiB7XG4gICAgbmFtZTogJ2Fycm93JyxcbiAgICBvcHRpb25zLFxuICAgIGZuKHN0YXRlKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGVsZW1lbnQsXG4gICAgICAgIHBhZGRpbmdcbiAgICAgIH0gPSB0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJyA/IG9wdGlvbnMoc3RhdGUpIDogb3B0aW9ucztcbiAgICAgIGlmIChlbGVtZW50ICYmIGlzUmVmKGVsZW1lbnQpKSB7XG4gICAgICAgIGlmIChlbGVtZW50LmN1cnJlbnQgIT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBhcnJvdyQyKHtcbiAgICAgICAgICAgIGVsZW1lbnQ6IGVsZW1lbnQuY3VycmVudCxcbiAgICAgICAgICAgIHBhZGRpbmdcbiAgICAgICAgICB9KS5mbihzdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgfVxuICAgICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIGFycm93JDIoe1xuICAgICAgICAgIGVsZW1lbnQsXG4gICAgICAgICAgcGFkZGluZ1xuICAgICAgICB9KS5mbihzdGF0ZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuICB9O1xufTtcblxuLyoqXG4gKiBNb2RpZmllcyB0aGUgcGxhY2VtZW50IGJ5IHRyYW5zbGF0aW5nIHRoZSBmbG9hdGluZyBlbGVtZW50IGFsb25nIHRoZVxuICogc3BlY2lmaWVkIGF4ZXMuXG4gKiBBIG51bWJlciAoc2hvcnRoYW5kIGZvciBgbWFpbkF4aXNgIG9yIGRpc3RhbmNlKSwgb3IgYW4gYXhlcyBjb25maWd1cmF0aW9uXG4gKiBvYmplY3QgbWF5IGJlIHBhc3NlZC5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9vZmZzZXRcbiAqL1xuY29uc3Qgb2Zmc2V0ID0gKG9wdGlvbnMsIGRlcHMpID0+ICh7XG4gIC4uLm9mZnNldCQxKG9wdGlvbnMpLFxuICBvcHRpb25zOiBbb3B0aW9ucywgZGVwc11cbn0pO1xuXG4vKipcbiAqIE9wdGltaXplcyB0aGUgdmlzaWJpbGl0eSBvZiB0aGUgZmxvYXRpbmcgZWxlbWVudCBieSBzaGlmdGluZyBpdCBpbiBvcmRlciB0b1xuICoga2VlcCBpdCBpbiB2aWV3IHdoZW4gaXQgd2lsbCBvdmVyZmxvdyB0aGUgY2xpcHBpbmcgYm91bmRhcnkuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3Mvc2hpZnRcbiAqL1xuY29uc3Qgc2hpZnQgPSAob3B0aW9ucywgZGVwcykgPT4gKHtcbiAgLi4uc2hpZnQkMShvcHRpb25zKSxcbiAgb3B0aW9uczogW29wdGlvbnMsIGRlcHNdXG59KTtcblxuLyoqXG4gKiBCdWlsdC1pbiBgbGltaXRlcmAgdGhhdCB3aWxsIHN0b3AgYHNoaWZ0KClgIGF0IGEgY2VydGFpbiBwb2ludC5cbiAqL1xuY29uc3QgbGltaXRTaGlmdCA9IChvcHRpb25zLCBkZXBzKSA9PiAoe1xuICAuLi5saW1pdFNoaWZ0JDEob3B0aW9ucyksXG4gIG9wdGlvbnM6IFtvcHRpb25zLCBkZXBzXVxufSk7XG5cbi8qKlxuICogT3B0aW1pemVzIHRoZSB2aXNpYmlsaXR5IG9mIHRoZSBmbG9hdGluZyBlbGVtZW50IGJ5IGZsaXBwaW5nIHRoZSBgcGxhY2VtZW50YFxuICogaW4gb3JkZXIgdG8ga2VlcCBpdCBpbiB2aWV3IHdoZW4gdGhlIHByZWZlcnJlZCBwbGFjZW1lbnQocykgd2lsbCBvdmVyZmxvdyB0aGVcbiAqIGNsaXBwaW5nIGJvdW5kYXJ5LiBBbHRlcm5hdGl2ZSB0byBgYXV0b1BsYWNlbWVudGAuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvZmxpcFxuICovXG5jb25zdCBmbGlwID0gKG9wdGlvbnMsIGRlcHMpID0+ICh7XG4gIC4uLmZsaXAkMShvcHRpb25zKSxcbiAgb3B0aW9uczogW29wdGlvbnMsIGRlcHNdXG59KTtcblxuLyoqXG4gKiBQcm92aWRlcyBkYXRhIHRoYXQgYWxsb3dzIHlvdSB0byBjaGFuZ2UgdGhlIHNpemUgb2YgdGhlIGZsb2F0aW5nIGVsZW1lbnQg4oCUXG4gKiBmb3IgaW5zdGFuY2UsIHByZXZlbnQgaXQgZnJvbSBvdmVyZmxvd2luZyB0aGUgY2xpcHBpbmcgYm91bmRhcnkgb3IgbWF0Y2ggdGhlXG4gKiB3aWR0aCBvZiB0aGUgcmVmZXJlbmNlIGVsZW1lbnQuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3Mvc2l6ZVxuICovXG5jb25zdCBzaXplID0gKG9wdGlvbnMsIGRlcHMpID0+ICh7XG4gIC4uLnNpemUkMShvcHRpb25zKSxcbiAgb3B0aW9uczogW29wdGlvbnMsIGRlcHNdXG59KTtcblxuLyoqXG4gKiBPcHRpbWl6ZXMgdGhlIHZpc2liaWxpdHkgb2YgdGhlIGZsb2F0aW5nIGVsZW1lbnQgYnkgY2hvb3NpbmcgdGhlIHBsYWNlbWVudFxuICogdGhhdCBoYXMgdGhlIG1vc3Qgc3BhY2UgYXZhaWxhYmxlIGF1dG9tYXRpY2FsbHksIHdpdGhvdXQgbmVlZGluZyB0byBzcGVjaWZ5IGFcbiAqIHByZWZlcnJlZCBwbGFjZW1lbnQuIEFsdGVybmF0aXZlIHRvIGBmbGlwYC5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9hdXRvUGxhY2VtZW50XG4gKi9cbmNvbnN0IGF1dG9QbGFjZW1lbnQgPSAob3B0aW9ucywgZGVwcykgPT4gKHtcbiAgLi4uYXV0b1BsYWNlbWVudCQxKG9wdGlvbnMpLFxuICBvcHRpb25zOiBbb3B0aW9ucywgZGVwc11cbn0pO1xuXG4vKipcbiAqIFByb3ZpZGVzIGRhdGEgdG8gaGlkZSB0aGUgZmxvYXRpbmcgZWxlbWVudCBpbiBhcHBsaWNhYmxlIHNpdHVhdGlvbnMsIHN1Y2ggYXNcbiAqIHdoZW4gaXQgaXMgbm90IGluIHRoZSBzYW1lIGNsaXBwaW5nIGNvbnRleHQgYXMgdGhlIHJlZmVyZW5jZSBlbGVtZW50LlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL2hpZGVcbiAqL1xuY29uc3QgaGlkZSA9IChvcHRpb25zLCBkZXBzKSA9PiAoe1xuICAuLi5oaWRlJDEob3B0aW9ucyksXG4gIG9wdGlvbnM6IFtvcHRpb25zLCBkZXBzXVxufSk7XG5cbi8qKlxuICogUHJvdmlkZXMgaW1wcm92ZWQgcG9zaXRpb25pbmcgZm9yIGlubGluZSByZWZlcmVuY2UgZWxlbWVudHMgdGhhdCBjYW4gc3BhblxuICogb3ZlciBtdWx0aXBsZSBsaW5lcywgc3VjaCBhcyBoeXBlcmxpbmtzIG9yIHJhbmdlIHNlbGVjdGlvbnMuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvaW5saW5lXG4gKi9cbmNvbnN0IGlubGluZSA9IChvcHRpb25zLCBkZXBzKSA9PiAoe1xuICAuLi5pbmxpbmUkMShvcHRpb25zKSxcbiAgb3B0aW9uczogW29wdGlvbnMsIGRlcHNdXG59KTtcblxuLyoqXG4gKiBQcm92aWRlcyBkYXRhIHRvIHBvc2l0aW9uIGFuIGlubmVyIGVsZW1lbnQgb2YgdGhlIGZsb2F0aW5nIGVsZW1lbnQgc28gdGhhdCBpdFxuICogYXBwZWFycyBjZW50ZXJlZCB0byB0aGUgcmVmZXJlbmNlIGVsZW1lbnQuXG4gKiBUaGlzIHdyYXBzIHRoZSBjb3JlIGBhcnJvd2AgbWlkZGxld2FyZSB0byBhbGxvdyBSZWFjdCByZWZzIGFzIHRoZSBlbGVtZW50LlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL2Fycm93XG4gKi9cbmNvbnN0IGFycm93ID0gKG9wdGlvbnMsIGRlcHMpID0+ICh7XG4gIC4uLmFycm93JDEob3B0aW9ucyksXG4gIG9wdGlvbnM6IFtvcHRpb25zLCBkZXBzXVxufSk7XG5cbmV4cG9ydCB7IGFycm93LCBhdXRvUGxhY2VtZW50LCBmbGlwLCBoaWRlLCBpbmxpbmUsIGxpbWl0U2hpZnQsIG9mZnNldCwgc2hpZnQsIHNpemUsIHVzZUZsb2F0aW5nIH07XG4iXSwibmFtZXMiOlsiY29tcHV0ZVBvc2l0aW9uIiwiYXJyb3ciLCJhcnJvdyQyIiwib2Zmc2V0Iiwib2Zmc2V0JDEiLCJzaGlmdCIsInNoaWZ0JDEiLCJsaW1pdFNoaWZ0IiwibGltaXRTaGlmdCQxIiwiZmxpcCIsImZsaXAkMSIsInNpemUiLCJzaXplJDEiLCJhdXRvUGxhY2VtZW50IiwiYXV0b1BsYWNlbWVudCQxIiwiaGlkZSIsImhpZGUkMSIsImlubGluZSIsImlubGluZSQxIiwiYXV0b1VwZGF0ZSIsImRldGVjdE92ZXJmbG93IiwiZ2V0T3ZlcmZsb3dBbmNlc3RvcnMiLCJwbGF0Zm9ybSIsIlJlYWN0IiwidXNlTGF5b3V0RWZmZWN0IiwidXNlRWZmZWN0IiwiUmVhY3RET00iLCJpbmRleCIsImRvY3VtZW50IiwiZGVlcEVxdWFsIiwiYSIsImIiLCJ0b1N0cmluZyIsImxlbmd0aCIsImkiLCJrZXlzIiwiQXJyYXkiLCJpc0FycmF5IiwiT2JqZWN0IiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwia2V5IiwiJCR0eXBlb2YiLCJnZXREUFIiLCJlbGVtZW50Iiwid2luIiwib3duZXJEb2N1bWVudCIsImRlZmF1bHRWaWV3Iiwid2luZG93IiwiZGV2aWNlUGl4ZWxSYXRpbyIsInJvdW5kQnlEUFIiLCJ2YWx1ZSIsImRwciIsIk1hdGgiLCJyb3VuZCIsInVzZUxhdGVzdFJlZiIsInJlZiIsInVzZVJlZiIsImN1cnJlbnQiLCJ1c2VGbG9hdGluZyIsIm9wdGlvbnMiLCJwbGFjZW1lbnQiLCJzdHJhdGVneSIsIm1pZGRsZXdhcmUiLCJlbGVtZW50cyIsInJlZmVyZW5jZSIsImV4dGVybmFsUmVmZXJlbmNlIiwiZmxvYXRpbmciLCJleHRlcm5hbEZsb2F0aW5nIiwidHJhbnNmb3JtIiwid2hpbGVFbGVtZW50c01vdW50ZWQiLCJvcGVuIiwiZGF0YSIsInNldERhdGEiLCJ1c2VTdGF0ZSIsIngiLCJ5IiwibWlkZGxld2FyZURhdGEiLCJpc1Bvc2l0aW9uZWQiLCJsYXRlc3RNaWRkbGV3YXJlIiwic2V0TGF0ZXN0TWlkZGxld2FyZSIsIl9yZWZlcmVuY2UiLCJfc2V0UmVmZXJlbmNlIiwiX2Zsb2F0aW5nIiwiX3NldEZsb2F0aW5nIiwic2V0UmVmZXJlbmNlIiwidXNlQ2FsbGJhY2siLCJub2RlIiwicmVmZXJlbmNlUmVmIiwic2V0RmxvYXRpbmciLCJmbG9hdGluZ1JlZiIsInJlZmVyZW5jZUVsIiwiZmxvYXRpbmdFbCIsImRhdGFSZWYiLCJoYXNXaGlsZUVsZW1lbnRzTW91bnRlZCIsIndoaWxlRWxlbWVudHNNb3VudGVkUmVmIiwicGxhdGZvcm1SZWYiLCJvcGVuUmVmIiwidXBkYXRlIiwiY29uZmlnIiwidGhlbiIsImZ1bGxEYXRhIiwiaXNNb3VudGVkUmVmIiwiZmx1c2hTeW5jIiwicmVmcyIsInVzZU1lbW8iLCJmbG9hdGluZ1N0eWxlcyIsImluaXRpYWxTdHlsZXMiLCJwb3NpdGlvbiIsImxlZnQiLCJ0b3AiLCJ3aWxsQ2hhbmdlIiwiYXJyb3ckMSIsImlzUmVmIiwibmFtZSIsImZuIiwic3RhdGUiLCJwYWRkaW5nIiwiZGVwcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../../../node_modules/@floating-ui/react-dom/dist/floating-ui.react-dom.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/../../../../node_modules/@floating-ui/react/dist/floating-ui.react.mjs":
/*!******************************************************************************!*\
  !*** ../../../../node_modules/@floating-ui/react/dist/floating-ui.react.mjs ***!
  \******************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("var react__WEBPACK_IMPORTED_MODULE_0___namespace_cache;\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Composite: function() { return /* binding */ Composite; },\n/* harmony export */   CompositeItem: function() { return /* binding */ CompositeItem; },\n/* harmony export */   FloatingArrow: function() { return /* binding */ FloatingArrow; },\n/* harmony export */   FloatingDelayGroup: function() { return /* binding */ FloatingDelayGroup; },\n/* harmony export */   FloatingFocusManager: function() { return /* binding */ FloatingFocusManager; },\n/* harmony export */   FloatingList: function() { return /* binding */ FloatingList; },\n/* harmony export */   FloatingNode: function() { return /* binding */ FloatingNode; },\n/* harmony export */   FloatingOverlay: function() { return /* binding */ FloatingOverlay; },\n/* harmony export */   FloatingPortal: function() { return /* binding */ FloatingPortal; },\n/* harmony export */   FloatingTree: function() { return /* binding */ FloatingTree; },\n/* harmony export */   arrow: function() { return /* reexport safe */ _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_2__.arrow; },\n/* harmony export */   autoPlacement: function() { return /* reexport safe */ _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_2__.autoPlacement; },\n/* harmony export */   autoUpdate: function() { return /* reexport safe */ _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_3__.autoUpdate; },\n/* harmony export */   computePosition: function() { return /* reexport safe */ _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_3__.computePosition; },\n/* harmony export */   detectOverflow: function() { return /* reexport safe */ _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_3__.detectOverflow; },\n/* harmony export */   flip: function() { return /* reexport safe */ _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_2__.flip; },\n/* harmony export */   getOverflowAncestors: function() { return /* reexport safe */ _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.getOverflowAncestors; },\n/* harmony export */   hide: function() { return /* reexport safe */ _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_2__.hide; },\n/* harmony export */   inline: function() { return /* reexport safe */ _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_2__.inline; },\n/* harmony export */   inner: function() { return /* binding */ inner; },\n/* harmony export */   limitShift: function() { return /* reexport safe */ _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_2__.limitShift; },\n/* harmony export */   offset: function() { return /* reexport safe */ _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_2__.offset; },\n/* harmony export */   platform: function() { return /* reexport safe */ _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_3__.platform; },\n/* harmony export */   safePolygon: function() { return /* binding */ safePolygon; },\n/* harmony export */   shift: function() { return /* reexport safe */ _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_2__.shift; },\n/* harmony export */   size: function() { return /* reexport safe */ _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_2__.size; },\n/* harmony export */   useClick: function() { return /* binding */ useClick; },\n/* harmony export */   useClientPoint: function() { return /* binding */ useClientPoint; },\n/* harmony export */   useDelayGroup: function() { return /* binding */ useDelayGroup; },\n/* harmony export */   useDelayGroupContext: function() { return /* binding */ useDelayGroupContext; },\n/* harmony export */   useDismiss: function() { return /* binding */ useDismiss; },\n/* harmony export */   useFloating: function() { return /* binding */ useFloating; },\n/* harmony export */   useFloatingNodeId: function() { return /* binding */ useFloatingNodeId; },\n/* harmony export */   useFloatingParentNodeId: function() { return /* binding */ useFloatingParentNodeId; },\n/* harmony export */   useFloatingPortalNode: function() { return /* binding */ useFloatingPortalNode; },\n/* harmony export */   useFloatingRootContext: function() { return /* binding */ useFloatingRootContext; },\n/* harmony export */   useFloatingTree: function() { return /* binding */ useFloatingTree; },\n/* harmony export */   useFocus: function() { return /* binding */ useFocus; },\n/* harmony export */   useHover: function() { return /* binding */ useHover; },\n/* harmony export */   useId: function() { return /* binding */ useId; },\n/* harmony export */   useInnerOffset: function() { return /* binding */ useInnerOffset; },\n/* harmony export */   useInteractions: function() { return /* binding */ useInteractions; },\n/* harmony export */   useListItem: function() { return /* binding */ useListItem; },\n/* harmony export */   useListNavigation: function() { return /* binding */ useListNavigation; },\n/* harmony export */   useMergeRefs: function() { return /* binding */ useMergeRefs; },\n/* harmony export */   useRole: function() { return /* binding */ useRole; },\n/* harmony export */   useTransitionStatus: function() { return /* binding */ useTransitionStatus; },\n/* harmony export */   useTransitionStyles: function() { return /* binding */ useTransitionStyles; },\n/* harmony export */   useTypeahead: function() { return /* binding */ useTypeahead; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var _floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @floating-ui/react/utils */ \"(app-pages-browser)/../../../../node_modules/@floating-ui/react/dist/floating-ui.react.utils.mjs\");\n/* harmony import */ var _floating_ui_utils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @floating-ui/utils */ \"(app-pages-browser)/../../../../node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs\");\n/* harmony import */ var _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @floating-ui/react-dom */ \"(app-pages-browser)/../../../../node_modules/@floating-ui/utils/dist/floating-ui.utils.dom.mjs\");\n/* harmony import */ var tabbable__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! tabbable */ \"(app-pages-browser)/../../../../node_modules/tabbable/dist/index.esm.js\");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-dom */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react-dom/index.js\");\n/* harmony import */ var _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @floating-ui/react-dom */ \"(app-pages-browser)/../../../../node_modules/@floating-ui/react-dom/dist/floating-ui.react-dom.mjs\");\n/* harmony import */ var _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @floating-ui/react-dom */ \"(app-pages-browser)/../../../../node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs\");\nvar _s = $RefreshSig$(), _s1 = $RefreshSig$(), _s2 = $RefreshSig$(), _s3 = $RefreshSig$(), _s4 = $RefreshSig$(), _s5 = $RefreshSig$(), _s6 = $RefreshSig$(), _s7 = $RefreshSig$(), _s8 = $RefreshSig$(), _s9 = $RefreshSig$(), _s10 = $RefreshSig$(), _s11 = $RefreshSig$(), _s12 = $RefreshSig$(), _s13 = $RefreshSig$(), _s14 = $RefreshSig$(), _s15 = $RefreshSig$(), _s16 = $RefreshSig$(), _s17 = $RefreshSig$(), _s18 = $RefreshSig$(), _s19 = $RefreshSig$(), _s20 = $RefreshSig$(), _s21 = $RefreshSig$(), _s22 = $RefreshSig$(), _s23 = $RefreshSig$(), _s24 = $RefreshSig$(), _s25 = $RefreshSig$(), _s26 = $RefreshSig$(), _s27 = $RefreshSig$(), _s28 = $RefreshSig$(), _s29 = $RefreshSig$(), _s30 = $RefreshSig$(), _s31 = $RefreshSig$(), _s32 = $RefreshSig$(), _s33 = $RefreshSig$(), _s34 = $RefreshSig$(), _s35 = $RefreshSig$(), _s36 = $RefreshSig$();\n\n\n\n\n\n\n\n\n\n/**\n * Merges an array of refs into a single memoized callback ref or `null`.\n * @see https://floating-ui.com/docs/react-utils#usemergerefs\n */ function useMergeRefs(refs) {\n    _s();\n    return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>{\n        if (refs.every((ref)=>ref == null)) {\n            return null;\n        }\n        return (value)=>{\n            refs.forEach((ref)=>{\n                if (typeof ref === \"function\") {\n                    ref(value);\n                } else if (ref != null) {\n                    ref.current = value;\n                }\n            });\n        };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, refs);\n}\n_s(useMergeRefs, \"nwk+m61qLgjDVUp4IGV/072DDN4=\");\n// https://github.com/mui/material-ui/issues/41190#issuecomment-2040873379\nconst SafeReact = {\n    .../*#__PURE__*/ (react__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (react__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(react__WEBPACK_IMPORTED_MODULE_0__, 2)))\n};\nconst useInsertionEffect = SafeReact.useInsertionEffect;\nconst useSafeInsertionEffect = useInsertionEffect || ((fn)=>fn());\nfunction useEffectEvent(callback) {\n    _s1();\n    const ref = react__WEBPACK_IMPORTED_MODULE_0__.useRef(()=>{\n        if (true) {\n            throw new Error(\"Cannot call an event handler while rendering.\");\n        }\n    });\n    useSafeInsertionEffect(()=>{\n        ref.current = callback;\n    });\n    return react__WEBPACK_IMPORTED_MODULE_0__.useCallback(function() {\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        return ref.current == null ? void 0 : ref.current(...args);\n    }, []);\n}\n_s1(useEffectEvent, \"qrtKvuvN3OOh/8qqvPk9GNZJgAI=\", false, function() {\n    return [\n        useSafeInsertionEffect\n    ];\n});\nconst ARROW_UP = \"ArrowUp\";\nconst ARROW_DOWN = \"ArrowDown\";\nconst ARROW_LEFT = \"ArrowLeft\";\nconst ARROW_RIGHT = \"ArrowRight\";\nfunction isDifferentRow(index, cols, prevRow) {\n    return Math.floor(index / cols) !== prevRow;\n}\nfunction isIndexOutOfBounds(listRef, index) {\n    return index < 0 || index >= listRef.current.length;\n}\nfunction getMinIndex(listRef, disabledIndices) {\n    return findNonDisabledIndex(listRef, {\n        disabledIndices\n    });\n}\nfunction getMaxIndex(listRef, disabledIndices) {\n    return findNonDisabledIndex(listRef, {\n        decrement: true,\n        startingIndex: listRef.current.length,\n        disabledIndices\n    });\n}\nfunction findNonDisabledIndex(listRef, _temp) {\n    let { startingIndex = -1, decrement = false, disabledIndices, amount = 1 } = _temp === void 0 ? {} : _temp;\n    const list = listRef.current;\n    let index = startingIndex;\n    do {\n        index += decrement ? -amount : amount;\n    }while (index >= 0 && index <= list.length - 1 && isDisabled(list, index, disabledIndices));\n    return index;\n}\nfunction getGridNavigatedIndex(elementsRef, _ref) {\n    let { event, orientation, loop, rtl, cols, disabledIndices, minIndex, maxIndex, prevIndex, stopEvent: stop = false } = _ref;\n    let nextIndex = prevIndex;\n    if (event.key === ARROW_UP) {\n        stop && (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.stopEvent)(event);\n        if (prevIndex === -1) {\n            nextIndex = maxIndex;\n        } else {\n            nextIndex = findNonDisabledIndex(elementsRef, {\n                startingIndex: nextIndex,\n                amount: cols,\n                decrement: true,\n                disabledIndices\n            });\n            if (loop && (prevIndex - cols < minIndex || nextIndex < 0)) {\n                const col = prevIndex % cols;\n                const maxCol = maxIndex % cols;\n                const offset = maxIndex - (maxCol - col);\n                if (maxCol === col) {\n                    nextIndex = maxIndex;\n                } else {\n                    nextIndex = maxCol > col ? offset : offset - cols;\n                }\n            }\n        }\n        if (isIndexOutOfBounds(elementsRef, nextIndex)) {\n            nextIndex = prevIndex;\n        }\n    }\n    if (event.key === ARROW_DOWN) {\n        stop && (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.stopEvent)(event);\n        if (prevIndex === -1) {\n            nextIndex = minIndex;\n        } else {\n            nextIndex = findNonDisabledIndex(elementsRef, {\n                startingIndex: prevIndex,\n                amount: cols,\n                disabledIndices\n            });\n            if (loop && prevIndex + cols > maxIndex) {\n                nextIndex = findNonDisabledIndex(elementsRef, {\n                    startingIndex: prevIndex % cols - cols,\n                    amount: cols,\n                    disabledIndices\n                });\n            }\n        }\n        if (isIndexOutOfBounds(elementsRef, nextIndex)) {\n            nextIndex = prevIndex;\n        }\n    }\n    // Remains on the same row/column.\n    if (orientation === \"both\") {\n        const prevRow = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_6__.floor)(prevIndex / cols);\n        if (event.key === (rtl ? ARROW_LEFT : ARROW_RIGHT)) {\n            stop && (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.stopEvent)(event);\n            if (prevIndex % cols !== cols - 1) {\n                nextIndex = findNonDisabledIndex(elementsRef, {\n                    startingIndex: prevIndex,\n                    disabledIndices\n                });\n                if (loop && isDifferentRow(nextIndex, cols, prevRow)) {\n                    nextIndex = findNonDisabledIndex(elementsRef, {\n                        startingIndex: prevIndex - prevIndex % cols - 1,\n                        disabledIndices\n                    });\n                }\n            } else if (loop) {\n                nextIndex = findNonDisabledIndex(elementsRef, {\n                    startingIndex: prevIndex - prevIndex % cols - 1,\n                    disabledIndices\n                });\n            }\n            if (isDifferentRow(nextIndex, cols, prevRow)) {\n                nextIndex = prevIndex;\n            }\n        }\n        if (event.key === (rtl ? ARROW_RIGHT : ARROW_LEFT)) {\n            stop && (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.stopEvent)(event);\n            if (prevIndex % cols !== 0) {\n                nextIndex = findNonDisabledIndex(elementsRef, {\n                    startingIndex: prevIndex,\n                    decrement: true,\n                    disabledIndices\n                });\n                if (loop && isDifferentRow(nextIndex, cols, prevRow)) {\n                    nextIndex = findNonDisabledIndex(elementsRef, {\n                        startingIndex: prevIndex + (cols - prevIndex % cols),\n                        decrement: true,\n                        disabledIndices\n                    });\n                }\n            } else if (loop) {\n                nextIndex = findNonDisabledIndex(elementsRef, {\n                    startingIndex: prevIndex + (cols - prevIndex % cols),\n                    decrement: true,\n                    disabledIndices\n                });\n            }\n            if (isDifferentRow(nextIndex, cols, prevRow)) {\n                nextIndex = prevIndex;\n            }\n        }\n        const lastRow = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_6__.floor)(maxIndex / cols) === prevRow;\n        if (isIndexOutOfBounds(elementsRef, nextIndex)) {\n            if (loop && lastRow) {\n                nextIndex = event.key === (rtl ? ARROW_RIGHT : ARROW_LEFT) ? maxIndex : findNonDisabledIndex(elementsRef, {\n                    startingIndex: prevIndex - prevIndex % cols - 1,\n                    disabledIndices\n                });\n            } else {\n                nextIndex = prevIndex;\n            }\n        }\n    }\n    return nextIndex;\n}\n/** For each cell index, gets the item index that occupies that cell */ function buildCellMap(sizes, cols, dense) {\n    const cellMap = [];\n    let startIndex = 0;\n    sizes.forEach((_ref2, index)=>{\n        let { width, height } = _ref2;\n        if (width > cols) {\n            if (true) {\n                throw new Error(\"[Floating UI]: Invalid grid - item width at index \" + index + \" is greater than grid columns\");\n            }\n        }\n        let itemPlaced = false;\n        if (dense) {\n            startIndex = 0;\n        }\n        while(!itemPlaced){\n            const targetCells = [];\n            for(let i = 0; i < width; i++){\n                for(let j = 0; j < height; j++){\n                    targetCells.push(startIndex + i + j * cols);\n                }\n            }\n            if (startIndex % cols + width <= cols && targetCells.every((cell)=>cellMap[cell] == null)) {\n                targetCells.forEach((cell)=>{\n                    cellMap[cell] = index;\n                });\n                itemPlaced = true;\n            } else {\n                startIndex++;\n            }\n        }\n    });\n    // convert into a non-sparse array\n    return [\n        ...cellMap\n    ];\n}\n/** Gets cell index of an item's corner or -1 when index is -1. */ function getCellIndexOfCorner(index, sizes, cellMap, cols, corner) {\n    if (index === -1) return -1;\n    const firstCellIndex = cellMap.indexOf(index);\n    const sizeItem = sizes[index];\n    switch(corner){\n        case \"tl\":\n            return firstCellIndex;\n        case \"tr\":\n            if (!sizeItem) {\n                return firstCellIndex;\n            }\n            return firstCellIndex + sizeItem.width - 1;\n        case \"bl\":\n            if (!sizeItem) {\n                return firstCellIndex;\n            }\n            return firstCellIndex + (sizeItem.height - 1) * cols;\n        case \"br\":\n            return cellMap.lastIndexOf(index);\n    }\n}\n/** Gets all cell indices that correspond to the specified indices */ function getCellIndices(indices, cellMap) {\n    return cellMap.flatMap((index, cellIndex)=>indices.includes(index) ? [\n            cellIndex\n        ] : []);\n}\nfunction isDisabled(list, index, disabledIndices) {\n    if (disabledIndices) {\n        return disabledIndices.includes(index);\n    }\n    const element = list[index];\n    return element == null || element.hasAttribute(\"disabled\") || element.getAttribute(\"aria-disabled\") === \"true\";\n}\nvar index = typeof document !== \"undefined\" ? react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect : react__WEBPACK_IMPORTED_MODULE_0__.useEffect;\nfunction sortByDocumentPosition(a, b) {\n    const position = a.compareDocumentPosition(b);\n    if (position & Node.DOCUMENT_POSITION_FOLLOWING || position & Node.DOCUMENT_POSITION_CONTAINED_BY) {\n        return -1;\n    }\n    if (position & Node.DOCUMENT_POSITION_PRECEDING || position & Node.DOCUMENT_POSITION_CONTAINS) {\n        return 1;\n    }\n    return 0;\n}\nfunction areMapsEqual(map1, map2) {\n    if (map1.size !== map2.size) {\n        return false;\n    }\n    for (const [key, value] of map1.entries()){\n        if (value !== map2.get(key)) {\n            return false;\n        }\n    }\n    return true;\n}\nconst FloatingListContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext({\n    register: ()=>{},\n    unregister: ()=>{},\n    map: /*#__PURE__*/ new Map(),\n    elementsRef: {\n        current: []\n    }\n});\n/**\n * Provides context for a list of items within the floating element.\n * @see https://floating-ui.com/docs/FloatingList\n */ function FloatingList(props) {\n    _s2();\n    const { children, elementsRef, labelsRef } = props;\n    const [map, setMap] = react__WEBPACK_IMPORTED_MODULE_0__.useState(()=>new Map());\n    const register = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((node)=>{\n        setMap((prevMap)=>new Map(prevMap).set(node, null));\n    }, []);\n    const unregister = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((node)=>{\n        setMap((prevMap)=>{\n            const map = new Map(prevMap);\n            map.delete(node);\n            return map;\n        });\n    }, []);\n    index(()=>{\n        const newMap = new Map(map);\n        const nodes = Array.from(newMap.keys()).sort(sortByDocumentPosition);\n        nodes.forEach((node, index)=>{\n            newMap.set(node, index);\n        });\n        if (!areMapsEqual(map, newMap)) {\n            setMap(newMap);\n        }\n    }, [\n        map\n    ]);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(FloatingListContext.Provider, {\n        value: react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>({\n                register,\n                unregister,\n                map,\n                elementsRef,\n                labelsRef\n            }), [\n            register,\n            unregister,\n            map,\n            elementsRef,\n            labelsRef\n        ])\n    }, children);\n}\n_s2(FloatingList, \"Rx9nWuvxAb4yQkynoJ7QSibeqHc=\");\n_c = FloatingList;\n/**\n * Used to register a list item and its index (DOM position) in the\n * `FloatingList`.\n * @see https://floating-ui.com/docs/FloatingList#uselistitem\n */ function useListItem(props) {\n    _s3();\n    if (props === void 0) {\n        props = {};\n    }\n    const { label } = props;\n    const { register, unregister, map, elementsRef, labelsRef } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(FloatingListContext);\n    const [index$1, setIndex] = react__WEBPACK_IMPORTED_MODULE_0__.useState(null);\n    const componentRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n    const ref = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((node)=>{\n        componentRef.current = node;\n        if (index$1 !== null) {\n            elementsRef.current[index$1] = node;\n            if (labelsRef) {\n                var _node$textContent;\n                const isLabelDefined = label !== undefined;\n                labelsRef.current[index$1] = isLabelDefined ? label : (_node$textContent = node == null ? void 0 : node.textContent) != null ? _node$textContent : null;\n            }\n        }\n    }, [\n        index$1,\n        elementsRef,\n        labelsRef,\n        label\n    ]);\n    index(()=>{\n        const node = componentRef.current;\n        if (node) {\n            register(node);\n            return ()=>{\n                unregister(node);\n            };\n        }\n    }, [\n        register,\n        unregister\n    ]);\n    index(()=>{\n        const index = componentRef.current ? map.get(componentRef.current) : null;\n        if (index != null) {\n            setIndex(index);\n        }\n    }, [\n        map\n    ]);\n    return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>({\n            ref,\n            index: index$1 == null ? -1 : index$1\n        }), [\n        index$1,\n        ref\n    ]);\n}\n_s3(useListItem, \"AShWHJQQu32vJq5tvsYvzPwDWV0=\");\nfunction renderJsx(render, computedProps) {\n    if (typeof render === \"function\") {\n        return render(computedProps);\n    }\n    if (render) {\n        return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.cloneElement(render, computedProps);\n    }\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", computedProps);\n}\nconst CompositeContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext({\n    activeIndex: 0,\n    onNavigate: ()=>{}\n});\nconst horizontalKeys = [\n    ARROW_LEFT,\n    ARROW_RIGHT\n];\nconst verticalKeys = [\n    ARROW_UP,\n    ARROW_DOWN\n];\nconst allKeys = [\n    ...horizontalKeys,\n    ...verticalKeys\n];\n/**\n * Creates a single tab stop whose items are navigated by arrow keys, which\n * provides list navigation outside of floating element contexts.\n *\n * This is useful to enable navigation of a list of items that arent part of a\n * floating element. A menubar is an example of a composite, with each reference\n * element being an item.\n * @see https://floating-ui.com/docs/Composite\n */ const Composite = /*#__PURE__*/ _s4(react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(_c1 = _s4(function Composite(props, forwardedRef) {\n    _s4();\n    const { render, orientation = \"both\", loop = true, rtl = false, cols = 1, disabledIndices, activeIndex: externalActiveIndex, onNavigate: externalSetActiveIndex, itemSizes, dense = false, ...domProps } = props;\n    const [internalActiveIndex, internalSetActiveIndex] = react__WEBPACK_IMPORTED_MODULE_0__.useState(0);\n    const activeIndex = externalActiveIndex != null ? externalActiveIndex : internalActiveIndex;\n    const onNavigate = useEffectEvent(externalSetActiveIndex != null ? externalSetActiveIndex : internalSetActiveIndex);\n    const elementsRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef([]);\n    const renderElementProps = render && typeof render !== \"function\" ? render.props : {};\n    const contextValue = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>({\n            activeIndex,\n            onNavigate\n        }), [\n        activeIndex,\n        onNavigate\n    ]);\n    const isGrid = cols > 1;\n    function handleKeyDown(event) {\n        if (!allKeys.includes(event.key)) return;\n        let nextIndex = activeIndex;\n        const minIndex = getMinIndex(elementsRef, disabledIndices);\n        const maxIndex = getMaxIndex(elementsRef, disabledIndices);\n        const horizontalEndKey = rtl ? ARROW_LEFT : ARROW_RIGHT;\n        const horizontalStartKey = rtl ? ARROW_RIGHT : ARROW_LEFT;\n        if (isGrid) {\n            const sizes = itemSizes || Array.from({\n                length: elementsRef.current.length\n            }, ()=>({\n                    width: 1,\n                    height: 1\n                }));\n            // To calculate movements on the grid, we use hypothetical cell indices\n            // as if every item was 1x1, then convert back to real indices.\n            const cellMap = buildCellMap(sizes, cols, dense);\n            const minGridIndex = cellMap.findIndex((index)=>index != null && !isDisabled(elementsRef.current, index, disabledIndices));\n            // last enabled index\n            const maxGridIndex = cellMap.reduce((foundIndex, index, cellIndex)=>index != null && !isDisabled(elementsRef.current, index, disabledIndices) ? cellIndex : foundIndex, -1);\n            const maybeNextIndex = cellMap[getGridNavigatedIndex({\n                current: cellMap.map((itemIndex)=>itemIndex ? elementsRef.current[itemIndex] : null)\n            }, {\n                event,\n                orientation,\n                loop,\n                rtl,\n                cols,\n                // treat undefined (empty grid spaces) as disabled indices so we\n                // don't end up in them\n                disabledIndices: getCellIndices([\n                    ...disabledIndices || elementsRef.current.map((_, index)=>isDisabled(elementsRef.current, index) ? index : undefined),\n                    undefined\n                ], cellMap),\n                minIndex: minGridIndex,\n                maxIndex: maxGridIndex,\n                prevIndex: getCellIndexOfCorner(activeIndex > maxIndex ? minIndex : activeIndex, sizes, cellMap, cols, // use a corner matching the edge closest to the direction we're\n                // moving in so we don't end up in the same item. Prefer\n                // top/left over bottom/right.\n                event.key === ARROW_DOWN ? \"bl\" : event.key === horizontalEndKey ? \"tr\" : \"tl\")\n            })];\n            if (maybeNextIndex != null) {\n                nextIndex = maybeNextIndex;\n            }\n        }\n        const toEndKeys = {\n            horizontal: [\n                horizontalEndKey\n            ],\n            vertical: [\n                ARROW_DOWN\n            ],\n            both: [\n                horizontalEndKey,\n                ARROW_DOWN\n            ]\n        }[orientation];\n        const toStartKeys = {\n            horizontal: [\n                horizontalStartKey\n            ],\n            vertical: [\n                ARROW_UP\n            ],\n            both: [\n                horizontalStartKey,\n                ARROW_UP\n            ]\n        }[orientation];\n        const preventedKeys = isGrid ? allKeys : ({\n            horizontal: horizontalKeys,\n            vertical: verticalKeys,\n            both: allKeys\n        })[orientation];\n        if (nextIndex === activeIndex && [\n            ...toEndKeys,\n            ...toStartKeys\n        ].includes(event.key)) {\n            if (loop && nextIndex === maxIndex && toEndKeys.includes(event.key)) {\n                nextIndex = minIndex;\n            } else if (loop && nextIndex === minIndex && toStartKeys.includes(event.key)) {\n                nextIndex = maxIndex;\n            } else {\n                nextIndex = findNonDisabledIndex(elementsRef, {\n                    startingIndex: nextIndex,\n                    decrement: toStartKeys.includes(event.key),\n                    disabledIndices\n                });\n            }\n        }\n        if (nextIndex !== activeIndex && !isIndexOutOfBounds(elementsRef, nextIndex)) {\n            var _elementsRef$current$;\n            event.stopPropagation();\n            if (preventedKeys.includes(event.key)) {\n                event.preventDefault();\n            }\n            onNavigate(nextIndex);\n            (_elementsRef$current$ = elementsRef.current[nextIndex]) == null || _elementsRef$current$.focus();\n        }\n    }\n    const computedProps = {\n        ...domProps,\n        ...renderElementProps,\n        ref: forwardedRef,\n        \"aria-orientation\": orientation === \"both\" ? undefined : orientation,\n        onKeyDown (e) {\n            domProps.onKeyDown == null || domProps.onKeyDown(e);\n            renderElementProps.onKeyDown == null || renderElementProps.onKeyDown(e);\n            handleKeyDown(e);\n        }\n    };\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(CompositeContext.Provider, {\n        value: contextValue\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(FloatingList, {\n        elementsRef: elementsRef\n    }, renderJsx(render, computedProps)));\n}, \"LJzVTSf/MAShEo2yDDoK6cjmzTM=\", false, function() {\n    return [\n        useEffectEvent\n    ];\n})), \"LJzVTSf/MAShEo2yDDoK6cjmzTM=\", false, function() {\n    return [\n        useEffectEvent\n    ];\n});\n_c2 = Composite;\n/**\n * @see https://floating-ui.com/docs/Composite\n */ const CompositeItem = /*#__PURE__*/ _s5(react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(_c3 = _s5(function CompositeItem(props, forwardedRef) {\n    _s5();\n    const { render, ...domProps } = props;\n    const renderElementProps = render && typeof render !== \"function\" ? render.props : {};\n    const { activeIndex, onNavigate } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(CompositeContext);\n    const { ref, index } = useListItem();\n    const mergedRef = useMergeRefs([\n        ref,\n        forwardedRef,\n        renderElementProps.ref\n    ]);\n    const isActive = activeIndex === index;\n    const computedProps = {\n        ...domProps,\n        ...renderElementProps,\n        ref: mergedRef,\n        tabIndex: isActive ? 0 : -1,\n        \"data-active\": isActive ? \"\" : undefined,\n        onFocus (e) {\n            domProps.onFocus == null || domProps.onFocus(e);\n            renderElementProps.onFocus == null || renderElementProps.onFocus(e);\n            onNavigate(index);\n        }\n    };\n    return renderJsx(render, computedProps);\n}, \"HDAbfI8gQC/jHKT0Z+gWrSkbDng=\", false, function() {\n    return [\n        useListItem,\n        useMergeRefs\n    ];\n})), \"HDAbfI8gQC/jHKT0Z+gWrSkbDng=\", false, function() {\n    return [\n        useListItem,\n        useMergeRefs\n    ];\n});\n_c4 = CompositeItem;\nfunction _extends() {\n    _extends = Object.assign ? Object.assign.bind() : function(target) {\n        for(var i = 1; i < arguments.length; i++){\n            var source = arguments[i];\n            for(var key in source){\n                if (Object.prototype.hasOwnProperty.call(source, key)) {\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    };\n    return _extends.apply(this, arguments);\n}\nlet serverHandoffComplete = false;\nlet count = 0;\nconst genId = ()=>// on <React 18\n    \"floating-ui-\" + Math.random().toString(36).slice(2, 6) + count++;\nfunction useFloatingId() {\n    _s6();\n    const [id, setId] = react__WEBPACK_IMPORTED_MODULE_0__.useState(()=>serverHandoffComplete ? genId() : undefined);\n    index(()=>{\n        if (id == null) {\n            setId(genId());\n        }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, []);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        serverHandoffComplete = true;\n    }, []);\n    return id;\n}\n_s6(useFloatingId, \"iqzxl1wNaGd91nZwt+QytT/OyhY=\");\nconst useReactId = SafeReact.useId;\n/**\n * Uses React 18's built-in `useId()` when available, or falls back to a\n * slightly less performant (requiring a double render) implementation for\n * earlier React versions.\n * @see https://floating-ui.com/docs/react-utils#useid\n */ const useId = useReactId || useFloatingId;\nlet devMessageSet;\nif (true) {\n    devMessageSet = /*#__PURE__*/ new Set();\n}\nfunction warn() {\n    var _devMessageSet;\n    for(var _len = arguments.length, messages = new Array(_len), _key = 0; _key < _len; _key++){\n        messages[_key] = arguments[_key];\n    }\n    const message = \"Floating UI: \" + messages.join(\" \");\n    if (!((_devMessageSet = devMessageSet) != null && _devMessageSet.has(message))) {\n        var _devMessageSet2;\n        (_devMessageSet2 = devMessageSet) == null || _devMessageSet2.add(message);\n        console.warn(message);\n    }\n}\nfunction error() {\n    var _devMessageSet3;\n    for(var _len2 = arguments.length, messages = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++){\n        messages[_key2] = arguments[_key2];\n    }\n    const message = \"Floating UI: \" + messages.join(\" \");\n    if (!((_devMessageSet3 = devMessageSet) != null && _devMessageSet3.has(message))) {\n        var _devMessageSet4;\n        (_devMessageSet4 = devMessageSet) == null || _devMessageSet4.add(message);\n        console.error(message);\n    }\n}\n/**\n * Renders a pointing arrow triangle.\n * @see https://floating-ui.com/docs/FloatingArrow\n */ const FloatingArrow = /*#__PURE__*/ _s7(react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(_c5 = _s7(function FloatingArrow(props, ref) {\n    _s7();\n    const { context: { placement, elements: { floating }, middlewareData: { arrow, shift } }, width = 14, height = 7, tipRadius = 0, strokeWidth = 0, staticOffset, stroke, d, style: { transform, ...restStyle } = {}, ...rest } = props;\n    if (true) {\n        if (!ref) {\n            warn(\"The `ref` prop is required for `FloatingArrow`.\");\n        }\n    }\n    const clipPathId = useId();\n    const [isRTL, setIsRTL] = react__WEBPACK_IMPORTED_MODULE_0__.useState(false);\n    // https://github.com/floating-ui/floating-ui/issues/2932\n    index(()=>{\n        if (!floating) return;\n        const isRTL = (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.getComputedStyle)(floating).direction === \"rtl\";\n        if (isRTL) {\n            setIsRTL(true);\n        }\n    }, [\n        floating\n    ]);\n    if (!floating) {\n        return null;\n    }\n    const [side, alignment] = placement.split(\"-\");\n    const isVerticalSide = side === \"top\" || side === \"bottom\";\n    let computedStaticOffset = staticOffset;\n    if (isVerticalSide && shift != null && shift.x || !isVerticalSide && shift != null && shift.y) {\n        computedStaticOffset = null;\n    }\n    // Strokes must be double the border width, this ensures the stroke's width\n    // works as you'd expect.\n    const computedStrokeWidth = strokeWidth * 2;\n    const halfStrokeWidth = computedStrokeWidth / 2;\n    const svgX = width / 2 * (tipRadius / -8 + 1);\n    const svgY = height / 2 * tipRadius / 4;\n    const isCustomShape = !!d;\n    const yOffsetProp = computedStaticOffset && alignment === \"end\" ? \"bottom\" : \"top\";\n    let xOffsetProp = computedStaticOffset && alignment === \"end\" ? \"right\" : \"left\";\n    if (computedStaticOffset && isRTL) {\n        xOffsetProp = alignment === \"end\" ? \"left\" : \"right\";\n    }\n    const arrowX = (arrow == null ? void 0 : arrow.x) != null ? computedStaticOffset || arrow.x : \"\";\n    const arrowY = (arrow == null ? void 0 : arrow.y) != null ? computedStaticOffset || arrow.y : \"\";\n    const dValue = d || \"M0,0\" + (\" H\" + width) + (\" L\" + (width - svgX) + \",\" + (height - svgY)) + (\" Q\" + width / 2 + \",\" + height + \" \" + svgX + \",\" + (height - svgY)) + \" Z\";\n    const rotation = {\n        top: isCustomShape ? \"rotate(180deg)\" : \"\",\n        left: isCustomShape ? \"rotate(90deg)\" : \"rotate(-90deg)\",\n        bottom: isCustomShape ? \"\" : \"rotate(180deg)\",\n        right: isCustomShape ? \"rotate(-90deg)\" : \"rotate(90deg)\"\n    }[side];\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"svg\", _extends({}, rest, {\n        \"aria-hidden\": true,\n        ref: ref,\n        width: isCustomShape ? width : width + computedStrokeWidth,\n        height: width,\n        viewBox: \"0 0 \" + width + \" \" + (height > width ? height : width),\n        style: {\n            position: \"absolute\",\n            pointerEvents: \"none\",\n            [xOffsetProp]: arrowX,\n            [yOffsetProp]: arrowY,\n            [side]: isVerticalSide || isCustomShape ? \"100%\" : \"calc(100% - \" + computedStrokeWidth / 2 + \"px)\",\n            transform: [\n                rotation,\n                transform\n            ].filter((t)=>!!t).join(\" \"),\n            ...restStyle\n        }\n    }), computedStrokeWidth > 0 && /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\", {\n        clipPath: \"url(#\" + clipPathId + \")\",\n        fill: \"none\",\n        stroke: stroke,\n        strokeWidth: computedStrokeWidth + (d ? 0 : 1),\n        d: dValue\n    }), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\", {\n        stroke: computedStrokeWidth && !d ? rest.fill : \"none\",\n        d: dValue\n    }), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"clipPath\", {\n        id: clipPathId\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"rect\", {\n        x: -halfStrokeWidth,\n        y: halfStrokeWidth * (isCustomShape ? -1 : 1),\n        width: width + computedStrokeWidth,\n        height: width\n    })));\n}, \"l4rSq1bjYVjEu46N2Dga3jyB6Ms=\", false, function() {\n    return [\n        useId\n    ];\n})), \"l4rSq1bjYVjEu46N2Dga3jyB6Ms=\", false, function() {\n    return [\n        useId\n    ];\n});\n_c6 = FloatingArrow;\nfunction createPubSub() {\n    const map = new Map();\n    return {\n        emit (event, data) {\n            var _map$get;\n            (_map$get = map.get(event)) == null || _map$get.forEach((handler)=>handler(data));\n        },\n        on (event, listener) {\n            map.set(event, [\n                ...map.get(event) || [],\n                listener\n            ]);\n        },\n        off (event, listener) {\n            var _map$get2;\n            map.set(event, ((_map$get2 = map.get(event)) == null ? void 0 : _map$get2.filter((l)=>l !== listener)) || []);\n        }\n    };\n}\nconst FloatingNodeContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\nconst FloatingTreeContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\n/**\n * Returns the parent node id for nested floating elements, if available.\n * Returns `null` for top-level floating elements.\n */ const useFloatingParentNodeId = ()=>{\n    _s8();\n    var _React$useContext;\n    return ((_React$useContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(FloatingNodeContext)) == null ? void 0 : _React$useContext.id) || null;\n};\n_s8(useFloatingParentNodeId, \"gDsCjeeItUuvgOWf1v4qoK9RF6k=\");\n/**\n * Returns the nearest floating tree context, if available.\n */ const useFloatingTree = ()=>{\n    _s9();\n    return react__WEBPACK_IMPORTED_MODULE_0__.useContext(FloatingTreeContext);\n};\n_s9(useFloatingTree, \"gDsCjeeItUuvgOWf1v4qoK9RF6k=\");\n/**\n * Registers a node into the `FloatingTree`, returning its id.\n * @see https://floating-ui.com/docs/FloatingTree\n */ function useFloatingNodeId(customParentId) {\n    _s10();\n    const id = useId();\n    const tree = useFloatingTree();\n    const reactParentId = useFloatingParentNodeId();\n    const parentId = customParentId || reactParentId;\n    index(()=>{\n        const node = {\n            id,\n            parentId\n        };\n        tree == null || tree.addNode(node);\n        return ()=>{\n            tree == null || tree.removeNode(node);\n        };\n    }, [\n        tree,\n        id,\n        parentId\n    ]);\n    return id;\n}\n_s10(useFloatingNodeId, \"6MqC6n3lK/Uo5KLbDx0ok7UUPSo=\", false, function() {\n    return [\n        useId,\n        useFloatingTree,\n        useFloatingParentNodeId\n    ];\n});\n/**\n * Provides parent node context for nested floating elements.\n * @see https://floating-ui.com/docs/FloatingTree\n */ function FloatingNode(props) {\n    _s11();\n    const { children, id } = props;\n    const parentId = useFloatingParentNodeId();\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(FloatingNodeContext.Provider, {\n        value: react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>({\n                id,\n                parentId\n            }), [\n            id,\n            parentId\n        ])\n    }, children);\n}\n_s11(FloatingNode, \"9Lx7CtjR76vFtELfeFJiwD5JJtg=\", false, function() {\n    return [\n        useFloatingParentNodeId\n    ];\n});\n_c7 = FloatingNode;\n/**\n * Provides context for nested floating elements when they are not children of\n * each other on the DOM.\n * This is not necessary in all cases, except when there must be explicit communication between parent and child floating elements. It is necessary for:\n * - The `bubbles` option in the `useDismiss()` Hook\n * - Nested virtual list navigation\n * - Nested floating elements that each open on hover\n * - Custom communication between parent and child floating elements\n * @see https://floating-ui.com/docs/FloatingTree\n */ function FloatingTree(props) {\n    _s12();\n    const { children } = props;\n    const nodesRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef([]);\n    const addNode = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((node)=>{\n        nodesRef.current = [\n            ...nodesRef.current,\n            node\n        ];\n    }, []);\n    const removeNode = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((node)=>{\n        nodesRef.current = nodesRef.current.filter((n)=>n !== node);\n    }, []);\n    const events = react__WEBPACK_IMPORTED_MODULE_0__.useState(()=>createPubSub())[0];\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(FloatingTreeContext.Provider, {\n        value: react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>({\n                nodesRef,\n                addNode,\n                removeNode,\n                events\n            }), [\n            addNode,\n            removeNode,\n            events\n        ])\n    }, children);\n}\n_s12(FloatingTree, \"w6THtUIewwiJ+9eMURqTFKJfxSw=\");\n_c8 = FloatingTree;\nfunction createAttribute(name) {\n    return \"data-floating-ui-\" + name;\n}\nfunction useLatestRef(value) {\n    _s13();\n    const ref = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(value);\n    index(()=>{\n        ref.current = value;\n    });\n    return ref;\n}\n_s13(useLatestRef, \"QMBuJFIdzLIeqBcFwhMf246mjOM=\");\nconst safePolygonIdentifier = /*#__PURE__*/ createAttribute(\"safe-polygon\");\nfunction getDelay(value, prop, pointerType) {\n    if (pointerType && !(0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.isMouseLikePointerType)(pointerType)) {\n        return 0;\n    }\n    if (typeof value === \"number\") {\n        return value;\n    }\n    return value == null ? void 0 : value[prop];\n}\n/**\n * Opens the floating element while hovering over the reference element, like\n * CSS `:hover`.\n * @see https://floating-ui.com/docs/useHover\n */ function useHover(context, props) {\n    _s14();\n    if (props === void 0) {\n        props = {};\n    }\n    const { open, onOpenChange, dataRef, events, elements } = context;\n    const { enabled = true, delay = 0, handleClose = null, mouseOnly = false, restMs = 0, move = true } = props;\n    const tree = useFloatingTree();\n    const parentId = useFloatingParentNodeId();\n    const handleCloseRef = useLatestRef(handleClose);\n    const delayRef = useLatestRef(delay);\n    const openRef = useLatestRef(open);\n    const pointerTypeRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef();\n    const timeoutRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(-1);\n    const handlerRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef();\n    const restTimeoutRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(-1);\n    const blockMouseMoveRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(true);\n    const performedPointerEventsMutationRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\n    const unbindMouseMoveRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(()=>{});\n    const restTimeoutPendingRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\n    const isHoverOpen = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(()=>{\n        var _dataRef$current$open;\n        const type = (_dataRef$current$open = dataRef.current.openEvent) == null ? void 0 : _dataRef$current$open.type;\n        return (type == null ? void 0 : type.includes(\"mouse\")) && type !== \"mousedown\";\n    }, [\n        dataRef\n    ]);\n    // When closing before opening, clear the delay timeouts to cancel it\n    // from showing.\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        if (!enabled) return;\n        function onOpenChange(_ref) {\n            let { open } = _ref;\n            if (!open) {\n                clearTimeout(timeoutRef.current);\n                clearTimeout(restTimeoutRef.current);\n                blockMouseMoveRef.current = true;\n                restTimeoutPendingRef.current = false;\n            }\n        }\n        events.on(\"openchange\", onOpenChange);\n        return ()=>{\n            events.off(\"openchange\", onOpenChange);\n        };\n    }, [\n        enabled,\n        events\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        if (!enabled) return;\n        if (!handleCloseRef.current) return;\n        if (!open) return;\n        function onLeave(event) {\n            if (isHoverOpen()) {\n                onOpenChange(false, event, \"hover\");\n            }\n        }\n        const html = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.getDocument)(elements.floating).documentElement;\n        html.addEventListener(\"mouseleave\", onLeave);\n        return ()=>{\n            html.removeEventListener(\"mouseleave\", onLeave);\n        };\n    }, [\n        elements.floating,\n        open,\n        onOpenChange,\n        enabled,\n        handleCloseRef,\n        isHoverOpen\n    ]);\n    const closeWithDelay = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(function(event, runElseBranch, reason) {\n        if (runElseBranch === void 0) {\n            runElseBranch = true;\n        }\n        if (reason === void 0) {\n            reason = \"hover\";\n        }\n        const closeDelay = getDelay(delayRef.current, \"close\", pointerTypeRef.current);\n        if (closeDelay && !handlerRef.current) {\n            clearTimeout(timeoutRef.current);\n            timeoutRef.current = window.setTimeout(()=>onOpenChange(false, event, reason), closeDelay);\n        } else if (runElseBranch) {\n            clearTimeout(timeoutRef.current);\n            onOpenChange(false, event, reason);\n        }\n    }, [\n        delayRef,\n        onOpenChange\n    ]);\n    const cleanupMouseMoveHandler = useEffectEvent(()=>{\n        unbindMouseMoveRef.current();\n        handlerRef.current = undefined;\n    });\n    const clearPointerEvents = useEffectEvent(()=>{\n        if (performedPointerEventsMutationRef.current) {\n            const body = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.getDocument)(elements.floating).body;\n            body.style.pointerEvents = \"\";\n            body.removeAttribute(safePolygonIdentifier);\n            performedPointerEventsMutationRef.current = false;\n        }\n    });\n    const isClickLikeOpenEvent = useEffectEvent(()=>{\n        return dataRef.current.openEvent ? [\n            \"click\",\n            \"mousedown\"\n        ].includes(dataRef.current.openEvent.type) : false;\n    });\n    // Registering the mouse events on the reference directly to bypass React's\n    // delegation system. If the cursor was on a disabled element and then entered\n    // the reference (no gap), `mouseenter` doesn't fire in the delegation system.\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        if (!enabled) return;\n        function onMouseEnter(event) {\n            clearTimeout(timeoutRef.current);\n            blockMouseMoveRef.current = false;\n            if (mouseOnly && !(0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.isMouseLikePointerType)(pointerTypeRef.current) || restMs > 0 && !getDelay(delayRef.current, \"open\")) {\n                return;\n            }\n            const openDelay = getDelay(delayRef.current, \"open\", pointerTypeRef.current);\n            if (openDelay) {\n                timeoutRef.current = window.setTimeout(()=>{\n                    if (!openRef.current) {\n                        onOpenChange(true, event, \"hover\");\n                    }\n                }, openDelay);\n            } else if (!open) {\n                onOpenChange(true, event, \"hover\");\n            }\n        }\n        function onMouseLeave(event) {\n            if (isClickLikeOpenEvent()) return;\n            unbindMouseMoveRef.current();\n            const doc = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.getDocument)(elements.floating);\n            clearTimeout(restTimeoutRef.current);\n            restTimeoutPendingRef.current = false;\n            if (handleCloseRef.current && dataRef.current.floatingContext) {\n                // Prevent clearing `onScrollMouseLeave` timeout.\n                if (!open) {\n                    clearTimeout(timeoutRef.current);\n                }\n                handlerRef.current = handleCloseRef.current({\n                    ...dataRef.current.floatingContext,\n                    tree,\n                    x: event.clientX,\n                    y: event.clientY,\n                    onClose () {\n                        clearPointerEvents();\n                        cleanupMouseMoveHandler();\n                        if (!isClickLikeOpenEvent()) {\n                            closeWithDelay(event, true, \"safe-polygon\");\n                        }\n                    }\n                });\n                const handler = handlerRef.current;\n                doc.addEventListener(\"mousemove\", handler);\n                unbindMouseMoveRef.current = ()=>{\n                    doc.removeEventListener(\"mousemove\", handler);\n                };\n                return;\n            }\n            // Allow interactivity without `safePolygon` on touch devices. With a\n            // pointer, a short close delay is an alternative, so it should work\n            // consistently.\n            const shouldClose = pointerTypeRef.current === \"touch\" ? !(0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.contains)(elements.floating, event.relatedTarget) : true;\n            if (shouldClose) {\n                closeWithDelay(event);\n            }\n        }\n        // Ensure the floating element closes after scrolling even if the pointer\n        // did not move.\n        // https://github.com/floating-ui/floating-ui/discussions/1692\n        function onScrollMouseLeave(event) {\n            if (isClickLikeOpenEvent()) return;\n            if (!dataRef.current.floatingContext) return;\n            handleCloseRef.current == null || handleCloseRef.current({\n                ...dataRef.current.floatingContext,\n                tree,\n                x: event.clientX,\n                y: event.clientY,\n                onClose () {\n                    clearPointerEvents();\n                    cleanupMouseMoveHandler();\n                    if (!isClickLikeOpenEvent()) {\n                        closeWithDelay(event);\n                    }\n                }\n            })(event);\n        }\n        if ((0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.isElement)(elements.domReference)) {\n            var _elements$floating;\n            const ref = elements.domReference;\n            open && ref.addEventListener(\"mouseleave\", onScrollMouseLeave);\n            (_elements$floating = elements.floating) == null || _elements$floating.addEventListener(\"mouseleave\", onScrollMouseLeave);\n            move && ref.addEventListener(\"mousemove\", onMouseEnter, {\n                once: true\n            });\n            ref.addEventListener(\"mouseenter\", onMouseEnter);\n            ref.addEventListener(\"mouseleave\", onMouseLeave);\n            return ()=>{\n                var _elements$floating2;\n                open && ref.removeEventListener(\"mouseleave\", onScrollMouseLeave);\n                (_elements$floating2 = elements.floating) == null || _elements$floating2.removeEventListener(\"mouseleave\", onScrollMouseLeave);\n                move && ref.removeEventListener(\"mousemove\", onMouseEnter);\n                ref.removeEventListener(\"mouseenter\", onMouseEnter);\n                ref.removeEventListener(\"mouseleave\", onMouseLeave);\n            };\n        }\n    }, [\n        elements,\n        enabled,\n        context,\n        mouseOnly,\n        restMs,\n        move,\n        closeWithDelay,\n        cleanupMouseMoveHandler,\n        clearPointerEvents,\n        onOpenChange,\n        open,\n        openRef,\n        tree,\n        delayRef,\n        handleCloseRef,\n        dataRef,\n        isClickLikeOpenEvent\n    ]);\n    // Block pointer-events of every element other than the reference and floating\n    // while the floating element is open and has a `handleClose` handler. Also\n    // handles nested floating elements.\n    // https://github.com/floating-ui/floating-ui/issues/1722\n    index(()=>{\n        var _handleCloseRef$curre;\n        if (!enabled) return;\n        if (open && (_handleCloseRef$curre = handleCloseRef.current) != null && _handleCloseRef$curre.__options.blockPointerEvents && isHoverOpen()) {\n            performedPointerEventsMutationRef.current = true;\n            const floatingEl = elements.floating;\n            if ((0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.isElement)(elements.domReference) && floatingEl) {\n                var _tree$nodesRef$curren;\n                const body = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.getDocument)(elements.floating).body;\n                body.setAttribute(safePolygonIdentifier, \"\");\n                const ref = elements.domReference;\n                const parentFloating = tree == null || (_tree$nodesRef$curren = tree.nodesRef.current.find((node)=>node.id === parentId)) == null || (_tree$nodesRef$curren = _tree$nodesRef$curren.context) == null ? void 0 : _tree$nodesRef$curren.elements.floating;\n                if (parentFloating) {\n                    parentFloating.style.pointerEvents = \"\";\n                }\n                body.style.pointerEvents = \"none\";\n                ref.style.pointerEvents = \"auto\";\n                floatingEl.style.pointerEvents = \"auto\";\n                return ()=>{\n                    body.style.pointerEvents = \"\";\n                    ref.style.pointerEvents = \"\";\n                    floatingEl.style.pointerEvents = \"\";\n                };\n            }\n        }\n    }, [\n        enabled,\n        open,\n        parentId,\n        elements,\n        tree,\n        handleCloseRef,\n        isHoverOpen\n    ]);\n    index(()=>{\n        if (!open) {\n            pointerTypeRef.current = undefined;\n            restTimeoutPendingRef.current = false;\n            cleanupMouseMoveHandler();\n            clearPointerEvents();\n        }\n    }, [\n        open,\n        cleanupMouseMoveHandler,\n        clearPointerEvents\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        return ()=>{\n            cleanupMouseMoveHandler();\n            clearTimeout(timeoutRef.current);\n            clearTimeout(restTimeoutRef.current);\n            clearPointerEvents();\n        };\n    }, [\n        enabled,\n        elements.domReference,\n        cleanupMouseMoveHandler,\n        clearPointerEvents\n    ]);\n    const reference = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>{\n        function setPointerRef(event) {\n            pointerTypeRef.current = event.pointerType;\n        }\n        return {\n            onPointerDown: setPointerRef,\n            onPointerEnter: setPointerRef,\n            onMouseMove (event) {\n                const { nativeEvent } = event;\n                function handleMouseMove() {\n                    if (!blockMouseMoveRef.current && !openRef.current) {\n                        onOpenChange(true, nativeEvent, \"hover\");\n                    }\n                }\n                if (mouseOnly && !(0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.isMouseLikePointerType)(pointerTypeRef.current)) {\n                    return;\n                }\n                if (open || restMs === 0) {\n                    return;\n                }\n                // Ignore insignificant movements to account for tremors.\n                if (restTimeoutPendingRef.current && event.movementX ** 2 + event.movementY ** 2 < 2) {\n                    return;\n                }\n                clearTimeout(restTimeoutRef.current);\n                if (pointerTypeRef.current === \"touch\") {\n                    handleMouseMove();\n                } else {\n                    restTimeoutPendingRef.current = true;\n                    restTimeoutRef.current = window.setTimeout(handleMouseMove, restMs);\n                }\n            }\n        };\n    }, [\n        mouseOnly,\n        onOpenChange,\n        open,\n        openRef,\n        restMs\n    ]);\n    const floating = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>({\n            onMouseEnter () {\n                clearTimeout(timeoutRef.current);\n            },\n            onMouseLeave (event) {\n                if (!isClickLikeOpenEvent()) {\n                    closeWithDelay(event.nativeEvent, false);\n                }\n            }\n        }), [\n        closeWithDelay,\n        isClickLikeOpenEvent\n    ]);\n    return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>enabled ? {\n            reference,\n            floating\n        } : {}, [\n        enabled,\n        reference,\n        floating\n    ]);\n}\n_s14(useHover, \"rWVFS5MrgCq/rIKu3wrjgU9LDc4=\", false, function() {\n    return [\n        useFloatingTree,\n        useFloatingParentNodeId,\n        useLatestRef,\n        useLatestRef,\n        useLatestRef,\n        useEffectEvent,\n        useEffectEvent,\n        useEffectEvent\n    ];\n});\nconst NOOP = ()=>{};\n_c9 = NOOP;\nconst FloatingDelayGroupContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext({\n    delay: 0,\n    initialDelay: 0,\n    timeoutMs: 0,\n    currentId: null,\n    setCurrentId: NOOP,\n    setState: NOOP,\n    isInstantPhase: false\n});\n/**\n * @deprecated\n * Use the return value of `useDelayGroup()` instead.\n */ const useDelayGroupContext = ()=>{\n    _s15();\n    return react__WEBPACK_IMPORTED_MODULE_0__.useContext(FloatingDelayGroupContext);\n};\n_s15(useDelayGroupContext, \"gDsCjeeItUuvgOWf1v4qoK9RF6k=\");\n/**\n * Provides context for a group of floating elements that should share a\n * `delay`.\n * @see https://floating-ui.com/docs/FloatingDelayGroup\n */ function FloatingDelayGroup(props) {\n    _s16();\n    const { children, delay, timeoutMs = 0 } = props;\n    const [state, setState] = react__WEBPACK_IMPORTED_MODULE_0__.useReducer((prev, next)=>({\n            ...prev,\n            ...next\n        }), {\n        delay,\n        timeoutMs,\n        initialDelay: delay,\n        currentId: null,\n        isInstantPhase: false\n    });\n    const initialCurrentIdRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n    const setCurrentId = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((currentId)=>{\n        setState({\n            currentId\n        });\n    }, []);\n    index(()=>{\n        if (state.currentId) {\n            if (initialCurrentIdRef.current === null) {\n                initialCurrentIdRef.current = state.currentId;\n            } else if (!state.isInstantPhase) {\n                setState({\n                    isInstantPhase: true\n                });\n            }\n        } else {\n            if (state.isInstantPhase) {\n                setState({\n                    isInstantPhase: false\n                });\n            }\n            initialCurrentIdRef.current = null;\n        }\n    }, [\n        state.currentId,\n        state.isInstantPhase\n    ]);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(FloatingDelayGroupContext.Provider, {\n        value: react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>({\n                ...state,\n                setState,\n                setCurrentId\n            }), [\n            state,\n            setCurrentId\n        ])\n    }, children);\n}\n_s16(FloatingDelayGroup, \"ViN+OwxkJQO5KXuVZIUkYF5Tczc=\");\n_c10 = FloatingDelayGroup;\n/**\n * Enables grouping when called inside a component that's a child of a\n * `FloatingDelayGroup`.\n * @see https://floating-ui.com/docs/FloatingDelayGroup\n */ function useDelayGroup(context, options) {\n    _s17();\n    if (options === void 0) {\n        options = {};\n    }\n    const { open, onOpenChange, floatingId } = context;\n    const { id: optionId, enabled = true } = options;\n    const id = optionId != null ? optionId : floatingId;\n    const groupContext = useDelayGroupContext();\n    const { currentId, setCurrentId, initialDelay, setState, timeoutMs } = groupContext;\n    index(()=>{\n        if (!enabled) return;\n        if (!currentId) return;\n        setState({\n            delay: {\n                open: 1,\n                close: getDelay(initialDelay, \"close\")\n            }\n        });\n        if (currentId !== id) {\n            onOpenChange(false);\n        }\n    }, [\n        enabled,\n        id,\n        onOpenChange,\n        setState,\n        currentId,\n        initialDelay\n    ]);\n    index(()=>{\n        function unset() {\n            onOpenChange(false);\n            setState({\n                delay: initialDelay,\n                currentId: null\n            });\n        }\n        if (!enabled) return;\n        if (!currentId) return;\n        if (!open && currentId === id) {\n            if (timeoutMs) {\n                const timeout = window.setTimeout(unset, timeoutMs);\n                return ()=>{\n                    clearTimeout(timeout);\n                };\n            }\n            unset();\n        }\n    }, [\n        enabled,\n        open,\n        setState,\n        currentId,\n        id,\n        onOpenChange,\n        initialDelay,\n        timeoutMs\n    ]);\n    index(()=>{\n        if (!enabled) return;\n        if (setCurrentId === NOOP || !open) return;\n        setCurrentId(id);\n    }, [\n        enabled,\n        open,\n        setCurrentId,\n        id\n    ]);\n    return groupContext;\n}\n_s17(useDelayGroup, \"AjFjtBfxJ5ja09+qDTfRZdFBzmY=\", false, function() {\n    return [\n        useDelayGroupContext\n    ];\n});\nlet rafId = 0;\nfunction enqueueFocus(el, options) {\n    if (options === void 0) {\n        options = {};\n    }\n    const { preventScroll = false, cancelPrevious = true, sync = false } = options;\n    cancelPrevious && cancelAnimationFrame(rafId);\n    const exec = ()=>el == null ? void 0 : el.focus({\n            preventScroll\n        });\n    if (sync) {\n        exec();\n    } else {\n        rafId = requestAnimationFrame(exec);\n    }\n}\nfunction getAncestors(nodes, id) {\n    var _nodes$find;\n    let allAncestors = [];\n    let currentParentId = (_nodes$find = nodes.find((node)=>node.id === id)) == null ? void 0 : _nodes$find.parentId;\n    while(currentParentId){\n        const currentNode = nodes.find((node)=>node.id === currentParentId);\n        currentParentId = currentNode == null ? void 0 : currentNode.parentId;\n        if (currentNode) {\n            allAncestors = allAncestors.concat(currentNode);\n        }\n    }\n    return allAncestors;\n}\nfunction getChildren(nodes, id) {\n    let allChildren = nodes.filter((node)=>{\n        var _node$context;\n        return node.parentId === id && ((_node$context = node.context) == null ? void 0 : _node$context.open);\n    });\n    let currentChildren = allChildren;\n    while(currentChildren.length){\n        currentChildren = nodes.filter((node)=>{\n            var _currentChildren;\n            return (_currentChildren = currentChildren) == null ? void 0 : _currentChildren.some((n)=>{\n                var _node$context2;\n                return node.parentId === n.id && ((_node$context2 = node.context) == null ? void 0 : _node$context2.open);\n            });\n        });\n        allChildren = allChildren.concat(currentChildren);\n    }\n    return allChildren;\n}\nfunction getDeepestNode(nodes, id) {\n    let deepestNodeId;\n    let maxDepth = -1;\n    function findDeepest(nodeId, depth) {\n        if (depth > maxDepth) {\n            deepestNodeId = nodeId;\n            maxDepth = depth;\n        }\n        const children = getChildren(nodes, nodeId);\n        children.forEach((child)=>{\n            findDeepest(child.id, depth + 1);\n        });\n    }\n    findDeepest(id, 0);\n    return nodes.find((node)=>node.id === deepestNodeId);\n}\n// Modified to add conditional `aria-hidden` support:\n// https://github.com/theKashey/aria-hidden/blob/9220c8f4a4fd35f63bee5510a9f41a37264382d4/src/index.ts\nlet counterMap = /*#__PURE__*/ new WeakMap();\nlet uncontrolledElementsSet = /*#__PURE__*/ new WeakSet();\nlet markerMap = {};\nlet lockCount$1 = 0;\nconst supportsInert = ()=>typeof HTMLElement !== \"undefined\" && \"inert\" in HTMLElement.prototype;\nconst unwrapHost = (node)=>node && (node.host || unwrapHost(node.parentNode));\nconst correctElements = (parent, targets)=>targets.map((target)=>{\n        if (parent.contains(target)) {\n            return target;\n        }\n        const correctedTarget = unwrapHost(target);\n        if (parent.contains(correctedTarget)) {\n            return correctedTarget;\n        }\n        return null;\n    }).filter((x)=>x != null);\nfunction applyAttributeToOthers(uncorrectedAvoidElements, body, ariaHidden, inert) {\n    const markerName = \"data-floating-ui-inert\";\n    const controlAttribute = inert ? \"inert\" : ariaHidden ? \"aria-hidden\" : null;\n    const avoidElements = correctElements(body, uncorrectedAvoidElements);\n    const elementsToKeep = new Set();\n    const elementsToStop = new Set(avoidElements);\n    const hiddenElements = [];\n    if (!markerMap[markerName]) {\n        markerMap[markerName] = new WeakMap();\n    }\n    const markerCounter = markerMap[markerName];\n    avoidElements.forEach(keep);\n    deep(body);\n    elementsToKeep.clear();\n    function keep(el) {\n        if (!el || elementsToKeep.has(el)) {\n            return;\n        }\n        elementsToKeep.add(el);\n        el.parentNode && keep(el.parentNode);\n    }\n    function deep(parent) {\n        if (!parent || elementsToStop.has(parent)) {\n            return;\n        }\n        [].forEach.call(parent.children, (node)=>{\n            if ((0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.getNodeName)(node) === \"script\") return;\n            if (elementsToKeep.has(node)) {\n                deep(node);\n            } else {\n                const attr = controlAttribute ? node.getAttribute(controlAttribute) : null;\n                const alreadyHidden = attr !== null && attr !== \"false\";\n                const counterValue = (counterMap.get(node) || 0) + 1;\n                const markerValue = (markerCounter.get(node) || 0) + 1;\n                counterMap.set(node, counterValue);\n                markerCounter.set(node, markerValue);\n                hiddenElements.push(node);\n                if (counterValue === 1 && alreadyHidden) {\n                    uncontrolledElementsSet.add(node);\n                }\n                if (markerValue === 1) {\n                    node.setAttribute(markerName, \"\");\n                }\n                if (!alreadyHidden && controlAttribute) {\n                    node.setAttribute(controlAttribute, \"true\");\n                }\n            }\n        });\n    }\n    lockCount$1++;\n    return ()=>{\n        hiddenElements.forEach((element)=>{\n            const counterValue = (counterMap.get(element) || 0) - 1;\n            const markerValue = (markerCounter.get(element) || 0) - 1;\n            counterMap.set(element, counterValue);\n            markerCounter.set(element, markerValue);\n            if (!counterValue) {\n                if (!uncontrolledElementsSet.has(element) && controlAttribute) {\n                    element.removeAttribute(controlAttribute);\n                }\n                uncontrolledElementsSet.delete(element);\n            }\n            if (!markerValue) {\n                element.removeAttribute(markerName);\n            }\n        });\n        lockCount$1--;\n        if (!lockCount$1) {\n            counterMap = new WeakMap();\n            counterMap = new WeakMap();\n            uncontrolledElementsSet = new WeakSet();\n            markerMap = {};\n        }\n    };\n}\nfunction markOthers(avoidElements, ariaHidden, inert) {\n    if (ariaHidden === void 0) {\n        ariaHidden = false;\n    }\n    if (inert === void 0) {\n        inert = false;\n    }\n    const body = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.getDocument)(avoidElements[0]).body;\n    return applyAttributeToOthers(avoidElements.concat(Array.from(body.querySelectorAll(\"[aria-live]\"))), body, ariaHidden, inert);\n}\nconst getTabbableOptions = ()=>({\n        getShadowRoot: true,\n        displayCheck: // JSDOM does not support the `tabbable` library. To solve this we can\n        // check if `ResizeObserver` is a real function (not polyfilled), which\n        // determines if the current environment is JSDOM-like.\n        typeof ResizeObserver === \"function\" && ResizeObserver.toString().includes(\"[native code]\") ? \"full\" : \"none\"\n    });\nfunction getTabbableIn(container, direction) {\n    const allTabbable = (0,tabbable__WEBPACK_IMPORTED_MODULE_7__.tabbable)(container, getTabbableOptions());\n    if (direction === \"prev\") {\n        allTabbable.reverse();\n    }\n    const activeIndex = allTabbable.indexOf((0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.activeElement)((0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.getDocument)(container)));\n    const nextTabbableElements = allTabbable.slice(activeIndex + 1);\n    return nextTabbableElements[0];\n}\nfunction getNextTabbable() {\n    return getTabbableIn(document.body, \"next\");\n}\nfunction getPreviousTabbable() {\n    return getTabbableIn(document.body, \"prev\");\n}\nfunction isOutsideEvent(event, container) {\n    const containerElement = container || event.currentTarget;\n    const relatedTarget = event.relatedTarget;\n    return !relatedTarget || !(0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.contains)(containerElement, relatedTarget);\n}\nfunction disableFocusInside(container) {\n    const tabbableElements = (0,tabbable__WEBPACK_IMPORTED_MODULE_7__.tabbable)(container, getTabbableOptions());\n    tabbableElements.forEach((element)=>{\n        element.dataset.tabindex = element.getAttribute(\"tabindex\") || \"\";\n        element.setAttribute(\"tabindex\", \"-1\");\n    });\n}\nfunction enableFocusInside(container) {\n    const elements = container.querySelectorAll(\"[data-tabindex]\");\n    elements.forEach((element)=>{\n        const tabindex = element.dataset.tabindex;\n        delete element.dataset.tabindex;\n        if (tabindex) {\n            element.setAttribute(\"tabindex\", tabindex);\n        } else {\n            element.removeAttribute(\"tabindex\");\n        }\n    });\n}\n// See Diego Haz's Sandbox for making this logic work well on Safari/iOS:\n// https://codesandbox.io/s/tabbable-portal-f4tng?file=/src/FocusTrap.tsx\nconst HIDDEN_STYLES = {\n    border: 0,\n    clip: \"rect(0 0 0 0)\",\n    height: \"1px\",\n    margin: \"-1px\",\n    overflow: \"hidden\",\n    padding: 0,\n    position: \"fixed\",\n    whiteSpace: \"nowrap\",\n    width: \"1px\",\n    top: 0,\n    left: 0\n};\nlet timeoutId;\nfunction setActiveElementOnTab(event) {\n    if (event.key === \"Tab\") {\n        event.target;\n        clearTimeout(timeoutId);\n    }\n}\nconst FocusGuard = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(_s18(function FocusGuard(props, ref) {\n    _s18();\n    const [role, setRole] = react__WEBPACK_IMPORTED_MODULE_0__.useState();\n    index(()=>{\n        if ((0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.isSafari)()) {\n            // Unlike other screen readers such as NVDA and JAWS, the virtual cursor\n            // on VoiceOver does trigger the onFocus event, so we can use the focus\n            // trap element. On Safari, only buttons trigger the onFocus event.\n            // NB: \"group\" role in the Sandbox no longer appears to work, must be a\n            // button role.\n            setRole(\"button\");\n        }\n        document.addEventListener(\"keydown\", setActiveElementOnTab);\n        return ()=>{\n            document.removeEventListener(\"keydown\", setActiveElementOnTab);\n        };\n    }, []);\n    const restProps = {\n        ref,\n        tabIndex: 0,\n        // Role is only for VoiceOver\n        role,\n        \"aria-hidden\": role ? undefined : true,\n        [createAttribute(\"focus-guard\")]: \"\",\n        style: HIDDEN_STYLES\n    };\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"span\", _extends({}, props, restProps));\n}, \"OBC9nS354c56TDagtISqQhXOTTk=\"));\n_c11 = FocusGuard;\nconst PortalContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\nconst attr = /*#__PURE__*/ createAttribute(\"portal\");\n/**\n * @see https://floating-ui.com/docs/FloatingPortal#usefloatingportalnode\n */ function useFloatingPortalNode(props) {\n    _s19();\n    if (props === void 0) {\n        props = {};\n    }\n    const { id, root } = props;\n    const uniqueId = useId();\n    const portalContext = usePortalContext();\n    const [portalNode, setPortalNode] = react__WEBPACK_IMPORTED_MODULE_0__.useState(null);\n    const portalNodeRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n    index(()=>{\n        return ()=>{\n            portalNode == null || portalNode.remove();\n            // Allow the subsequent layout effects to create a new node on updates.\n            // The portal node will still be cleaned up on unmount.\n            // https://github.com/floating-ui/floating-ui/issues/2454\n            queueMicrotask(()=>{\n                portalNodeRef.current = null;\n            });\n        };\n    }, [\n        portalNode\n    ]);\n    index(()=>{\n        // Wait for the uniqueId to be generated before creating the portal node in\n        // React <18 (using `useFloatingId` instead of the native `useId`).\n        // https://github.com/floating-ui/floating-ui/issues/2778\n        if (!uniqueId) return;\n        if (portalNodeRef.current) return;\n        const existingIdRoot = id ? document.getElementById(id) : null;\n        if (!existingIdRoot) return;\n        const subRoot = document.createElement(\"div\");\n        subRoot.id = uniqueId;\n        subRoot.setAttribute(attr, \"\");\n        existingIdRoot.appendChild(subRoot);\n        portalNodeRef.current = subRoot;\n        setPortalNode(subRoot);\n    }, [\n        id,\n        uniqueId\n    ]);\n    index(()=>{\n        // Wait for the root to exist before creating the portal node. The root must\n        // be stored in state, not a ref, for this to work reactively.\n        if (root === null) return;\n        if (!uniqueId) return;\n        if (portalNodeRef.current) return;\n        let container = root || (portalContext == null ? void 0 : portalContext.portalNode);\n        if (container && !(0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.isElement)(container)) container = container.current;\n        container = container || document.body;\n        let idWrapper = null;\n        if (id) {\n            idWrapper = document.createElement(\"div\");\n            idWrapper.id = id;\n            container.appendChild(idWrapper);\n        }\n        const subRoot = document.createElement(\"div\");\n        subRoot.id = uniqueId;\n        subRoot.setAttribute(attr, \"\");\n        container = idWrapper || container;\n        container.appendChild(subRoot);\n        portalNodeRef.current = subRoot;\n        setPortalNode(subRoot);\n    }, [\n        id,\n        root,\n        uniqueId,\n        portalContext\n    ]);\n    return portalNode;\n}\n_s19(useFloatingPortalNode, \"XKtoL1ZauW9cCee9y3IGY5DSUeU=\", false, function() {\n    return [\n        useId,\n        usePortalContext\n    ];\n});\n/**\n * Portals the floating element into a given container element  by default,\n * outside of the app root and into the body.\n * This is necessary to ensure the floating element can appear outside any\n * potential parent containers that cause clipping (such as `overflow: hidden`),\n * while retaining its location in the React tree.\n * @see https://floating-ui.com/docs/FloatingPortal\n */ function FloatingPortal(props) {\n    _s20();\n    const { children, id, root, preserveTabOrder = true } = props;\n    const portalNode = useFloatingPortalNode({\n        id,\n        root\n    });\n    const [focusManagerState, setFocusManagerState] = react__WEBPACK_IMPORTED_MODULE_0__.useState(null);\n    const beforeOutsideRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n    const afterOutsideRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n    const beforeInsideRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n    const afterInsideRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n    const modal = focusManagerState == null ? void 0 : focusManagerState.modal;\n    const open = focusManagerState == null ? void 0 : focusManagerState.open;\n    const shouldRenderGuards = // The FocusManager and therefore floating element are currently open/\n    // rendered.\n    !!focusManagerState && // Guards are only for non-modal focus management.\n    !focusManagerState.modal && // Don't render if unmount is transitioning.\n    focusManagerState.open && preserveTabOrder && !!(root || portalNode);\n    // https://codesandbox.io/s/tabbable-portal-f4tng?file=/src/TabbablePortal.tsx\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        if (!portalNode || !preserveTabOrder || modal) {\n            return;\n        }\n        // Make sure elements inside the portal element are tabbable only when the\n        // portal has already been focused, either by tabbing into a focus trap\n        // element outside or using the mouse.\n        function onFocus(event) {\n            if (portalNode && isOutsideEvent(event)) {\n                const focusing = event.type === \"focusin\";\n                const manageFocus = focusing ? enableFocusInside : disableFocusInside;\n                manageFocus(portalNode);\n            }\n        }\n        // Listen to the event on the capture phase so they run before the focus\n        // trap elements onFocus prop is called.\n        portalNode.addEventListener(\"focusin\", onFocus, true);\n        portalNode.addEventListener(\"focusout\", onFocus, true);\n        return ()=>{\n            portalNode.removeEventListener(\"focusin\", onFocus, true);\n            portalNode.removeEventListener(\"focusout\", onFocus, true);\n        };\n    }, [\n        portalNode,\n        preserveTabOrder,\n        modal\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        if (!portalNode) return;\n        if (open) return;\n        enableFocusInside(portalNode);\n    }, [\n        open,\n        portalNode\n    ]);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(PortalContext.Provider, {\n        value: react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>({\n                preserveTabOrder,\n                beforeOutsideRef,\n                afterOutsideRef,\n                beforeInsideRef,\n                afterInsideRef,\n                portalNode,\n                setFocusManagerState\n            }), [\n            preserveTabOrder,\n            portalNode\n        ])\n    }, shouldRenderGuards && portalNode && /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(FocusGuard, {\n        \"data-type\": \"outside\",\n        ref: beforeOutsideRef,\n        onFocus: (event)=>{\n            if (isOutsideEvent(event, portalNode)) {\n                var _beforeInsideRef$curr;\n                (_beforeInsideRef$curr = beforeInsideRef.current) == null || _beforeInsideRef$curr.focus();\n            } else {\n                const prevTabbable = getPreviousTabbable() || (focusManagerState == null ? void 0 : focusManagerState.refs.domReference.current);\n                prevTabbable == null || prevTabbable.focus();\n            }\n        }\n    }), shouldRenderGuards && portalNode && /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"span\", {\n        \"aria-owns\": portalNode.id,\n        style: HIDDEN_STYLES\n    }), portalNode && /*#__PURE__*/ react_dom__WEBPACK_IMPORTED_MODULE_1__.createPortal(children, portalNode), shouldRenderGuards && portalNode && /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(FocusGuard, {\n        \"data-type\": \"outside\",\n        ref: afterOutsideRef,\n        onFocus: (event)=>{\n            if (isOutsideEvent(event, portalNode)) {\n                var _afterInsideRef$curre;\n                (_afterInsideRef$curre = afterInsideRef.current) == null || _afterInsideRef$curre.focus();\n            } else {\n                const nextTabbable = getNextTabbable() || (focusManagerState == null ? void 0 : focusManagerState.refs.domReference.current);\n                nextTabbable == null || nextTabbable.focus();\n                (focusManagerState == null ? void 0 : focusManagerState.closeOnFocusOut) && (focusManagerState == null ? void 0 : focusManagerState.onOpenChange(false, event.nativeEvent, \"focus-out\"));\n            }\n        }\n    }));\n}\n_s20(FloatingPortal, \"s3KL28k6Dx8H5eOqoqgvMZcAeqc=\", false, function() {\n    return [\n        useFloatingPortalNode\n    ];\n});\n_c12 = FloatingPortal;\nconst usePortalContext = ()=>{\n    _s21();\n    return react__WEBPACK_IMPORTED_MODULE_0__.useContext(PortalContext);\n};\n_s21(usePortalContext, \"gDsCjeeItUuvgOWf1v4qoK9RF6k=\");\nconst FOCUSABLE_ATTRIBUTE = \"data-floating-ui-focusable\";\nfunction getFloatingFocusElement(floatingElement) {\n    if (!floatingElement) {\n        return null;\n    }\n    // Try to find the element that has `{...getFloatingProps()}` spread on it.\n    // This indicates the floating element is acting as a positioning wrapper, and\n    // so focus should be managed on the child element with the event handlers and\n    // aria props.\n    return floatingElement.hasAttribute(FOCUSABLE_ATTRIBUTE) ? floatingElement : floatingElement.querySelector(\"[\" + FOCUSABLE_ATTRIBUTE + \"]\") || floatingElement;\n}\nconst LIST_LIMIT = 20;\nlet previouslyFocusedElements = [];\nfunction addPreviouslyFocusedElement(element) {\n    previouslyFocusedElements = previouslyFocusedElements.filter((el)=>el.isConnected);\n    let tabbableEl = element;\n    if (!tabbableEl || (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.getNodeName)(tabbableEl) === \"body\") return;\n    if (!(0,tabbable__WEBPACK_IMPORTED_MODULE_7__.isTabbable)(tabbableEl, getTabbableOptions())) {\n        const tabbableChild = (0,tabbable__WEBPACK_IMPORTED_MODULE_7__.tabbable)(tabbableEl, getTabbableOptions())[0];\n        if (tabbableChild) {\n            tabbableEl = tabbableChild;\n        }\n    }\n    previouslyFocusedElements.push(tabbableEl);\n    if (previouslyFocusedElements.length > LIST_LIMIT) {\n        previouslyFocusedElements = previouslyFocusedElements.slice(-LIST_LIMIT);\n    }\n}\nfunction getPreviouslyFocusedElement() {\n    return previouslyFocusedElements.slice().reverse().find((el)=>el.isConnected);\n}\nconst VisuallyHiddenDismiss = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(function VisuallyHiddenDismiss(props, ref) {\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"button\", _extends({}, props, {\n        type: \"button\",\n        ref: ref,\n        tabIndex: -1,\n        style: HIDDEN_STYLES\n    }));\n});\n_c13 = VisuallyHiddenDismiss;\n/**\n * Provides focus management for the floating element.\n * @see https://floating-ui.com/docs/FloatingFocusManager\n */ function FloatingFocusManager(props) {\n    _s22();\n    const { context, children, disabled = false, order = [\n        \"content\"\n    ], guards: _guards = true, initialFocus = 0, returnFocus = true, restoreFocus = false, modal = true, visuallyHiddenDismiss = false, closeOnFocusOut = true } = props;\n    const { open, refs, nodeId, onOpenChange, events, dataRef, floatingId, elements: { domReference, floating } } = context;\n    const ignoreInitialFocus = typeof initialFocus === \"number\" && initialFocus < 0;\n    // If the reference is a combobox and is typeable (e.g. input/textarea),\n    // there are different focus semantics. The guards should not be rendered, but\n    // aria-hidden should be applied to all nodes still. Further, the visually\n    // hidden dismiss button should only appear at the end of the list, not the\n    // start.\n    const isUntrappedTypeableCombobox = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.isTypeableCombobox)(domReference) && ignoreInitialFocus;\n    // Force the guards to be rendered if the `inert` attribute is not supported.\n    const guards = supportsInert() ? _guards : true;\n    const orderRef = useLatestRef(order);\n    const initialFocusRef = useLatestRef(initialFocus);\n    const returnFocusRef = useLatestRef(returnFocus);\n    const tree = useFloatingTree();\n    const portalContext = usePortalContext();\n    const startDismissButtonRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n    const endDismissButtonRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n    const preventReturnFocusRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\n    const isPointerDownRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\n    const tabbableIndexRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(-1);\n    const isInsidePortal = portalContext != null;\n    const floatingFocusElement = getFloatingFocusElement(floating);\n    const getTabbableContent = useEffectEvent(function(container) {\n        if (container === void 0) {\n            container = floatingFocusElement;\n        }\n        return container ? (0,tabbable__WEBPACK_IMPORTED_MODULE_7__.tabbable)(container, getTabbableOptions()) : [];\n    });\n    const getTabbableElements = useEffectEvent((container)=>{\n        const content = getTabbableContent(container);\n        return orderRef.current.map((type)=>{\n            if (domReference && type === \"reference\") {\n                return domReference;\n            }\n            if (floatingFocusElement && type === \"floating\") {\n                return floatingFocusElement;\n            }\n            return content;\n        }).filter(Boolean).flat();\n    });\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        if (disabled) return;\n        if (!modal) return;\n        function onKeyDown(event) {\n            if (event.key === \"Tab\") {\n                // The focus guards have nothing to focus, so we need to stop the event.\n                if ((0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.contains)(floatingFocusElement, (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.activeElement)((0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.getDocument)(floatingFocusElement))) && getTabbableContent().length === 0 && !isUntrappedTypeableCombobox) {\n                    (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.stopEvent)(event);\n                }\n                const els = getTabbableElements();\n                const target = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.getTarget)(event);\n                if (orderRef.current[0] === \"reference\" && target === domReference) {\n                    (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.stopEvent)(event);\n                    if (event.shiftKey) {\n                        enqueueFocus(els[els.length - 1]);\n                    } else {\n                        enqueueFocus(els[1]);\n                    }\n                }\n                if (orderRef.current[1] === \"floating\" && target === floatingFocusElement && event.shiftKey) {\n                    (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.stopEvent)(event);\n                    enqueueFocus(els[0]);\n                }\n            }\n        }\n        const doc = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.getDocument)(floatingFocusElement);\n        doc.addEventListener(\"keydown\", onKeyDown);\n        return ()=>{\n            doc.removeEventListener(\"keydown\", onKeyDown);\n        };\n    }, [\n        disabled,\n        domReference,\n        floatingFocusElement,\n        modal,\n        orderRef,\n        isUntrappedTypeableCombobox,\n        getTabbableContent,\n        getTabbableElements\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        if (disabled) return;\n        if (!floating) return;\n        function handleFocusIn(event) {\n            const target = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.getTarget)(event);\n            const tabbableContent = getTabbableContent();\n            const tabbableIndex = tabbableContent.indexOf(target);\n            if (tabbableIndex !== -1) {\n                tabbableIndexRef.current = tabbableIndex;\n            }\n        }\n        floating.addEventListener(\"focusin\", handleFocusIn);\n        return ()=>{\n            floating.removeEventListener(\"focusin\", handleFocusIn);\n        };\n    }, [\n        disabled,\n        floating,\n        getTabbableContent\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        if (disabled) return;\n        if (!closeOnFocusOut) return;\n        // In Safari, buttons lose focus when pressing them.\n        function handlePointerDown() {\n            isPointerDownRef.current = true;\n            setTimeout(()=>{\n                isPointerDownRef.current = false;\n            });\n        }\n        function handleFocusOutside(event) {\n            const relatedTarget = event.relatedTarget;\n            queueMicrotask(()=>{\n                const movedToUnrelatedNode = !((0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.contains)(domReference, relatedTarget) || (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.contains)(floating, relatedTarget) || (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.contains)(relatedTarget, floating) || (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.contains)(portalContext == null ? void 0 : portalContext.portalNode, relatedTarget) || relatedTarget != null && relatedTarget.hasAttribute(createAttribute(\"focus-guard\")) || tree && (getChildren(tree.nodesRef.current, nodeId).find((node)=>{\n                    var _node$context, _node$context2;\n                    return (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.contains)((_node$context = node.context) == null ? void 0 : _node$context.elements.floating, relatedTarget) || (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.contains)((_node$context2 = node.context) == null ? void 0 : _node$context2.elements.domReference, relatedTarget);\n                }) || getAncestors(tree.nodesRef.current, nodeId).find((node)=>{\n                    var _node$context3, _node$context4;\n                    return ((_node$context3 = node.context) == null ? void 0 : _node$context3.elements.floating) === relatedTarget || ((_node$context4 = node.context) == null ? void 0 : _node$context4.elements.domReference) === relatedTarget;\n                })));\n                // Restore focus to the previous tabbable element index to prevent\n                // focus from being lost outside the floating tree.\n                if (restoreFocus && movedToUnrelatedNode && (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.activeElement)((0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.getDocument)(floatingFocusElement)) === (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.getDocument)(floatingFocusElement).body) {\n                    // Let `FloatingPortal` effect knows that focus is still inside the\n                    // floating tree.\n                    if ((0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.isHTMLElement)(floatingFocusElement)) {\n                        floatingFocusElement.focus();\n                    }\n                    const prevTabbableIndex = tabbableIndexRef.current;\n                    const tabbableContent = getTabbableContent();\n                    const nodeToFocus = tabbableContent[prevTabbableIndex] || tabbableContent[tabbableContent.length - 1] || floatingFocusElement;\n                    if ((0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.isHTMLElement)(nodeToFocus)) {\n                        nodeToFocus.focus();\n                    }\n                }\n                // Focus did not move inside the floating tree, and there are no tabbable\n                // portal guards to handle closing.\n                if ((isUntrappedTypeableCombobox ? true : !modal) && relatedTarget && movedToUnrelatedNode && !isPointerDownRef.current && // Fix React 18 Strict Mode returnFocus due to double rendering.\n                relatedTarget !== getPreviouslyFocusedElement()) {\n                    preventReturnFocusRef.current = true;\n                    onOpenChange(false, event, \"focus-out\");\n                }\n            });\n        }\n        if (floating && (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.isHTMLElement)(domReference)) {\n            domReference.addEventListener(\"focusout\", handleFocusOutside);\n            domReference.addEventListener(\"pointerdown\", handlePointerDown);\n            floating.addEventListener(\"focusout\", handleFocusOutside);\n            return ()=>{\n                domReference.removeEventListener(\"focusout\", handleFocusOutside);\n                domReference.removeEventListener(\"pointerdown\", handlePointerDown);\n                floating.removeEventListener(\"focusout\", handleFocusOutside);\n            };\n        }\n    }, [\n        disabled,\n        domReference,\n        floating,\n        floatingFocusElement,\n        modal,\n        nodeId,\n        tree,\n        portalContext,\n        onOpenChange,\n        closeOnFocusOut,\n        restoreFocus,\n        getTabbableContent,\n        isUntrappedTypeableCombobox\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        var _portalContext$portal;\n        if (disabled) return;\n        // Don't hide portals nested within the parent portal.\n        const portalNodes = Array.from((portalContext == null || (_portalContext$portal = portalContext.portalNode) == null ? void 0 : _portalContext$portal.querySelectorAll(\"[\" + createAttribute(\"portal\") + \"]\")) || []);\n        if (floating) {\n            const insideElements = [\n                floating,\n                ...portalNodes,\n                startDismissButtonRef.current,\n                endDismissButtonRef.current,\n                orderRef.current.includes(\"reference\") || isUntrappedTypeableCombobox ? domReference : null\n            ].filter((x)=>x != null);\n            const cleanup = modal || isUntrappedTypeableCombobox ? markOthers(insideElements, guards, !guards) : markOthers(insideElements);\n            return ()=>{\n                cleanup();\n            };\n        }\n    }, [\n        disabled,\n        domReference,\n        floating,\n        modal,\n        orderRef,\n        portalContext,\n        isUntrappedTypeableCombobox,\n        guards\n    ]);\n    index(()=>{\n        if (disabled || !(0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.isHTMLElement)(floatingFocusElement)) return;\n        const doc = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.getDocument)(floatingFocusElement);\n        const previouslyFocusedElement = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.activeElement)(doc);\n        // Wait for any layout effect state setters to execute to set `tabIndex`.\n        queueMicrotask(()=>{\n            const focusableElements = getTabbableElements(floatingFocusElement);\n            const initialFocusValue = initialFocusRef.current;\n            const elToFocus = (typeof initialFocusValue === \"number\" ? focusableElements[initialFocusValue] : initialFocusValue.current) || floatingFocusElement;\n            const focusAlreadyInsideFloatingEl = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.contains)(floatingFocusElement, previouslyFocusedElement);\n            if (!ignoreInitialFocus && !focusAlreadyInsideFloatingEl && open) {\n                enqueueFocus(elToFocus, {\n                    preventScroll: elToFocus === floatingFocusElement\n                });\n            }\n        });\n    }, [\n        disabled,\n        open,\n        floatingFocusElement,\n        ignoreInitialFocus,\n        getTabbableElements,\n        initialFocusRef\n    ]);\n    index(()=>{\n        if (disabled || !floatingFocusElement) return;\n        let preventReturnFocusScroll = false;\n        const doc = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.getDocument)(floatingFocusElement);\n        const previouslyFocusedElement = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.activeElement)(doc);\n        const contextData = dataRef.current;\n        let openEvent = contextData.openEvent;\n        addPreviouslyFocusedElement(previouslyFocusedElement);\n        // Dismissing via outside press should always ignore `returnFocus` to\n        // prevent unwanted scrolling.\n        function onOpenChange(_ref) {\n            let { open, reason, event, nested } = _ref;\n            if (open) {\n                openEvent = event;\n            }\n            if (reason === \"escape-key\" && refs.domReference.current) {\n                addPreviouslyFocusedElement(refs.domReference.current);\n            }\n            if (reason === \"hover\" && event.type === \"mouseleave\") {\n                preventReturnFocusRef.current = true;\n            }\n            if (reason !== \"outside-press\") return;\n            if (nested) {\n                preventReturnFocusRef.current = false;\n                preventReturnFocusScroll = true;\n            } else {\n                preventReturnFocusRef.current = !((0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.isVirtualClick)(event) || (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.isVirtualPointerEvent)(event));\n            }\n        }\n        events.on(\"openchange\", onOpenChange);\n        const fallbackEl = doc.createElement(\"span\");\n        fallbackEl.setAttribute(\"tabindex\", \"-1\");\n        fallbackEl.setAttribute(\"aria-hidden\", \"true\");\n        Object.assign(fallbackEl.style, HIDDEN_STYLES);\n        if (isInsidePortal && domReference) {\n            domReference.insertAdjacentElement(\"afterend\", fallbackEl);\n        }\n        function getReturnElement() {\n            if (typeof returnFocusRef.current === \"boolean\") {\n                return getPreviouslyFocusedElement() || fallbackEl;\n            }\n            return returnFocusRef.current.current || fallbackEl;\n        }\n        return ()=>{\n            events.off(\"openchange\", onOpenChange);\n            const activeEl = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.activeElement)(doc);\n            const isFocusInsideFloatingTree = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.contains)(floating, activeEl) || tree && getChildren(tree.nodesRef.current, nodeId).some((node)=>{\n                var _node$context5;\n                return (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.contains)((_node$context5 = node.context) == null ? void 0 : _node$context5.elements.floating, activeEl);\n            });\n            const shouldFocusReference = isFocusInsideFloatingTree || openEvent && [\n                \"click\",\n                \"mousedown\"\n            ].includes(openEvent.type);\n            if (shouldFocusReference && refs.domReference.current) {\n                addPreviouslyFocusedElement(refs.domReference.current);\n            }\n            const returnElement = getReturnElement();\n            queueMicrotask(()=>{\n                if (// eslint-disable-next-line react-hooks/exhaustive-deps\n                returnFocusRef.current && !preventReturnFocusRef.current && (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.isHTMLElement)(returnElement) && // If the focus moved somewhere else after mount, avoid returning focus\n                // since it likely entered a different element which should be\n                // respected: https://github.com/floating-ui/floating-ui/issues/2607\n                (returnElement !== activeEl && activeEl !== doc.body ? isFocusInsideFloatingTree : true)) {\n                    returnElement.focus({\n                        preventScroll: preventReturnFocusScroll\n                    });\n                }\n                fallbackEl.remove();\n            });\n        };\n    }, [\n        disabled,\n        floating,\n        floatingFocusElement,\n        returnFocusRef,\n        dataRef,\n        refs,\n        events,\n        tree,\n        nodeId,\n        isInsidePortal,\n        domReference\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        // The `returnFocus` cleanup behavior is inside a microtask; ensure we\n        // wait for it to complete before resetting the flag.\n        queueMicrotask(()=>{\n            preventReturnFocusRef.current = false;\n        });\n    }, [\n        disabled\n    ]);\n    // Synchronize the `context` & `modal` value to the FloatingPortal context.\n    // It will decide whether or not it needs to render its own guards.\n    index(()=>{\n        if (disabled) return;\n        if (!portalContext) return;\n        portalContext.setFocusManagerState({\n            modal,\n            closeOnFocusOut,\n            open,\n            onOpenChange,\n            refs\n        });\n        return ()=>{\n            portalContext.setFocusManagerState(null);\n        };\n    }, [\n        disabled,\n        portalContext,\n        modal,\n        open,\n        onOpenChange,\n        refs,\n        closeOnFocusOut\n    ]);\n    index(()=>{\n        if (disabled) return;\n        if (!floatingFocusElement) return;\n        if (typeof MutationObserver !== \"function\") return;\n        if (ignoreInitialFocus) return;\n        const handleMutation = ()=>{\n            const tabIndex = floatingFocusElement.getAttribute(\"tabindex\");\n            const tabbableContent = getTabbableContent();\n            const activeEl = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.activeElement)((0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.getDocument)(floating));\n            const tabbableIndex = tabbableContent.indexOf(activeEl);\n            if (tabbableIndex !== -1) {\n                tabbableIndexRef.current = tabbableIndex;\n            }\n            if (orderRef.current.includes(\"floating\") || activeEl !== refs.domReference.current && tabbableContent.length === 0) {\n                if (tabIndex !== \"0\") {\n                    floatingFocusElement.setAttribute(\"tabindex\", \"0\");\n                }\n            } else if (tabIndex !== \"-1\") {\n                floatingFocusElement.setAttribute(\"tabindex\", \"-1\");\n            }\n        };\n        handleMutation();\n        const observer = new MutationObserver(handleMutation);\n        observer.observe(floatingFocusElement, {\n            childList: true,\n            subtree: true,\n            attributes: true\n        });\n        return ()=>{\n            observer.disconnect();\n        };\n    }, [\n        disabled,\n        floating,\n        floatingFocusElement,\n        refs,\n        orderRef,\n        getTabbableContent,\n        ignoreInitialFocus\n    ]);\n    function renderDismissButton(location) {\n        if (disabled || !visuallyHiddenDismiss || !modal) {\n            return null;\n        }\n        return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(VisuallyHiddenDismiss, {\n            ref: location === \"start\" ? startDismissButtonRef : endDismissButtonRef,\n            onClick: (event)=>onOpenChange(false, event.nativeEvent)\n        }, typeof visuallyHiddenDismiss === \"string\" ? visuallyHiddenDismiss : \"Dismiss\");\n    }\n    const shouldRenderGuards = !disabled && guards && (modal ? !isUntrappedTypeableCombobox : true) && (isInsidePortal || modal);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, shouldRenderGuards && /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(FocusGuard, {\n        \"data-type\": \"inside\",\n        ref: portalContext == null ? void 0 : portalContext.beforeInsideRef,\n        onFocus: (event)=>{\n            if (modal) {\n                const els = getTabbableElements();\n                enqueueFocus(order[0] === \"reference\" ? els[0] : els[els.length - 1]);\n            } else if (portalContext != null && portalContext.preserveTabOrder && portalContext.portalNode) {\n                preventReturnFocusRef.current = false;\n                if (isOutsideEvent(event, portalContext.portalNode)) {\n                    const nextTabbable = getNextTabbable() || domReference;\n                    nextTabbable == null || nextTabbable.focus();\n                } else {\n                    var _portalContext$before;\n                    (_portalContext$before = portalContext.beforeOutsideRef.current) == null || _portalContext$before.focus();\n                }\n            }\n        }\n    }), !isUntrappedTypeableCombobox && renderDismissButton(\"start\"), children, renderDismissButton(\"end\"), shouldRenderGuards && /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(FocusGuard, {\n        \"data-type\": \"inside\",\n        ref: portalContext == null ? void 0 : portalContext.afterInsideRef,\n        onFocus: (event)=>{\n            if (modal) {\n                enqueueFocus(getTabbableElements()[0]);\n            } else if (portalContext != null && portalContext.preserveTabOrder && portalContext.portalNode) {\n                if (closeOnFocusOut) {\n                    preventReturnFocusRef.current = true;\n                }\n                if (isOutsideEvent(event, portalContext.portalNode)) {\n                    const prevTabbable = getPreviousTabbable() || domReference;\n                    prevTabbable == null || prevTabbable.focus();\n                } else {\n                    var _portalContext$afterO;\n                    (_portalContext$afterO = portalContext.afterOutsideRef.current) == null || _portalContext$afterO.focus();\n                }\n            }\n        }\n    }));\n}\n_s22(FloatingFocusManager, \"SRNYQRLbamlP9BziwKHKcJmLK6M=\", false, function() {\n    return [\n        useLatestRef,\n        useLatestRef,\n        useLatestRef,\n        useFloatingTree,\n        usePortalContext,\n        useEffectEvent,\n        useEffectEvent\n    ];\n});\n_c14 = FloatingFocusManager;\nlet lockCount = 0;\nfunction enableScrollLock() {\n    const isIOS = /iP(hone|ad|od)|iOS/.test((0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.getPlatform)());\n    const bodyStyle = document.body.style;\n    // RTL <body> scrollbar\n    const scrollbarX = Math.round(document.documentElement.getBoundingClientRect().left) + document.documentElement.scrollLeft;\n    const paddingProp = scrollbarX ? \"paddingLeft\" : \"paddingRight\";\n    const scrollbarWidth = window.innerWidth - document.documentElement.clientWidth;\n    const scrollX = bodyStyle.left ? parseFloat(bodyStyle.left) : window.scrollX;\n    const scrollY = bodyStyle.top ? parseFloat(bodyStyle.top) : window.scrollY;\n    bodyStyle.overflow = \"hidden\";\n    if (scrollbarWidth) {\n        bodyStyle[paddingProp] = scrollbarWidth + \"px\";\n    }\n    // Only iOS doesn't respect `overflow: hidden` on document.body, and this\n    // technique has fewer side effects.\n    if (isIOS) {\n        var _window$visualViewpor, _window$visualViewpor2;\n        // iOS 12 does not support `visualViewport`.\n        const offsetLeft = ((_window$visualViewpor = window.visualViewport) == null ? void 0 : _window$visualViewpor.offsetLeft) || 0;\n        const offsetTop = ((_window$visualViewpor2 = window.visualViewport) == null ? void 0 : _window$visualViewpor2.offsetTop) || 0;\n        Object.assign(bodyStyle, {\n            position: \"fixed\",\n            top: -(scrollY - Math.floor(offsetTop)) + \"px\",\n            left: -(scrollX - Math.floor(offsetLeft)) + \"px\",\n            right: \"0\"\n        });\n    }\n    return ()=>{\n        Object.assign(bodyStyle, {\n            overflow: \"\",\n            [paddingProp]: \"\"\n        });\n        if (isIOS) {\n            Object.assign(bodyStyle, {\n                position: \"\",\n                top: \"\",\n                left: \"\",\n                right: \"\"\n            });\n            window.scrollTo(scrollX, scrollY);\n        }\n    };\n}\nlet cleanup = ()=>{};\n/**\n * Provides base styling for a fixed overlay element to dim content or block\n * pointer events behind a floating element.\n * It's a regular `<div>`, so it can be styled via any CSS solution you prefer.\n * @see https://floating-ui.com/docs/FloatingOverlay\n */ const FloatingOverlay = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(_c15 = function FloatingOverlay(props, ref) {\n    const { lockScroll = false, ...rest } = props;\n    index(()=>{\n        if (!lockScroll) return;\n        lockCount++;\n        if (lockCount === 1) {\n            cleanup = enableScrollLock();\n        }\n        return ()=>{\n            lockCount--;\n            if (lockCount === 0) {\n                cleanup();\n            }\n        };\n    }, [\n        lockScroll\n    ]);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", _extends({\n        ref: ref\n    }, rest, {\n        style: {\n            position: \"fixed\",\n            overflow: \"auto\",\n            top: 0,\n            right: 0,\n            bottom: 0,\n            left: 0,\n            ...rest.style\n        }\n    }));\n});\n_c16 = FloatingOverlay;\nfunction isButtonTarget(event) {\n    return (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.isHTMLElement)(event.target) && event.target.tagName === \"BUTTON\";\n}\nfunction isSpaceIgnored(element) {\n    return (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.isTypeableElement)(element);\n}\n/**\n * Opens or closes the floating element when clicking the reference element.\n * @see https://floating-ui.com/docs/useClick\n */ function useClick(context, props) {\n    _s23();\n    if (props === void 0) {\n        props = {};\n    }\n    const { open, onOpenChange, dataRef, elements: { domReference } } = context;\n    const { enabled = true, event: eventOption = \"click\", toggle = true, ignoreMouse = false, keyboardHandlers = true, stickIfOpen = true } = props;\n    const pointerTypeRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef();\n    const didKeyDownRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\n    const reference = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>({\n            onPointerDown (event) {\n                pointerTypeRef.current = event.pointerType;\n            },\n            onMouseDown (event) {\n                const pointerType = pointerTypeRef.current;\n                // Ignore all buttons except for the \"main\" button.\n                // https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/button\n                if (event.button !== 0) return;\n                if (eventOption === \"click\") return;\n                if ((0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.isMouseLikePointerType)(pointerType, true) && ignoreMouse) return;\n                if (open && toggle && (dataRef.current.openEvent && stickIfOpen ? dataRef.current.openEvent.type === \"mousedown\" : true)) {\n                    onOpenChange(false, event.nativeEvent, \"click\");\n                } else {\n                    // Prevent stealing focus from the floating element\n                    event.preventDefault();\n                    onOpenChange(true, event.nativeEvent, \"click\");\n                }\n            },\n            onClick (event) {\n                const pointerType = pointerTypeRef.current;\n                if (eventOption === \"mousedown\" && pointerTypeRef.current) {\n                    pointerTypeRef.current = undefined;\n                    return;\n                }\n                if ((0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.isMouseLikePointerType)(pointerType, true) && ignoreMouse) return;\n                if (open && toggle && (dataRef.current.openEvent && stickIfOpen ? dataRef.current.openEvent.type === \"click\" : true)) {\n                    onOpenChange(false, event.nativeEvent, \"click\");\n                } else {\n                    onOpenChange(true, event.nativeEvent, \"click\");\n                }\n            },\n            onKeyDown (event) {\n                pointerTypeRef.current = undefined;\n                if (event.defaultPrevented || !keyboardHandlers || isButtonTarget(event)) {\n                    return;\n                }\n                if (event.key === \" \" && !isSpaceIgnored(domReference)) {\n                    // Prevent scrolling\n                    event.preventDefault();\n                    didKeyDownRef.current = true;\n                }\n                if (event.key === \"Enter\") {\n                    if (open && toggle) {\n                        onOpenChange(false, event.nativeEvent, \"click\");\n                    } else {\n                        onOpenChange(true, event.nativeEvent, \"click\");\n                    }\n                }\n            },\n            onKeyUp (event) {\n                if (event.defaultPrevented || !keyboardHandlers || isButtonTarget(event) || isSpaceIgnored(domReference)) {\n                    return;\n                }\n                if (event.key === \" \" && didKeyDownRef.current) {\n                    didKeyDownRef.current = false;\n                    if (open && toggle) {\n                        onOpenChange(false, event.nativeEvent, \"click\");\n                    } else {\n                        onOpenChange(true, event.nativeEvent, \"click\");\n                    }\n                }\n            }\n        }), [\n        dataRef,\n        domReference,\n        eventOption,\n        ignoreMouse,\n        keyboardHandlers,\n        onOpenChange,\n        open,\n        stickIfOpen,\n        toggle\n    ]);\n    return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>enabled ? {\n            reference\n        } : {}, [\n        enabled,\n        reference\n    ]);\n}\n_s23(useClick, \"w9gEuLaf/MBEZPrv7a4DFUvdLNI=\");\nfunction createVirtualElement(domElement, data) {\n    let offsetX = null;\n    let offsetY = null;\n    let isAutoUpdateEvent = false;\n    return {\n        contextElement: domElement || undefined,\n        getBoundingClientRect () {\n            var _data$dataRef$current;\n            const domRect = (domElement == null ? void 0 : domElement.getBoundingClientRect()) || {\n                width: 0,\n                height: 0,\n                x: 0,\n                y: 0\n            };\n            const isXAxis = data.axis === \"x\" || data.axis === \"both\";\n            const isYAxis = data.axis === \"y\" || data.axis === \"both\";\n            const canTrackCursorOnAutoUpdate = [\n                \"mouseenter\",\n                \"mousemove\"\n            ].includes(((_data$dataRef$current = data.dataRef.current.openEvent) == null ? void 0 : _data$dataRef$current.type) || \"\") && data.pointerType !== \"touch\";\n            let width = domRect.width;\n            let height = domRect.height;\n            let x = domRect.x;\n            let y = domRect.y;\n            if (offsetX == null && data.x && isXAxis) {\n                offsetX = domRect.x - data.x;\n            }\n            if (offsetY == null && data.y && isYAxis) {\n                offsetY = domRect.y - data.y;\n            }\n            x -= offsetX || 0;\n            y -= offsetY || 0;\n            width = 0;\n            height = 0;\n            if (!isAutoUpdateEvent || canTrackCursorOnAutoUpdate) {\n                width = data.axis === \"y\" ? domRect.width : 0;\n                height = data.axis === \"x\" ? domRect.height : 0;\n                x = isXAxis && data.x != null ? data.x : x;\n                y = isYAxis && data.y != null ? data.y : y;\n            } else if (isAutoUpdateEvent && !canTrackCursorOnAutoUpdate) {\n                height = data.axis === \"x\" ? domRect.height : height;\n                width = data.axis === \"y\" ? domRect.width : width;\n            }\n            isAutoUpdateEvent = true;\n            return {\n                width,\n                height,\n                x,\n                y,\n                top: y,\n                right: x + width,\n                bottom: y + height,\n                left: x\n            };\n        }\n    };\n}\nfunction isMouseBasedEvent(event) {\n    return event != null && event.clientX != null;\n}\n/**\n * Positions the floating element relative to a client point (in the viewport),\n * such as the mouse position. By default, it follows the mouse cursor.\n * @see https://floating-ui.com/docs/useClientPoint\n */ function useClientPoint(context, props) {\n    _s24();\n    if (props === void 0) {\n        props = {};\n    }\n    const { open, dataRef, elements: { floating, domReference }, refs } = context;\n    const { enabled = true, axis = \"both\", x = null, y = null } = props;\n    const initialRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\n    const cleanupListenerRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n    const [pointerType, setPointerType] = react__WEBPACK_IMPORTED_MODULE_0__.useState();\n    const [reactive, setReactive] = react__WEBPACK_IMPORTED_MODULE_0__.useState([]);\n    const setReference = useEffectEvent((x, y)=>{\n        if (initialRef.current) return;\n        // Prevent setting if the open event was not a mouse-like one\n        // (e.g. focus to open, then hover over the reference element).\n        // Only apply if the event exists.\n        if (dataRef.current.openEvent && !isMouseBasedEvent(dataRef.current.openEvent)) {\n            return;\n        }\n        refs.setPositionReference(createVirtualElement(domReference, {\n            x,\n            y,\n            axis,\n            dataRef,\n            pointerType\n        }));\n    });\n    const handleReferenceEnterOrMove = useEffectEvent((event)=>{\n        if (x != null || y != null) return;\n        if (!open) {\n            setReference(event.clientX, event.clientY);\n        } else if (!cleanupListenerRef.current) {\n            // If there's no cleanup, there's no listener, but we want to ensure\n            // we add the listener if the cursor landed on the floating element and\n            // then back on the reference (i.e. it's interactive).\n            setReactive([]);\n        }\n    });\n    // If the pointer is a mouse-like pointer, we want to continue following the\n    // mouse even if the floating element is transitioning out. On touch\n    // devices, this is undesirable because the floating element will move to\n    // the dismissal touch point.\n    const openCheck = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.isMouseLikePointerType)(pointerType) ? floating : open;\n    const addListener = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(()=>{\n        // Explicitly specified `x`/`y` coordinates shouldn't add a listener.\n        if (!openCheck || !enabled || x != null || y != null) return;\n        const win = (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.getWindow)(floating);\n        function handleMouseMove(event) {\n            const target = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.getTarget)(event);\n            if (!(0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.contains)(floating, target)) {\n                setReference(event.clientX, event.clientY);\n            } else {\n                win.removeEventListener(\"mousemove\", handleMouseMove);\n                cleanupListenerRef.current = null;\n            }\n        }\n        if (!dataRef.current.openEvent || isMouseBasedEvent(dataRef.current.openEvent)) {\n            win.addEventListener(\"mousemove\", handleMouseMove);\n            const cleanup = ()=>{\n                win.removeEventListener(\"mousemove\", handleMouseMove);\n                cleanupListenerRef.current = null;\n            };\n            cleanupListenerRef.current = cleanup;\n            return cleanup;\n        }\n        refs.setPositionReference(domReference);\n    }, [\n        openCheck,\n        enabled,\n        x,\n        y,\n        floating,\n        dataRef,\n        refs,\n        domReference,\n        setReference\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        return addListener();\n    }, [\n        addListener,\n        reactive\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        if (enabled && !floating) {\n            initialRef.current = false;\n        }\n    }, [\n        enabled,\n        floating\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        if (!enabled && open) {\n            initialRef.current = true;\n        }\n    }, [\n        enabled,\n        open\n    ]);\n    index(()=>{\n        if (enabled && (x != null || y != null)) {\n            initialRef.current = false;\n            setReference(x, y);\n        }\n    }, [\n        enabled,\n        x,\n        y,\n        setReference\n    ]);\n    const reference = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>{\n        function setPointerTypeRef(_ref) {\n            let { pointerType } = _ref;\n            setPointerType(pointerType);\n        }\n        return {\n            onPointerDown: setPointerTypeRef,\n            onPointerEnter: setPointerTypeRef,\n            onMouseMove: handleReferenceEnterOrMove,\n            onMouseEnter: handleReferenceEnterOrMove\n        };\n    }, [\n        handleReferenceEnterOrMove\n    ]);\n    return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>enabled ? {\n            reference\n        } : {}, [\n        enabled,\n        reference\n    ]);\n}\n_s24(useClientPoint, \"ZEwyVsaFoWSUaOaJ+eaQAHqMbCE=\", false, function() {\n    return [\n        useEffectEvent,\n        useEffectEvent\n    ];\n});\nconst bubbleHandlerKeys = {\n    pointerdown: \"onPointerDown\",\n    mousedown: \"onMouseDown\",\n    click: \"onClick\"\n};\nconst captureHandlerKeys = {\n    pointerdown: \"onPointerDownCapture\",\n    mousedown: \"onMouseDownCapture\",\n    click: \"onClickCapture\"\n};\nconst normalizeProp = (normalizable)=>{\n    var _normalizable$escapeK, _normalizable$outside;\n    return {\n        escapeKey: typeof normalizable === \"boolean\" ? normalizable : (_normalizable$escapeK = normalizable == null ? void 0 : normalizable.escapeKey) != null ? _normalizable$escapeK : false,\n        outsidePress: typeof normalizable === \"boolean\" ? normalizable : (_normalizable$outside = normalizable == null ? void 0 : normalizable.outsidePress) != null ? _normalizable$outside : true\n    };\n};\n/**\n * Closes the floating element when a dismissal is requested  by default, when\n * the user presses the `escape` key or outside of the floating element.\n * @see https://floating-ui.com/docs/useDismiss\n */ function useDismiss(context, props) {\n    _s25();\n    if (props === void 0) {\n        props = {};\n    }\n    const { open, onOpenChange, elements, dataRef } = context;\n    const { enabled = true, escapeKey = true, outsidePress: unstable_outsidePress = true, outsidePressEvent = \"pointerdown\", referencePress = false, referencePressEvent = \"pointerdown\", ancestorScroll = false, bubbles, capture } = props;\n    const tree = useFloatingTree();\n    const outsidePressFn = useEffectEvent(typeof unstable_outsidePress === \"function\" ? unstable_outsidePress : ()=>false);\n    const outsidePress = typeof unstable_outsidePress === \"function\" ? outsidePressFn : unstable_outsidePress;\n    const insideReactTreeRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\n    const endedOrStartedInsideRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\n    const { escapeKey: escapeKeyBubbles, outsidePress: outsidePressBubbles } = normalizeProp(bubbles);\n    const { escapeKey: escapeKeyCapture, outsidePress: outsidePressCapture } = normalizeProp(capture);\n    const isComposingRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\n    const closeOnEscapeKeyDown = useEffectEvent((event)=>{\n        var _dataRef$current$floa;\n        if (!open || !enabled || !escapeKey || event.key !== \"Escape\") {\n            return;\n        }\n        // Wait until IME is settled. Pressing `Escape` while composing should\n        // close the compose menu, but not the floating element.\n        if (isComposingRef.current) {\n            return;\n        }\n        const nodeId = (_dataRef$current$floa = dataRef.current.floatingContext) == null ? void 0 : _dataRef$current$floa.nodeId;\n        const children = tree ? getChildren(tree.nodesRef.current, nodeId) : [];\n        if (!escapeKeyBubbles) {\n            event.stopPropagation();\n            if (children.length > 0) {\n                let shouldDismiss = true;\n                children.forEach((child)=>{\n                    var _child$context;\n                    if ((_child$context = child.context) != null && _child$context.open && !child.context.dataRef.current.__escapeKeyBubbles) {\n                        shouldDismiss = false;\n                        return;\n                    }\n                });\n                if (!shouldDismiss) {\n                    return;\n                }\n            }\n        }\n        onOpenChange(false, (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.isReactEvent)(event) ? event.nativeEvent : event, \"escape-key\");\n    });\n    const closeOnEscapeKeyDownCapture = useEffectEvent((event)=>{\n        var _getTarget2;\n        const callback = ()=>{\n            var _getTarget;\n            closeOnEscapeKeyDown(event);\n            (_getTarget = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.getTarget)(event)) == null || _getTarget.removeEventListener(\"keydown\", callback);\n        };\n        (_getTarget2 = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.getTarget)(event)) == null || _getTarget2.addEventListener(\"keydown\", callback);\n    });\n    const closeOnPressOutside = useEffectEvent((event)=>{\n        var _dataRef$current$floa2;\n        // Given developers can stop the propagation of the synthetic event,\n        // we can only be confident with a positive value.\n        const insideReactTree = insideReactTreeRef.current;\n        insideReactTreeRef.current = false;\n        // When click outside is lazy (`click` event), handle dragging.\n        // Don't close if:\n        // - The click started inside the floating element.\n        // - The click ended inside the floating element.\n        const endedOrStartedInside = endedOrStartedInsideRef.current;\n        endedOrStartedInsideRef.current = false;\n        if (outsidePressEvent === \"click\" && endedOrStartedInside) {\n            return;\n        }\n        if (insideReactTree) {\n            return;\n        }\n        if (typeof outsidePress === \"function\" && !outsidePress(event)) {\n            return;\n        }\n        const target = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.getTarget)(event);\n        const inertSelector = \"[\" + createAttribute(\"inert\") + \"]\";\n        const markers = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.getDocument)(elements.floating).querySelectorAll(inertSelector);\n        let targetRootAncestor = (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.isElement)(target) ? target : null;\n        while(targetRootAncestor && !(0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.isLastTraversableNode)(targetRootAncestor)){\n            const nextParent = (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.getParentNode)(targetRootAncestor);\n            if ((0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.isLastTraversableNode)(nextParent) || !(0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.isElement)(nextParent)) {\n                break;\n            }\n            targetRootAncestor = nextParent;\n        }\n        // Check if the click occurred on a third-party element injected after the\n        // floating element rendered.\n        if (markers.length && (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.isElement)(target) && !(0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.isRootElement)(target) && // Clicked on a direct ancestor (e.g. FloatingOverlay).\n        !(0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.contains)(target, elements.floating) && // If the target root element contains none of the markers, then the\n        // element was injected after the floating element rendered.\n        Array.from(markers).every((marker)=>!(0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.contains)(targetRootAncestor, marker))) {\n            return;\n        }\n        // Check if the click occurred on the scrollbar\n        if ((0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.isHTMLElement)(target) && floating) {\n            // In Firefox, `target.scrollWidth > target.clientWidth` for inline\n            // elements.\n            const canScrollX = target.clientWidth > 0 && target.scrollWidth > target.clientWidth;\n            const canScrollY = target.clientHeight > 0 && target.scrollHeight > target.clientHeight;\n            let xCond = canScrollY && event.offsetX > target.clientWidth;\n            // In some browsers it is possible to change the <body> (or window)\n            // scrollbar to the left side, but is very rare and is difficult to\n            // check for. Plus, for modal dialogs with backdrops, it is more\n            // important that the backdrop is checked but not so much the window.\n            if (canScrollY) {\n                const isRTL = (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.getComputedStyle)(target).direction === \"rtl\";\n                if (isRTL) {\n                    xCond = event.offsetX <= target.offsetWidth - target.clientWidth;\n                }\n            }\n            if (xCond || canScrollX && event.offsetY > target.clientHeight) {\n                return;\n            }\n        }\n        const nodeId = (_dataRef$current$floa2 = dataRef.current.floatingContext) == null ? void 0 : _dataRef$current$floa2.nodeId;\n        const targetIsInsideChildren = tree && getChildren(tree.nodesRef.current, nodeId).some((node)=>{\n            var _node$context;\n            return (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.isEventTargetWithin)(event, (_node$context = node.context) == null ? void 0 : _node$context.elements.floating);\n        });\n        if ((0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.isEventTargetWithin)(event, elements.floating) || (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.isEventTargetWithin)(event, elements.domReference) || targetIsInsideChildren) {\n            return;\n        }\n        const children = tree ? getChildren(tree.nodesRef.current, nodeId) : [];\n        if (children.length > 0) {\n            let shouldDismiss = true;\n            children.forEach((child)=>{\n                var _child$context2;\n                if ((_child$context2 = child.context) != null && _child$context2.open && !child.context.dataRef.current.__outsidePressBubbles) {\n                    shouldDismiss = false;\n                    return;\n                }\n            });\n            if (!shouldDismiss) {\n                return;\n            }\n        }\n        onOpenChange(false, event, \"outside-press\");\n    });\n    const closeOnPressOutsideCapture = useEffectEvent((event)=>{\n        var _getTarget4;\n        const callback = ()=>{\n            var _getTarget3;\n            closeOnPressOutside(event);\n            (_getTarget3 = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.getTarget)(event)) == null || _getTarget3.removeEventListener(outsidePressEvent, callback);\n        };\n        (_getTarget4 = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.getTarget)(event)) == null || _getTarget4.addEventListener(outsidePressEvent, callback);\n    });\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        if (!open || !enabled) {\n            return;\n        }\n        dataRef.current.__escapeKeyBubbles = escapeKeyBubbles;\n        dataRef.current.__outsidePressBubbles = outsidePressBubbles;\n        let compositionTimeout = -1;\n        function onScroll(event) {\n            onOpenChange(false, event, \"ancestor-scroll\");\n        }\n        function handleCompositionStart() {\n            window.clearTimeout(compositionTimeout);\n            isComposingRef.current = true;\n        }\n        function handleCompositionEnd() {\n            // Safari fires `compositionend` before `keydown`, so we need to wait\n            // until the next tick to set `isComposing` to `false`.\n            // https://bugs.webkit.org/show_bug.cgi?id=165004\n            compositionTimeout = window.setTimeout(()=>{\n                isComposingRef.current = false;\n            }, // 0ms or 1ms don't work in Safari. 5ms appears to consistently work.\n            // Only apply to WebKit for the test to remain 0ms.\n            (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.isWebKit)() ? 5 : 0);\n        }\n        const doc = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.getDocument)(elements.floating);\n        if (escapeKey) {\n            doc.addEventListener(\"keydown\", escapeKeyCapture ? closeOnEscapeKeyDownCapture : closeOnEscapeKeyDown, escapeKeyCapture);\n            doc.addEventListener(\"compositionstart\", handleCompositionStart);\n            doc.addEventListener(\"compositionend\", handleCompositionEnd);\n        }\n        outsidePress && doc.addEventListener(outsidePressEvent, outsidePressCapture ? closeOnPressOutsideCapture : closeOnPressOutside, outsidePressCapture);\n        let ancestors = [];\n        if (ancestorScroll) {\n            if ((0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.isElement)(elements.domReference)) {\n                ancestors = (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.getOverflowAncestors)(elements.domReference);\n            }\n            if ((0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.isElement)(elements.floating)) {\n                ancestors = ancestors.concat((0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.getOverflowAncestors)(elements.floating));\n            }\n            if (!(0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.isElement)(elements.reference) && elements.reference && elements.reference.contextElement) {\n                ancestors = ancestors.concat((0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.getOverflowAncestors)(elements.reference.contextElement));\n            }\n        }\n        // Ignore the visual viewport for scrolling dismissal (allow pinch-zoom)\n        ancestors = ancestors.filter((ancestor)=>{\n            var _doc$defaultView;\n            return ancestor !== ((_doc$defaultView = doc.defaultView) == null ? void 0 : _doc$defaultView.visualViewport);\n        });\n        ancestors.forEach((ancestor)=>{\n            ancestor.addEventListener(\"scroll\", onScroll, {\n                passive: true\n            });\n        });\n        return ()=>{\n            if (escapeKey) {\n                doc.removeEventListener(\"keydown\", escapeKeyCapture ? closeOnEscapeKeyDownCapture : closeOnEscapeKeyDown, escapeKeyCapture);\n                doc.removeEventListener(\"compositionstart\", handleCompositionStart);\n                doc.removeEventListener(\"compositionend\", handleCompositionEnd);\n            }\n            outsidePress && doc.removeEventListener(outsidePressEvent, outsidePressCapture ? closeOnPressOutsideCapture : closeOnPressOutside, outsidePressCapture);\n            ancestors.forEach((ancestor)=>{\n                ancestor.removeEventListener(\"scroll\", onScroll);\n            });\n            window.clearTimeout(compositionTimeout);\n        };\n    }, [\n        dataRef,\n        elements,\n        escapeKey,\n        outsidePress,\n        outsidePressEvent,\n        open,\n        onOpenChange,\n        ancestorScroll,\n        enabled,\n        escapeKeyBubbles,\n        outsidePressBubbles,\n        closeOnEscapeKeyDown,\n        escapeKeyCapture,\n        closeOnEscapeKeyDownCapture,\n        closeOnPressOutside,\n        outsidePressCapture,\n        closeOnPressOutsideCapture\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        insideReactTreeRef.current = false;\n    }, [\n        outsidePress,\n        outsidePressEvent\n    ]);\n    const reference = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>({\n            onKeyDown: closeOnEscapeKeyDown,\n            [bubbleHandlerKeys[referencePressEvent]]: (event)=>{\n                if (referencePress) {\n                    onOpenChange(false, event.nativeEvent, \"reference-press\");\n                }\n            }\n        }), [\n        closeOnEscapeKeyDown,\n        onOpenChange,\n        referencePress,\n        referencePressEvent\n    ]);\n    const floating = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>({\n            onKeyDown: closeOnEscapeKeyDown,\n            onMouseDown () {\n                endedOrStartedInsideRef.current = true;\n            },\n            onMouseUp () {\n                endedOrStartedInsideRef.current = true;\n            },\n            [captureHandlerKeys[outsidePressEvent]]: ()=>{\n                insideReactTreeRef.current = true;\n            }\n        }), [\n        closeOnEscapeKeyDown,\n        outsidePressEvent\n    ]);\n    return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>enabled ? {\n            reference,\n            floating\n        } : {}, [\n        enabled,\n        reference,\n        floating\n    ]);\n}\n_s25(useDismiss, \"Ow9Zh3EiuyYOpVgm20j7EyTwb98=\", false, function() {\n    return [\n        useFloatingTree,\n        useEffectEvent,\n        useEffectEvent,\n        useEffectEvent,\n        useEffectEvent,\n        useEffectEvent\n    ];\n});\nfunction useFloatingRootContext(options) {\n    _s26();\n    const { open = false, onOpenChange: onOpenChangeProp, elements: elementsProp } = options;\n    const floatingId = useId();\n    const dataRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef({});\n    const [events] = react__WEBPACK_IMPORTED_MODULE_0__.useState(()=>createPubSub());\n    const nested = useFloatingParentNodeId() != null;\n    if (true) {\n        const optionDomReference = elementsProp.reference;\n        if (optionDomReference && !(0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.isElement)(optionDomReference)) {\n            error(\"Cannot pass a virtual element to the `elements.reference` option,\", \"as it must be a real DOM element. Use `refs.setPositionReference()`\", \"instead.\");\n        }\n    }\n    const [positionReference, setPositionReference] = react__WEBPACK_IMPORTED_MODULE_0__.useState(elementsProp.reference);\n    const onOpenChange = useEffectEvent((open, event, reason)=>{\n        dataRef.current.openEvent = open ? event : undefined;\n        events.emit(\"openchange\", {\n            open,\n            event,\n            reason,\n            nested\n        });\n        onOpenChangeProp == null || onOpenChangeProp(open, event, reason);\n    });\n    const refs = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>({\n            setPositionReference\n        }), []);\n    const elements = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>({\n            reference: positionReference || elementsProp.reference || null,\n            floating: elementsProp.floating || null,\n            domReference: elementsProp.reference\n        }), [\n        positionReference,\n        elementsProp.reference,\n        elementsProp.floating\n    ]);\n    return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>({\n            dataRef,\n            open,\n            onOpenChange,\n            elements,\n            events,\n            floatingId,\n            refs\n        }), [\n        open,\n        onOpenChange,\n        elements,\n        events,\n        floatingId,\n        refs\n    ]);\n}\n_s26(useFloatingRootContext, \"gbE5GtBks7eAzDBsvlifZZb8s2g=\", false, function() {\n    return [\n        useId,\n        useFloatingParentNodeId,\n        useEffectEvent\n    ];\n});\n/**\n * Provides data to position a floating element and context to add interactions.\n * @see https://floating-ui.com/docs/useFloating\n */ function useFloating(options) {\n    _s27();\n    if (options === void 0) {\n        options = {};\n    }\n    const { nodeId } = options;\n    const internalRootContext = useFloatingRootContext({\n        ...options,\n        elements: {\n            reference: null,\n            floating: null,\n            ...options.elements\n        }\n    });\n    const rootContext = options.rootContext || internalRootContext;\n    const computedElements = rootContext.elements;\n    const [_domReference, setDomReference] = react__WEBPACK_IMPORTED_MODULE_0__.useState(null);\n    const [positionReference, _setPositionReference] = react__WEBPACK_IMPORTED_MODULE_0__.useState(null);\n    const optionDomReference = computedElements == null ? void 0 : computedElements.domReference;\n    const domReference = optionDomReference || _domReference;\n    const domReferenceRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n    const tree = useFloatingTree();\n    index(()=>{\n        if (domReference) {\n            domReferenceRef.current = domReference;\n        }\n    }, [\n        domReference\n    ]);\n    const position = (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_2__.useFloating)({\n        ...options,\n        elements: {\n            ...computedElements,\n            ...positionReference && {\n                reference: positionReference\n            }\n        }\n    });\n    const setPositionReference = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((node)=>{\n        const computedPositionReference = (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.isElement)(node) ? {\n            getBoundingClientRect: ()=>node.getBoundingClientRect(),\n            contextElement: node\n        } : node;\n        // Store the positionReference in state if the DOM reference is specified externally via the\n        // `elements.reference` option. This ensures that it won't be overridden on future renders.\n        _setPositionReference(computedPositionReference);\n        position.refs.setReference(computedPositionReference);\n    }, [\n        position.refs\n    ]);\n    const setReference = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((node)=>{\n        if ((0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.isElement)(node) || node === null) {\n            domReferenceRef.current = node;\n            setDomReference(node);\n        }\n        // Backwards-compatibility for passing a virtual element to `reference`\n        // after it has set the DOM reference.\n        if ((0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.isElement)(position.refs.reference.current) || position.refs.reference.current === null || // Don't allow setting virtual elements using the old technique back to\n        // `null` to support `positionReference` + an unstable `reference`\n        // callback ref.\n        node !== null && !(0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.isElement)(node)) {\n            position.refs.setReference(node);\n        }\n    }, [\n        position.refs\n    ]);\n    const refs = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>({\n            ...position.refs,\n            setReference,\n            setPositionReference,\n            domReference: domReferenceRef\n        }), [\n        position.refs,\n        setReference,\n        setPositionReference\n    ]);\n    const elements = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>({\n            ...position.elements,\n            domReference: domReference\n        }), [\n        position.elements,\n        domReference\n    ]);\n    const context = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>({\n            ...position,\n            ...rootContext,\n            refs,\n            elements,\n            nodeId\n        }), [\n        position,\n        refs,\n        elements,\n        nodeId,\n        rootContext\n    ]);\n    index(()=>{\n        rootContext.dataRef.current.floatingContext = context;\n        const node = tree == null ? void 0 : tree.nodesRef.current.find((node)=>node.id === nodeId);\n        if (node) {\n            node.context = context;\n        }\n    });\n    return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>({\n            ...position,\n            context,\n            refs,\n            elements\n        }), [\n        position,\n        refs,\n        elements,\n        context\n    ]);\n}\n_s27(useFloating, \"b7wHqaVzT0zoUHzWGlWUsqhBLX4=\", false, function() {\n    return [\n        useFloatingRootContext,\n        useFloatingTree,\n        _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_2__.useFloating\n    ];\n});\n/**\n * Opens the floating element while the reference element has focus, like CSS\n * `:focus`.\n * @see https://floating-ui.com/docs/useFocus\n */ function useFocus(context, props) {\n    _s28();\n    if (props === void 0) {\n        props = {};\n    }\n    const { open, onOpenChange, events, dataRef, elements } = context;\n    const { enabled = true, visibleOnly = true } = props;\n    const blockFocusRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\n    const timeoutRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef();\n    const keyboardModalityRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(true);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        if (!enabled) return;\n        const win = (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.getWindow)(elements.domReference);\n        // If the reference was focused and the user left the tab/window, and the\n        // floating element was not open, the focus should be blocked when they\n        // return to the tab/window.\n        function onBlur() {\n            if (!open && (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.isHTMLElement)(elements.domReference) && elements.domReference === (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.activeElement)((0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.getDocument)(elements.domReference))) {\n                blockFocusRef.current = true;\n            }\n        }\n        function onKeyDown() {\n            keyboardModalityRef.current = true;\n        }\n        win.addEventListener(\"blur\", onBlur);\n        win.addEventListener(\"keydown\", onKeyDown, true);\n        return ()=>{\n            win.removeEventListener(\"blur\", onBlur);\n            win.removeEventListener(\"keydown\", onKeyDown, true);\n        };\n    }, [\n        elements.domReference,\n        open,\n        enabled\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        if (!enabled) return;\n        function onOpenChange(_ref) {\n            let { reason } = _ref;\n            if (reason === \"reference-press\" || reason === \"escape-key\") {\n                blockFocusRef.current = true;\n            }\n        }\n        events.on(\"openchange\", onOpenChange);\n        return ()=>{\n            events.off(\"openchange\", onOpenChange);\n        };\n    }, [\n        events,\n        enabled\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        return ()=>{\n            clearTimeout(timeoutRef.current);\n        };\n    }, []);\n    const reference = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>({\n            onPointerDown (event) {\n                if ((0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.isVirtualPointerEvent)(event.nativeEvent)) return;\n                keyboardModalityRef.current = false;\n            },\n            onMouseLeave () {\n                blockFocusRef.current = false;\n            },\n            onFocus (event) {\n                if (blockFocusRef.current) return;\n                const target = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.getTarget)(event.nativeEvent);\n                if (visibleOnly && (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.isElement)(target)) {\n                    try {\n                        // Mac Safari unreliably matches `:focus-visible` on the reference\n                        // if focus was outside the page initially - use the fallback\n                        // instead.\n                        if ((0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.isSafari)() && (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.isMac)()) throw Error();\n                        if (!target.matches(\":focus-visible\")) return;\n                    } catch (e) {\n                        // Old browsers will throw an error when using `:focus-visible`.\n                        if (!keyboardModalityRef.current && !(0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.isTypeableElement)(target)) {\n                            return;\n                        }\n                    }\n                }\n                onOpenChange(true, event.nativeEvent, \"focus\");\n            },\n            onBlur (event) {\n                blockFocusRef.current = false;\n                const relatedTarget = event.relatedTarget;\n                const nativeEvent = event.nativeEvent;\n                // Hit the non-modal focus management portal guard. Focus will be\n                // moved into the floating element immediately after.\n                const movedToFocusGuard = (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.isElement)(relatedTarget) && relatedTarget.hasAttribute(createAttribute(\"focus-guard\")) && relatedTarget.getAttribute(\"data-type\") === \"outside\";\n                // Wait for the window blur listener to fire.\n                timeoutRef.current = window.setTimeout(()=>{\n                    var _dataRef$current$floa;\n                    const activeEl = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.activeElement)(elements.domReference ? elements.domReference.ownerDocument : document);\n                    // Focus left the page, keep it open.\n                    if (!relatedTarget && activeEl === elements.domReference) return;\n                    // When focusing the reference element (e.g. regular click), then\n                    // clicking into the floating element, prevent it from hiding.\n                    // Note: it must be focusable, e.g. `tabindex=\"-1\"`.\n                    // We can not rely on relatedTarget to point to the correct element\n                    // as it will only point to the shadow host of the newly focused element\n                    // and not the element that actually has received focus if it is located\n                    // inside a shadow root.\n                    if ((0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.contains)((_dataRef$current$floa = dataRef.current.floatingContext) == null ? void 0 : _dataRef$current$floa.refs.floating.current, activeEl) || (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.contains)(elements.domReference, activeEl) || movedToFocusGuard) {\n                        return;\n                    }\n                    onOpenChange(false, nativeEvent, \"focus\");\n                });\n            }\n        }), [\n        dataRef,\n        elements.domReference,\n        onOpenChange,\n        visibleOnly\n    ]);\n    return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>enabled ? {\n            reference\n        } : {}, [\n        enabled,\n        reference\n    ]);\n}\n_s28(useFocus, \"Mw4fGk2zvsi51kjL8BBs9KqPNLc=\");\nconst ACTIVE_KEY = \"active\";\nconst SELECTED_KEY = \"selected\";\nfunction mergeProps(userProps, propsList, elementKey) {\n    const map = new Map();\n    const isItem = elementKey === \"item\";\n    let domUserProps = userProps;\n    if (isItem && userProps) {\n        const { [ACTIVE_KEY]: _, [SELECTED_KEY]: __, ...validProps } = userProps;\n        domUserProps = validProps;\n    }\n    return {\n        ...elementKey === \"floating\" && {\n            tabIndex: -1,\n            [FOCUSABLE_ATTRIBUTE]: \"\"\n        },\n        ...domUserProps,\n        ...propsList.map((value)=>{\n            const propsOrGetProps = value ? value[elementKey] : null;\n            if (typeof propsOrGetProps === \"function\") {\n                return userProps ? propsOrGetProps(userProps) : null;\n            }\n            return propsOrGetProps;\n        }).concat(userProps).reduce((acc, props)=>{\n            if (!props) {\n                return acc;\n            }\n            Object.entries(props).forEach((_ref)=>{\n                let [key, value] = _ref;\n                if (isItem && [\n                    ACTIVE_KEY,\n                    SELECTED_KEY\n                ].includes(key)) {\n                    return;\n                }\n                if (key.indexOf(\"on\") === 0) {\n                    if (!map.has(key)) {\n                        map.set(key, []);\n                    }\n                    if (typeof value === \"function\") {\n                        var _map$get;\n                        (_map$get = map.get(key)) == null || _map$get.push(value);\n                        acc[key] = function() {\n                            var _map$get2;\n                            for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n                                args[_key] = arguments[_key];\n                            }\n                            return (_map$get2 = map.get(key)) == null ? void 0 : _map$get2.map((fn)=>fn(...args)).find((val)=>val !== undefined);\n                        };\n                    }\n                } else {\n                    acc[key] = value;\n                }\n            });\n            return acc;\n        }, {})\n    };\n}\n/**\n * Merges an array of interaction hooks' props into prop getters, allowing\n * event handler functions to be composed together without overwriting one\n * another.\n * @see https://floating-ui.com/docs/useInteractions\n */ function useInteractions(propsList) {\n    _s29();\n    if (propsList === void 0) {\n        propsList = [];\n    }\n    const referenceDeps = propsList.map((key)=>key == null ? void 0 : key.reference);\n    const floatingDeps = propsList.map((key)=>key == null ? void 0 : key.floating);\n    const itemDeps = propsList.map((key)=>key == null ? void 0 : key.item);\n    const getReferenceProps = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((userProps)=>mergeProps(userProps, propsList, \"reference\"), // eslint-disable-next-line react-hooks/exhaustive-deps\n    referenceDeps);\n    const getFloatingProps = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((userProps)=>mergeProps(userProps, propsList, \"floating\"), // eslint-disable-next-line react-hooks/exhaustive-deps\n    floatingDeps);\n    const getItemProps = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((userProps)=>mergeProps(userProps, propsList, \"item\"), // eslint-disable-next-line react-hooks/exhaustive-deps\n    itemDeps);\n    return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>({\n            getReferenceProps,\n            getFloatingProps,\n            getItemProps\n        }), [\n        getReferenceProps,\n        getFloatingProps,\n        getItemProps\n    ]);\n}\n_s29(useInteractions, \"yYB5r5XQ8hVcAli+Mf2TOjNoGxY=\");\nlet isPreventScrollSupported = false;\nfunction doSwitch(orientation, vertical, horizontal) {\n    switch(orientation){\n        case \"vertical\":\n            return vertical;\n        case \"horizontal\":\n            return horizontal;\n        default:\n            return vertical || horizontal;\n    }\n}\nfunction isMainOrientationKey(key, orientation) {\n    const vertical = key === ARROW_UP || key === ARROW_DOWN;\n    const horizontal = key === ARROW_LEFT || key === ARROW_RIGHT;\n    return doSwitch(orientation, vertical, horizontal);\n}\nfunction isMainOrientationToEndKey(key, orientation, rtl) {\n    const vertical = key === ARROW_DOWN;\n    const horizontal = rtl ? key === ARROW_LEFT : key === ARROW_RIGHT;\n    return doSwitch(orientation, vertical, horizontal) || key === \"Enter\" || key === \" \" || key === \"\";\n}\nfunction isCrossOrientationOpenKey(key, orientation, rtl) {\n    const vertical = rtl ? key === ARROW_LEFT : key === ARROW_RIGHT;\n    const horizontal = key === ARROW_DOWN;\n    return doSwitch(orientation, vertical, horizontal);\n}\nfunction isCrossOrientationCloseKey(key, orientation, rtl) {\n    const vertical = rtl ? key === ARROW_RIGHT : key === ARROW_LEFT;\n    const horizontal = key === ARROW_UP;\n    return doSwitch(orientation, vertical, horizontal);\n}\n/**\n * Adds arrow key-based navigation of a list of items, either using real DOM\n * focus or virtual focus.\n * @see https://floating-ui.com/docs/useListNavigation\n */ function useListNavigation(context, props) {\n    _s30();\n    const { open, onOpenChange, elements } = context;\n    const { listRef, activeIndex, onNavigate: unstable_onNavigate = ()=>{}, enabled = true, selectedIndex = null, allowEscape = false, loop = false, nested = false, rtl = false, virtual = false, focusItemOnOpen = \"auto\", focusItemOnHover = true, openOnArrowKeyDown = true, disabledIndices = undefined, orientation = \"vertical\", cols = 1, scrollItemIntoView = true, virtualItemRef, itemSizes, dense = false } = props;\n    if (true) {\n        if (allowEscape) {\n            if (!loop) {\n                warn(\"`useListNavigation` looping must be enabled to allow escaping.\");\n            }\n            if (!virtual) {\n                warn(\"`useListNavigation` must be virtual to allow escaping.\");\n            }\n        }\n        if (orientation === \"vertical\" && cols > 1) {\n            warn(\"In grid list navigation mode (`cols` > 1), the `orientation` should\", 'be either \"horizontal\" or \"both\".');\n        }\n    }\n    const floatingFocusElement = getFloatingFocusElement(elements.floating);\n    const floatingFocusElementRef = useLatestRef(floatingFocusElement);\n    const parentId = useFloatingParentNodeId();\n    const tree = useFloatingTree();\n    const onNavigate = useEffectEvent(unstable_onNavigate);\n    const typeableComboboxReference = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.isTypeableCombobox)(elements.domReference);\n    const focusItemOnOpenRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(focusItemOnOpen);\n    const indexRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(selectedIndex != null ? selectedIndex : -1);\n    const keyRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n    const isPointerModalityRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(true);\n    const previousOnNavigateRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(onNavigate);\n    const previousMountedRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(!!elements.floating);\n    const previousOpenRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(open);\n    const forceSyncFocus = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\n    const forceScrollIntoViewRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\n    const disabledIndicesRef = useLatestRef(disabledIndices);\n    const latestOpenRef = useLatestRef(open);\n    const scrollItemIntoViewRef = useLatestRef(scrollItemIntoView);\n    const selectedIndexRef = useLatestRef(selectedIndex);\n    const [activeId, setActiveId] = react__WEBPACK_IMPORTED_MODULE_0__.useState();\n    const [virtualId, setVirtualId] = react__WEBPACK_IMPORTED_MODULE_0__.useState();\n    const focusItem = useEffectEvent(function(listRef, indexRef, forceScrollIntoView) {\n        if (forceScrollIntoView === void 0) {\n            forceScrollIntoView = false;\n        }\n        function runFocus(item) {\n            if (virtual) {\n                setActiveId(item.id);\n                tree == null || tree.events.emit(\"virtualfocus\", item);\n                if (virtualItemRef) {\n                    virtualItemRef.current = item;\n                }\n            } else {\n                enqueueFocus(item, {\n                    preventScroll: true,\n                    // Mac Safari does not move the virtual cursor unless the focus call\n                    // is sync. However, for the very first focus call, we need to wait\n                    // for the position to be ready in order to prevent unwanted\n                    // scrolling. This means the virtual cursor will not move to the first\n                    // item when first opening the floating element, but will on\n                    // subsequent calls. `preventScroll` is supported in modern Safari,\n                    // so we can use that instead.\n                    // iOS Safari must be async or the first item will not be focused.\n                    sync: (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.isMac)() && (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.isSafari)() ? isPreventScrollSupported || forceSyncFocus.current : false\n                });\n            }\n        }\n        const initialItem = listRef.current[indexRef.current];\n        if (initialItem) {\n            runFocus(initialItem);\n        }\n        requestAnimationFrame(()=>{\n            const waitedItem = listRef.current[indexRef.current] || initialItem;\n            if (!waitedItem) return;\n            if (!initialItem) {\n                runFocus(waitedItem);\n            }\n            const scrollIntoViewOptions = scrollItemIntoViewRef.current;\n            const shouldScrollIntoView = scrollIntoViewOptions && item && (forceScrollIntoView || !isPointerModalityRef.current);\n            if (shouldScrollIntoView) {\n                // JSDOM doesn't support `.scrollIntoView()` but it's widely supported\n                // by all browsers.\n                waitedItem.scrollIntoView == null || waitedItem.scrollIntoView(typeof scrollIntoViewOptions === \"boolean\" ? {\n                    block: \"nearest\",\n                    inline: \"nearest\"\n                } : scrollIntoViewOptions);\n            }\n        });\n    });\n    index(()=>{\n        document.createElement(\"div\").focus({\n            get preventScroll () {\n                isPreventScrollSupported = true;\n                return false;\n            }\n        });\n    }, []);\n    // Sync `selectedIndex` to be the `activeIndex` upon opening the floating\n    // element. Also, reset `activeIndex` upon closing the floating element.\n    index(()=>{\n        if (!enabled) return;\n        if (open && elements.floating) {\n            if (focusItemOnOpenRef.current && selectedIndex != null) {\n                // Regardless of the pointer modality, we want to ensure the selected\n                // item comes into view when the floating element is opened.\n                forceScrollIntoViewRef.current = true;\n                indexRef.current = selectedIndex;\n                onNavigate(selectedIndex);\n            }\n        } else if (previousMountedRef.current) {\n            // Since the user can specify `onNavigate` conditionally\n            // (onNavigate: open ? setActiveIndex : setSelectedIndex),\n            // we store and call the previous function.\n            indexRef.current = -1;\n            previousOnNavigateRef.current(null);\n        }\n    }, [\n        enabled,\n        open,\n        elements.floating,\n        selectedIndex,\n        onNavigate\n    ]);\n    // Sync `activeIndex` to be the focused item while the floating element is\n    // open.\n    index(()=>{\n        if (!enabled) return;\n        if (open && elements.floating) {\n            if (activeIndex == null) {\n                forceSyncFocus.current = false;\n                if (selectedIndexRef.current != null) {\n                    return;\n                }\n                // Reset while the floating element was open (e.g. the list changed).\n                if (previousMountedRef.current) {\n                    indexRef.current = -1;\n                    focusItem(listRef, indexRef);\n                }\n                // Initial sync.\n                if ((!previousOpenRef.current || !previousMountedRef.current) && focusItemOnOpenRef.current && (keyRef.current != null || focusItemOnOpenRef.current === true && keyRef.current == null)) {\n                    let runs = 0;\n                    const waitForListPopulated = ()=>{\n                        if (listRef.current[0] == null) {\n                            // Avoid letting the browser paint if possible on the first try,\n                            // otherwise use rAF. Don't try more than twice, since something\n                            // is wrong otherwise.\n                            if (runs < 2) {\n                                const scheduler = runs ? requestAnimationFrame : queueMicrotask;\n                                scheduler(waitForListPopulated);\n                            }\n                            runs++;\n                        } else {\n                            indexRef.current = keyRef.current == null || isMainOrientationToEndKey(keyRef.current, orientation, rtl) || nested ? getMinIndex(listRef, disabledIndicesRef.current) : getMaxIndex(listRef, disabledIndicesRef.current);\n                            keyRef.current = null;\n                            onNavigate(indexRef.current);\n                        }\n                    };\n                    waitForListPopulated();\n                }\n            } else if (!isIndexOutOfBounds(listRef, activeIndex)) {\n                indexRef.current = activeIndex;\n                focusItem(listRef, indexRef, forceScrollIntoViewRef.current);\n                forceScrollIntoViewRef.current = false;\n            }\n        }\n    }, [\n        enabled,\n        open,\n        elements.floating,\n        activeIndex,\n        selectedIndexRef,\n        nested,\n        listRef,\n        orientation,\n        rtl,\n        onNavigate,\n        focusItem,\n        disabledIndicesRef\n    ]);\n    // Ensure the parent floating element has focus when a nested child closes\n    // to allow arrow key navigation to work after the pointer leaves the child.\n    index(()=>{\n        var _nodes$find;\n        if (!enabled || elements.floating || !tree || virtual || !previousMountedRef.current) {\n            return;\n        }\n        const nodes = tree.nodesRef.current;\n        const parent = (_nodes$find = nodes.find((node)=>node.id === parentId)) == null || (_nodes$find = _nodes$find.context) == null ? void 0 : _nodes$find.elements.floating;\n        const activeEl = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.activeElement)((0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.getDocument)(elements.floating));\n        const treeContainsActiveEl = nodes.some((node)=>node.context && (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.contains)(node.context.elements.floating, activeEl));\n        if (parent && !treeContainsActiveEl && isPointerModalityRef.current) {\n            parent.focus({\n                preventScroll: true\n            });\n        }\n    }, [\n        enabled,\n        elements.floating,\n        tree,\n        parentId,\n        virtual\n    ]);\n    index(()=>{\n        if (!enabled) return;\n        if (!tree) return;\n        if (!virtual) return;\n        if (parentId) return;\n        function handleVirtualFocus(item) {\n            setVirtualId(item.id);\n            if (virtualItemRef) {\n                virtualItemRef.current = item;\n            }\n        }\n        tree.events.on(\"virtualfocus\", handleVirtualFocus);\n        return ()=>{\n            tree.events.off(\"virtualfocus\", handleVirtualFocus);\n        };\n    }, [\n        enabled,\n        tree,\n        virtual,\n        parentId,\n        virtualItemRef\n    ]);\n    index(()=>{\n        previousOnNavigateRef.current = onNavigate;\n        previousMountedRef.current = !!elements.floating;\n    });\n    index(()=>{\n        if (!open) {\n            keyRef.current = null;\n        }\n    }, [\n        open\n    ]);\n    index(()=>{\n        previousOpenRef.current = open;\n    }, [\n        open\n    ]);\n    const hasActiveIndex = activeIndex != null;\n    const item = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>{\n        function syncCurrentTarget(currentTarget) {\n            if (!open) return;\n            const index = listRef.current.indexOf(currentTarget);\n            if (index !== -1) {\n                onNavigate(index);\n            }\n        }\n        const props = {\n            onFocus (_ref) {\n                let { currentTarget } = _ref;\n                syncCurrentTarget(currentTarget);\n            },\n            onClick: (_ref2)=>{\n                let { currentTarget } = _ref2;\n                return currentTarget.focus({\n                    preventScroll: true\n                });\n            },\n            // Safari\n            ...focusItemOnHover && {\n                onMouseMove (_ref3) {\n                    let { currentTarget } = _ref3;\n                    syncCurrentTarget(currentTarget);\n                },\n                onPointerLeave (_ref4) {\n                    let { pointerType } = _ref4;\n                    if (!isPointerModalityRef.current || pointerType === \"touch\") {\n                        return;\n                    }\n                    indexRef.current = -1;\n                    focusItem(listRef, indexRef);\n                    onNavigate(null);\n                    if (!virtual) {\n                        enqueueFocus(floatingFocusElementRef.current, {\n                            preventScroll: true\n                        });\n                    }\n                }\n            }\n        };\n        return props;\n    }, [\n        open,\n        floatingFocusElementRef,\n        focusItem,\n        focusItemOnHover,\n        listRef,\n        onNavigate,\n        virtual\n    ]);\n    const commonOnKeyDown = useEffectEvent((event)=>{\n        isPointerModalityRef.current = false;\n        forceSyncFocus.current = true;\n        // When composing a character, Chrome fires ArrowDown twice. Firefox/Safari\n        // don't appear to suffer from this. `event.isComposing` is avoided due to\n        // Safari not supporting it properly (although it's not needed in the first\n        // place for Safari, just avoiding any possible issues).\n        if (event.which === 229) {\n            return;\n        }\n        // If the floating element is animating out, ignore navigation. Otherwise,\n        // the `activeIndex` gets set to 0 despite not being open so the next time\n        // the user ArrowDowns, the first item won't be focused.\n        if (!latestOpenRef.current && event.currentTarget === floatingFocusElementRef.current) {\n            return;\n        }\n        if (nested && isCrossOrientationCloseKey(event.key, orientation, rtl)) {\n            (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.stopEvent)(event);\n            onOpenChange(false, event.nativeEvent, \"list-navigation\");\n            if ((0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.isHTMLElement)(elements.domReference)) {\n                if (virtual) {\n                    tree == null || tree.events.emit(\"virtualfocus\", elements.domReference);\n                } else {\n                    elements.domReference.focus();\n                }\n            }\n            return;\n        }\n        const currentIndex = indexRef.current;\n        const minIndex = getMinIndex(listRef, disabledIndices);\n        const maxIndex = getMaxIndex(listRef, disabledIndices);\n        if (!typeableComboboxReference) {\n            if (event.key === \"Home\") {\n                (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.stopEvent)(event);\n                indexRef.current = minIndex;\n                onNavigate(indexRef.current);\n            }\n            if (event.key === \"End\") {\n                (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.stopEvent)(event);\n                indexRef.current = maxIndex;\n                onNavigate(indexRef.current);\n            }\n        }\n        // Grid navigation.\n        if (cols > 1) {\n            const sizes = itemSizes || Array.from({\n                length: listRef.current.length\n            }, ()=>({\n                    width: 1,\n                    height: 1\n                }));\n            // To calculate movements on the grid, we use hypothetical cell indices\n            // as if every item was 1x1, then convert back to real indices.\n            const cellMap = buildCellMap(sizes, cols, dense);\n            const minGridIndex = cellMap.findIndex((index)=>index != null && !isDisabled(listRef.current, index, disabledIndices));\n            // last enabled index\n            const maxGridIndex = cellMap.reduce((foundIndex, index, cellIndex)=>index != null && !isDisabled(listRef.current, index, disabledIndices) ? cellIndex : foundIndex, -1);\n            const index = cellMap[getGridNavigatedIndex({\n                current: cellMap.map((itemIndex)=>itemIndex != null ? listRef.current[itemIndex] : null)\n            }, {\n                event,\n                orientation,\n                loop,\n                rtl,\n                cols,\n                // treat undefined (empty grid spaces) as disabled indices so we\n                // don't end up in them\n                disabledIndices: getCellIndices([\n                    ...disabledIndices || listRef.current.map((_, index)=>isDisabled(listRef.current, index) ? index : undefined),\n                    undefined\n                ], cellMap),\n                minIndex: minGridIndex,\n                maxIndex: maxGridIndex,\n                prevIndex: getCellIndexOfCorner(indexRef.current > maxIndex ? minIndex : indexRef.current, sizes, cellMap, cols, // use a corner matching the edge closest to the direction\n                // we're moving in so we don't end up in the same item. Prefer\n                // top/left over bottom/right.\n                event.key === ARROW_DOWN ? \"bl\" : event.key === (rtl ? ARROW_LEFT : ARROW_RIGHT) ? \"tr\" : \"tl\"),\n                stopEvent: true\n            })];\n            if (index != null) {\n                indexRef.current = index;\n                onNavigate(indexRef.current);\n            }\n            if (orientation === \"both\") {\n                return;\n            }\n        }\n        if (isMainOrientationKey(event.key, orientation)) {\n            (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.stopEvent)(event);\n            // Reset the index if no item is focused.\n            if (open && !virtual && (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.activeElement)(event.currentTarget.ownerDocument) === event.currentTarget) {\n                indexRef.current = isMainOrientationToEndKey(event.key, orientation, rtl) ? minIndex : maxIndex;\n                onNavigate(indexRef.current);\n                return;\n            }\n            if (isMainOrientationToEndKey(event.key, orientation, rtl)) {\n                if (loop) {\n                    indexRef.current = currentIndex >= maxIndex ? allowEscape && currentIndex !== listRef.current.length ? -1 : minIndex : findNonDisabledIndex(listRef, {\n                        startingIndex: currentIndex,\n                        disabledIndices\n                    });\n                } else {\n                    indexRef.current = Math.min(maxIndex, findNonDisabledIndex(listRef, {\n                        startingIndex: currentIndex,\n                        disabledIndices\n                    }));\n                }\n            } else {\n                if (loop) {\n                    indexRef.current = currentIndex <= minIndex ? allowEscape && currentIndex !== -1 ? listRef.current.length : maxIndex : findNonDisabledIndex(listRef, {\n                        startingIndex: currentIndex,\n                        decrement: true,\n                        disabledIndices\n                    });\n                } else {\n                    indexRef.current = Math.max(minIndex, findNonDisabledIndex(listRef, {\n                        startingIndex: currentIndex,\n                        decrement: true,\n                        disabledIndices\n                    }));\n                }\n            }\n            if (isIndexOutOfBounds(listRef, indexRef.current)) {\n                onNavigate(null);\n            } else {\n                onNavigate(indexRef.current);\n            }\n        }\n    });\n    const ariaActiveDescendantProp = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>{\n        return virtual && open && hasActiveIndex && {\n            \"aria-activedescendant\": virtualId || activeId\n        };\n    }, [\n        virtual,\n        open,\n        hasActiveIndex,\n        virtualId,\n        activeId\n    ]);\n    const floating = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>{\n        return {\n            \"aria-orientation\": orientation === \"both\" ? undefined : orientation,\n            ...!(0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.isTypeableCombobox)(elements.domReference) && ariaActiveDescendantProp,\n            onKeyDown: commonOnKeyDown,\n            onPointerMove () {\n                isPointerModalityRef.current = true;\n            }\n        };\n    }, [\n        ariaActiveDescendantProp,\n        commonOnKeyDown,\n        elements.domReference,\n        orientation\n    ]);\n    const reference = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>{\n        function checkVirtualMouse(event) {\n            if (focusItemOnOpen === \"auto\" && (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.isVirtualClick)(event.nativeEvent)) {\n                focusItemOnOpenRef.current = true;\n            }\n        }\n        function checkVirtualPointer(event) {\n            // `pointerdown` fires first, reset the state then perform the checks.\n            focusItemOnOpenRef.current = focusItemOnOpen;\n            if (focusItemOnOpen === \"auto\" && (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.isVirtualPointerEvent)(event.nativeEvent)) {\n                focusItemOnOpenRef.current = true;\n            }\n        }\n        return {\n            ...ariaActiveDescendantProp,\n            onKeyDown (event) {\n                isPointerModalityRef.current = false;\n                const isArrowKey = event.key.startsWith(\"Arrow\");\n                const isHomeOrEndKey = [\n                    \"Home\",\n                    \"End\"\n                ].includes(event.key);\n                const isMoveKey = isArrowKey || isHomeOrEndKey;\n                const isCrossOpenKey = isCrossOrientationOpenKey(event.key, orientation, rtl);\n                const isCrossCloseKey = isCrossOrientationCloseKey(event.key, orientation, rtl);\n                const isMainKey = isMainOrientationKey(event.key, orientation);\n                const isNavigationKey = (nested ? isCrossOpenKey : isMainKey) || event.key === \"Enter\" || event.key.trim() === \"\";\n                if (virtual && open) {\n                    const rootNode = tree == null ? void 0 : tree.nodesRef.current.find((node)=>node.parentId == null);\n                    const deepestNode = tree && rootNode ? getDeepestNode(tree.nodesRef.current, rootNode.id) : null;\n                    if (isMoveKey && deepestNode && virtualItemRef) {\n                        const eventObject = new KeyboardEvent(\"keydown\", {\n                            key: event.key,\n                            bubbles: true\n                        });\n                        if (isCrossOpenKey || isCrossCloseKey) {\n                            var _deepestNode$context, _deepestNode$context2;\n                            const isCurrentTarget = ((_deepestNode$context = deepestNode.context) == null ? void 0 : _deepestNode$context.elements.domReference) === event.currentTarget;\n                            const dispatchItem = isCrossCloseKey && !isCurrentTarget ? (_deepestNode$context2 = deepestNode.context) == null ? void 0 : _deepestNode$context2.elements.domReference : isCrossOpenKey ? listRef.current.find((item)=>(item == null ? void 0 : item.id) === activeId) : null;\n                            if (dispatchItem) {\n                                (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.stopEvent)(event);\n                                dispatchItem.dispatchEvent(eventObject);\n                                setVirtualId(undefined);\n                            }\n                        }\n                        if ((isMainKey || isHomeOrEndKey) && deepestNode.context) {\n                            if (deepestNode.context.open && deepestNode.parentId && event.currentTarget !== deepestNode.context.elements.domReference) {\n                                var _deepestNode$context$;\n                                (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.stopEvent)(event);\n                                (_deepestNode$context$ = deepestNode.context.elements.domReference) == null || _deepestNode$context$.dispatchEvent(eventObject);\n                                return;\n                            }\n                        }\n                    }\n                    return commonOnKeyDown(event);\n                }\n                // If a floating element should not open on arrow key down, avoid\n                // setting `activeIndex` while it's closed.\n                if (!open && !openOnArrowKeyDown && isArrowKey) {\n                    return;\n                }\n                if (isNavigationKey) {\n                    keyRef.current = nested && isMainKey ? null : event.key;\n                }\n                if (nested) {\n                    if (isCrossOpenKey) {\n                        (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.stopEvent)(event);\n                        if (open) {\n                            indexRef.current = getMinIndex(listRef, disabledIndicesRef.current);\n                            onNavigate(indexRef.current);\n                        } else {\n                            onOpenChange(true, event.nativeEvent, \"list-navigation\");\n                        }\n                    }\n                    return;\n                }\n                if (isMainKey) {\n                    if (selectedIndex != null) {\n                        indexRef.current = selectedIndex;\n                    }\n                    (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.stopEvent)(event);\n                    if (!open && openOnArrowKeyDown) {\n                        onOpenChange(true, event.nativeEvent, \"list-navigation\");\n                    } else {\n                        commonOnKeyDown(event);\n                    }\n                    if (open) {\n                        onNavigate(indexRef.current);\n                    }\n                }\n            },\n            onFocus () {\n                if (open && !virtual) {\n                    onNavigate(null);\n                }\n            },\n            onPointerDown: checkVirtualPointer,\n            onMouseDown: checkVirtualMouse,\n            onClick: checkVirtualMouse\n        };\n    }, [\n        activeId,\n        ariaActiveDescendantProp,\n        commonOnKeyDown,\n        disabledIndicesRef,\n        focusItemOnOpen,\n        listRef,\n        nested,\n        onNavigate,\n        onOpenChange,\n        open,\n        openOnArrowKeyDown,\n        orientation,\n        rtl,\n        selectedIndex,\n        tree,\n        virtual,\n        virtualItemRef\n    ]);\n    return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>enabled ? {\n            reference,\n            floating,\n            item\n        } : {}, [\n        enabled,\n        reference,\n        floating,\n        item\n    ]);\n}\n_s30(useListNavigation, \"q48RSJS3fM26mibI4TqHtaM4awQ=\", false, function() {\n    return [\n        useLatestRef,\n        useFloatingParentNodeId,\n        useFloatingTree,\n        useEffectEvent,\n        useLatestRef,\n        useLatestRef,\n        useLatestRef,\n        useLatestRef,\n        useEffectEvent,\n        useEffectEvent\n    ];\n});\nconst componentRoleToAriaRoleMap = /*#__PURE__*/ new Map([\n    [\n        \"select\",\n        \"listbox\"\n    ],\n    [\n        \"combobox\",\n        \"listbox\"\n    ],\n    [\n        \"label\",\n        false\n    ]\n]);\n/**\n * Adds base screen reader props to the reference and floating elements for a\n * given floating element `role`.\n * @see https://floating-ui.com/docs/useRole\n */ function useRole(context, props) {\n    _s31();\n    var _componentRoleToAriaR;\n    if (props === void 0) {\n        props = {};\n    }\n    const { open, floatingId } = context;\n    const { enabled = true, role = \"dialog\" } = props;\n    const ariaRole = (_componentRoleToAriaR = componentRoleToAriaRoleMap.get(role)) != null ? _componentRoleToAriaR : role;\n    const referenceId = useId();\n    const parentId = useFloatingParentNodeId();\n    const isNested = parentId != null;\n    const reference = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>{\n        if (ariaRole === \"tooltip\" || role === \"label\") {\n            return {\n                [\"aria-\" + (role === \"label\" ? \"labelledby\" : \"describedby\")]: open ? floatingId : undefined\n            };\n        }\n        return {\n            \"aria-expanded\": open ? \"true\" : \"false\",\n            \"aria-haspopup\": ariaRole === \"alertdialog\" ? \"dialog\" : ariaRole,\n            \"aria-controls\": open ? floatingId : undefined,\n            ...ariaRole === \"listbox\" && {\n                role: \"combobox\"\n            },\n            ...ariaRole === \"menu\" && {\n                id: referenceId\n            },\n            ...ariaRole === \"menu\" && isNested && {\n                role: \"menuitem\"\n            },\n            ...role === \"select\" && {\n                \"aria-autocomplete\": \"none\"\n            },\n            ...role === \"combobox\" && {\n                \"aria-autocomplete\": \"list\"\n            }\n        };\n    }, [\n        ariaRole,\n        floatingId,\n        isNested,\n        open,\n        referenceId,\n        role\n    ]);\n    const floating = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>{\n        const floatingProps = {\n            id: floatingId,\n            ...ariaRole && {\n                role: ariaRole\n            }\n        };\n        if (ariaRole === \"tooltip\" || role === \"label\") {\n            return floatingProps;\n        }\n        return {\n            ...floatingProps,\n            ...ariaRole === \"menu\" && {\n                \"aria-labelledby\": referenceId\n            }\n        };\n    }, [\n        ariaRole,\n        floatingId,\n        referenceId,\n        role\n    ]);\n    const item = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((_ref)=>{\n        let { active, selected } = _ref;\n        const commonProps = {\n            role: \"option\",\n            ...active && {\n                id: floatingId + \"-option\"\n            }\n        };\n        // For `menu`, we are unable to tell if the item is a `menuitemradio`\n        // or `menuitemcheckbox`. For backwards-compatibility reasons, also\n        // avoid defaulting to `menuitem` as it may overwrite custom role props.\n        switch(role){\n            case \"select\":\n                return {\n                    ...commonProps,\n                    \"aria-selected\": active && selected\n                };\n            case \"combobox\":\n                {\n                    return {\n                        ...commonProps,\n                        ...active && {\n                            \"aria-selected\": true\n                        }\n                    };\n                }\n        }\n        return {};\n    }, [\n        floatingId,\n        role\n    ]);\n    return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>enabled ? {\n            reference,\n            floating,\n            item\n        } : {}, [\n        enabled,\n        reference,\n        floating,\n        item\n    ]);\n}\n_s31(useRole, \"z30sz0+8aXrqaWLSDqKShvQLpjs=\", false, function() {\n    return [\n        useId,\n        useFloatingParentNodeId\n    ];\n});\n// Converts a JS style key like `backgroundColor` to a CSS transition-property\n// like `background-color`.\nconst camelCaseToKebabCase = (str)=>str.replace(/[A-Z]+(?![a-z])|[A-Z]/g, ($, ofs)=>(ofs ? \"-\" : \"\") + $.toLowerCase());\nfunction execWithArgsOrReturn(valueOrFn, args) {\n    return typeof valueOrFn === \"function\" ? valueOrFn(args) : valueOrFn;\n}\nfunction useDelayUnmount(open, durationMs) {\n    _s32();\n    const [isMounted, setIsMounted] = react__WEBPACK_IMPORTED_MODULE_0__.useState(open);\n    if (open && !isMounted) {\n        setIsMounted(true);\n    }\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        if (!open && isMounted) {\n            const timeout = setTimeout(()=>setIsMounted(false), durationMs);\n            return ()=>clearTimeout(timeout);\n        }\n    }, [\n        open,\n        isMounted,\n        durationMs\n    ]);\n    return isMounted;\n}\n_s32(useDelayUnmount, \"4CYkG256694540r0r4llaq2moHQ=\");\n/**\n * Provides a status string to apply CSS transitions to a floating element,\n * correctly handling placement-aware transitions.\n * @see https://floating-ui.com/docs/useTransition#usetransitionstatus\n */ function useTransitionStatus(context, props) {\n    _s33();\n    if (props === void 0) {\n        props = {};\n    }\n    const { open, elements: { floating } } = context;\n    const { duration = 250 } = props;\n    const isNumberDuration = typeof duration === \"number\";\n    const closeDuration = (isNumberDuration ? duration : duration.close) || 0;\n    const [status, setStatus] = react__WEBPACK_IMPORTED_MODULE_0__.useState(\"unmounted\");\n    const isMounted = useDelayUnmount(open, closeDuration);\n    if (!isMounted && status === \"close\") {\n        setStatus(\"unmounted\");\n    }\n    index(()=>{\n        if (!floating) return;\n        if (open) {\n            setStatus(\"initial\");\n            const frame = requestAnimationFrame(()=>{\n                setStatus(\"open\");\n            });\n            return ()=>{\n                cancelAnimationFrame(frame);\n            };\n        }\n        setStatus(\"close\");\n    }, [\n        open,\n        floating\n    ]);\n    return {\n        isMounted,\n        status\n    };\n}\n_s33(useTransitionStatus, \"DpZQxISVJwN50Vb2Ldb7V+hfuEc=\", false, function() {\n    return [\n        useDelayUnmount\n    ];\n});\n/**\n * Provides styles to apply CSS transitions to a floating element, correctly\n * handling placement-aware transitions. Wrapper around `useTransitionStatus`.\n * @see https://floating-ui.com/docs/useTransition#usetransitionstyles\n */ function useTransitionStyles(context, props) {\n    _s34();\n    if (props === void 0) {\n        props = {};\n    }\n    const { initial: unstable_initial = {\n        opacity: 0\n    }, open: unstable_open, close: unstable_close, common: unstable_common, duration = 250 } = props;\n    const placement = context.placement;\n    const side = placement.split(\"-\")[0];\n    const fnArgs = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>({\n            side,\n            placement\n        }), [\n        side,\n        placement\n    ]);\n    const isNumberDuration = typeof duration === \"number\";\n    const openDuration = (isNumberDuration ? duration : duration.open) || 0;\n    const closeDuration = (isNumberDuration ? duration : duration.close) || 0;\n    const [styles, setStyles] = react__WEBPACK_IMPORTED_MODULE_0__.useState(()=>({\n            ...execWithArgsOrReturn(unstable_common, fnArgs),\n            ...execWithArgsOrReturn(unstable_initial, fnArgs)\n        }));\n    const { isMounted, status } = useTransitionStatus(context, {\n        duration\n    });\n    const initialRef = useLatestRef(unstable_initial);\n    const openRef = useLatestRef(unstable_open);\n    const closeRef = useLatestRef(unstable_close);\n    const commonRef = useLatestRef(unstable_common);\n    index(()=>{\n        const initialStyles = execWithArgsOrReturn(initialRef.current, fnArgs);\n        const closeStyles = execWithArgsOrReturn(closeRef.current, fnArgs);\n        const commonStyles = execWithArgsOrReturn(commonRef.current, fnArgs);\n        const openStyles = execWithArgsOrReturn(openRef.current, fnArgs) || Object.keys(initialStyles).reduce((acc, key)=>{\n            acc[key] = \"\";\n            return acc;\n        }, {});\n        if (status === \"initial\") {\n            setStyles((styles)=>({\n                    transitionProperty: styles.transitionProperty,\n                    ...commonStyles,\n                    ...initialStyles\n                }));\n        }\n        if (status === \"open\") {\n            setStyles({\n                transitionProperty: Object.keys(openStyles).map(camelCaseToKebabCase).join(\",\"),\n                transitionDuration: openDuration + \"ms\",\n                ...commonStyles,\n                ...openStyles\n            });\n        }\n        if (status === \"close\") {\n            const styles = closeStyles || initialStyles;\n            setStyles({\n                transitionProperty: Object.keys(styles).map(camelCaseToKebabCase).join(\",\"),\n                transitionDuration: closeDuration + \"ms\",\n                ...commonStyles,\n                ...styles\n            });\n        }\n    }, [\n        closeDuration,\n        closeRef,\n        initialRef,\n        openRef,\n        commonRef,\n        openDuration,\n        status,\n        fnArgs\n    ]);\n    return {\n        isMounted,\n        styles\n    };\n}\n_s34(useTransitionStyles, \"TQF660jTBdXgMUZv9Ici4ZSMWYo=\", false, function() {\n    return [\n        useTransitionStatus,\n        useLatestRef,\n        useLatestRef,\n        useLatestRef,\n        useLatestRef\n    ];\n});\n/**\n * Provides a matching callback that can be used to focus an item as the user\n * types, often used in tandem with `useListNavigation()`.\n * @see https://floating-ui.com/docs/useTypeahead\n */ function useTypeahead(context, props) {\n    _s35();\n    var _ref;\n    const { open, dataRef } = context;\n    const { listRef, activeIndex, onMatch: unstable_onMatch, onTypingChange: unstable_onTypingChange, enabled = true, findMatch = null, resetMs = 750, ignoreKeys = [], selectedIndex = null } = props;\n    const timeoutIdRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef();\n    const stringRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(\"\");\n    const prevIndexRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef((_ref = selectedIndex != null ? selectedIndex : activeIndex) != null ? _ref : -1);\n    const matchIndexRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n    const onMatch = useEffectEvent(unstable_onMatch);\n    const onTypingChange = useEffectEvent(unstable_onTypingChange);\n    const findMatchRef = useLatestRef(findMatch);\n    const ignoreKeysRef = useLatestRef(ignoreKeys);\n    index(()=>{\n        if (open) {\n            clearTimeout(timeoutIdRef.current);\n            matchIndexRef.current = null;\n            stringRef.current = \"\";\n        }\n    }, [\n        open\n    ]);\n    index(()=>{\n        // Sync arrow key navigation but not typeahead navigation.\n        if (open && stringRef.current === \"\") {\n            var _ref2;\n            prevIndexRef.current = (_ref2 = selectedIndex != null ? selectedIndex : activeIndex) != null ? _ref2 : -1;\n        }\n    }, [\n        open,\n        selectedIndex,\n        activeIndex\n    ]);\n    const setTypingChange = useEffectEvent((value)=>{\n        if (value) {\n            if (!dataRef.current.typing) {\n                dataRef.current.typing = value;\n                onTypingChange(value);\n            }\n        } else {\n            if (dataRef.current.typing) {\n                dataRef.current.typing = value;\n                onTypingChange(value);\n            }\n        }\n    });\n    const onKeyDown = useEffectEvent((event)=>{\n        function getMatchingIndex(list, orderedList, string) {\n            const str = findMatchRef.current ? findMatchRef.current(orderedList, string) : orderedList.find((text)=>(text == null ? void 0 : text.toLocaleLowerCase().indexOf(string.toLocaleLowerCase())) === 0);\n            return str ? list.indexOf(str) : -1;\n        }\n        const listContent = listRef.current;\n        if (stringRef.current.length > 0 && stringRef.current[0] !== \" \") {\n            if (getMatchingIndex(listContent, listContent, stringRef.current) === -1) {\n                setTypingChange(false);\n            } else if (event.key === \" \") {\n                (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.stopEvent)(event);\n            }\n        }\n        if (listContent == null || ignoreKeysRef.current.includes(event.key) || // Character key.\n        event.key.length !== 1 || // Modifier key.\n        event.ctrlKey || event.metaKey || event.altKey) {\n            return;\n        }\n        if (open && event.key !== \" \") {\n            (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.stopEvent)(event);\n            setTypingChange(true);\n        }\n        // Bail out if the list contains a word like \"llama\" or \"aaron\". TODO:\n        // allow it in this case, too.\n        const allowRapidSuccessionOfFirstLetter = listContent.every((text)=>{\n            var _text$, _text$2;\n            return text ? ((_text$ = text[0]) == null ? void 0 : _text$.toLocaleLowerCase()) !== ((_text$2 = text[1]) == null ? void 0 : _text$2.toLocaleLowerCase()) : true;\n        });\n        // Allows the user to cycle through items that start with the same letter\n        // in rapid succession.\n        if (allowRapidSuccessionOfFirstLetter && stringRef.current === event.key) {\n            stringRef.current = \"\";\n            prevIndexRef.current = matchIndexRef.current;\n        }\n        stringRef.current += event.key;\n        clearTimeout(timeoutIdRef.current);\n        timeoutIdRef.current = setTimeout(()=>{\n            stringRef.current = \"\";\n            prevIndexRef.current = matchIndexRef.current;\n            setTypingChange(false);\n        }, resetMs);\n        const prevIndex = prevIndexRef.current;\n        const index = getMatchingIndex(listContent, [\n            ...listContent.slice((prevIndex || 0) + 1),\n            ...listContent.slice(0, (prevIndex || 0) + 1)\n        ], stringRef.current);\n        if (index !== -1) {\n            onMatch(index);\n            matchIndexRef.current = index;\n        } else if (event.key !== \" \") {\n            stringRef.current = \"\";\n            setTypingChange(false);\n        }\n    });\n    const reference = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>({\n            onKeyDown\n        }), [\n        onKeyDown\n    ]);\n    const floating = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>{\n        return {\n            onKeyDown,\n            onKeyUp (event) {\n                if (event.key === \" \") {\n                    setTypingChange(false);\n                }\n            }\n        };\n    }, [\n        onKeyDown,\n        setTypingChange\n    ]);\n    return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>enabled ? {\n            reference,\n            floating\n        } : {}, [\n        enabled,\n        reference,\n        floating\n    ]);\n}\n_s35(useTypeahead, \"FaW0XRw9+FuNFVCaA1r1lKXL4Iw=\", false, function() {\n    return [\n        useEffectEvent,\n        useEffectEvent,\n        useLatestRef,\n        useLatestRef,\n        useEffectEvent,\n        useEffectEvent\n    ];\n});\nfunction getArgsWithCustomFloatingHeight(state, height) {\n    return {\n        ...state,\n        rects: {\n            ...state.rects,\n            floating: {\n                ...state.rects.floating,\n                height\n            }\n        }\n    };\n}\n/**\n * Positions the floating element such that an inner element inside of it is\n * anchored to the reference element.\n * @see https://floating-ui.com/docs/inner\n */ const inner = (props)=>({\n        name: \"inner\",\n        options: props,\n        async fn (state) {\n            const { listRef, overflowRef, onFallbackChange, offset: innerOffset = 0, index = 0, minItemsVisible = 4, referenceOverflowThreshold = 0, scrollRef, ...detectOverflowOptions } = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_6__.evaluate)(props, state);\n            const { rects, elements: { floating } } = state;\n            const item = listRef.current[index];\n            const scrollEl = (scrollRef == null ? void 0 : scrollRef.current) || floating;\n            // Valid combinations:\n            // 1. Floating element is the scrollRef and has a border (default)\n            // 2. Floating element is not the scrollRef, floating element has a border\n            // 3. Floating element is not the scrollRef, scrollRef has a border\n            // Floating > {...getFloatingProps()} wrapper > scrollRef > items is not\n            // allowed as VoiceOver doesn't work.\n            const clientTop = floating.clientTop || scrollEl.clientTop;\n            const floatingIsBordered = floating.clientTop !== 0;\n            const scrollElIsBordered = scrollEl.clientTop !== 0;\n            const floatingIsScrollEl = floating === scrollEl;\n            if (true) {\n                if (!state.placement.startsWith(\"bottom\")) {\n                    warn('`placement` side must be \"bottom\" when using the `inner`', \"middleware.\");\n                }\n            }\n            if (!item) {\n                return {};\n            }\n            const nextArgs = {\n                ...state,\n                ...await (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_2__.offset)(-item.offsetTop - floating.clientTop - rects.reference.height / 2 - item.offsetHeight / 2 - innerOffset).fn(state)\n            };\n            const overflow = await (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_3__.detectOverflow)(getArgsWithCustomFloatingHeight(nextArgs, scrollEl.scrollHeight + clientTop + floating.clientTop), detectOverflowOptions);\n            const refOverflow = await (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_3__.detectOverflow)(nextArgs, {\n                ...detectOverflowOptions,\n                elementContext: \"reference\"\n            });\n            const diffY = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_6__.max)(0, overflow.top);\n            const nextY = nextArgs.y + diffY;\n            const isScrollable = scrollEl.scrollHeight > scrollEl.clientHeight;\n            const rounder = isScrollable ? (v)=>v : _floating_ui_utils__WEBPACK_IMPORTED_MODULE_6__.round;\n            const maxHeight = rounder((0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_6__.max)(0, scrollEl.scrollHeight + (floatingIsBordered && floatingIsScrollEl || scrollElIsBordered ? clientTop * 2 : 0) - diffY - (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_6__.max)(0, overflow.bottom)));\n            scrollEl.style.maxHeight = maxHeight + \"px\";\n            scrollEl.scrollTop = diffY;\n            // There is not enough space, fallback to standard anchored positioning\n            if (onFallbackChange) {\n                const shouldFallback = scrollEl.offsetHeight < item.offsetHeight * (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_6__.min)(minItemsVisible, listRef.current.length) - 1 || refOverflow.top >= -referenceOverflowThreshold || refOverflow.bottom >= -referenceOverflowThreshold;\n                react_dom__WEBPACK_IMPORTED_MODULE_1__.flushSync(()=>onFallbackChange(shouldFallback));\n            }\n            if (overflowRef) {\n                overflowRef.current = await (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_3__.detectOverflow)(getArgsWithCustomFloatingHeight({\n                    ...nextArgs,\n                    y: nextY\n                }, scrollEl.offsetHeight + clientTop + floating.clientTop), detectOverflowOptions);\n            }\n            return {\n                y: nextY\n            };\n        }\n    });\n/**\n * Changes the `inner` middleware's `offset` upon a `wheel` event to\n * expand the floating element's height, revealing more list items.\n * @see https://floating-ui.com/docs/inner\n */ function useInnerOffset(context, props) {\n    _s36();\n    const { open, elements } = context;\n    const { enabled = true, overflowRef, scrollRef, onChange: unstable_onChange } = props;\n    const onChange = useEffectEvent(unstable_onChange);\n    const controlledScrollingRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\n    const prevScrollTopRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n    const initialOverflowRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        if (!enabled) return;\n        function onWheel(e) {\n            if (e.ctrlKey || !el || overflowRef.current == null) {\n                return;\n            }\n            const dY = e.deltaY;\n            const isAtTop = overflowRef.current.top >= -0.5;\n            const isAtBottom = overflowRef.current.bottom >= -0.5;\n            const remainingScroll = el.scrollHeight - el.clientHeight;\n            const sign = dY < 0 ? -1 : 1;\n            const method = dY < 0 ? \"max\" : \"min\";\n            if (el.scrollHeight <= el.clientHeight) {\n                return;\n            }\n            if (!isAtTop && dY > 0 || !isAtBottom && dY < 0) {\n                e.preventDefault();\n                react_dom__WEBPACK_IMPORTED_MODULE_1__.flushSync(()=>{\n                    onChange((d)=>d + Math[method](dY, remainingScroll * sign));\n                });\n            } else if (/firefox/i.test((0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.getUserAgent)())) {\n                // Needed to propagate scrolling during momentum scrolling phase once\n                // it gets limited by the boundary. UX improvement, not critical.\n                el.scrollTop += dY;\n            }\n        }\n        const el = (scrollRef == null ? void 0 : scrollRef.current) || elements.floating;\n        if (open && el) {\n            el.addEventListener(\"wheel\", onWheel);\n            // Wait for the position to be ready.\n            requestAnimationFrame(()=>{\n                prevScrollTopRef.current = el.scrollTop;\n                if (overflowRef.current != null) {\n                    initialOverflowRef.current = {\n                        ...overflowRef.current\n                    };\n                }\n            });\n            return ()=>{\n                prevScrollTopRef.current = null;\n                initialOverflowRef.current = null;\n                el.removeEventListener(\"wheel\", onWheel);\n            };\n        }\n    }, [\n        enabled,\n        open,\n        elements.floating,\n        overflowRef,\n        scrollRef,\n        onChange\n    ]);\n    const floating = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>({\n            onKeyDown () {\n                controlledScrollingRef.current = true;\n            },\n            onWheel () {\n                controlledScrollingRef.current = false;\n            },\n            onPointerMove () {\n                controlledScrollingRef.current = false;\n            },\n            onScroll () {\n                const el = (scrollRef == null ? void 0 : scrollRef.current) || elements.floating;\n                if (!overflowRef.current || !el || !controlledScrollingRef.current) {\n                    return;\n                }\n                if (prevScrollTopRef.current !== null) {\n                    const scrollDiff = el.scrollTop - prevScrollTopRef.current;\n                    if (overflowRef.current.bottom < -0.5 && scrollDiff < -1 || overflowRef.current.top < -0.5 && scrollDiff > 1) {\n                        react_dom__WEBPACK_IMPORTED_MODULE_1__.flushSync(()=>onChange((d)=>d + scrollDiff));\n                    }\n                }\n                // [Firefox] Wait for the height change to have been applied.\n                requestAnimationFrame(()=>{\n                    prevScrollTopRef.current = el.scrollTop;\n                });\n            }\n        }), [\n        elements.floating,\n        onChange,\n        overflowRef,\n        scrollRef\n    ]);\n    return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>enabled ? {\n            floating\n        } : {}, [\n        enabled,\n        floating\n    ]);\n}\n_s36(useInnerOffset, \"XSR+nj0VCaAQpXg+AMwkd1PmoWY=\", false, function() {\n    return [\n        useEffectEvent\n    ];\n});\nfunction isPointInPolygon(point, polygon) {\n    const [x, y] = point;\n    let isInside = false;\n    const length = polygon.length;\n    for(let i = 0, j = length - 1; i < length; j = i++){\n        const [xi, yi] = polygon[i] || [\n            0,\n            0\n        ];\n        const [xj, yj] = polygon[j] || [\n            0,\n            0\n        ];\n        const intersect = yi >= y !== yj >= y && x <= (xj - xi) * (y - yi) / (yj - yi) + xi;\n        if (intersect) {\n            isInside = !isInside;\n        }\n    }\n    return isInside;\n}\nfunction isInside(point, rect) {\n    return point[0] >= rect.x && point[0] <= rect.x + rect.width && point[1] >= rect.y && point[1] <= rect.y + rect.height;\n}\n/**\n * Generates a safe polygon area that the user can traverse without closing the\n * floating element once leaving the reference element.\n * @see https://floating-ui.com/docs/useHover#safepolygon\n */ function safePolygon(options) {\n    if (options === void 0) {\n        options = {};\n    }\n    const { buffer = 0.5, blockPointerEvents = false, requireIntent = true } = options;\n    let timeoutId;\n    let hasLanded = false;\n    let lastX = null;\n    let lastY = null;\n    let lastCursorTime = performance.now();\n    function getCursorSpeed(x, y) {\n        const currentTime = performance.now();\n        const elapsedTime = currentTime - lastCursorTime;\n        if (lastX === null || lastY === null || elapsedTime === 0) {\n            lastX = x;\n            lastY = y;\n            lastCursorTime = currentTime;\n            return null;\n        }\n        const deltaX = x - lastX;\n        const deltaY = y - lastY;\n        const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);\n        const speed = distance / elapsedTime; // px / ms\n        lastX = x;\n        lastY = y;\n        lastCursorTime = currentTime;\n        return speed;\n    }\n    const fn = (_ref)=>{\n        let { x, y, placement, elements, onClose, nodeId, tree } = _ref;\n        return function onMouseMove(event) {\n            function close() {\n                clearTimeout(timeoutId);\n                onClose();\n            }\n            clearTimeout(timeoutId);\n            if (!elements.domReference || !elements.floating || placement == null || x == null || y == null) {\n                return;\n            }\n            const { clientX, clientY } = event;\n            const clientPoint = [\n                clientX,\n                clientY\n            ];\n            const target = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.getTarget)(event);\n            const isLeave = event.type === \"mouseleave\";\n            const isOverFloatingEl = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.contains)(elements.floating, target);\n            const isOverReferenceEl = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.contains)(elements.domReference, target);\n            const refRect = elements.domReference.getBoundingClientRect();\n            const rect = elements.floating.getBoundingClientRect();\n            const side = placement.split(\"-\")[0];\n            const cursorLeaveFromRight = x > rect.right - rect.width / 2;\n            const cursorLeaveFromBottom = y > rect.bottom - rect.height / 2;\n            const isOverReferenceRect = isInside(clientPoint, refRect);\n            const isFloatingWider = rect.width > refRect.width;\n            const isFloatingTaller = rect.height > refRect.height;\n            const left = (isFloatingWider ? refRect : rect).left;\n            const right = (isFloatingWider ? refRect : rect).right;\n            const top = (isFloatingTaller ? refRect : rect).top;\n            const bottom = (isFloatingTaller ? refRect : rect).bottom;\n            if (isOverFloatingEl) {\n                hasLanded = true;\n                if (!isLeave) {\n                    return;\n                }\n            }\n            if (isOverReferenceEl) {\n                hasLanded = false;\n            }\n            if (isOverReferenceEl && !isLeave) {\n                hasLanded = true;\n                return;\n            }\n            // Prevent overlapping floating element from being stuck in an open-close\n            // loop: https://github.com/floating-ui/floating-ui/issues/1910\n            if (isLeave && (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.isElement)(event.relatedTarget) && (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_5__.contains)(elements.floating, event.relatedTarget)) {\n                return;\n            }\n            // If any nested child is open, abort.\n            if (tree && getChildren(tree.nodesRef.current, nodeId).some((_ref2)=>{\n                let { context } = _ref2;\n                return context == null ? void 0 : context.open;\n            })) {\n                return;\n            }\n            // If the pointer is leaving from the opposite side, the \"buffer\" logic\n            // creates a point where the floating element remains open, but should be\n            // ignored.\n            // A constant of 1 handles floating point rounding errors.\n            if (side === \"top\" && y >= refRect.bottom - 1 || side === \"bottom\" && y <= refRect.top + 1 || side === \"left\" && x >= refRect.right - 1 || side === \"right\" && x <= refRect.left + 1) {\n                return close();\n            }\n            // Ignore when the cursor is within the rectangular trough between the\n            // two elements. Since the triangle is created from the cursor point,\n            // which can start beyond the ref element's edge, traversing back and\n            // forth from the ref to the floating element can cause it to close. This\n            // ensures it always remains open in that case.\n            let rectPoly = [];\n            switch(side){\n                case \"top\":\n                    rectPoly = [\n                        [\n                            left,\n                            refRect.top + 1\n                        ],\n                        [\n                            left,\n                            rect.bottom - 1\n                        ],\n                        [\n                            right,\n                            rect.bottom - 1\n                        ],\n                        [\n                            right,\n                            refRect.top + 1\n                        ]\n                    ];\n                    break;\n                case \"bottom\":\n                    rectPoly = [\n                        [\n                            left,\n                            rect.top + 1\n                        ],\n                        [\n                            left,\n                            refRect.bottom - 1\n                        ],\n                        [\n                            right,\n                            refRect.bottom - 1\n                        ],\n                        [\n                            right,\n                            rect.top + 1\n                        ]\n                    ];\n                    break;\n                case \"left\":\n                    rectPoly = [\n                        [\n                            rect.right - 1,\n                            bottom\n                        ],\n                        [\n                            rect.right - 1,\n                            top\n                        ],\n                        [\n                            refRect.left + 1,\n                            top\n                        ],\n                        [\n                            refRect.left + 1,\n                            bottom\n                        ]\n                    ];\n                    break;\n                case \"right\":\n                    rectPoly = [\n                        [\n                            refRect.right - 1,\n                            bottom\n                        ],\n                        [\n                            refRect.right - 1,\n                            top\n                        ],\n                        [\n                            rect.left + 1,\n                            top\n                        ],\n                        [\n                            rect.left + 1,\n                            bottom\n                        ]\n                    ];\n                    break;\n            }\n            function getPolygon(_ref3) {\n                let [x, y] = _ref3;\n                switch(side){\n                    case \"top\":\n                        {\n                            const cursorPointOne = [\n                                isFloatingWider ? x + buffer / 2 : cursorLeaveFromRight ? x + buffer * 4 : x - buffer * 4,\n                                y + buffer + 1\n                            ];\n                            const cursorPointTwo = [\n                                isFloatingWider ? x - buffer / 2 : cursorLeaveFromRight ? x + buffer * 4 : x - buffer * 4,\n                                y + buffer + 1\n                            ];\n                            const commonPoints = [\n                                [\n                                    rect.left,\n                                    cursorLeaveFromRight ? rect.bottom - buffer : isFloatingWider ? rect.bottom - buffer : rect.top\n                                ],\n                                [\n                                    rect.right,\n                                    cursorLeaveFromRight ? isFloatingWider ? rect.bottom - buffer : rect.top : rect.bottom - buffer\n                                ]\n                            ];\n                            return [\n                                cursorPointOne,\n                                cursorPointTwo,\n                                ...commonPoints\n                            ];\n                        }\n                    case \"bottom\":\n                        {\n                            const cursorPointOne = [\n                                isFloatingWider ? x + buffer / 2 : cursorLeaveFromRight ? x + buffer * 4 : x - buffer * 4,\n                                y - buffer\n                            ];\n                            const cursorPointTwo = [\n                                isFloatingWider ? x - buffer / 2 : cursorLeaveFromRight ? x + buffer * 4 : x - buffer * 4,\n                                y - buffer\n                            ];\n                            const commonPoints = [\n                                [\n                                    rect.left,\n                                    cursorLeaveFromRight ? rect.top + buffer : isFloatingWider ? rect.top + buffer : rect.bottom\n                                ],\n                                [\n                                    rect.right,\n                                    cursorLeaveFromRight ? isFloatingWider ? rect.top + buffer : rect.bottom : rect.top + buffer\n                                ]\n                            ];\n                            return [\n                                cursorPointOne,\n                                cursorPointTwo,\n                                ...commonPoints\n                            ];\n                        }\n                    case \"left\":\n                        {\n                            const cursorPointOne = [\n                                x + buffer + 1,\n                                isFloatingTaller ? y + buffer / 2 : cursorLeaveFromBottom ? y + buffer * 4 : y - buffer * 4\n                            ];\n                            const cursorPointTwo = [\n                                x + buffer + 1,\n                                isFloatingTaller ? y - buffer / 2 : cursorLeaveFromBottom ? y + buffer * 4 : y - buffer * 4\n                            ];\n                            const commonPoints = [\n                                [\n                                    cursorLeaveFromBottom ? rect.right - buffer : isFloatingTaller ? rect.right - buffer : rect.left,\n                                    rect.top\n                                ],\n                                [\n                                    cursorLeaveFromBottom ? isFloatingTaller ? rect.right - buffer : rect.left : rect.right - buffer,\n                                    rect.bottom\n                                ]\n                            ];\n                            return [\n                                ...commonPoints,\n                                cursorPointOne,\n                                cursorPointTwo\n                            ];\n                        }\n                    case \"right\":\n                        {\n                            const cursorPointOne = [\n                                x - buffer,\n                                isFloatingTaller ? y + buffer / 2 : cursorLeaveFromBottom ? y + buffer * 4 : y - buffer * 4\n                            ];\n                            const cursorPointTwo = [\n                                x - buffer,\n                                isFloatingTaller ? y - buffer / 2 : cursorLeaveFromBottom ? y + buffer * 4 : y - buffer * 4\n                            ];\n                            const commonPoints = [\n                                [\n                                    cursorLeaveFromBottom ? rect.left + buffer : isFloatingTaller ? rect.left + buffer : rect.right,\n                                    rect.top\n                                ],\n                                [\n                                    cursorLeaveFromBottom ? isFloatingTaller ? rect.left + buffer : rect.right : rect.left + buffer,\n                                    rect.bottom\n                                ]\n                            ];\n                            return [\n                                cursorPointOne,\n                                cursorPointTwo,\n                                ...commonPoints\n                            ];\n                        }\n                }\n            }\n            if (isPointInPolygon([\n                clientX,\n                clientY\n            ], rectPoly)) {\n                return;\n            }\n            if (hasLanded && !isOverReferenceRect) {\n                return close();\n            }\n            if (!isLeave && requireIntent) {\n                const cursorSpeed = getCursorSpeed(event.clientX, event.clientY);\n                const cursorSpeedThreshold = 0.1;\n                if (cursorSpeed !== null && cursorSpeed < cursorSpeedThreshold) {\n                    return close();\n                }\n            }\n            if (!isPointInPolygon([\n                clientX,\n                clientY\n            ], getPolygon([\n                x,\n                y\n            ]))) {\n                close();\n            } else if (!hasLanded && requireIntent) {\n                timeoutId = window.setTimeout(close, 40);\n            }\n        };\n    };\n    fn.__options = {\n        blockPointerEvents\n    };\n    return fn;\n}\n\nvar _c, _c1, _c2, _c3, _c4, _c5, _c6, _c7, _c8, _c9, _c10, _c11, _c12, _c13, _c14, _c15, _c16;\n$RefreshReg$(_c, \"FloatingList\");\n$RefreshReg$(_c1, \"Composite$React.forwardRef\");\n$RefreshReg$(_c2, \"Composite\");\n$RefreshReg$(_c3, \"CompositeItem$React.forwardRef\");\n$RefreshReg$(_c4, \"CompositeItem\");\n$RefreshReg$(_c5, \"FloatingArrow$React.forwardRef\");\n$RefreshReg$(_c6, \"FloatingArrow\");\n$RefreshReg$(_c7, \"FloatingNode\");\n$RefreshReg$(_c8, \"FloatingTree\");\n$RefreshReg$(_c9, \"NOOP\");\n$RefreshReg$(_c10, \"FloatingDelayGroup\");\n$RefreshReg$(_c11, \"FocusGuard\");\n$RefreshReg$(_c12, \"FloatingPortal\");\n$RefreshReg$(_c13, \"VisuallyHiddenDismiss\");\n$RefreshReg$(_c14, \"FloatingFocusManager\");\n$RefreshReg$(_c15, \"FloatingOverlay$React.forwardRef\");\n$RefreshReg$(_c16, \"FloatingOverlay\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQGZsb2F0aW5nLXVpL3JlYWN0L2Rpc3QvZmxvYXRpbmctdWkucmVhY3QubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQStCO0FBQzRCO0FBQytPO0FBQ3BPO0FBQ3NGO0FBQzVHO0FBQ1Y7QUFDOEU7QUFDNEU7QUFFaE07OztDQUdDLEdBQ0QsU0FBU3FELGFBQWFDLElBQUk7O0lBQ3hCLE9BQU90RCwwQ0FBYSxDQUFDO1FBQ25CLElBQUlzRCxLQUFLRSxLQUFLLENBQUNDLENBQUFBLE1BQU9BLE9BQU8sT0FBTztZQUNsQyxPQUFPO1FBQ1Q7UUFDQSxPQUFPQyxDQUFBQTtZQUNMSixLQUFLSyxPQUFPLENBQUNGLENBQUFBO2dCQUNYLElBQUksT0FBT0EsUUFBUSxZQUFZO29CQUM3QkEsSUFBSUM7Z0JBQ04sT0FBTyxJQUFJRCxPQUFPLE1BQU07b0JBQ3RCQSxJQUFJRyxPQUFPLEdBQUdGO2dCQUNoQjtZQUNGO1FBQ0Y7SUFDQSx1REFBdUQ7SUFDekQsR0FBR0o7QUFDTDtHQWhCU0Q7QUFrQlQsMEVBQTBFO0FBQzFFLE1BQU1RLFlBQVk7SUFDaEIsR0FBRzdELHlMQUFLO0FBQ1Y7QUFFQSxNQUFNOEQscUJBQXFCRCxVQUFVQyxrQkFBa0I7QUFDdkQsTUFBTUMseUJBQXlCRCxzQkFBdUJFLENBQUFBLENBQUFBLEtBQU1BLElBQUc7QUFDL0QsU0FBU0MsZUFBZUMsUUFBUTs7SUFDOUIsTUFBTVQsTUFBTXpELHlDQUFZLENBQUM7UUFDdkIsSUFBSW1FLElBQXFDLEVBQUU7WUFDekMsTUFBTSxJQUFJQyxNQUFNO1FBQ2xCO0lBQ0Y7SUFDQUwsdUJBQXVCO1FBQ3JCTixJQUFJRyxPQUFPLEdBQUdNO0lBQ2hCO0lBQ0EsT0FBT2xFLDhDQUFpQixDQUFDO1FBQ3ZCLElBQUssSUFBSXNFLE9BQU9D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QjtvQkFDOUQsT0FBT3ZuQjtnQkFDVDtZQUNGO1lBQ0EsSUFBSSxDQUFDNmtCLGlCQUFpQjtnQkFBQzVuQjtnQkFBU0M7YUFBUSxFQUFFZ3FCLFdBQVc7Z0JBQUN6d0I7Z0JBQUdDO2FBQUUsSUFBSTtnQkFDN0RzSjtZQUNGLE9BQU8sSUFBSSxDQUFDMGxCLGFBQWFELGVBQWU7Z0JBQ3RDNWYsWUFBWXhKLE9BQU9DLFVBQVUsQ0FBQzBELE9BQU87WUFDdkM7UUFDRjtJQUNGO0lBQ0FwWSxHQUFHZ1csU0FBUyxHQUFHO1FBQ2JDO0lBQ0Y7SUFDQSxPQUFPalc7QUFDVDtBQUUyaUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AZmxvYXRpbmctdWkvcmVhY3QvZGlzdC9mbG9hdGluZy11aS5yZWFjdC5tanM/MTc2MyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyB1c2VMYXlvdXRFZmZlY3QsIHVzZUVmZmVjdCwgdXNlUmVmIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgc3RvcEV2ZW50LCBnZXREb2N1bWVudCwgaXNNb3VzZUxpa2VQb2ludGVyVHlwZSwgY29udGFpbnMsIGFjdGl2ZUVsZW1lbnQsIGlzU2FmYXJpLCBpc1R5cGVhYmxlQ29tYm9ib3gsIGlzVmlydHVhbENsaWNrLCBpc1ZpcnR1YWxQb2ludGVyRXZlbnQsIGdldFRhcmdldCwgZ2V0UGxhdGZvcm0sIGlzVHlwZWFibGVFbGVtZW50LCBpc1JlYWN0RXZlbnQsIGlzUm9vdEVsZW1lbnQsIGlzRXZlbnRUYXJnZXRXaXRoaW4sIGlzTWFjLCBnZXRVc2VyQWdlbnQgfSBmcm9tICdAZmxvYXRpbmctdWkvcmVhY3QvdXRpbHMnO1xuaW1wb3J0IHsgZmxvb3IsIGV2YWx1YXRlLCBtYXgsIG1pbiwgcm91bmQgfSBmcm9tICdAZmxvYXRpbmctdWkvdXRpbHMnO1xuaW1wb3J0IHsgZ2V0Q29tcHV0ZWRTdHlsZSwgaXNFbGVtZW50LCBnZXROb2RlTmFtZSwgaXNIVE1MRWxlbWVudCwgZ2V0V2luZG93LCBpc0xhc3RUcmF2ZXJzYWJsZU5vZGUsIGdldFBhcmVudE5vZGUsIGlzV2ViS2l0IH0gZnJvbSAnQGZsb2F0aW5nLXVpL3V0aWxzL2RvbSc7XG5pbXBvcnQgeyB0YWJiYWJsZSwgaXNUYWJiYWJsZSB9IGZyb20gJ3RhYmJhYmxlJztcbmltcG9ydCAqIGFzIFJlYWN0RE9NIGZyb20gJ3JlYWN0LWRvbSc7XG5pbXBvcnQgeyBnZXRPdmVyZmxvd0FuY2VzdG9ycywgdXNlRmxvYXRpbmcgYXMgdXNlRmxvYXRpbmckMSwgb2Zmc2V0LCBkZXRlY3RPdmVyZmxvdyB9IGZyb20gJ0BmbG9hdGluZy11aS9yZWFjdC1kb20nO1xuZXhwb3J0IHsgYXJyb3csIGF1dG9QbGFjZW1lbnQsIGF1dG9VcGRhdGUsIGNvbXB1dGVQb3NpdGlvbiwgZGV0ZWN0T3ZlcmZsb3csIGZsaXAsIGdldE92ZXJmbG93QW5jZXN0b3JzLCBoaWRlLCBpbmxpbmUsIGxpbWl0U2hpZnQsIG9mZnNldCwgcGxhdGZvcm0sIHNoaWZ0LCBzaXplIH0gZnJvbSAnQGZsb2F0aW5nLXVpL3JlYWN0LWRvbSc7XG5cbi8qKlxuICogTWVyZ2VzIGFuIGFycmF5IG9mIHJlZnMgaW50byBhIHNpbmdsZSBtZW1vaXplZCBjYWxsYmFjayByZWYgb3IgYG51bGxgLlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL3JlYWN0LXV0aWxzI3VzZW1lcmdlcmVmc1xuICovXG5mdW5jdGlvbiB1c2VNZXJnZVJlZnMocmVmcykge1xuICByZXR1cm4gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgaWYgKHJlZnMuZXZlcnkocmVmID0+IHJlZiA9PSBudWxsKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZSA9PiB7XG4gICAgICByZWZzLmZvckVhY2gocmVmID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiByZWYgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICByZWYodmFsdWUpO1xuICAgICAgICB9IGVsc2UgaWYgKHJlZiAhPSBudWxsKSB7XG4gICAgICAgICAgcmVmLmN1cnJlbnQgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gIH0sIHJlZnMpO1xufVxuXG4vLyBodHRwczovL2dpdGh1Yi5jb20vbXVpL21hdGVyaWFsLXVpL2lzc3Vlcy80MTE5MCNpc3N1ZWNvbW1lbnQtMjA0MDg3MzM3OVxuY29uc3QgU2FmZVJlYWN0ID0ge1xuICAuLi5SZWFjdFxufTtcblxuY29uc3QgdXNlSW5zZXJ0aW9uRWZmZWN0ID0gU2FmZVJlYWN0LnVzZUluc2VydGlvbkVmZmVjdDtcbmNvbnN0IHVzZVNhZmVJbnNlcnRpb25FZmZlY3QgPSB1c2VJbnNlcnRpb25FZmZlY3QgfHwgKGZuID0+IGZuKCkpO1xuZnVuY3Rpb24gdXNlRWZmZWN0RXZlbnQoY2FsbGJhY2spIHtcbiAgY29uc3QgcmVmID0gUmVhY3QudXNlUmVmKCgpID0+IHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBjYWxsIGFuIGV2ZW50IGhhbmRsZXIgd2hpbGUgcmVuZGVyaW5nLicpO1xuICAgIH1cbiAgfSk7XG4gIHVzZVNhZmVJbnNlcnRpb25FZmZlY3QoKCkgPT4ge1xuICAgIHJlZi5jdXJyZW50ID0gY2FsbGJhY2s7XG4gIH0pO1xuICByZXR1cm4gUmVhY3QudXNlQ2FsbGJhY2soZnVuY3Rpb24gKCkge1xuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG4gICAgcmV0dXJuIHJlZi5jdXJyZW50ID09IG51bGwgPyB2b2lkIDAgOiByZWYuY3VycmVudCguLi5hcmdzKTtcbiAgfSwgW10pO1xufVxuXG5jb25zdCBBUlJPV19VUCA9ICdBcnJvd1VwJztcbmNvbnN0IEFSUk9XX0RPV04gPSAnQXJyb3dEb3duJztcbmNvbnN0IEFSUk9XX0xFRlQgPSAnQXJyb3dMZWZ0JztcbmNvbnN0IEFSUk9XX1JJR0hUID0gJ0Fycm93UmlnaHQnO1xuZnVuY3Rpb24gaXNEaWZmZXJlbnRSb3coaW5kZXgsIGNvbHMsIHByZXZSb3cpIHtcbiAgcmV0dXJuIE1hdGguZmxvb3IoaW5kZXggLyBjb2xzKSAhPT0gcHJldlJvdztcbn1cbmZ1bmN0aW9uIGlzSW5kZXhPdXRPZkJvdW5kcyhsaXN0UmVmLCBpbmRleCkge1xuICByZXR1cm4gaW5kZXggPCAwIHx8IGluZGV4ID49IGxpc3RSZWYuY3VycmVudC5sZW5ndGg7XG59XG5mdW5jdGlvbiBnZXRNaW5JbmRleChsaXN0UmVmLCBkaXNhYmxlZEluZGljZXMpIHtcbiAgcmV0dXJuIGZpbmROb25EaXNhYmxlZEluZGV4KGxpc3RSZWYsIHtcbiAgICBkaXNhYmxlZEluZGljZXNcbiAgfSk7XG59XG5mdW5jdGlvbiBnZXRNYXhJbmRleChsaXN0UmVmLCBkaXNhYmxlZEluZGljZXMpIHtcbiAgcmV0dXJuIGZpbmROb25EaXNhYmxlZEluZGV4KGxpc3RSZWYsIHtcbiAgICBkZWNyZW1lbnQ6IHRydWUsXG4gICAgc3RhcnRpbmdJbmRleDogbGlzdFJlZi5jdXJyZW50Lmxlbmd0aCxcbiAgICBkaXNhYmxlZEluZGljZXNcbiAgfSk7XG59XG5mdW5jdGlvbiBmaW5kTm9uRGlzYWJsZWRJbmRleChsaXN0UmVmLCBfdGVtcCkge1xuICBsZXQge1xuICAgIHN0YXJ0aW5nSW5kZXggPSAtMSxcbiAgICBkZWNyZW1lbnQgPSBmYWxzZSxcbiAgICBkaXNhYmxlZEluZGljZXMsXG4gICAgYW1vdW50ID0gMVxuICB9ID0gX3RlbXAgPT09IHZvaWQgMCA/IHt9IDogX3RlbXA7XG4gIGNvbnN0IGxpc3QgPSBsaXN0UmVmLmN1cnJlbnQ7XG4gIGxldCBpbmRleCA9IHN0YXJ0aW5nSW5kZXg7XG4gIGRvIHtcbiAgICBpbmRleCArPSBkZWNyZW1lbnQgPyAtYW1vdW50IDogYW1vdW50O1xuICB9IHdoaWxlIChpbmRleCA+PSAwICYmIGluZGV4IDw9IGxpc3QubGVuZ3RoIC0gMSAmJiBpc0Rpc2FibGVkKGxpc3QsIGluZGV4LCBkaXNhYmxlZEluZGljZXMpKTtcbiAgcmV0dXJuIGluZGV4O1xufVxuZnVuY3Rpb24gZ2V0R3JpZE5hdmlnYXRlZEluZGV4KGVsZW1lbnRzUmVmLCBfcmVmKSB7XG4gIGxldCB7XG4gICAgZXZlbnQsXG4gICAgb3JpZW50YXRpb24sXG4gICAgbG9vcCxcbiAgICBydGwsXG4gICAgY29scyxcbiAgICBkaXNhYmxlZEluZGljZXMsXG4gICAgbWluSW5kZXgsXG4gICAgbWF4SW5kZXgsXG4gICAgcHJldkluZGV4LFxuICAgIHN0b3BFdmVudDogc3RvcCA9IGZhbHNlXG4gIH0gPSBfcmVmO1xuICBsZXQgbmV4dEluZGV4ID0gcHJldkluZGV4O1xuICBpZiAoZXZlbnQua2V5ID09PSBBUlJPV19VUCkge1xuICAgIHN0b3AgJiYgc3RvcEV2ZW50KGV2ZW50KTtcbiAgICBpZiAocHJldkluZGV4ID09PSAtMSkge1xuICAgICAgbmV4dEluZGV4ID0gbWF4SW5kZXg7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5leHRJbmRleCA9IGZpbmROb25EaXNhYmxlZEluZGV4KGVsZW1lbnRzUmVmLCB7XG4gICAgICAgIHN0YXJ0aW5nSW5kZXg6IG5leHRJbmRleCxcbiAgICAgICAgYW1vdW50OiBjb2xzLFxuICAgICAgICBkZWNyZW1lbnQ6IHRydWUsXG4gICAgICAgIGRpc2FibGVkSW5kaWNlc1xuICAgICAgfSk7XG4gICAgICBpZiAobG9vcCAmJiAocHJldkluZGV4IC0gY29scyA8IG1pbkluZGV4IHx8IG5leHRJbmRleCA8IDApKSB7XG4gICAgICAgIGNvbnN0IGNvbCA9IHByZXZJbmRleCAlIGNvbHM7XG4gICAgICAgIGNvbnN0IG1heENvbCA9IG1heEluZGV4ICUgY29scztcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gbWF4SW5kZXggLSAobWF4Q29sIC0gY29sKTtcbiAgICAgICAgaWYgKG1heENvbCA9PT0gY29sKSB7XG4gICAgICAgICAgbmV4dEluZGV4ID0gbWF4SW5kZXg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbmV4dEluZGV4ID0gbWF4Q29sID4gY29sID8gb2Zmc2V0IDogb2Zmc2V0IC0gY29scztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaXNJbmRleE91dE9mQm91bmRzKGVsZW1lbnRzUmVmLCBuZXh0SW5kZXgpKSB7XG4gICAgICBuZXh0SW5kZXggPSBwcmV2SW5kZXg7XG4gICAgfVxuICB9XG4gIGlmIChldmVudC5rZXkgPT09IEFSUk9XX0RPV04pIHtcbiAgICBzdG9wICYmIHN0b3BFdmVudChldmVudCk7XG4gICAgaWYgKHByZXZJbmRleCA9PT0gLTEpIHtcbiAgICAgIG5leHRJbmRleCA9IG1pbkluZGV4O1xuICAgIH0gZWxzZSB7XG4gICAgICBuZXh0SW5kZXggPSBmaW5kTm9uRGlzYWJsZWRJbmRleChlbGVtZW50c1JlZiwge1xuICAgICAgICBzdGFydGluZ0luZGV4OiBwcmV2SW5kZXgsXG4gICAgICAgIGFtb3VudDogY29scyxcbiAgICAgICAgZGlzYWJsZWRJbmRpY2VzXG4gICAgICB9KTtcbiAgICAgIGlmIChsb29wICYmIHByZXZJbmRleCArIGNvbHMgPiBtYXhJbmRleCkge1xuICAgICAgICBuZXh0SW5kZXggPSBmaW5kTm9uRGlzYWJsZWRJbmRleChlbGVtZW50c1JlZiwge1xuICAgICAgICAgIHN0YXJ0aW5nSW5kZXg6IHByZXZJbmRleCAlIGNvbHMgLSBjb2xzLFxuICAgICAgICAgIGFtb3VudDogY29scyxcbiAgICAgICAgICBkaXNhYmxlZEluZGljZXNcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpc0luZGV4T3V0T2ZCb3VuZHMoZWxlbWVudHNSZWYsIG5leHRJbmRleCkpIHtcbiAgICAgIG5leHRJbmRleCA9IHByZXZJbmRleDtcbiAgICB9XG4gIH1cblxuICAvLyBSZW1haW5zIG9uIHRoZSBzYW1lIHJvdy9jb2x1bW4uXG4gIGlmIChvcmllbnRhdGlvbiA9PT0gJ2JvdGgnKSB7XG4gICAgY29uc3QgcHJldlJvdyA9IGZsb29yKHByZXZJbmRleCAvIGNvbHMpO1xuICAgIGlmIChldmVudC5rZXkgPT09IChydGwgPyBBUlJPV19MRUZUIDogQVJST1dfUklHSFQpKSB7XG4gICAgICBzdG9wICYmIHN0b3BFdmVudChldmVudCk7XG4gICAgICBpZiAocHJldkluZGV4ICUgY29scyAhPT0gY29scyAtIDEpIHtcbiAgICAgICAgbmV4dEluZGV4ID0gZmluZE5vbkRpc2FibGVkSW5kZXgoZWxlbWVudHNSZWYsIHtcbiAgICAgICAgICBzdGFydGluZ0luZGV4OiBwcmV2SW5kZXgsXG4gICAgICAgICAgZGlzYWJsZWRJbmRpY2VzXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAobG9vcCAmJiBpc0RpZmZlcmVudFJvdyhuZXh0SW5kZXgsIGNvbHMsIHByZXZSb3cpKSB7XG4gICAgICAgICAgbmV4dEluZGV4ID0gZmluZE5vbkRpc2FibGVkSW5kZXgoZWxlbWVudHNSZWYsIHtcbiAgICAgICAgICAgIHN0YXJ0aW5nSW5kZXg6IHByZXZJbmRleCAtIHByZXZJbmRleCAlIGNvbHMgLSAxLFxuICAgICAgICAgICAgZGlzYWJsZWRJbmRpY2VzXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAobG9vcCkge1xuICAgICAgICBuZXh0SW5kZXggPSBmaW5kTm9uRGlzYWJsZWRJbmRleChlbGVtZW50c1JlZiwge1xuICAgICAgICAgIHN0YXJ0aW5nSW5kZXg6IHByZXZJbmRleCAtIHByZXZJbmRleCAlIGNvbHMgLSAxLFxuICAgICAgICAgIGRpc2FibGVkSW5kaWNlc1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChpc0RpZmZlcmVudFJvdyhuZXh0SW5kZXgsIGNvbHMsIHByZXZSb3cpKSB7XG4gICAgICAgIG5leHRJbmRleCA9IHByZXZJbmRleDtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGV2ZW50LmtleSA9PT0gKHJ0bCA/IEFSUk9XX1JJR0hUIDogQVJST1dfTEVGVCkpIHtcbiAgICAgIHN0b3AgJiYgc3RvcEV2ZW50KGV2ZW50KTtcbiAgICAgIGlmIChwcmV2SW5kZXggJSBjb2xzICE9PSAwKSB7XG4gICAgICAgIG5leHRJbmRleCA9IGZpbmROb25EaXNhYmxlZEluZGV4KGVsZW1lbnRzUmVmLCB7XG4gICAgICAgICAgc3RhcnRpbmdJbmRleDogcHJldkluZGV4LFxuICAgICAgICAgIGRlY3JlbWVudDogdHJ1ZSxcbiAgICAgICAgICBkaXNhYmxlZEluZGljZXNcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChsb29wICYmIGlzRGlmZmVyZW50Um93KG5leHRJbmRleCwgY29scywgcHJldlJvdykpIHtcbiAgICAgICAgICBuZXh0SW5kZXggPSBmaW5kTm9uRGlzYWJsZWRJbmRleChlbGVtZW50c1JlZiwge1xuICAgICAgICAgICAgc3RhcnRpbmdJbmRleDogcHJldkluZGV4ICsgKGNvbHMgLSBwcmV2SW5kZXggJSBjb2xzKSxcbiAgICAgICAgICAgIGRlY3JlbWVudDogdHJ1ZSxcbiAgICAgICAgICAgIGRpc2FibGVkSW5kaWNlc1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGxvb3ApIHtcbiAgICAgICAgbmV4dEluZGV4ID0gZmluZE5vbkRpc2FibGVkSW5kZXgoZWxlbWVudHNSZWYsIHtcbiAgICAgICAgICBzdGFydGluZ0luZGV4OiBwcmV2SW5kZXggKyAoY29scyAtIHByZXZJbmRleCAlIGNvbHMpLFxuICAgICAgICAgIGRlY3JlbWVudDogdHJ1ZSxcbiAgICAgICAgICBkaXNhYmxlZEluZGljZXNcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAoaXNEaWZmZXJlbnRSb3cobmV4dEluZGV4LCBjb2xzLCBwcmV2Um93KSkge1xuICAgICAgICBuZXh0SW5kZXggPSBwcmV2SW5kZXg7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGxhc3RSb3cgPSBmbG9vcihtYXhJbmRleCAvIGNvbHMpID09PSBwcmV2Um93O1xuICAgIGlmIChpc0luZGV4T3V0T2ZCb3VuZHMoZWxlbWVudHNSZWYsIG5leHRJbmRleCkpIHtcbiAgICAgIGlmIChsb29wICYmIGxhc3RSb3cpIHtcbiAgICAgICAgbmV4dEluZGV4ID0gZXZlbnQua2V5ID09PSAocnRsID8gQVJST1dfUklHSFQgOiBBUlJPV19MRUZUKSA/IG1heEluZGV4IDogZmluZE5vbkRpc2FibGVkSW5kZXgoZWxlbWVudHNSZWYsIHtcbiAgICAgICAgICBzdGFydGluZ0luZGV4OiBwcmV2SW5kZXggLSBwcmV2SW5kZXggJSBjb2xzIC0gMSxcbiAgICAgICAgICBkaXNhYmxlZEluZGljZXNcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXh0SW5kZXggPSBwcmV2SW5kZXg7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBuZXh0SW5kZXg7XG59XG5cbi8qKiBGb3IgZWFjaCBjZWxsIGluZGV4LCBnZXRzIHRoZSBpdGVtIGluZGV4IHRoYXQgb2NjdXBpZXMgdGhhdCBjZWxsICovXG5mdW5jdGlvbiBidWlsZENlbGxNYXAoc2l6ZXMsIGNvbHMsIGRlbnNlKSB7XG4gIGNvbnN0IGNlbGxNYXAgPSBbXTtcbiAgbGV0IHN0YXJ0SW5kZXggPSAwO1xuICBzaXplcy5mb3JFYWNoKChfcmVmMiwgaW5kZXgpID0+IHtcbiAgICBsZXQge1xuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHRcbiAgICB9ID0gX3JlZjI7XG4gICAgaWYgKHdpZHRoID4gY29scykge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJbRmxvYXRpbmcgVUldOiBJbnZhbGlkIGdyaWQgLSBpdGVtIHdpZHRoIGF0IGluZGV4IFwiICsgaW5kZXggKyBcIiBpcyBncmVhdGVyIHRoYW4gZ3JpZCBjb2x1bW5zXCIpO1xuICAgICAgfVxuICAgIH1cbiAgICBsZXQgaXRlbVBsYWNlZCA9IGZhbHNlO1xuICAgIGlmIChkZW5zZSkge1xuICAgICAgc3RhcnRJbmRleCA9IDA7XG4gICAgfVxuICAgIHdoaWxlICghaXRlbVBsYWNlZCkge1xuICAgICAgY29uc3QgdGFyZ2V0Q2VsbHMgPSBbXTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgd2lkdGg7IGkrKykge1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGhlaWdodDsgaisrKSB7XG4gICAgICAgICAgdGFyZ2V0Q2VsbHMucHVzaChzdGFydEluZGV4ICsgaSArIGogKiBjb2xzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHN0YXJ0SW5kZXggJSBjb2xzICsgd2lkdGggPD0gY29scyAmJiB0YXJnZXRDZWxscy5ldmVyeShjZWxsID0+IGNlbGxNYXBbY2VsbF0gPT0gbnVsbCkpIHtcbiAgICAgICAgdGFyZ2V0Q2VsbHMuZm9yRWFjaChjZWxsID0+IHtcbiAgICAgICAgICBjZWxsTWFwW2NlbGxdID0gaW5kZXg7XG4gICAgICAgIH0pO1xuICAgICAgICBpdGVtUGxhY2VkID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXJ0SW5kZXgrKztcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIC8vIGNvbnZlcnQgaW50byBhIG5vbi1zcGFyc2UgYXJyYXlcbiAgcmV0dXJuIFsuLi5jZWxsTWFwXTtcbn1cblxuLyoqIEdldHMgY2VsbCBpbmRleCBvZiBhbiBpdGVtJ3MgY29ybmVyIG9yIC0xIHdoZW4gaW5kZXggaXMgLTEuICovXG5mdW5jdGlvbiBnZXRDZWxsSW5kZXhPZkNvcm5lcihpbmRleCwgc2l6ZXMsIGNlbGxNYXAsIGNvbHMsIGNvcm5lcikge1xuICBpZiAoaW5kZXggPT09IC0xKSByZXR1cm4gLTE7XG4gIGNvbnN0IGZpcnN0Q2VsbEluZGV4ID0gY2VsbE1hcC5pbmRleE9mKGluZGV4KTtcbiAgY29uc3Qgc2l6ZUl0ZW0gPSBzaXplc1tpbmRleF07XG4gIHN3aXRjaCAoY29ybmVyKSB7XG4gICAgY2FzZSAndGwnOlxuICAgICAgcmV0dXJuIGZpcnN0Q2VsbEluZGV4O1xuICAgIGNhc2UgJ3RyJzpcbiAgICAgIGlmICghc2l6ZUl0ZW0pIHtcbiAgICAgICAgcmV0dXJuIGZpcnN0Q2VsbEluZGV4O1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZpcnN0Q2VsbEluZGV4ICsgc2l6ZUl0ZW0ud2lkdGggLSAxO1xuICAgIGNhc2UgJ2JsJzpcbiAgICAgIGlmICghc2l6ZUl0ZW0pIHtcbiAgICAgICAgcmV0dXJuIGZpcnN0Q2VsbEluZGV4O1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZpcnN0Q2VsbEluZGV4ICsgKHNpemVJdGVtLmhlaWdodCAtIDEpICogY29scztcbiAgICBjYXNlICdicic6XG4gICAgICByZXR1cm4gY2VsbE1hcC5sYXN0SW5kZXhPZihpbmRleCk7XG4gIH1cbn1cblxuLyoqIEdldHMgYWxsIGNlbGwgaW5kaWNlcyB0aGF0IGNvcnJlc3BvbmQgdG8gdGhlIHNwZWNpZmllZCBpbmRpY2VzICovXG5mdW5jdGlvbiBnZXRDZWxsSW5kaWNlcyhpbmRpY2VzLCBjZWxsTWFwKSB7XG4gIHJldHVybiBjZWxsTWFwLmZsYXRNYXAoKGluZGV4LCBjZWxsSW5kZXgpID0+IGluZGljZXMuaW5jbHVkZXMoaW5kZXgpID8gW2NlbGxJbmRleF0gOiBbXSk7XG59XG5mdW5jdGlvbiBpc0Rpc2FibGVkKGxpc3QsIGluZGV4LCBkaXNhYmxlZEluZGljZXMpIHtcbiAgaWYgKGRpc2FibGVkSW5kaWNlcykge1xuICAgIHJldHVybiBkaXNhYmxlZEluZGljZXMuaW5jbHVkZXMoaW5kZXgpO1xuICB9XG4gIGNvbnN0IGVsZW1lbnQgPSBsaXN0W2luZGV4XTtcbiAgcmV0dXJuIGVsZW1lbnQgPT0gbnVsbCB8fCBlbGVtZW50Lmhhc0F0dHJpYnV0ZSgnZGlzYWJsZWQnKSB8fCBlbGVtZW50LmdldEF0dHJpYnV0ZSgnYXJpYS1kaXNhYmxlZCcpID09PSAndHJ1ZSc7XG59XG5cbnZhciBpbmRleCA9IHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgPyB1c2VMYXlvdXRFZmZlY3QgOiB1c2VFZmZlY3Q7XG5cbmZ1bmN0aW9uIHNvcnRCeURvY3VtZW50UG9zaXRpb24oYSwgYikge1xuICBjb25zdCBwb3NpdGlvbiA9IGEuY29tcGFyZURvY3VtZW50UG9zaXRpb24oYik7XG4gIGlmIChwb3NpdGlvbiAmIE5vZGUuRE9DVU1FTlRfUE9TSVRJT05fRk9MTE9XSU5HIHx8IHBvc2l0aW9uICYgTm9kZS5ET0NVTUVOVF9QT1NJVElPTl9DT05UQUlORURfQlkpIHtcbiAgICByZXR1cm4gLTE7XG4gIH1cbiAgaWYgKHBvc2l0aW9uICYgTm9kZS5ET0NVTUVOVF9QT1NJVElPTl9QUkVDRURJTkcgfHwgcG9zaXRpb24gJiBOb2RlLkRPQ1VNRU5UX1BPU0lUSU9OX0NPTlRBSU5TKSB7XG4gICAgcmV0dXJuIDE7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5mdW5jdGlvbiBhcmVNYXBzRXF1YWwobWFwMSwgbWFwMikge1xuICBpZiAobWFwMS5zaXplICE9PSBtYXAyLnNpemUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgbWFwMS5lbnRyaWVzKCkpIHtcbiAgICBpZiAodmFsdWUgIT09IG1hcDIuZ2V0KGtleSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5jb25zdCBGbG9hdGluZ0xpc3RDb250ZXh0ID0gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUNvbnRleHQoe1xuICByZWdpc3RlcjogKCkgPT4ge30sXG4gIHVucmVnaXN0ZXI6ICgpID0+IHt9LFxuICBtYXA6IC8qI19fUFVSRV9fKi9uZXcgTWFwKCksXG4gIGVsZW1lbnRzUmVmOiB7XG4gICAgY3VycmVudDogW11cbiAgfVxufSk7XG4vKipcbiAqIFByb3ZpZGVzIGNvbnRleHQgZm9yIGEgbGlzdCBvZiBpdGVtcyB3aXRoaW4gdGhlIGZsb2F0aW5nIGVsZW1lbnQuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvRmxvYXRpbmdMaXN0XG4gKi9cbmZ1bmN0aW9uIEZsb2F0aW5nTGlzdChwcm9wcykge1xuICBjb25zdCB7XG4gICAgY2hpbGRyZW4sXG4gICAgZWxlbWVudHNSZWYsXG4gICAgbGFiZWxzUmVmXG4gIH0gPSBwcm9wcztcbiAgY29uc3QgW21hcCwgc2V0TWFwXSA9IFJlYWN0LnVzZVN0YXRlKCgpID0+IG5ldyBNYXAoKSk7XG4gIGNvbnN0IHJlZ2lzdGVyID0gUmVhY3QudXNlQ2FsbGJhY2sobm9kZSA9PiB7XG4gICAgc2V0TWFwKHByZXZNYXAgPT4gbmV3IE1hcChwcmV2TWFwKS5zZXQobm9kZSwgbnVsbCkpO1xuICB9LCBbXSk7XG4gIGNvbnN0IHVucmVnaXN0ZXIgPSBSZWFjdC51c2VDYWxsYmFjayhub2RlID0+IHtcbiAgICBzZXRNYXAocHJldk1hcCA9PiB7XG4gICAgICBjb25zdCBtYXAgPSBuZXcgTWFwKHByZXZNYXApO1xuICAgICAgbWFwLmRlbGV0ZShub2RlKTtcbiAgICAgIHJldHVybiBtYXA7XG4gICAgfSk7XG4gIH0sIFtdKTtcbiAgaW5kZXgoKCkgPT4ge1xuICAgIGNvbnN0IG5ld01hcCA9IG5ldyBNYXAobWFwKTtcbiAgICBjb25zdCBub2RlcyA9IEFycmF5LmZyb20obmV3TWFwLmtleXMoKSkuc29ydChzb3J0QnlEb2N1bWVudFBvc2l0aW9uKTtcbiAgICBub2Rlcy5mb3JFYWNoKChub2RlLCBpbmRleCkgPT4ge1xuICAgICAgbmV3TWFwLnNldChub2RlLCBpbmRleCk7XG4gICAgfSk7XG4gICAgaWYgKCFhcmVNYXBzRXF1YWwobWFwLCBuZXdNYXApKSB7XG4gICAgICBzZXRNYXAobmV3TWFwKTtcbiAgICB9XG4gIH0sIFttYXBdKTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KEZsb2F0aW5nTGlzdENvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogUmVhY3QudXNlTWVtbygoKSA9PiAoe1xuICAgICAgcmVnaXN0ZXIsXG4gICAgICB1bnJlZ2lzdGVyLFxuICAgICAgbWFwLFxuICAgICAgZWxlbWVudHNSZWYsXG4gICAgICBsYWJlbHNSZWZcbiAgICB9KSwgW3JlZ2lzdGVyLCB1bnJlZ2lzdGVyLCBtYXAsIGVsZW1lbnRzUmVmLCBsYWJlbHNSZWZdKVxuICB9LCBjaGlsZHJlbik7XG59XG4vKipcbiAqIFVzZWQgdG8gcmVnaXN0ZXIgYSBsaXN0IGl0ZW0gYW5kIGl0cyBpbmRleCAoRE9NIHBvc2l0aW9uKSBpbiB0aGVcbiAqIGBGbG9hdGluZ0xpc3RgLlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL0Zsb2F0aW5nTGlzdCN1c2VsaXN0aXRlbVxuICovXG5mdW5jdGlvbiB1c2VMaXN0SXRlbShwcm9wcykge1xuICBpZiAocHJvcHMgPT09IHZvaWQgMCkge1xuICAgIHByb3BzID0ge307XG4gIH1cbiAgY29uc3Qge1xuICAgIGxhYmVsXG4gIH0gPSBwcm9wcztcbiAgY29uc3Qge1xuICAgIHJlZ2lzdGVyLFxuICAgIHVucmVnaXN0ZXIsXG4gICAgbWFwLFxuICAgIGVsZW1lbnRzUmVmLFxuICAgIGxhYmVsc1JlZlxuICB9ID0gUmVhY3QudXNlQ29udGV4dChGbG9hdGluZ0xpc3RDb250ZXh0KTtcbiAgY29uc3QgW2luZGV4JDEsIHNldEluZGV4XSA9IFJlYWN0LnVzZVN0YXRlKG51bGwpO1xuICBjb25zdCBjb21wb25lbnRSZWYgPSBSZWFjdC51c2VSZWYobnVsbCk7XG4gIGNvbnN0IHJlZiA9IFJlYWN0LnVzZUNhbGxiYWNrKG5vZGUgPT4ge1xuICAgIGNvbXBvbmVudFJlZi5jdXJyZW50ID0gbm9kZTtcbiAgICBpZiAoaW5kZXgkMSAhPT0gbnVsbCkge1xuICAgICAgZWxlbWVudHNSZWYuY3VycmVudFtpbmRleCQxXSA9IG5vZGU7XG4gICAgICBpZiAobGFiZWxzUmVmKSB7XG4gICAgICAgIHZhciBfbm9kZSR0ZXh0Q29udGVudDtcbiAgICAgICAgY29uc3QgaXNMYWJlbERlZmluZWQgPSBsYWJlbCAhPT0gdW5kZWZpbmVkO1xuICAgICAgICBsYWJlbHNSZWYuY3VycmVudFtpbmRleCQxXSA9IGlzTGFiZWxEZWZpbmVkID8gbGFiZWwgOiAoX25vZGUkdGV4dENvbnRlbnQgPSBub2RlID09IG51bGwgPyB2b2lkIDAgOiBub2RlLnRleHRDb250ZW50KSAhPSBudWxsID8gX25vZGUkdGV4dENvbnRlbnQgOiBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgfSwgW2luZGV4JDEsIGVsZW1lbnRzUmVmLCBsYWJlbHNSZWYsIGxhYmVsXSk7XG4gIGluZGV4KCgpID0+IHtcbiAgICBjb25zdCBub2RlID0gY29tcG9uZW50UmVmLmN1cnJlbnQ7XG4gICAgaWYgKG5vZGUpIHtcbiAgICAgIHJlZ2lzdGVyKG5vZGUpO1xuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgdW5yZWdpc3Rlcihub2RlKTtcbiAgICAgIH07XG4gICAgfVxuICB9LCBbcmVnaXN0ZXIsIHVucmVnaXN0ZXJdKTtcbiAgaW5kZXgoKCkgPT4ge1xuICAgIGNvbnN0IGluZGV4ID0gY29tcG9uZW50UmVmLmN1cnJlbnQgPyBtYXAuZ2V0KGNvbXBvbmVudFJlZi5jdXJyZW50KSA6IG51bGw7XG4gICAgaWYgKGluZGV4ICE9IG51bGwpIHtcbiAgICAgIHNldEluZGV4KGluZGV4KTtcbiAgICB9XG4gIH0sIFttYXBdKTtcbiAgcmV0dXJuIFJlYWN0LnVzZU1lbW8oKCkgPT4gKHtcbiAgICByZWYsXG4gICAgaW5kZXg6IGluZGV4JDEgPT0gbnVsbCA/IC0xIDogaW5kZXgkMVxuICB9KSwgW2luZGV4JDEsIHJlZl0pO1xufVxuXG5mdW5jdGlvbiByZW5kZXJKc3gocmVuZGVyLCBjb21wdXRlZFByb3BzKSB7XG4gIGlmICh0eXBlb2YgcmVuZGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHJlbmRlcihjb21wdXRlZFByb3BzKTtcbiAgfVxuICBpZiAocmVuZGVyKSB7XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jbG9uZUVsZW1lbnQocmVuZGVyLCBjb21wdXRlZFByb3BzKTtcbiAgfVxuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgY29tcHV0ZWRQcm9wcyk7XG59XG5jb25zdCBDb21wb3NpdGVDb250ZXh0ID0gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUNvbnRleHQoe1xuICBhY3RpdmVJbmRleDogMCxcbiAgb25OYXZpZ2F0ZTogKCkgPT4ge31cbn0pO1xuY29uc3QgaG9yaXpvbnRhbEtleXMgPSBbQVJST1dfTEVGVCwgQVJST1dfUklHSFRdO1xuY29uc3QgdmVydGljYWxLZXlzID0gW0FSUk9XX1VQLCBBUlJPV19ET1dOXTtcbmNvbnN0IGFsbEtleXMgPSBbLi4uaG9yaXpvbnRhbEtleXMsIC4uLnZlcnRpY2FsS2V5c107XG5cbi8qKlxuICogQ3JlYXRlcyBhIHNpbmdsZSB0YWIgc3RvcCB3aG9zZSBpdGVtcyBhcmUgbmF2aWdhdGVkIGJ5IGFycm93IGtleXMsIHdoaWNoXG4gKiBwcm92aWRlcyBsaXN0IG5hdmlnYXRpb24gb3V0c2lkZSBvZiBmbG9hdGluZyBlbGVtZW50IGNvbnRleHRzLlxuICpcbiAqIFRoaXMgaXMgdXNlZnVsIHRvIGVuYWJsZSBuYXZpZ2F0aW9uIG9mIGEgbGlzdCBvZiBpdGVtcyB0aGF0IGFyZW7igJl0IHBhcnQgb2YgYVxuICogZmxvYXRpbmcgZWxlbWVudC4gQSBtZW51YmFyIGlzIGFuIGV4YW1wbGUgb2YgYSBjb21wb3NpdGUsIHdpdGggZWFjaCByZWZlcmVuY2VcbiAqIGVsZW1lbnQgYmVpbmcgYW4gaXRlbS5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9Db21wb3NpdGVcbiAqL1xuY29uc3QgQ29tcG9zaXRlID0gLyojX19QVVJFX18qL1JlYWN0LmZvcndhcmRSZWYoZnVuY3Rpb24gQ29tcG9zaXRlKHByb3BzLCBmb3J3YXJkZWRSZWYpIHtcbiAgY29uc3Qge1xuICAgIHJlbmRlcixcbiAgICBvcmllbnRhdGlvbiA9ICdib3RoJyxcbiAgICBsb29wID0gdHJ1ZSxcbiAgICBydGwgPSBmYWxzZSxcbiAgICBjb2xzID0gMSxcbiAgICBkaXNhYmxlZEluZGljZXMsXG4gICAgYWN0aXZlSW5kZXg6IGV4dGVybmFsQWN0aXZlSW5kZXgsXG4gICAgb25OYXZpZ2F0ZTogZXh0ZXJuYWxTZXRBY3RpdmVJbmRleCxcbiAgICBpdGVtU2l6ZXMsXG4gICAgZGVuc2UgPSBmYWxzZSxcbiAgICAuLi5kb21Qcm9wc1xuICB9ID0gcHJvcHM7XG4gIGNvbnN0IFtpbnRlcm5hbEFjdGl2ZUluZGV4LCBpbnRlcm5hbFNldEFjdGl2ZUluZGV4XSA9IFJlYWN0LnVzZVN0YXRlKDApO1xuICBjb25zdCBhY3RpdmVJbmRleCA9IGV4dGVybmFsQWN0aXZlSW5kZXggIT0gbnVsbCA/IGV4dGVybmFsQWN0aXZlSW5kZXggOiBpbnRlcm5hbEFjdGl2ZUluZGV4O1xuICBjb25zdCBvbk5hdmlnYXRlID0gdXNlRWZmZWN0RXZlbnQoZXh0ZXJuYWxTZXRBY3RpdmVJbmRleCAhPSBudWxsID8gZXh0ZXJuYWxTZXRBY3RpdmVJbmRleCA6IGludGVybmFsU2V0QWN0aXZlSW5kZXgpO1xuICBjb25zdCBlbGVtZW50c1JlZiA9IFJlYWN0LnVzZVJlZihbXSk7XG4gIGNvbnN0IHJlbmRlckVsZW1lbnRQcm9wcyA9IHJlbmRlciAmJiB0eXBlb2YgcmVuZGVyICE9PSAnZnVuY3Rpb24nID8gcmVuZGVyLnByb3BzIDoge307XG4gIGNvbnN0IGNvbnRleHRWYWx1ZSA9IFJlYWN0LnVzZU1lbW8oKCkgPT4gKHtcbiAgICBhY3RpdmVJbmRleCxcbiAgICBvbk5hdmlnYXRlXG4gIH0pLCBbYWN0aXZlSW5kZXgsIG9uTmF2aWdhdGVdKTtcbiAgY29uc3QgaXNHcmlkID0gY29scyA+IDE7XG4gIGZ1bmN0aW9uIGhhbmRsZUtleURvd24oZXZlbnQpIHtcbiAgICBpZiAoIWFsbEtleXMuaW5jbHVkZXMoZXZlbnQua2V5KSkgcmV0dXJuO1xuICAgIGxldCBuZXh0SW5kZXggPSBhY3RpdmVJbmRleDtcbiAgICBjb25zdCBtaW5JbmRleCA9IGdldE1pbkluZGV4KGVsZW1lbnRzUmVmLCBkaXNhYmxlZEluZGljZXMpO1xuICAgIGNvbnN0IG1heEluZGV4ID0gZ2V0TWF4SW5kZXgoZWxlbWVudHNSZWYsIGRpc2FibGVkSW5kaWNlcyk7XG4gICAgY29uc3QgaG9yaXpvbnRhbEVuZEtleSA9IHJ0bCA/IEFSUk9XX0xFRlQgOiBBUlJPV19SSUdIVDtcbiAgICBjb25zdCBob3Jpem9udGFsU3RhcnRLZXkgPSBydGwgPyBBUlJPV19SSUdIVCA6IEFSUk9XX0xFRlQ7XG4gICAgaWYgKGlzR3JpZCkge1xuICAgICAgY29uc3Qgc2l6ZXMgPSBpdGVtU2l6ZXMgfHwgQXJyYXkuZnJvbSh7XG4gICAgICAgIGxlbmd0aDogZWxlbWVudHNSZWYuY3VycmVudC5sZW5ndGhcbiAgICAgIH0sICgpID0+ICh7XG4gICAgICAgIHdpZHRoOiAxLFxuICAgICAgICBoZWlnaHQ6IDFcbiAgICAgIH0pKTtcbiAgICAgIC8vIFRvIGNhbGN1bGF0ZSBtb3ZlbWVudHMgb24gdGhlIGdyaWQsIHdlIHVzZSBoeXBvdGhldGljYWwgY2VsbCBpbmRpY2VzXG4gICAgICAvLyBhcyBpZiBldmVyeSBpdGVtIHdhcyAxeDEsIHRoZW4gY29udmVydCBiYWNrIHRvIHJlYWwgaW5kaWNlcy5cbiAgICAgIGNvbnN0IGNlbGxNYXAgPSBidWlsZENlbGxNYXAoc2l6ZXMsIGNvbHMsIGRlbnNlKTtcbiAgICAgIGNvbnN0IG1pbkdyaWRJbmRleCA9IGNlbGxNYXAuZmluZEluZGV4KGluZGV4ID0+IGluZGV4ICE9IG51bGwgJiYgIWlzRGlzYWJsZWQoZWxlbWVudHNSZWYuY3VycmVudCwgaW5kZXgsIGRpc2FibGVkSW5kaWNlcykpO1xuICAgICAgLy8gbGFzdCBlbmFibGVkIGluZGV4XG4gICAgICBjb25zdCBtYXhHcmlkSW5kZXggPSBjZWxsTWFwLnJlZHVjZSgoZm91bmRJbmRleCwgaW5kZXgsIGNlbGxJbmRleCkgPT4gaW5kZXggIT0gbnVsbCAmJiAhaXNEaXNhYmxlZChlbGVtZW50c1JlZi5jdXJyZW50LCBpbmRleCwgZGlzYWJsZWRJbmRpY2VzKSA/IGNlbGxJbmRleCA6IGZvdW5kSW5kZXgsIC0xKTtcbiAgICAgIGNvbnN0IG1heWJlTmV4dEluZGV4ID0gY2VsbE1hcFtnZXRHcmlkTmF2aWdhdGVkSW5kZXgoe1xuICAgICAgICBjdXJyZW50OiBjZWxsTWFwLm1hcChpdGVtSW5kZXggPT4gaXRlbUluZGV4ID8gZWxlbWVudHNSZWYuY3VycmVudFtpdGVtSW5kZXhdIDogbnVsbClcbiAgICAgIH0sIHtcbiAgICAgICAgZXZlbnQsXG4gICAgICAgIG9yaWVudGF0aW9uLFxuICAgICAgICBsb29wLFxuICAgICAgICBydGwsXG4gICAgICAgIGNvbHMsXG4gICAgICAgIC8vIHRyZWF0IHVuZGVmaW5lZCAoZW1wdHkgZ3JpZCBzcGFjZXMpIGFzIGRpc2FibGVkIGluZGljZXMgc28gd2VcbiAgICAgICAgLy8gZG9uJ3QgZW5kIHVwIGluIHRoZW1cbiAgICAgICAgZGlzYWJsZWRJbmRpY2VzOiBnZXRDZWxsSW5kaWNlcyhbLi4uKGRpc2FibGVkSW5kaWNlcyB8fCBlbGVtZW50c1JlZi5jdXJyZW50Lm1hcCgoXywgaW5kZXgpID0+IGlzRGlzYWJsZWQoZWxlbWVudHNSZWYuY3VycmVudCwgaW5kZXgpID8gaW5kZXggOiB1bmRlZmluZWQpKSwgdW5kZWZpbmVkXSwgY2VsbE1hcCksXG4gICAgICAgIG1pbkluZGV4OiBtaW5HcmlkSW5kZXgsXG4gICAgICAgIG1heEluZGV4OiBtYXhHcmlkSW5kZXgsXG4gICAgICAgIHByZXZJbmRleDogZ2V0Q2VsbEluZGV4T2ZDb3JuZXIoYWN0aXZlSW5kZXggPiBtYXhJbmRleCA/IG1pbkluZGV4IDogYWN0aXZlSW5kZXgsIHNpemVzLCBjZWxsTWFwLCBjb2xzLFxuICAgICAgICAvLyB1c2UgYSBjb3JuZXIgbWF0Y2hpbmcgdGhlIGVkZ2UgY2xvc2VzdCB0byB0aGUgZGlyZWN0aW9uIHdlJ3JlXG4gICAgICAgIC8vIG1vdmluZyBpbiBzbyB3ZSBkb24ndCBlbmQgdXAgaW4gdGhlIHNhbWUgaXRlbS4gUHJlZmVyXG4gICAgICAgIC8vIHRvcC9sZWZ0IG92ZXIgYm90dG9tL3JpZ2h0LlxuICAgICAgICBldmVudC5rZXkgPT09IEFSUk9XX0RPV04gPyAnYmwnIDogZXZlbnQua2V5ID09PSBob3Jpem9udGFsRW5kS2V5ID8gJ3RyJyA6ICd0bCcpXG4gICAgICB9KV07XG4gICAgICBpZiAobWF5YmVOZXh0SW5kZXggIT0gbnVsbCkge1xuICAgICAgICBuZXh0SW5kZXggPSBtYXliZU5leHRJbmRleDtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgdG9FbmRLZXlzID0ge1xuICAgICAgaG9yaXpvbnRhbDogW2hvcml6b250YWxFbmRLZXldLFxuICAgICAgdmVydGljYWw6IFtBUlJPV19ET1dOXSxcbiAgICAgIGJvdGg6IFtob3Jpem9udGFsRW5kS2V5LCBBUlJPV19ET1dOXVxuICAgIH1bb3JpZW50YXRpb25dO1xuICAgIGNvbnN0IHRvU3RhcnRLZXlzID0ge1xuICAgICAgaG9yaXpvbnRhbDogW2hvcml6b250YWxTdGFydEtleV0sXG4gICAgICB2ZXJ0aWNhbDogW0FSUk9XX1VQXSxcbiAgICAgIGJvdGg6IFtob3Jpem9udGFsU3RhcnRLZXksIEFSUk9XX1VQXVxuICAgIH1bb3JpZW50YXRpb25dO1xuICAgIGNvbnN0IHByZXZlbnRlZEtleXMgPSBpc0dyaWQgPyBhbGxLZXlzIDoge1xuICAgICAgaG9yaXpvbnRhbDogaG9yaXpvbnRhbEtleXMsXG4gICAgICB2ZXJ0aWNhbDogdmVydGljYWxLZXlzLFxuICAgICAgYm90aDogYWxsS2V5c1xuICAgIH1bb3JpZW50YXRpb25dO1xuICAgIGlmIChuZXh0SW5kZXggPT09IGFjdGl2ZUluZGV4ICYmIFsuLi50b0VuZEtleXMsIC4uLnRvU3RhcnRLZXlzXS5pbmNsdWRlcyhldmVudC5rZXkpKSB7XG4gICAgICBpZiAobG9vcCAmJiBuZXh0SW5kZXggPT09IG1heEluZGV4ICYmIHRvRW5kS2V5cy5pbmNsdWRlcyhldmVudC5rZXkpKSB7XG4gICAgICAgIG5leHRJbmRleCA9IG1pbkluZGV4O1xuICAgICAgfSBlbHNlIGlmIChsb29wICYmIG5leHRJbmRleCA9PT0gbWluSW5kZXggJiYgdG9TdGFydEtleXMuaW5jbHVkZXMoZXZlbnQua2V5KSkge1xuICAgICAgICBuZXh0SW5kZXggPSBtYXhJbmRleDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5leHRJbmRleCA9IGZpbmROb25EaXNhYmxlZEluZGV4KGVsZW1lbnRzUmVmLCB7XG4gICAgICAgICAgc3RhcnRpbmdJbmRleDogbmV4dEluZGV4LFxuICAgICAgICAgIGRlY3JlbWVudDogdG9TdGFydEtleXMuaW5jbHVkZXMoZXZlbnQua2V5KSxcbiAgICAgICAgICBkaXNhYmxlZEluZGljZXNcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChuZXh0SW5kZXggIT09IGFjdGl2ZUluZGV4ICYmICFpc0luZGV4T3V0T2ZCb3VuZHMoZWxlbWVudHNSZWYsIG5leHRJbmRleCkpIHtcbiAgICAgIHZhciBfZWxlbWVudHNSZWYkY3VycmVudCQ7XG4gICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgIGlmIChwcmV2ZW50ZWRLZXlzLmluY2x1ZGVzKGV2ZW50LmtleSkpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIH1cbiAgICAgIG9uTmF2aWdhdGUobmV4dEluZGV4KTtcbiAgICAgIChfZWxlbWVudHNSZWYkY3VycmVudCQgPSBlbGVtZW50c1JlZi5jdXJyZW50W25leHRJbmRleF0pID09IG51bGwgfHwgX2VsZW1lbnRzUmVmJGN1cnJlbnQkLmZvY3VzKCk7XG4gICAgfVxuICB9XG4gIGNvbnN0IGNvbXB1dGVkUHJvcHMgPSB7XG4gICAgLi4uZG9tUHJvcHMsXG4gICAgLi4ucmVuZGVyRWxlbWVudFByb3BzLFxuICAgIHJlZjogZm9yd2FyZGVkUmVmLFxuICAgICdhcmlhLW9yaWVudGF0aW9uJzogb3JpZW50YXRpb24gPT09ICdib3RoJyA/IHVuZGVmaW5lZCA6IG9yaWVudGF0aW9uLFxuICAgIG9uS2V5RG93bihlKSB7XG4gICAgICBkb21Qcm9wcy5vbktleURvd24gPT0gbnVsbCB8fCBkb21Qcm9wcy5vbktleURvd24oZSk7XG4gICAgICByZW5kZXJFbGVtZW50UHJvcHMub25LZXlEb3duID09IG51bGwgfHwgcmVuZGVyRWxlbWVudFByb3BzLm9uS2V5RG93bihlKTtcbiAgICAgIGhhbmRsZUtleURvd24oZSk7XG4gICAgfVxuICB9O1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoQ29tcG9zaXRlQ29udGV4dC5Qcm92aWRlciwge1xuICAgIHZhbHVlOiBjb250ZXh0VmFsdWVcbiAgfSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoRmxvYXRpbmdMaXN0LCB7XG4gICAgZWxlbWVudHNSZWY6IGVsZW1lbnRzUmVmXG4gIH0sIHJlbmRlckpzeChyZW5kZXIsIGNvbXB1dGVkUHJvcHMpKSk7XG59KTtcbi8qKlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL0NvbXBvc2l0ZVxuICovXG5jb25zdCBDb21wb3NpdGVJdGVtID0gLyojX19QVVJFX18qL1JlYWN0LmZvcndhcmRSZWYoZnVuY3Rpb24gQ29tcG9zaXRlSXRlbShwcm9wcywgZm9yd2FyZGVkUmVmKSB7XG4gIGNvbnN0IHtcbiAgICByZW5kZXIsXG4gICAgLi4uZG9tUHJvcHNcbiAgfSA9IHByb3BzO1xuICBjb25zdCByZW5kZXJFbGVtZW50UHJvcHMgPSByZW5kZXIgJiYgdHlwZW9mIHJlbmRlciAhPT0gJ2Z1bmN0aW9uJyA/IHJlbmRlci5wcm9wcyA6IHt9O1xuICBjb25zdCB7XG4gICAgYWN0aXZlSW5kZXgsXG4gICAgb25OYXZpZ2F0ZVxuICB9ID0gUmVhY3QudXNlQ29udGV4dChDb21wb3NpdGVDb250ZXh0KTtcbiAgY29uc3Qge1xuICAgIHJlZixcbiAgICBpbmRleFxuICB9ID0gdXNlTGlzdEl0ZW0oKTtcbiAgY29uc3QgbWVyZ2VkUmVmID0gdXNlTWVyZ2VSZWZzKFtyZWYsIGZvcndhcmRlZFJlZiwgcmVuZGVyRWxlbWVudFByb3BzLnJlZl0pO1xuICBjb25zdCBpc0FjdGl2ZSA9IGFjdGl2ZUluZGV4ID09PSBpbmRleDtcbiAgY29uc3QgY29tcHV0ZWRQcm9wcyA9IHtcbiAgICAuLi5kb21Qcm9wcyxcbiAgICAuLi5yZW5kZXJFbGVtZW50UHJvcHMsXG4gICAgcmVmOiBtZXJnZWRSZWYsXG4gICAgdGFiSW5kZXg6IGlzQWN0aXZlID8gMCA6IC0xLFxuICAgICdkYXRhLWFjdGl2ZSc6IGlzQWN0aXZlID8gJycgOiB1bmRlZmluZWQsXG4gICAgb25Gb2N1cyhlKSB7XG4gICAgICBkb21Qcm9wcy5vbkZvY3VzID09IG51bGwgfHwgZG9tUHJvcHMub25Gb2N1cyhlKTtcbiAgICAgIHJlbmRlckVsZW1lbnRQcm9wcy5vbkZvY3VzID09IG51bGwgfHwgcmVuZGVyRWxlbWVudFByb3BzLm9uRm9jdXMoZSk7XG4gICAgICBvbk5hdmlnYXRlKGluZGV4KTtcbiAgICB9XG4gIH07XG4gIHJldHVybiByZW5kZXJKc3gocmVuZGVyLCBjb21wdXRlZFByb3BzKTtcbn0pO1xuXG5mdW5jdGlvbiBfZXh0ZW5kcygpIHtcbiAgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduID8gT2JqZWN0LmFzc2lnbi5iaW5kKCkgOiBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07XG4gICAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7XG4gICAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9O1xuICByZXR1cm4gX2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxubGV0IHNlcnZlckhhbmRvZmZDb21wbGV0ZSA9IGZhbHNlO1xubGV0IGNvdW50ID0gMDtcbmNvbnN0IGdlbklkID0gKCkgPT4gLy8gRW5zdXJlIHRoZSBpZCBpcyB1bmlxdWUgd2l0aCBtdWx0aXBsZSBpbmRlcGVuZGVudCB2ZXJzaW9ucyBvZiBGbG9hdGluZyBVSVxuLy8gb24gPFJlYWN0IDE4XG5cImZsb2F0aW5nLXVpLVwiICsgTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc2xpY2UoMiwgNikgKyBjb3VudCsrO1xuZnVuY3Rpb24gdXNlRmxvYXRpbmdJZCgpIHtcbiAgY29uc3QgW2lkLCBzZXRJZF0gPSBSZWFjdC51c2VTdGF0ZSgoKSA9PiBzZXJ2ZXJIYW5kb2ZmQ29tcGxldGUgPyBnZW5JZCgpIDogdW5kZWZpbmVkKTtcbiAgaW5kZXgoKCkgPT4ge1xuICAgIGlmIChpZCA9PSBudWxsKSB7XG4gICAgICBzZXRJZChnZW5JZCgpKTtcbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICB9LCBbXSk7XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgc2VydmVySGFuZG9mZkNvbXBsZXRlID0gdHJ1ZTtcbiAgfSwgW10pO1xuICByZXR1cm4gaWQ7XG59XG5jb25zdCB1c2VSZWFjdElkID0gU2FmZVJlYWN0LnVzZUlkO1xuXG4vKipcbiAqIFVzZXMgUmVhY3QgMTgncyBidWlsdC1pbiBgdXNlSWQoKWAgd2hlbiBhdmFpbGFibGUsIG9yIGZhbGxzIGJhY2sgdG8gYVxuICogc2xpZ2h0bHkgbGVzcyBwZXJmb3JtYW50IChyZXF1aXJpbmcgYSBkb3VibGUgcmVuZGVyKSBpbXBsZW1lbnRhdGlvbiBmb3JcbiAqIGVhcmxpZXIgUmVhY3QgdmVyc2lvbnMuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvcmVhY3QtdXRpbHMjdXNlaWRcbiAqL1xuY29uc3QgdXNlSWQgPSB1c2VSZWFjdElkIHx8IHVzZUZsb2F0aW5nSWQ7XG5cbmxldCBkZXZNZXNzYWdlU2V0O1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICBkZXZNZXNzYWdlU2V0ID0gLyojX19QVVJFX18qL25ldyBTZXQoKTtcbn1cbmZ1bmN0aW9uIHdhcm4oKSB7XG4gIHZhciBfZGV2TWVzc2FnZVNldDtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIG1lc3NhZ2VzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIG1lc3NhZ2VzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICB9XG4gIGNvbnN0IG1lc3NhZ2UgPSBcIkZsb2F0aW5nIFVJOiBcIiArIG1lc3NhZ2VzLmpvaW4oJyAnKTtcbiAgaWYgKCEoKF9kZXZNZXNzYWdlU2V0ID0gZGV2TWVzc2FnZVNldCkgIT0gbnVsbCAmJiBfZGV2TWVzc2FnZVNldC5oYXMobWVzc2FnZSkpKSB7XG4gICAgdmFyIF9kZXZNZXNzYWdlU2V0MjtcbiAgICAoX2Rldk1lc3NhZ2VTZXQyID0gZGV2TWVzc2FnZVNldCkgPT0gbnVsbCB8fCBfZGV2TWVzc2FnZVNldDIuYWRkKG1lc3NhZ2UpO1xuICAgIGNvbnNvbGUud2FybihtZXNzYWdlKTtcbiAgfVxufVxuZnVuY3Rpb24gZXJyb3IoKSB7XG4gIHZhciBfZGV2TWVzc2FnZVNldDM7XG4gIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgbWVzc2FnZXMgPSBuZXcgQXJyYXkoX2xlbjIpLCBfa2V5MiA9IDA7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICBtZXNzYWdlc1tfa2V5Ml0gPSBhcmd1bWVudHNbX2tleTJdO1xuICB9XG4gIGNvbnN0IG1lc3NhZ2UgPSBcIkZsb2F0aW5nIFVJOiBcIiArIG1lc3NhZ2VzLmpvaW4oJyAnKTtcbiAgaWYgKCEoKF9kZXZNZXNzYWdlU2V0MyA9IGRldk1lc3NhZ2VTZXQpICE9IG51bGwgJiYgX2Rldk1lc3NhZ2VTZXQzLmhhcyhtZXNzYWdlKSkpIHtcbiAgICB2YXIgX2Rldk1lc3NhZ2VTZXQ0O1xuICAgIChfZGV2TWVzc2FnZVNldDQgPSBkZXZNZXNzYWdlU2V0KSA9PSBudWxsIHx8IF9kZXZNZXNzYWdlU2V0NC5hZGQobWVzc2FnZSk7XG4gICAgY29uc29sZS5lcnJvcihtZXNzYWdlKTtcbiAgfVxufVxuXG4vKipcbiAqIFJlbmRlcnMgYSBwb2ludGluZyBhcnJvdyB0cmlhbmdsZS5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9GbG9hdGluZ0Fycm93XG4gKi9cbmNvbnN0IEZsb2F0aW5nQXJyb3cgPSAvKiNfX1BVUkVfXyovUmVhY3QuZm9yd2FyZFJlZihmdW5jdGlvbiBGbG9hdGluZ0Fycm93KHByb3BzLCByZWYpIHtcbiAgY29uc3Qge1xuICAgIGNvbnRleHQ6IHtcbiAgICAgIHBsYWNlbWVudCxcbiAgICAgIGVsZW1lbnRzOiB7XG4gICAgICAgIGZsb2F0aW5nXG4gICAgICB9LFxuICAgICAgbWlkZGxld2FyZURhdGE6IHtcbiAgICAgICAgYXJyb3csXG4gICAgICAgIHNoaWZ0XG4gICAgICB9XG4gICAgfSxcbiAgICB3aWR0aCA9IDE0LFxuICAgIGhlaWdodCA9IDcsXG4gICAgdGlwUmFkaXVzID0gMCxcbiAgICBzdHJva2VXaWR0aCA9IDAsXG4gICAgc3RhdGljT2Zmc2V0LFxuICAgIHN0cm9rZSxcbiAgICBkLFxuICAgIHN0eWxlOiB7XG4gICAgICB0cmFuc2Zvcm0sXG4gICAgICAuLi5yZXN0U3R5bGVcbiAgICB9ID0ge30sXG4gICAgLi4ucmVzdFxuICB9ID0gcHJvcHM7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICBpZiAoIXJlZikge1xuICAgICAgd2FybignVGhlIGByZWZgIHByb3AgaXMgcmVxdWlyZWQgZm9yIGBGbG9hdGluZ0Fycm93YC4nKTtcbiAgICB9XG4gIH1cbiAgY29uc3QgY2xpcFBhdGhJZCA9IHVzZUlkKCk7XG4gIGNvbnN0IFtpc1JUTCwgc2V0SXNSVExdID0gUmVhY3QudXNlU3RhdGUoZmFsc2UpO1xuXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mbG9hdGluZy11aS9mbG9hdGluZy11aS9pc3N1ZXMvMjkzMlxuICBpbmRleCgoKSA9PiB7XG4gICAgaWYgKCFmbG9hdGluZykgcmV0dXJuO1xuICAgIGNvbnN0IGlzUlRMID0gZ2V0Q29tcHV0ZWRTdHlsZShmbG9hdGluZykuZGlyZWN0aW9uID09PSAncnRsJztcbiAgICBpZiAoaXNSVEwpIHtcbiAgICAgIHNldElzUlRMKHRydWUpO1xuICAgIH1cbiAgfSwgW2Zsb2F0aW5nXSk7XG4gIGlmICghZmxvYXRpbmcpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdCBbc2lkZSwgYWxpZ25tZW50XSA9IHBsYWNlbWVudC5zcGxpdCgnLScpO1xuICBjb25zdCBpc1ZlcnRpY2FsU2lkZSA9IHNpZGUgPT09ICd0b3AnIHx8IHNpZGUgPT09ICdib3R0b20nO1xuICBsZXQgY29tcHV0ZWRTdGF0aWNPZmZzZXQgPSBzdGF0aWNPZmZzZXQ7XG4gIGlmIChpc1ZlcnRpY2FsU2lkZSAmJiBzaGlmdCAhPSBudWxsICYmIHNoaWZ0LnggfHwgIWlzVmVydGljYWxTaWRlICYmIHNoaWZ0ICE9IG51bGwgJiYgc2hpZnQueSkge1xuICAgIGNvbXB1dGVkU3RhdGljT2Zmc2V0ID0gbnVsbDtcbiAgfVxuXG4gIC8vIFN0cm9rZXMgbXVzdCBiZSBkb3VibGUgdGhlIGJvcmRlciB3aWR0aCwgdGhpcyBlbnN1cmVzIHRoZSBzdHJva2UncyB3aWR0aFxuICAvLyB3b3JrcyBhcyB5b3UnZCBleHBlY3QuXG4gIGNvbnN0IGNvbXB1dGVkU3Ryb2tlV2lkdGggPSBzdHJva2VXaWR0aCAqIDI7XG4gIGNvbnN0IGhhbGZTdHJva2VXaWR0aCA9IGNvbXB1dGVkU3Ryb2tlV2lkdGggLyAyO1xuICBjb25zdCBzdmdYID0gd2lkdGggLyAyICogKHRpcFJhZGl1cyAvIC04ICsgMSk7XG4gIGNvbnN0IHN2Z1kgPSBoZWlnaHQgLyAyICogdGlwUmFkaXVzIC8gNDtcbiAgY29uc3QgaXNDdXN0b21TaGFwZSA9ICEhZDtcbiAgY29uc3QgeU9mZnNldFByb3AgPSBjb21wdXRlZFN0YXRpY09mZnNldCAmJiBhbGlnbm1lbnQgPT09ICdlbmQnID8gJ2JvdHRvbScgOiAndG9wJztcbiAgbGV0IHhPZmZzZXRQcm9wID0gY29tcHV0ZWRTdGF0aWNPZmZzZXQgJiYgYWxpZ25tZW50ID09PSAnZW5kJyA/ICdyaWdodCcgOiAnbGVmdCc7XG4gIGlmIChjb21wdXRlZFN0YXRpY09mZnNldCAmJiBpc1JUTCkge1xuICAgIHhPZmZzZXRQcm9wID0gYWxpZ25tZW50ID09PSAnZW5kJyA/ICdsZWZ0JyA6ICdyaWdodCc7XG4gIH1cbiAgY29uc3QgYXJyb3dYID0gKGFycm93ID09IG51bGwgPyB2b2lkIDAgOiBhcnJvdy54KSAhPSBudWxsID8gY29tcHV0ZWRTdGF0aWNPZmZzZXQgfHwgYXJyb3cueCA6ICcnO1xuICBjb25zdCBhcnJvd1kgPSAoYXJyb3cgPT0gbnVsbCA/IHZvaWQgMCA6IGFycm93LnkpICE9IG51bGwgPyBjb21wdXRlZFN0YXRpY09mZnNldCB8fCBhcnJvdy55IDogJyc7XG4gIGNvbnN0IGRWYWx1ZSA9IGQgfHwgJ00wLDAnICsgKFwiIEhcIiArIHdpZHRoKSArIChcIiBMXCIgKyAod2lkdGggLSBzdmdYKSArIFwiLFwiICsgKGhlaWdodCAtIHN2Z1kpKSArIChcIiBRXCIgKyB3aWR0aCAvIDIgKyBcIixcIiArIGhlaWdodCArIFwiIFwiICsgc3ZnWCArIFwiLFwiICsgKGhlaWdodCAtIHN2Z1kpKSArICcgWic7XG4gIGNvbnN0IHJvdGF0aW9uID0ge1xuICAgIHRvcDogaXNDdXN0b21TaGFwZSA/ICdyb3RhdGUoMTgwZGVnKScgOiAnJyxcbiAgICBsZWZ0OiBpc0N1c3RvbVNoYXBlID8gJ3JvdGF0ZSg5MGRlZyknIDogJ3JvdGF0ZSgtOTBkZWcpJyxcbiAgICBib3R0b206IGlzQ3VzdG9tU2hhcGUgPyAnJyA6ICdyb3RhdGUoMTgwZGVnKScsXG4gICAgcmlnaHQ6IGlzQ3VzdG9tU2hhcGUgPyAncm90YXRlKC05MGRlZyknIDogJ3JvdGF0ZSg5MGRlZyknXG4gIH1bc2lkZV07XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcInN2Z1wiLCBfZXh0ZW5kcyh7fSwgcmVzdCwge1xuICAgIFwiYXJpYS1oaWRkZW5cIjogdHJ1ZSxcbiAgICByZWY6IHJlZixcbiAgICB3aWR0aDogaXNDdXN0b21TaGFwZSA/IHdpZHRoIDogd2lkdGggKyBjb21wdXRlZFN0cm9rZVdpZHRoLFxuICAgIGhlaWdodDogd2lkdGgsXG4gICAgdmlld0JveDogXCIwIDAgXCIgKyB3aWR0aCArIFwiIFwiICsgKGhlaWdodCA+IHdpZHRoID8gaGVpZ2h0IDogd2lkdGgpLFxuICAgIHN0eWxlOiB7XG4gICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgIHBvaW50ZXJFdmVudHM6ICdub25lJyxcbiAgICAgIFt4T2Zmc2V0UHJvcF06IGFycm93WCxcbiAgICAgIFt5T2Zmc2V0UHJvcF06IGFycm93WSxcbiAgICAgIFtzaWRlXTogaXNWZXJ0aWNhbFNpZGUgfHwgaXNDdXN0b21TaGFwZSA/ICcxMDAlJyA6IFwiY2FsYygxMDAlIC0gXCIgKyBjb21wdXRlZFN0cm9rZVdpZHRoIC8gMiArIFwicHgpXCIsXG4gICAgICB0cmFuc2Zvcm06IFtyb3RhdGlvbiwgdHJhbnNmb3JtXS5maWx0ZXIodCA9PiAhIXQpLmpvaW4oJyAnKSxcbiAgICAgIC4uLnJlc3RTdHlsZVxuICAgIH1cbiAgfSksIGNvbXB1dGVkU3Ryb2tlV2lkdGggPiAwICYmIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwicGF0aFwiLCB7XG4gICAgY2xpcFBhdGg6IFwidXJsKCNcIiArIGNsaXBQYXRoSWQgKyBcIilcIixcbiAgICBmaWxsOiBcIm5vbmVcIixcbiAgICBzdHJva2U6IHN0cm9rZVxuICAgIC8vIEFjY291bnQgZm9yIHRoZSBzdHJva2Ugb24gdGhlIGZpbGwgcGF0aCByZW5kZXJlZCBiZWxvdy5cbiAgICAsXG4gICAgc3Ryb2tlV2lkdGg6IGNvbXB1dGVkU3Ryb2tlV2lkdGggKyAoZCA/IDAgOiAxKSxcbiAgICBkOiBkVmFsdWVcbiAgfSksIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwicGF0aFwiLCB7XG4gICAgc3Ryb2tlOiBjb21wdXRlZFN0cm9rZVdpZHRoICYmICFkID8gcmVzdC5maWxsIDogJ25vbmUnLFxuICAgIGQ6IGRWYWx1ZVxuICB9KSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJjbGlwUGF0aFwiLCB7XG4gICAgaWQ6IGNsaXBQYXRoSWRcbiAgfSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJyZWN0XCIsIHtcbiAgICB4OiAtaGFsZlN0cm9rZVdpZHRoLFxuICAgIHk6IGhhbGZTdHJva2VXaWR0aCAqIChpc0N1c3RvbVNoYXBlID8gLTEgOiAxKSxcbiAgICB3aWR0aDogd2lkdGggKyBjb21wdXRlZFN0cm9rZVdpZHRoLFxuICAgIGhlaWdodDogd2lkdGhcbiAgfSkpKTtcbn0pO1xuXG5mdW5jdGlvbiBjcmVhdGVQdWJTdWIoKSB7XG4gIGNvbnN0IG1hcCA9IG5ldyBNYXAoKTtcbiAgcmV0dXJuIHtcbiAgICBlbWl0KGV2ZW50LCBkYXRhKSB7XG4gICAgICB2YXIgX21hcCRnZXQ7XG4gICAgICAoX21hcCRnZXQgPSBtYXAuZ2V0KGV2ZW50KSkgPT0gbnVsbCB8fCBfbWFwJGdldC5mb3JFYWNoKGhhbmRsZXIgPT4gaGFuZGxlcihkYXRhKSk7XG4gICAgfSxcbiAgICBvbihldmVudCwgbGlzdGVuZXIpIHtcbiAgICAgIG1hcC5zZXQoZXZlbnQsIFsuLi4obWFwLmdldChldmVudCkgfHwgW10pLCBsaXN0ZW5lcl0pO1xuICAgIH0sXG4gICAgb2ZmKGV2ZW50LCBsaXN0ZW5lcikge1xuICAgICAgdmFyIF9tYXAkZ2V0MjtcbiAgICAgIG1hcC5zZXQoZXZlbnQsICgoX21hcCRnZXQyID0gbWFwLmdldChldmVudCkpID09IG51bGwgPyB2b2lkIDAgOiBfbWFwJGdldDIuZmlsdGVyKGwgPT4gbCAhPT0gbGlzdGVuZXIpKSB8fCBbXSk7XG4gICAgfVxuICB9O1xufVxuXG5jb25zdCBGbG9hdGluZ05vZGVDb250ZXh0ID0gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUNvbnRleHQobnVsbCk7XG5jb25zdCBGbG9hdGluZ1RyZWVDb250ZXh0ID0gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUNvbnRleHQobnVsbCk7XG5cbi8qKlxuICogUmV0dXJucyB0aGUgcGFyZW50IG5vZGUgaWQgZm9yIG5lc3RlZCBmbG9hdGluZyBlbGVtZW50cywgaWYgYXZhaWxhYmxlLlxuICogUmV0dXJucyBgbnVsbGAgZm9yIHRvcC1sZXZlbCBmbG9hdGluZyBlbGVtZW50cy5cbiAqL1xuY29uc3QgdXNlRmxvYXRpbmdQYXJlbnROb2RlSWQgPSAoKSA9PiB7XG4gIHZhciBfUmVhY3QkdXNlQ29udGV4dDtcbiAgcmV0dXJuICgoX1JlYWN0JHVzZUNvbnRleHQgPSBSZWFjdC51c2VDb250ZXh0KEZsb2F0aW5nTm9kZUNvbnRleHQpKSA9PSBudWxsID8gdm9pZCAwIDogX1JlYWN0JHVzZUNvbnRleHQuaWQpIHx8IG51bGw7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIG5lYXJlc3QgZmxvYXRpbmcgdHJlZSBjb250ZXh0LCBpZiBhdmFpbGFibGUuXG4gKi9cbmNvbnN0IHVzZUZsb2F0aW5nVHJlZSA9ICgpID0+IFJlYWN0LnVzZUNvbnRleHQoRmxvYXRpbmdUcmVlQ29udGV4dCk7XG5cbi8qKlxuICogUmVnaXN0ZXJzIGEgbm9kZSBpbnRvIHRoZSBgRmxvYXRpbmdUcmVlYCwgcmV0dXJuaW5nIGl0cyBpZC5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9GbG9hdGluZ1RyZWVcbiAqL1xuZnVuY3Rpb24gdXNlRmxvYXRpbmdOb2RlSWQoY3VzdG9tUGFyZW50SWQpIHtcbiAgY29uc3QgaWQgPSB1c2VJZCgpO1xuICBjb25zdCB0cmVlID0gdXNlRmxvYXRpbmdUcmVlKCk7XG4gIGNvbnN0IHJlYWN0UGFyZW50SWQgPSB1c2VGbG9hdGluZ1BhcmVudE5vZGVJZCgpO1xuICBjb25zdCBwYXJlbnRJZCA9IGN1c3RvbVBhcmVudElkIHx8IHJlYWN0UGFyZW50SWQ7XG4gIGluZGV4KCgpID0+IHtcbiAgICBjb25zdCBub2RlID0ge1xuICAgICAgaWQsXG4gICAgICBwYXJlbnRJZFxuICAgIH07XG4gICAgdHJlZSA9PSBudWxsIHx8IHRyZWUuYWRkTm9kZShub2RlKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgdHJlZSA9PSBudWxsIHx8IHRyZWUucmVtb3ZlTm9kZShub2RlKTtcbiAgICB9O1xuICB9LCBbdHJlZSwgaWQsIHBhcmVudElkXSk7XG4gIHJldHVybiBpZDtcbn1cbi8qKlxuICogUHJvdmlkZXMgcGFyZW50IG5vZGUgY29udGV4dCBmb3IgbmVzdGVkIGZsb2F0aW5nIGVsZW1lbnRzLlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL0Zsb2F0aW5nVHJlZVxuICovXG5mdW5jdGlvbiBGbG9hdGluZ05vZGUocHJvcHMpIHtcbiAgY29uc3Qge1xuICAgIGNoaWxkcmVuLFxuICAgIGlkXG4gIH0gPSBwcm9wcztcbiAgY29uc3QgcGFyZW50SWQgPSB1c2VGbG9hdGluZ1BhcmVudE5vZGVJZCgpO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoRmxvYXRpbmdOb2RlQ29udGV4dC5Qcm92aWRlciwge1xuICAgIHZhbHVlOiBSZWFjdC51c2VNZW1vKCgpID0+ICh7XG4gICAgICBpZCxcbiAgICAgIHBhcmVudElkXG4gICAgfSksIFtpZCwgcGFyZW50SWRdKVxuICB9LCBjaGlsZHJlbik7XG59XG4vKipcbiAqIFByb3ZpZGVzIGNvbnRleHQgZm9yIG5lc3RlZCBmbG9hdGluZyBlbGVtZW50cyB3aGVuIHRoZXkgYXJlIG5vdCBjaGlsZHJlbiBvZlxuICogZWFjaCBvdGhlciBvbiB0aGUgRE9NLlxuICogVGhpcyBpcyBub3QgbmVjZXNzYXJ5IGluIGFsbCBjYXNlcywgZXhjZXB0IHdoZW4gdGhlcmUgbXVzdCBiZSBleHBsaWNpdCBjb21tdW5pY2F0aW9uIGJldHdlZW4gcGFyZW50IGFuZCBjaGlsZCBmbG9hdGluZyBlbGVtZW50cy4gSXQgaXMgbmVjZXNzYXJ5IGZvcjpcbiAqIC0gVGhlIGBidWJibGVzYCBvcHRpb24gaW4gdGhlIGB1c2VEaXNtaXNzKClgIEhvb2tcbiAqIC0gTmVzdGVkIHZpcnR1YWwgbGlzdCBuYXZpZ2F0aW9uXG4gKiAtIE5lc3RlZCBmbG9hdGluZyBlbGVtZW50cyB0aGF0IGVhY2ggb3BlbiBvbiBob3ZlclxuICogLSBDdXN0b20gY29tbXVuaWNhdGlvbiBiZXR3ZWVuIHBhcmVudCBhbmQgY2hpbGQgZmxvYXRpbmcgZWxlbWVudHNcbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9GbG9hdGluZ1RyZWVcbiAqL1xuZnVuY3Rpb24gRmxvYXRpbmdUcmVlKHByb3BzKSB7XG4gIGNvbnN0IHtcbiAgICBjaGlsZHJlblxuICB9ID0gcHJvcHM7XG4gIGNvbnN0IG5vZGVzUmVmID0gUmVhY3QudXNlUmVmKFtdKTtcbiAgY29uc3QgYWRkTm9kZSA9IFJlYWN0LnVzZUNhbGxiYWNrKG5vZGUgPT4ge1xuICAgIG5vZGVzUmVmLmN1cnJlbnQgPSBbLi4ubm9kZXNSZWYuY3VycmVudCwgbm9kZV07XG4gIH0sIFtdKTtcbiAgY29uc3QgcmVtb3ZlTm9kZSA9IFJlYWN0LnVzZUNhbGxiYWNrKG5vZGUgPT4ge1xuICAgIG5vZGVzUmVmLmN1cnJlbnQgPSBub2Rlc1JlZi5jdXJyZW50LmZpbHRlcihuID0+IG4gIT09IG5vZGUpO1xuICB9LCBbXSk7XG4gIGNvbnN0IGV2ZW50cyA9IFJlYWN0LnVzZVN0YXRlKCgpID0+IGNyZWF0ZVB1YlN1YigpKVswXTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KEZsb2F0aW5nVHJlZUNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogUmVhY3QudXNlTWVtbygoKSA9PiAoe1xuICAgICAgbm9kZXNSZWYsXG4gICAgICBhZGROb2RlLFxuICAgICAgcmVtb3ZlTm9kZSxcbiAgICAgIGV2ZW50c1xuICAgIH0pLCBbYWRkTm9kZSwgcmVtb3ZlTm9kZSwgZXZlbnRzXSlcbiAgfSwgY2hpbGRyZW4pO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVBdHRyaWJ1dGUobmFtZSkge1xuICByZXR1cm4gXCJkYXRhLWZsb2F0aW5nLXVpLVwiICsgbmFtZTtcbn1cblxuZnVuY3Rpb24gdXNlTGF0ZXN0UmVmKHZhbHVlKSB7XG4gIGNvbnN0IHJlZiA9IHVzZVJlZih2YWx1ZSk7XG4gIGluZGV4KCgpID0+IHtcbiAgICByZWYuY3VycmVudCA9IHZhbHVlO1xuICB9KTtcbiAgcmV0dXJuIHJlZjtcbn1cblxuY29uc3Qgc2FmZVBvbHlnb25JZGVudGlmaWVyID0gLyojX19QVVJFX18qL2NyZWF0ZUF0dHJpYnV0ZSgnc2FmZS1wb2x5Z29uJyk7XG5mdW5jdGlvbiBnZXREZWxheSh2YWx1ZSwgcHJvcCwgcG9pbnRlclR5cGUpIHtcbiAgaWYgKHBvaW50ZXJUeXBlICYmICFpc01vdXNlTGlrZVBvaW50ZXJUeXBlKHBvaW50ZXJUeXBlKSkge1xuICAgIHJldHVybiAwO1xuICB9XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHJldHVybiB2YWx1ZSA9PSBudWxsID8gdm9pZCAwIDogdmFsdWVbcHJvcF07XG59XG4vKipcbiAqIE9wZW5zIHRoZSBmbG9hdGluZyBlbGVtZW50IHdoaWxlIGhvdmVyaW5nIG92ZXIgdGhlIHJlZmVyZW5jZSBlbGVtZW50LCBsaWtlXG4gKiBDU1MgYDpob3ZlcmAuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvdXNlSG92ZXJcbiAqL1xuZnVuY3Rpb24gdXNlSG92ZXIoY29udGV4dCwgcHJvcHMpIHtcbiAgaWYgKHByb3BzID09PSB2b2lkIDApIHtcbiAgICBwcm9wcyA9IHt9O1xuICB9XG4gIGNvbnN0IHtcbiAgICBvcGVuLFxuICAgIG9uT3BlbkNoYW5nZSxcbiAgICBkYXRhUmVmLFxuICAgIGV2ZW50cyxcbiAgICBlbGVtZW50c1xuICB9ID0gY29udGV4dDtcbiAgY29uc3Qge1xuICAgIGVuYWJsZWQgPSB0cnVlLFxuICAgIGRlbGF5ID0gMCxcbiAgICBoYW5kbGVDbG9zZSA9IG51bGwsXG4gICAgbW91c2VPbmx5ID0gZmFsc2UsXG4gICAgcmVzdE1zID0gMCxcbiAgICBtb3ZlID0gdHJ1ZVxuICB9ID0gcHJvcHM7XG4gIGNvbnN0IHRyZWUgPSB1c2VGbG9hdGluZ1RyZWUoKTtcbiAgY29uc3QgcGFyZW50SWQgPSB1c2VGbG9hdGluZ1BhcmVudE5vZGVJZCgpO1xuICBjb25zdCBoYW5kbGVDbG9zZVJlZiA9IHVzZUxhdGVzdFJlZihoYW5kbGVDbG9zZSk7XG4gIGNvbnN0IGRlbGF5UmVmID0gdXNlTGF0ZXN0UmVmKGRlbGF5KTtcbiAgY29uc3Qgb3BlblJlZiA9IHVzZUxhdGVzdFJlZihvcGVuKTtcbiAgY29uc3QgcG9pbnRlclR5cGVSZWYgPSBSZWFjdC51c2VSZWYoKTtcbiAgY29uc3QgdGltZW91dFJlZiA9IFJlYWN0LnVzZVJlZigtMSk7XG4gIGNvbnN0IGhhbmRsZXJSZWYgPSBSZWFjdC51c2VSZWYoKTtcbiAgY29uc3QgcmVzdFRpbWVvdXRSZWYgPSBSZWFjdC51c2VSZWYoLTEpO1xuICBjb25zdCBibG9ja01vdXNlTW92ZVJlZiA9IFJlYWN0LnVzZVJlZih0cnVlKTtcbiAgY29uc3QgcGVyZm9ybWVkUG9pbnRlckV2ZW50c011dGF0aW9uUmVmID0gUmVhY3QudXNlUmVmKGZhbHNlKTtcbiAgY29uc3QgdW5iaW5kTW91c2VNb3ZlUmVmID0gUmVhY3QudXNlUmVmKCgpID0+IHt9KTtcbiAgY29uc3QgcmVzdFRpbWVvdXRQZW5kaW5nUmVmID0gUmVhY3QudXNlUmVmKGZhbHNlKTtcbiAgY29uc3QgaXNIb3Zlck9wZW4gPSBSZWFjdC51c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgdmFyIF9kYXRhUmVmJGN1cnJlbnQkb3BlbjtcbiAgICBjb25zdCB0eXBlID0gKF9kYXRhUmVmJGN1cnJlbnQkb3BlbiA9IGRhdGFSZWYuY3VycmVudC5vcGVuRXZlbnQpID09IG51bGwgPyB2b2lkIDAgOiBfZGF0YVJlZiRjdXJyZW50JG9wZW4udHlwZTtcbiAgICByZXR1cm4gKHR5cGUgPT0gbnVsbCA/IHZvaWQgMCA6IHR5cGUuaW5jbHVkZXMoJ21vdXNlJykpICYmIHR5cGUgIT09ICdtb3VzZWRvd24nO1xuICB9LCBbZGF0YVJlZl0pO1xuXG4gIC8vIFdoZW4gY2xvc2luZyBiZWZvcmUgb3BlbmluZywgY2xlYXIgdGhlIGRlbGF5IHRpbWVvdXRzIHRvIGNhbmNlbCBpdFxuICAvLyBmcm9tIHNob3dpbmcuXG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFlbmFibGVkKSByZXR1cm47XG4gICAgZnVuY3Rpb24gb25PcGVuQ2hhbmdlKF9yZWYpIHtcbiAgICAgIGxldCB7XG4gICAgICAgIG9wZW5cbiAgICAgIH0gPSBfcmVmO1xuICAgICAgaWYgKCFvcGVuKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0UmVmLmN1cnJlbnQpO1xuICAgICAgICBjbGVhclRpbWVvdXQocmVzdFRpbWVvdXRSZWYuY3VycmVudCk7XG4gICAgICAgIGJsb2NrTW91c2VNb3ZlUmVmLmN1cnJlbnQgPSB0cnVlO1xuICAgICAgICByZXN0VGltZW91dFBlbmRpbmdSZWYuY3VycmVudCA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICBldmVudHMub24oJ29wZW5jaGFuZ2UnLCBvbk9wZW5DaGFuZ2UpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBldmVudHMub2ZmKCdvcGVuY2hhbmdlJywgb25PcGVuQ2hhbmdlKTtcbiAgICB9O1xuICB9LCBbZW5hYmxlZCwgZXZlbnRzXSk7XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFlbmFibGVkKSByZXR1cm47XG4gICAgaWYgKCFoYW5kbGVDbG9zZVJlZi5jdXJyZW50KSByZXR1cm47XG4gICAgaWYgKCFvcGVuKSByZXR1cm47XG4gICAgZnVuY3Rpb24gb25MZWF2ZShldmVudCkge1xuICAgICAgaWYgKGlzSG92ZXJPcGVuKCkpIHtcbiAgICAgICAgb25PcGVuQ2hhbmdlKGZhbHNlLCBldmVudCwgJ2hvdmVyJyk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGh0bWwgPSBnZXREb2N1bWVudChlbGVtZW50cy5mbG9hdGluZykuZG9jdW1lbnRFbGVtZW50O1xuICAgIGh0bWwuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VsZWF2ZScsIG9uTGVhdmUpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBodG1sLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbGVhdmUnLCBvbkxlYXZlKTtcbiAgICB9O1xuICB9LCBbZWxlbWVudHMuZmxvYXRpbmcsIG9wZW4sIG9uT3BlbkNoYW5nZSwgZW5hYmxlZCwgaGFuZGxlQ2xvc2VSZWYsIGlzSG92ZXJPcGVuXSk7XG4gIGNvbnN0IGNsb3NlV2l0aERlbGF5ID0gUmVhY3QudXNlQ2FsbGJhY2soZnVuY3Rpb24gKGV2ZW50LCBydW5FbHNlQnJhbmNoLCByZWFzb24pIHtcbiAgICBpZiAocnVuRWxzZUJyYW5jaCA9PT0gdm9pZCAwKSB7XG4gICAgICBydW5FbHNlQnJhbmNoID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHJlYXNvbiA9PT0gdm9pZCAwKSB7XG4gICAgICByZWFzb24gPSAnaG92ZXInO1xuICAgIH1cbiAgICBjb25zdCBjbG9zZURlbGF5ID0gZ2V0RGVsYXkoZGVsYXlSZWYuY3VycmVudCwgJ2Nsb3NlJywgcG9pbnRlclR5cGVSZWYuY3VycmVudCk7XG4gICAgaWYgKGNsb3NlRGVsYXkgJiYgIWhhbmRsZXJSZWYuY3VycmVudCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRSZWYuY3VycmVudCk7XG4gICAgICB0aW1lb3V0UmVmLmN1cnJlbnQgPSB3aW5kb3cuc2V0VGltZW91dCgoKSA9PiBvbk9wZW5DaGFuZ2UoZmFsc2UsIGV2ZW50LCByZWFzb24pLCBjbG9zZURlbGF5KTtcbiAgICB9IGVsc2UgaWYgKHJ1bkVsc2VCcmFuY2gpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0UmVmLmN1cnJlbnQpO1xuICAgICAgb25PcGVuQ2hhbmdlKGZhbHNlLCBldmVudCwgcmVhc29uKTtcbiAgICB9XG4gIH0sIFtkZWxheVJlZiwgb25PcGVuQ2hhbmdlXSk7XG4gIGNvbnN0IGNsZWFudXBNb3VzZU1vdmVIYW5kbGVyID0gdXNlRWZmZWN0RXZlbnQoKCkgPT4ge1xuICAgIHVuYmluZE1vdXNlTW92ZVJlZi5jdXJyZW50KCk7XG4gICAgaGFuZGxlclJlZi5jdXJyZW50ID0gdW5kZWZpbmVkO1xuICB9KTtcbiAgY29uc3QgY2xlYXJQb2ludGVyRXZlbnRzID0gdXNlRWZmZWN0RXZlbnQoKCkgPT4ge1xuICAgIGlmIChwZXJmb3JtZWRQb2ludGVyRXZlbnRzTXV0YXRpb25SZWYuY3VycmVudCkge1xuICAgICAgY29uc3QgYm9keSA9IGdldERvY3VtZW50KGVsZW1lbnRzLmZsb2F0aW5nKS5ib2R5O1xuICAgICAgYm9keS5zdHlsZS5wb2ludGVyRXZlbnRzID0gJyc7XG4gICAgICBib2R5LnJlbW92ZUF0dHJpYnV0ZShzYWZlUG9seWdvbklkZW50aWZpZXIpO1xuICAgICAgcGVyZm9ybWVkUG9pbnRlckV2ZW50c011dGF0aW9uUmVmLmN1cnJlbnQgPSBmYWxzZTtcbiAgICB9XG4gIH0pO1xuICBjb25zdCBpc0NsaWNrTGlrZU9wZW5FdmVudCA9IHVzZUVmZmVjdEV2ZW50KCgpID0+IHtcbiAgICByZXR1cm4gZGF0YVJlZi5jdXJyZW50Lm9wZW5FdmVudCA/IFsnY2xpY2snLCAnbW91c2Vkb3duJ10uaW5jbHVkZXMoZGF0YVJlZi5jdXJyZW50Lm9wZW5FdmVudC50eXBlKSA6IGZhbHNlO1xuICB9KTtcblxuICAvLyBSZWdpc3RlcmluZyB0aGUgbW91c2UgZXZlbnRzIG9uIHRoZSByZWZlcmVuY2UgZGlyZWN0bHkgdG8gYnlwYXNzIFJlYWN0J3NcbiAgLy8gZGVsZWdhdGlvbiBzeXN0ZW0uIElmIHRoZSBjdXJzb3Igd2FzIG9uIGEgZGlzYWJsZWQgZWxlbWVudCBhbmQgdGhlbiBlbnRlcmVkXG4gIC8vIHRoZSByZWZlcmVuY2UgKG5vIGdhcCksIGBtb3VzZWVudGVyYCBkb2Vzbid0IGZpcmUgaW4gdGhlIGRlbGVnYXRpb24gc3lzdGVtLlxuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghZW5hYmxlZCkgcmV0dXJuO1xuICAgIGZ1bmN0aW9uIG9uTW91c2VFbnRlcihldmVudCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRSZWYuY3VycmVudCk7XG4gICAgICBibG9ja01vdXNlTW92ZVJlZi5jdXJyZW50ID0gZmFsc2U7XG4gICAgICBpZiAobW91c2VPbmx5ICYmICFpc01vdXNlTGlrZVBvaW50ZXJUeXBlKHBvaW50ZXJUeXBlUmVmLmN1cnJlbnQpIHx8IHJlc3RNcyA+IDAgJiYgIWdldERlbGF5KGRlbGF5UmVmLmN1cnJlbnQsICdvcGVuJykpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3Qgb3BlbkRlbGF5ID0gZ2V0RGVsYXkoZGVsYXlSZWYuY3VycmVudCwgJ29wZW4nLCBwb2ludGVyVHlwZVJlZi5jdXJyZW50KTtcbiAgICAgIGlmIChvcGVuRGVsYXkpIHtcbiAgICAgICAgdGltZW91dFJlZi5jdXJyZW50ID0gd2luZG93LnNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIGlmICghb3BlblJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgICBvbk9wZW5DaGFuZ2UodHJ1ZSwgZXZlbnQsICdob3ZlcicpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgb3BlbkRlbGF5KTtcbiAgICAgIH0gZWxzZSBpZiAoIW9wZW4pIHtcbiAgICAgICAgb25PcGVuQ2hhbmdlKHRydWUsIGV2ZW50LCAnaG92ZXInKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gb25Nb3VzZUxlYXZlKGV2ZW50KSB7XG4gICAgICBpZiAoaXNDbGlja0xpa2VPcGVuRXZlbnQoKSkgcmV0dXJuO1xuICAgICAgdW5iaW5kTW91c2VNb3ZlUmVmLmN1cnJlbnQoKTtcbiAgICAgIGNvbnN0IGRvYyA9IGdldERvY3VtZW50KGVsZW1lbnRzLmZsb2F0aW5nKTtcbiAgICAgIGNsZWFyVGltZW91dChyZXN0VGltZW91dFJlZi5jdXJyZW50KTtcbiAgICAgIHJlc3RUaW1lb3V0UGVuZGluZ1JlZi5jdXJyZW50ID0gZmFsc2U7XG4gICAgICBpZiAoaGFuZGxlQ2xvc2VSZWYuY3VycmVudCAmJiBkYXRhUmVmLmN1cnJlbnQuZmxvYXRpbmdDb250ZXh0KSB7XG4gICAgICAgIC8vIFByZXZlbnQgY2xlYXJpbmcgYG9uU2Nyb2xsTW91c2VMZWF2ZWAgdGltZW91dC5cbiAgICAgICAgaWYgKCFvcGVuKSB7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRSZWYuY3VycmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgaGFuZGxlclJlZi5jdXJyZW50ID0gaGFuZGxlQ2xvc2VSZWYuY3VycmVudCh7XG4gICAgICAgICAgLi4uZGF0YVJlZi5jdXJyZW50LmZsb2F0aW5nQ29udGV4dCxcbiAgICAgICAgICB0cmVlLFxuICAgICAgICAgIHg6IGV2ZW50LmNsaWVudFgsXG4gICAgICAgICAgeTogZXZlbnQuY2xpZW50WSxcbiAgICAgICAgICBvbkNsb3NlKCkge1xuICAgICAgICAgICAgY2xlYXJQb2ludGVyRXZlbnRzKCk7XG4gICAgICAgICAgICBjbGVhbnVwTW91c2VNb3ZlSGFuZGxlcigpO1xuICAgICAgICAgICAgaWYgKCFpc0NsaWNrTGlrZU9wZW5FdmVudCgpKSB7XG4gICAgICAgICAgICAgIGNsb3NlV2l0aERlbGF5KGV2ZW50LCB0cnVlLCAnc2FmZS1wb2x5Z29uJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgaGFuZGxlciA9IGhhbmRsZXJSZWYuY3VycmVudDtcbiAgICAgICAgZG9jLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIGhhbmRsZXIpO1xuICAgICAgICB1bmJpbmRNb3VzZU1vdmVSZWYuY3VycmVudCA9ICgpID0+IHtcbiAgICAgICAgICBkb2MucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgaGFuZGxlcik7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gQWxsb3cgaW50ZXJhY3Rpdml0eSB3aXRob3V0IGBzYWZlUG9seWdvbmAgb24gdG91Y2ggZGV2aWNlcy4gV2l0aCBhXG4gICAgICAvLyBwb2ludGVyLCBhIHNob3J0IGNsb3NlIGRlbGF5IGlzIGFuIGFsdGVybmF0aXZlLCBzbyBpdCBzaG91bGQgd29ya1xuICAgICAgLy8gY29uc2lzdGVudGx5LlxuICAgICAgY29uc3Qgc2hvdWxkQ2xvc2UgPSBwb2ludGVyVHlwZVJlZi5jdXJyZW50ID09PSAndG91Y2gnID8gIWNvbnRhaW5zKGVsZW1lbnRzLmZsb2F0aW5nLCBldmVudC5yZWxhdGVkVGFyZ2V0KSA6IHRydWU7XG4gICAgICBpZiAoc2hvdWxkQ2xvc2UpIHtcbiAgICAgICAgY2xvc2VXaXRoRGVsYXkoZXZlbnQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEVuc3VyZSB0aGUgZmxvYXRpbmcgZWxlbWVudCBjbG9zZXMgYWZ0ZXIgc2Nyb2xsaW5nIGV2ZW4gaWYgdGhlIHBvaW50ZXJcbiAgICAvLyBkaWQgbm90IG1vdmUuXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2Zsb2F0aW5nLXVpL2Zsb2F0aW5nLXVpL2Rpc2N1c3Npb25zLzE2OTJcbiAgICBmdW5jdGlvbiBvblNjcm9sbE1vdXNlTGVhdmUoZXZlbnQpIHtcbiAgICAgIGlmIChpc0NsaWNrTGlrZU9wZW5FdmVudCgpKSByZXR1cm47XG4gICAgICBpZiAoIWRhdGFSZWYuY3VycmVudC5mbG9hdGluZ0NvbnRleHQpIHJldHVybjtcbiAgICAgIGhhbmRsZUNsb3NlUmVmLmN1cnJlbnQgPT0gbnVsbCB8fCBoYW5kbGVDbG9zZVJlZi5jdXJyZW50KHtcbiAgICAgICAgLi4uZGF0YVJlZi5jdXJyZW50LmZsb2F0aW5nQ29udGV4dCxcbiAgICAgICAgdHJlZSxcbiAgICAgICAgeDogZXZlbnQuY2xpZW50WCxcbiAgICAgICAgeTogZXZlbnQuY2xpZW50WSxcbiAgICAgICAgb25DbG9zZSgpIHtcbiAgICAgICAgICBjbGVhclBvaW50ZXJFdmVudHMoKTtcbiAgICAgICAgICBjbGVhbnVwTW91c2VNb3ZlSGFuZGxlcigpO1xuICAgICAgICAgIGlmICghaXNDbGlja0xpa2VPcGVuRXZlbnQoKSkge1xuICAgICAgICAgICAgY2xvc2VXaXRoRGVsYXkoZXZlbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSkoZXZlbnQpO1xuICAgIH1cbiAgICBpZiAoaXNFbGVtZW50KGVsZW1lbnRzLmRvbVJlZmVyZW5jZSkpIHtcbiAgICAgIHZhciBfZWxlbWVudHMkZmxvYXRpbmc7XG4gICAgICBjb25zdCByZWYgPSBlbGVtZW50cy5kb21SZWZlcmVuY2U7XG4gICAgICBvcGVuICYmIHJlZi5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWxlYXZlJywgb25TY3JvbGxNb3VzZUxlYXZlKTtcbiAgICAgIChfZWxlbWVudHMkZmxvYXRpbmcgPSBlbGVtZW50cy5mbG9hdGluZykgPT0gbnVsbCB8fCBfZWxlbWVudHMkZmxvYXRpbmcuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VsZWF2ZScsIG9uU2Nyb2xsTW91c2VMZWF2ZSk7XG4gICAgICBtb3ZlICYmIHJlZi5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBvbk1vdXNlRW50ZXIsIHtcbiAgICAgICAgb25jZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgICByZWYuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VlbnRlcicsIG9uTW91c2VFbnRlcik7XG4gICAgICByZWYuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VsZWF2ZScsIG9uTW91c2VMZWF2ZSk7XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICB2YXIgX2VsZW1lbnRzJGZsb2F0aW5nMjtcbiAgICAgICAgb3BlbiAmJiByZWYucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2VsZWF2ZScsIG9uU2Nyb2xsTW91c2VMZWF2ZSk7XG4gICAgICAgIChfZWxlbWVudHMkZmxvYXRpbmcyID0gZWxlbWVudHMuZmxvYXRpbmcpID09IG51bGwgfHwgX2VsZW1lbnRzJGZsb2F0aW5nMi5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWxlYXZlJywgb25TY3JvbGxNb3VzZUxlYXZlKTtcbiAgICAgICAgbW92ZSAmJiByZWYucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgb25Nb3VzZUVudGVyKTtcbiAgICAgICAgcmVmLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZW50ZXInLCBvbk1vdXNlRW50ZXIpO1xuICAgICAgICByZWYucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2VsZWF2ZScsIG9uTW91c2VMZWF2ZSk7XG4gICAgICB9O1xuICAgIH1cbiAgfSwgW2VsZW1lbnRzLCBlbmFibGVkLCBjb250ZXh0LCBtb3VzZU9ubHksIHJlc3RNcywgbW92ZSwgY2xvc2VXaXRoRGVsYXksIGNsZWFudXBNb3VzZU1vdmVIYW5kbGVyLCBjbGVhclBvaW50ZXJFdmVudHMsIG9uT3BlbkNoYW5nZSwgb3Blbiwgb3BlblJlZiwgdHJlZSwgZGVsYXlSZWYsIGhhbmRsZUNsb3NlUmVmLCBkYXRhUmVmLCBpc0NsaWNrTGlrZU9wZW5FdmVudF0pO1xuXG4gIC8vIEJsb2NrIHBvaW50ZXItZXZlbnRzIG9mIGV2ZXJ5IGVsZW1lbnQgb3RoZXIgdGhhbiB0aGUgcmVmZXJlbmNlIGFuZCBmbG9hdGluZ1xuICAvLyB3aGlsZSB0aGUgZmxvYXRpbmcgZWxlbWVudCBpcyBvcGVuIGFuZCBoYXMgYSBgaGFuZGxlQ2xvc2VgIGhhbmRsZXIuIEFsc29cbiAgLy8gaGFuZGxlcyBuZXN0ZWQgZmxvYXRpbmcgZWxlbWVudHMuXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mbG9hdGluZy11aS9mbG9hdGluZy11aS9pc3N1ZXMvMTcyMlxuICBpbmRleCgoKSA9PiB7XG4gICAgdmFyIF9oYW5kbGVDbG9zZVJlZiRjdXJyZTtcbiAgICBpZiAoIWVuYWJsZWQpIHJldHVybjtcbiAgICBpZiAob3BlbiAmJiAoX2hhbmRsZUNsb3NlUmVmJGN1cnJlID0gaGFuZGxlQ2xvc2VSZWYuY3VycmVudCkgIT0gbnVsbCAmJiBfaGFuZGxlQ2xvc2VSZWYkY3VycmUuX19vcHRpb25zLmJsb2NrUG9pbnRlckV2ZW50cyAmJiBpc0hvdmVyT3BlbigpKSB7XG4gICAgICBwZXJmb3JtZWRQb2ludGVyRXZlbnRzTXV0YXRpb25SZWYuY3VycmVudCA9IHRydWU7XG4gICAgICBjb25zdCBmbG9hdGluZ0VsID0gZWxlbWVudHMuZmxvYXRpbmc7XG4gICAgICBpZiAoaXNFbGVtZW50KGVsZW1lbnRzLmRvbVJlZmVyZW5jZSkgJiYgZmxvYXRpbmdFbCkge1xuICAgICAgICB2YXIgX3RyZWUkbm9kZXNSZWYkY3VycmVuO1xuICAgICAgICBjb25zdCBib2R5ID0gZ2V0RG9jdW1lbnQoZWxlbWVudHMuZmxvYXRpbmcpLmJvZHk7XG4gICAgICAgIGJvZHkuc2V0QXR0cmlidXRlKHNhZmVQb2x5Z29uSWRlbnRpZmllciwgJycpO1xuICAgICAgICBjb25zdCByZWYgPSBlbGVtZW50cy5kb21SZWZlcmVuY2U7XG4gICAgICAgIGNvbnN0IHBhcmVudEZsb2F0aW5nID0gdHJlZSA9PSBudWxsIHx8IChfdHJlZSRub2Rlc1JlZiRjdXJyZW4gPSB0cmVlLm5vZGVzUmVmLmN1cnJlbnQuZmluZChub2RlID0+IG5vZGUuaWQgPT09IHBhcmVudElkKSkgPT0gbnVsbCB8fCAoX3RyZWUkbm9kZXNSZWYkY3VycmVuID0gX3RyZWUkbm9kZXNSZWYkY3VycmVuLmNvbnRleHQpID09IG51bGwgPyB2b2lkIDAgOiBfdHJlZSRub2Rlc1JlZiRjdXJyZW4uZWxlbWVudHMuZmxvYXRpbmc7XG4gICAgICAgIGlmIChwYXJlbnRGbG9hdGluZykge1xuICAgICAgICAgIHBhcmVudEZsb2F0aW5nLnN0eWxlLnBvaW50ZXJFdmVudHMgPSAnJztcbiAgICAgICAgfVxuICAgICAgICBib2R5LnN0eWxlLnBvaW50ZXJFdmVudHMgPSAnbm9uZSc7XG4gICAgICAgIHJlZi5zdHlsZS5wb2ludGVyRXZlbnRzID0gJ2F1dG8nO1xuICAgICAgICBmbG9hdGluZ0VsLnN0eWxlLnBvaW50ZXJFdmVudHMgPSAnYXV0byc7XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgYm9keS5zdHlsZS5wb2ludGVyRXZlbnRzID0gJyc7XG4gICAgICAgICAgcmVmLnN0eWxlLnBvaW50ZXJFdmVudHMgPSAnJztcbiAgICAgICAgICBmbG9hdGluZ0VsLnN0eWxlLnBvaW50ZXJFdmVudHMgPSAnJztcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIFtlbmFibGVkLCBvcGVuLCBwYXJlbnRJZCwgZWxlbWVudHMsIHRyZWUsIGhhbmRsZUNsb3NlUmVmLCBpc0hvdmVyT3Blbl0pO1xuICBpbmRleCgoKSA9PiB7XG4gICAgaWYgKCFvcGVuKSB7XG4gICAgICBwb2ludGVyVHlwZVJlZi5jdXJyZW50ID0gdW5kZWZpbmVkO1xuICAgICAgcmVzdFRpbWVvdXRQZW5kaW5nUmVmLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgIGNsZWFudXBNb3VzZU1vdmVIYW5kbGVyKCk7XG4gICAgICBjbGVhclBvaW50ZXJFdmVudHMoKTtcbiAgICB9XG4gIH0sIFtvcGVuLCBjbGVhbnVwTW91c2VNb3ZlSGFuZGxlciwgY2xlYXJQb2ludGVyRXZlbnRzXSk7XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGNsZWFudXBNb3VzZU1vdmVIYW5kbGVyKCk7XG4gICAgICBjbGVhclRpbWVvdXQodGltZW91dFJlZi5jdXJyZW50KTtcbiAgICAgIGNsZWFyVGltZW91dChyZXN0VGltZW91dFJlZi5jdXJyZW50KTtcbiAgICAgIGNsZWFyUG9pbnRlckV2ZW50cygpO1xuICAgIH07XG4gIH0sIFtlbmFibGVkLCBlbGVtZW50cy5kb21SZWZlcmVuY2UsIGNsZWFudXBNb3VzZU1vdmVIYW5kbGVyLCBjbGVhclBvaW50ZXJFdmVudHNdKTtcbiAgY29uc3QgcmVmZXJlbmNlID0gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgZnVuY3Rpb24gc2V0UG9pbnRlclJlZihldmVudCkge1xuICAgICAgcG9pbnRlclR5cGVSZWYuY3VycmVudCA9IGV2ZW50LnBvaW50ZXJUeXBlO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgb25Qb2ludGVyRG93bjogc2V0UG9pbnRlclJlZixcbiAgICAgIG9uUG9pbnRlckVudGVyOiBzZXRQb2ludGVyUmVmLFxuICAgICAgb25Nb3VzZU1vdmUoZXZlbnQpIHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIG5hdGl2ZUV2ZW50XG4gICAgICAgIH0gPSBldmVudDtcbiAgICAgICAgZnVuY3Rpb24gaGFuZGxlTW91c2VNb3ZlKCkge1xuICAgICAgICAgIGlmICghYmxvY2tNb3VzZU1vdmVSZWYuY3VycmVudCAmJiAhb3BlblJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgICBvbk9wZW5DaGFuZ2UodHJ1ZSwgbmF0aXZlRXZlbnQsICdob3ZlcicpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobW91c2VPbmx5ICYmICFpc01vdXNlTGlrZVBvaW50ZXJUeXBlKHBvaW50ZXJUeXBlUmVmLmN1cnJlbnQpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcGVuIHx8IHJlc3RNcyA9PT0gMCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElnbm9yZSBpbnNpZ25pZmljYW50IG1vdmVtZW50cyB0byBhY2NvdW50IGZvciB0cmVtb3JzLlxuICAgICAgICBpZiAocmVzdFRpbWVvdXRQZW5kaW5nUmVmLmN1cnJlbnQgJiYgZXZlbnQubW92ZW1lbnRYICoqIDIgKyBldmVudC5tb3ZlbWVudFkgKiogMiA8IDIpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY2xlYXJUaW1lb3V0KHJlc3RUaW1lb3V0UmVmLmN1cnJlbnQpO1xuICAgICAgICBpZiAocG9pbnRlclR5cGVSZWYuY3VycmVudCA9PT0gJ3RvdWNoJykge1xuICAgICAgICAgIGhhbmRsZU1vdXNlTW92ZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3RUaW1lb3V0UGVuZGluZ1JlZi5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgICAgICByZXN0VGltZW91dFJlZi5jdXJyZW50ID0gd2luZG93LnNldFRpbWVvdXQoaGFuZGxlTW91c2VNb3ZlLCByZXN0TXMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfSwgW21vdXNlT25seSwgb25PcGVuQ2hhbmdlLCBvcGVuLCBvcGVuUmVmLCByZXN0TXNdKTtcbiAgY29uc3QgZmxvYXRpbmcgPSBSZWFjdC51c2VNZW1vKCgpID0+ICh7XG4gICAgb25Nb3VzZUVudGVyKCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRSZWYuY3VycmVudCk7XG4gICAgfSxcbiAgICBvbk1vdXNlTGVhdmUoZXZlbnQpIHtcbiAgICAgIGlmICghaXNDbGlja0xpa2VPcGVuRXZlbnQoKSkge1xuICAgICAgICBjbG9zZVdpdGhEZWxheShldmVudC5uYXRpdmVFdmVudCwgZmFsc2UpO1xuICAgICAgfVxuICAgIH1cbiAgfSksIFtjbG9zZVdpdGhEZWxheSwgaXNDbGlja0xpa2VPcGVuRXZlbnRdKTtcbiAgcmV0dXJuIFJlYWN0LnVzZU1lbW8oKCkgPT4gZW5hYmxlZCA/IHtcbiAgICByZWZlcmVuY2UsXG4gICAgZmxvYXRpbmdcbiAgfSA6IHt9LCBbZW5hYmxlZCwgcmVmZXJlbmNlLCBmbG9hdGluZ10pO1xufVxuXG5jb25zdCBOT09QID0gKCkgPT4ge307XG5jb25zdCBGbG9hdGluZ0RlbGF5R3JvdXBDb250ZXh0ID0gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUNvbnRleHQoe1xuICBkZWxheTogMCxcbiAgaW5pdGlhbERlbGF5OiAwLFxuICB0aW1lb3V0TXM6IDAsXG4gIGN1cnJlbnRJZDogbnVsbCxcbiAgc2V0Q3VycmVudElkOiBOT09QLFxuICBzZXRTdGF0ZTogTk9PUCxcbiAgaXNJbnN0YW50UGhhc2U6IGZhbHNlXG59KTtcblxuLyoqXG4gKiBAZGVwcmVjYXRlZFxuICogVXNlIHRoZSByZXR1cm4gdmFsdWUgb2YgYHVzZURlbGF5R3JvdXAoKWAgaW5zdGVhZC5cbiAqL1xuY29uc3QgdXNlRGVsYXlHcm91cENvbnRleHQgPSAoKSA9PiBSZWFjdC51c2VDb250ZXh0KEZsb2F0aW5nRGVsYXlHcm91cENvbnRleHQpO1xuLyoqXG4gKiBQcm92aWRlcyBjb250ZXh0IGZvciBhIGdyb3VwIG9mIGZsb2F0aW5nIGVsZW1lbnRzIHRoYXQgc2hvdWxkIHNoYXJlIGFcbiAqIGBkZWxheWAuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvRmxvYXRpbmdEZWxheUdyb3VwXG4gKi9cbmZ1bmN0aW9uIEZsb2F0aW5nRGVsYXlHcm91cChwcm9wcykge1xuICBjb25zdCB7XG4gICAgY2hpbGRyZW4sXG4gICAgZGVsYXksXG4gICAgdGltZW91dE1zID0gMFxuICB9ID0gcHJvcHM7XG4gIGNvbnN0IFtzdGF0ZSwgc2V0U3RhdGVdID0gUmVhY3QudXNlUmVkdWNlcigocHJldiwgbmV4dCkgPT4gKHtcbiAgICAuLi5wcmV2LFxuICAgIC4uLm5leHRcbiAgfSksIHtcbiAgICBkZWxheSxcbiAgICB0aW1lb3V0TXMsXG4gICAgaW5pdGlhbERlbGF5OiBkZWxheSxcbiAgICBjdXJyZW50SWQ6IG51bGwsXG4gICAgaXNJbnN0YW50UGhhc2U6IGZhbHNlXG4gIH0pO1xuICBjb25zdCBpbml0aWFsQ3VycmVudElkUmVmID0gUmVhY3QudXNlUmVmKG51bGwpO1xuICBjb25zdCBzZXRDdXJyZW50SWQgPSBSZWFjdC51c2VDYWxsYmFjayhjdXJyZW50SWQgPT4ge1xuICAgIHNldFN0YXRlKHtcbiAgICAgIGN1cnJlbnRJZFxuICAgIH0pO1xuICB9LCBbXSk7XG4gIGluZGV4KCgpID0+IHtcbiAgICBpZiAoc3RhdGUuY3VycmVudElkKSB7XG4gICAgICBpZiAoaW5pdGlhbEN1cnJlbnRJZFJlZi5jdXJyZW50ID09PSBudWxsKSB7XG4gICAgICAgIGluaXRpYWxDdXJyZW50SWRSZWYuY3VycmVudCA9IHN0YXRlLmN1cnJlbnRJZDtcbiAgICAgIH0gZWxzZSBpZiAoIXN0YXRlLmlzSW5zdGFudFBoYXNlKSB7XG4gICAgICAgIHNldFN0YXRlKHtcbiAgICAgICAgICBpc0luc3RhbnRQaGFzZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHN0YXRlLmlzSW5zdGFudFBoYXNlKSB7XG4gICAgICAgIHNldFN0YXRlKHtcbiAgICAgICAgICBpc0luc3RhbnRQaGFzZTogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpbml0aWFsQ3VycmVudElkUmVmLmN1cnJlbnQgPSBudWxsO1xuICAgIH1cbiAgfSwgW3N0YXRlLmN1cnJlbnRJZCwgc3RhdGUuaXNJbnN0YW50UGhhc2VdKTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KEZsb2F0aW5nRGVsYXlHcm91cENvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogUmVhY3QudXNlTWVtbygoKSA9PiAoe1xuICAgICAgLi4uc3RhdGUsXG4gICAgICBzZXRTdGF0ZSxcbiAgICAgIHNldEN1cnJlbnRJZFxuICAgIH0pLCBbc3RhdGUsIHNldEN1cnJlbnRJZF0pXG4gIH0sIGNoaWxkcmVuKTtcbn1cbi8qKlxuICogRW5hYmxlcyBncm91cGluZyB3aGVuIGNhbGxlZCBpbnNpZGUgYSBjb21wb25lbnQgdGhhdCdzIGEgY2hpbGQgb2YgYVxuICogYEZsb2F0aW5nRGVsYXlHcm91cGAuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvRmxvYXRpbmdEZWxheUdyb3VwXG4gKi9cbmZ1bmN0aW9uIHVzZURlbGF5R3JvdXAoY29udGV4dCwgb3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG4gIGNvbnN0IHtcbiAgICBvcGVuLFxuICAgIG9uT3BlbkNoYW5nZSxcbiAgICBmbG9hdGluZ0lkXG4gIH0gPSBjb250ZXh0O1xuICBjb25zdCB7XG4gICAgaWQ6IG9wdGlvbklkLFxuICAgIGVuYWJsZWQgPSB0cnVlXG4gIH0gPSBvcHRpb25zO1xuICBjb25zdCBpZCA9IG9wdGlvbklkICE9IG51bGwgPyBvcHRpb25JZCA6IGZsb2F0aW5nSWQ7XG4gIGNvbnN0IGdyb3VwQ29udGV4dCA9IHVzZURlbGF5R3JvdXBDb250ZXh0KCk7XG4gIGNvbnN0IHtcbiAgICBjdXJyZW50SWQsXG4gICAgc2V0Q3VycmVudElkLFxuICAgIGluaXRpYWxEZWxheSxcbiAgICBzZXRTdGF0ZSxcbiAgICB0aW1lb3V0TXNcbiAgfSA9IGdyb3VwQ29udGV4dDtcbiAgaW5kZXgoKCkgPT4ge1xuICAgIGlmICghZW5hYmxlZCkgcmV0dXJuO1xuICAgIGlmICghY3VycmVudElkKSByZXR1cm47XG4gICAgc2V0U3RhdGUoe1xuICAgICAgZGVsYXk6IHtcbiAgICAgICAgb3BlbjogMSxcbiAgICAgICAgY2xvc2U6IGdldERlbGF5KGluaXRpYWxEZWxheSwgJ2Nsb3NlJylcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoY3VycmVudElkICE9PSBpZCkge1xuICAgICAgb25PcGVuQ2hhbmdlKGZhbHNlKTtcbiAgICB9XG4gIH0sIFtlbmFibGVkLCBpZCwgb25PcGVuQ2hhbmdlLCBzZXRTdGF0ZSwgY3VycmVudElkLCBpbml0aWFsRGVsYXldKTtcbiAgaW5kZXgoKCkgPT4ge1xuICAgIGZ1bmN0aW9uIHVuc2V0KCkge1xuICAgICAgb25PcGVuQ2hhbmdlKGZhbHNlKTtcbiAgICAgIHNldFN0YXRlKHtcbiAgICAgICAgZGVsYXk6IGluaXRpYWxEZWxheSxcbiAgICAgICAgY3VycmVudElkOiBudWxsXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKCFlbmFibGVkKSByZXR1cm47XG4gICAgaWYgKCFjdXJyZW50SWQpIHJldHVybjtcbiAgICBpZiAoIW9wZW4gJiYgY3VycmVudElkID09PSBpZCkge1xuICAgICAgaWYgKHRpbWVvdXRNcykge1xuICAgICAgICBjb25zdCB0aW1lb3V0ID0gd2luZG93LnNldFRpbWVvdXQodW5zZXQsIHRpbWVvdXRNcyk7XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgdW5zZXQoKTtcbiAgICB9XG4gIH0sIFtlbmFibGVkLCBvcGVuLCBzZXRTdGF0ZSwgY3VycmVudElkLCBpZCwgb25PcGVuQ2hhbmdlLCBpbml0aWFsRGVsYXksIHRpbWVvdXRNc10pO1xuICBpbmRleCgoKSA9PiB7XG4gICAgaWYgKCFlbmFibGVkKSByZXR1cm47XG4gICAgaWYgKHNldEN1cnJlbnRJZCA9PT0gTk9PUCB8fCAhb3BlbikgcmV0dXJuO1xuICAgIHNldEN1cnJlbnRJZChpZCk7XG4gIH0sIFtlbmFibGVkLCBvcGVuLCBzZXRDdXJyZW50SWQsIGlkXSk7XG4gIHJldHVybiBncm91cENvbnRleHQ7XG59XG5cbmxldCByYWZJZCA9IDA7XG5mdW5jdGlvbiBlbnF1ZXVlRm9jdXMoZWwsIG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuICBjb25zdCB7XG4gICAgcHJldmVudFNjcm9sbCA9IGZhbHNlLFxuICAgIGNhbmNlbFByZXZpb3VzID0gdHJ1ZSxcbiAgICBzeW5jID0gZmFsc2VcbiAgfSA9IG9wdGlvbnM7XG4gIGNhbmNlbFByZXZpb3VzICYmIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHJhZklkKTtcbiAgY29uc3QgZXhlYyA9ICgpID0+IGVsID09IG51bGwgPyB2b2lkIDAgOiBlbC5mb2N1cyh7XG4gICAgcHJldmVudFNjcm9sbFxuICB9KTtcbiAgaWYgKHN5bmMpIHtcbiAgICBleGVjKCk7XG4gIH0gZWxzZSB7XG4gICAgcmFmSWQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZXhlYyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0QW5jZXN0b3JzKG5vZGVzLCBpZCkge1xuICB2YXIgX25vZGVzJGZpbmQ7XG4gIGxldCBhbGxBbmNlc3RvcnMgPSBbXTtcbiAgbGV0IGN1cnJlbnRQYXJlbnRJZCA9IChfbm9kZXMkZmluZCA9IG5vZGVzLmZpbmQobm9kZSA9PiBub2RlLmlkID09PSBpZCkpID09IG51bGwgPyB2b2lkIDAgOiBfbm9kZXMkZmluZC5wYXJlbnRJZDtcbiAgd2hpbGUgKGN1cnJlbnRQYXJlbnRJZCkge1xuICAgIGNvbnN0IGN1cnJlbnROb2RlID0gbm9kZXMuZmluZChub2RlID0+IG5vZGUuaWQgPT09IGN1cnJlbnRQYXJlbnRJZCk7XG4gICAgY3VycmVudFBhcmVudElkID0gY3VycmVudE5vZGUgPT0gbnVsbCA/IHZvaWQgMCA6IGN1cnJlbnROb2RlLnBhcmVudElkO1xuICAgIGlmIChjdXJyZW50Tm9kZSkge1xuICAgICAgYWxsQW5jZXN0b3JzID0gYWxsQW5jZXN0b3JzLmNvbmNhdChjdXJyZW50Tm9kZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBhbGxBbmNlc3RvcnM7XG59XG5cbmZ1bmN0aW9uIGdldENoaWxkcmVuKG5vZGVzLCBpZCkge1xuICBsZXQgYWxsQ2hpbGRyZW4gPSBub2Rlcy5maWx0ZXIobm9kZSA9PiB7XG4gICAgdmFyIF9ub2RlJGNvbnRleHQ7XG4gICAgcmV0dXJuIG5vZGUucGFyZW50SWQgPT09IGlkICYmICgoX25vZGUkY29udGV4dCA9IG5vZGUuY29udGV4dCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9ub2RlJGNvbnRleHQub3Blbik7XG4gIH0pO1xuICBsZXQgY3VycmVudENoaWxkcmVuID0gYWxsQ2hpbGRyZW47XG4gIHdoaWxlIChjdXJyZW50Q2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgY3VycmVudENoaWxkcmVuID0gbm9kZXMuZmlsdGVyKG5vZGUgPT4ge1xuICAgICAgdmFyIF9jdXJyZW50Q2hpbGRyZW47XG4gICAgICByZXR1cm4gKF9jdXJyZW50Q2hpbGRyZW4gPSBjdXJyZW50Q2hpbGRyZW4pID09IG51bGwgPyB2b2lkIDAgOiBfY3VycmVudENoaWxkcmVuLnNvbWUobiA9PiB7XG4gICAgICAgIHZhciBfbm9kZSRjb250ZXh0MjtcbiAgICAgICAgcmV0dXJuIG5vZGUucGFyZW50SWQgPT09IG4uaWQgJiYgKChfbm9kZSRjb250ZXh0MiA9IG5vZGUuY29udGV4dCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9ub2RlJGNvbnRleHQyLm9wZW4pO1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgYWxsQ2hpbGRyZW4gPSBhbGxDaGlsZHJlbi5jb25jYXQoY3VycmVudENoaWxkcmVuKTtcbiAgfVxuICByZXR1cm4gYWxsQ2hpbGRyZW47XG59XG5mdW5jdGlvbiBnZXREZWVwZXN0Tm9kZShub2RlcywgaWQpIHtcbiAgbGV0IGRlZXBlc3ROb2RlSWQ7XG4gIGxldCBtYXhEZXB0aCA9IC0xO1xuICBmdW5jdGlvbiBmaW5kRGVlcGVzdChub2RlSWQsIGRlcHRoKSB7XG4gICAgaWYgKGRlcHRoID4gbWF4RGVwdGgpIHtcbiAgICAgIGRlZXBlc3ROb2RlSWQgPSBub2RlSWQ7XG4gICAgICBtYXhEZXB0aCA9IGRlcHRoO1xuICAgIH1cbiAgICBjb25zdCBjaGlsZHJlbiA9IGdldENoaWxkcmVuKG5vZGVzLCBub2RlSWQpO1xuICAgIGNoaWxkcmVuLmZvckVhY2goY2hpbGQgPT4ge1xuICAgICAgZmluZERlZXBlc3QoY2hpbGQuaWQsIGRlcHRoICsgMSk7XG4gICAgfSk7XG4gIH1cbiAgZmluZERlZXBlc3QoaWQsIDApO1xuICByZXR1cm4gbm9kZXMuZmluZChub2RlID0+IG5vZGUuaWQgPT09IGRlZXBlc3ROb2RlSWQpO1xufVxuXG4vLyBNb2RpZmllZCB0byBhZGQgY29uZGl0aW9uYWwgYGFyaWEtaGlkZGVuYCBzdXBwb3J0OlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL3RoZUthc2hleS9hcmlhLWhpZGRlbi9ibG9iLzkyMjBjOGY0YTRmZDM1ZjYzYmVlNTUxMGE5ZjQxYTM3MjY0MzgyZDQvc3JjL2luZGV4LnRzXG5sZXQgY291bnRlck1hcCA9IC8qI19fUFVSRV9fKi9uZXcgV2Vha01hcCgpO1xubGV0IHVuY29udHJvbGxlZEVsZW1lbnRzU2V0ID0gLyojX19QVVJFX18qL25ldyBXZWFrU2V0KCk7XG5sZXQgbWFya2VyTWFwID0ge307XG5sZXQgbG9ja0NvdW50JDEgPSAwO1xuY29uc3Qgc3VwcG9ydHNJbmVydCA9ICgpID0+IHR5cGVvZiBIVE1MRWxlbWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgJ2luZXJ0JyBpbiBIVE1MRWxlbWVudC5wcm90b3R5cGU7XG5jb25zdCB1bndyYXBIb3N0ID0gbm9kZSA9PiBub2RlICYmIChub2RlLmhvc3QgfHwgdW53cmFwSG9zdChub2RlLnBhcmVudE5vZGUpKTtcbmNvbnN0IGNvcnJlY3RFbGVtZW50cyA9IChwYXJlbnQsIHRhcmdldHMpID0+IHRhcmdldHMubWFwKHRhcmdldCA9PiB7XG4gIGlmIChwYXJlbnQuY29udGFpbnModGFyZ2V0KSkge1xuICAgIHJldHVybiB0YXJnZXQ7XG4gIH1cbiAgY29uc3QgY29ycmVjdGVkVGFyZ2V0ID0gdW53cmFwSG9zdCh0YXJnZXQpO1xuICBpZiAocGFyZW50LmNvbnRhaW5zKGNvcnJlY3RlZFRhcmdldCkpIHtcbiAgICByZXR1cm4gY29ycmVjdGVkVGFyZ2V0O1xuICB9XG4gIHJldHVybiBudWxsO1xufSkuZmlsdGVyKHggPT4geCAhPSBudWxsKTtcbmZ1bmN0aW9uIGFwcGx5QXR0cmlidXRlVG9PdGhlcnModW5jb3JyZWN0ZWRBdm9pZEVsZW1lbnRzLCBib2R5LCBhcmlhSGlkZGVuLCBpbmVydCkge1xuICBjb25zdCBtYXJrZXJOYW1lID0gJ2RhdGEtZmxvYXRpbmctdWktaW5lcnQnO1xuICBjb25zdCBjb250cm9sQXR0cmlidXRlID0gaW5lcnQgPyAnaW5lcnQnIDogYXJpYUhpZGRlbiA/ICdhcmlhLWhpZGRlbicgOiBudWxsO1xuICBjb25zdCBhdm9pZEVsZW1lbnRzID0gY29ycmVjdEVsZW1lbnRzKGJvZHksIHVuY29ycmVjdGVkQXZvaWRFbGVtZW50cyk7XG4gIGNvbnN0IGVsZW1lbnRzVG9LZWVwID0gbmV3IFNldCgpO1xuICBjb25zdCBlbGVtZW50c1RvU3RvcCA9IG5ldyBTZXQoYXZvaWRFbGVtZW50cyk7XG4gIGNvbnN0IGhpZGRlbkVsZW1lbnRzID0gW107XG4gIGlmICghbWFya2VyTWFwW21hcmtlck5hbWVdKSB7XG4gICAgbWFya2VyTWFwW21hcmtlck5hbWVdID0gbmV3IFdlYWtNYXAoKTtcbiAgfVxuICBjb25zdCBtYXJrZXJDb3VudGVyID0gbWFya2VyTWFwW21hcmtlck5hbWVdO1xuICBhdm9pZEVsZW1lbnRzLmZvckVhY2goa2VlcCk7XG4gIGRlZXAoYm9keSk7XG4gIGVsZW1lbnRzVG9LZWVwLmNsZWFyKCk7XG4gIGZ1bmN0aW9uIGtlZXAoZWwpIHtcbiAgICBpZiAoIWVsIHx8IGVsZW1lbnRzVG9LZWVwLmhhcyhlbCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZWxlbWVudHNUb0tlZXAuYWRkKGVsKTtcbiAgICBlbC5wYXJlbnROb2RlICYmIGtlZXAoZWwucGFyZW50Tm9kZSk7XG4gIH1cbiAgZnVuY3Rpb24gZGVlcChwYXJlbnQpIHtcbiAgICBpZiAoIXBhcmVudCB8fCBlbGVtZW50c1RvU3RvcC5oYXMocGFyZW50KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBbXS5mb3JFYWNoLmNhbGwocGFyZW50LmNoaWxkcmVuLCBub2RlID0+IHtcbiAgICAgIGlmIChnZXROb2RlTmFtZShub2RlKSA9PT0gJ3NjcmlwdCcpIHJldHVybjtcbiAgICAgIGlmIChlbGVtZW50c1RvS2VlcC5oYXMobm9kZSkpIHtcbiAgICAgICAgZGVlcChub2RlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGF0dHIgPSBjb250cm9sQXR0cmlidXRlID8gbm9kZS5nZXRBdHRyaWJ1dGUoY29udHJvbEF0dHJpYnV0ZSkgOiBudWxsO1xuICAgICAgICBjb25zdCBhbHJlYWR5SGlkZGVuID0gYXR0ciAhPT0gbnVsbCAmJiBhdHRyICE9PSAnZmFsc2UnO1xuICAgICAgICBjb25zdCBjb3VudGVyVmFsdWUgPSAoY291bnRlck1hcC5nZXQobm9kZSkgfHwgMCkgKyAxO1xuICAgICAgICBjb25zdCBtYXJrZXJWYWx1ZSA9IChtYXJrZXJDb3VudGVyLmdldChub2RlKSB8fCAwKSArIDE7XG4gICAgICAgIGNvdW50ZXJNYXAuc2V0KG5vZGUsIGNvdW50ZXJWYWx1ZSk7XG4gICAgICAgIG1hcmtlckNvdW50ZXIuc2V0KG5vZGUsIG1hcmtlclZhbHVlKTtcbiAgICAgICAgaGlkZGVuRWxlbWVudHMucHVzaChub2RlKTtcbiAgICAgICAgaWYgKGNvdW50ZXJWYWx1ZSA9PT0gMSAmJiBhbHJlYWR5SGlkZGVuKSB7XG4gICAgICAgICAgdW5jb250cm9sbGVkRWxlbWVudHNTZXQuYWRkKG5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtYXJrZXJWYWx1ZSA9PT0gMSkge1xuICAgICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKG1hcmtlck5hbWUsICcnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWFscmVhZHlIaWRkZW4gJiYgY29udHJvbEF0dHJpYnV0ZSkge1xuICAgICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKGNvbnRyb2xBdHRyaWJ1dGUsICd0cnVlJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBsb2NrQ291bnQkMSsrO1xuICByZXR1cm4gKCkgPT4ge1xuICAgIGhpZGRlbkVsZW1lbnRzLmZvckVhY2goZWxlbWVudCA9PiB7XG4gICAgICBjb25zdCBjb3VudGVyVmFsdWUgPSAoY291bnRlck1hcC5nZXQoZWxlbWVudCkgfHwgMCkgLSAxO1xuICAgICAgY29uc3QgbWFya2VyVmFsdWUgPSAobWFya2VyQ291bnRlci5nZXQoZWxlbWVudCkgfHwgMCkgLSAxO1xuICAgICAgY291bnRlck1hcC5zZXQoZWxlbWVudCwgY291bnRlclZhbHVlKTtcbiAgICAgIG1hcmtlckNvdW50ZXIuc2V0KGVsZW1lbnQsIG1hcmtlclZhbHVlKTtcbiAgICAgIGlmICghY291bnRlclZhbHVlKSB7XG4gICAgICAgIGlmICghdW5jb250cm9sbGVkRWxlbWVudHNTZXQuaGFzKGVsZW1lbnQpICYmIGNvbnRyb2xBdHRyaWJ1dGUpIHtcbiAgICAgICAgICBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShjb250cm9sQXR0cmlidXRlKTtcbiAgICAgICAgfVxuICAgICAgICB1bmNvbnRyb2xsZWRFbGVtZW50c1NldC5kZWxldGUoZWxlbWVudCk7XG4gICAgICB9XG4gICAgICBpZiAoIW1hcmtlclZhbHVlKSB7XG4gICAgICAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKG1hcmtlck5hbWUpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGxvY2tDb3VudCQxLS07XG4gICAgaWYgKCFsb2NrQ291bnQkMSkge1xuICAgICAgY291bnRlck1hcCA9IG5ldyBXZWFrTWFwKCk7XG4gICAgICBjb3VudGVyTWFwID0gbmV3IFdlYWtNYXAoKTtcbiAgICAgIHVuY29udHJvbGxlZEVsZW1lbnRzU2V0ID0gbmV3IFdlYWtTZXQoKTtcbiAgICAgIG1hcmtlck1hcCA9IHt9O1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIG1hcmtPdGhlcnMoYXZvaWRFbGVtZW50cywgYXJpYUhpZGRlbiwgaW5lcnQpIHtcbiAgaWYgKGFyaWFIaWRkZW4gPT09IHZvaWQgMCkge1xuICAgIGFyaWFIaWRkZW4gPSBmYWxzZTtcbiAgfVxuICBpZiAoaW5lcnQgPT09IHZvaWQgMCkge1xuICAgIGluZXJ0ID0gZmFsc2U7XG4gIH1cbiAgY29uc3QgYm9keSA9IGdldERvY3VtZW50KGF2b2lkRWxlbWVudHNbMF0pLmJvZHk7XG4gIHJldHVybiBhcHBseUF0dHJpYnV0ZVRvT3RoZXJzKGF2b2lkRWxlbWVudHMuY29uY2F0KEFycmF5LmZyb20oYm9keS5xdWVyeVNlbGVjdG9yQWxsKCdbYXJpYS1saXZlXScpKSksIGJvZHksIGFyaWFIaWRkZW4sIGluZXJ0KTtcbn1cblxuY29uc3QgZ2V0VGFiYmFibGVPcHRpb25zID0gKCkgPT4gKHtcbiAgZ2V0U2hhZG93Um9vdDogdHJ1ZSxcbiAgZGlzcGxheUNoZWNrOlxuICAvLyBKU0RPTSBkb2VzIG5vdCBzdXBwb3J0IHRoZSBgdGFiYmFibGVgIGxpYnJhcnkuIFRvIHNvbHZlIHRoaXMgd2UgY2FuXG4gIC8vIGNoZWNrIGlmIGBSZXNpemVPYnNlcnZlcmAgaXMgYSByZWFsIGZ1bmN0aW9uIChub3QgcG9seWZpbGxlZCksIHdoaWNoXG4gIC8vIGRldGVybWluZXMgaWYgdGhlIGN1cnJlbnQgZW52aXJvbm1lbnQgaXMgSlNET00tbGlrZS5cbiAgdHlwZW9mIFJlc2l6ZU9ic2VydmVyID09PSAnZnVuY3Rpb24nICYmIFJlc2l6ZU9ic2VydmVyLnRvU3RyaW5nKCkuaW5jbHVkZXMoJ1tuYXRpdmUgY29kZV0nKSA/ICdmdWxsJyA6ICdub25lJ1xufSk7XG5mdW5jdGlvbiBnZXRUYWJiYWJsZUluKGNvbnRhaW5lciwgZGlyZWN0aW9uKSB7XG4gIGNvbnN0IGFsbFRhYmJhYmxlID0gdGFiYmFibGUoY29udGFpbmVyLCBnZXRUYWJiYWJsZU9wdGlvbnMoKSk7XG4gIGlmIChkaXJlY3Rpb24gPT09ICdwcmV2Jykge1xuICAgIGFsbFRhYmJhYmxlLnJldmVyc2UoKTtcbiAgfVxuICBjb25zdCBhY3RpdmVJbmRleCA9IGFsbFRhYmJhYmxlLmluZGV4T2YoYWN0aXZlRWxlbWVudChnZXREb2N1bWVudChjb250YWluZXIpKSk7XG4gIGNvbnN0IG5leHRUYWJiYWJsZUVsZW1lbnRzID0gYWxsVGFiYmFibGUuc2xpY2UoYWN0aXZlSW5kZXggKyAxKTtcbiAgcmV0dXJuIG5leHRUYWJiYWJsZUVsZW1lbnRzWzBdO1xufVxuZnVuY3Rpb24gZ2V0TmV4dFRhYmJhYmxlKCkge1xuICByZXR1cm4gZ2V0VGFiYmFibGVJbihkb2N1bWVudC5ib2R5LCAnbmV4dCcpO1xufVxuZnVuY3Rpb24gZ2V0UHJldmlvdXNUYWJiYWJsZSgpIHtcbiAgcmV0dXJuIGdldFRhYmJhYmxlSW4oZG9jdW1lbnQuYm9keSwgJ3ByZXYnKTtcbn1cbmZ1bmN0aW9uIGlzT3V0c2lkZUV2ZW50KGV2ZW50LCBjb250YWluZXIpIHtcbiAgY29uc3QgY29udGFpbmVyRWxlbWVudCA9IGNvbnRhaW5lciB8fCBldmVudC5jdXJyZW50VGFyZ2V0O1xuICBjb25zdCByZWxhdGVkVGFyZ2V0ID0gZXZlbnQucmVsYXRlZFRhcmdldDtcbiAgcmV0dXJuICFyZWxhdGVkVGFyZ2V0IHx8ICFjb250YWlucyhjb250YWluZXJFbGVtZW50LCByZWxhdGVkVGFyZ2V0KTtcbn1cbmZ1bmN0aW9uIGRpc2FibGVGb2N1c0luc2lkZShjb250YWluZXIpIHtcbiAgY29uc3QgdGFiYmFibGVFbGVtZW50cyA9IHRhYmJhYmxlKGNvbnRhaW5lciwgZ2V0VGFiYmFibGVPcHRpb25zKCkpO1xuICB0YWJiYWJsZUVsZW1lbnRzLmZvckVhY2goZWxlbWVudCA9PiB7XG4gICAgZWxlbWVudC5kYXRhc2V0LnRhYmluZGV4ID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3RhYmluZGV4JykgfHwgJyc7XG4gICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3RhYmluZGV4JywgJy0xJyk7XG4gIH0pO1xufVxuZnVuY3Rpb24gZW5hYmxlRm9jdXNJbnNpZGUoY29udGFpbmVyKSB7XG4gIGNvbnN0IGVsZW1lbnRzID0gY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3JBbGwoJ1tkYXRhLXRhYmluZGV4XScpO1xuICBlbGVtZW50cy5mb3JFYWNoKGVsZW1lbnQgPT4ge1xuICAgIGNvbnN0IHRhYmluZGV4ID0gZWxlbWVudC5kYXRhc2V0LnRhYmluZGV4O1xuICAgIGRlbGV0ZSBlbGVtZW50LmRhdGFzZXQudGFiaW5kZXg7XG4gICAgaWYgKHRhYmluZGV4KSB7XG4gICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgndGFiaW5kZXgnLCB0YWJpbmRleCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCd0YWJpbmRleCcpO1xuICAgIH1cbiAgfSk7XG59XG5cbi8vIFNlZSBEaWVnbyBIYXoncyBTYW5kYm94IGZvciBtYWtpbmcgdGhpcyBsb2dpYyB3b3JrIHdlbGwgb24gU2FmYXJpL2lPUzpcbi8vIGh0dHBzOi8vY29kZXNhbmRib3guaW8vcy90YWJiYWJsZS1wb3J0YWwtZjR0bmc/ZmlsZT0vc3JjL0ZvY3VzVHJhcC50c3hcblxuY29uc3QgSElEREVOX1NUWUxFUyA9IHtcbiAgYm9yZGVyOiAwLFxuICBjbGlwOiAncmVjdCgwIDAgMCAwKScsXG4gIGhlaWdodDogJzFweCcsXG4gIG1hcmdpbjogJy0xcHgnLFxuICBvdmVyZmxvdzogJ2hpZGRlbicsXG4gIHBhZGRpbmc6IDAsXG4gIHBvc2l0aW9uOiAnZml4ZWQnLFxuICB3aGl0ZVNwYWNlOiAnbm93cmFwJyxcbiAgd2lkdGg6ICcxcHgnLFxuICB0b3A6IDAsXG4gIGxlZnQ6IDBcbn07XG5sZXQgdGltZW91dElkO1xuZnVuY3Rpb24gc2V0QWN0aXZlRWxlbWVudE9uVGFiKGV2ZW50KSB7XG4gIGlmIChldmVudC5rZXkgPT09ICdUYWInKSB7XG4gICAgZXZlbnQudGFyZ2V0O1xuICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SWQpO1xuICB9XG59XG5jb25zdCBGb2N1c0d1YXJkID0gLyojX19QVVJFX18qL1JlYWN0LmZvcndhcmRSZWYoZnVuY3Rpb24gRm9jdXNHdWFyZChwcm9wcywgcmVmKSB7XG4gIGNvbnN0IFtyb2xlLCBzZXRSb2xlXSA9IFJlYWN0LnVzZVN0YXRlKCk7XG4gIGluZGV4KCgpID0+IHtcbiAgICBpZiAoaXNTYWZhcmkoKSkge1xuICAgICAgLy8gVW5saWtlIG90aGVyIHNjcmVlbiByZWFkZXJzIHN1Y2ggYXMgTlZEQSBhbmQgSkFXUywgdGhlIHZpcnR1YWwgY3Vyc29yXG4gICAgICAvLyBvbiBWb2ljZU92ZXIgZG9lcyB0cmlnZ2VyIHRoZSBvbkZvY3VzIGV2ZW50LCBzbyB3ZSBjYW4gdXNlIHRoZSBmb2N1c1xuICAgICAgLy8gdHJhcCBlbGVtZW50LiBPbiBTYWZhcmksIG9ubHkgYnV0dG9ucyB0cmlnZ2VyIHRoZSBvbkZvY3VzIGV2ZW50LlxuICAgICAgLy8gTkI6IFwiZ3JvdXBcIiByb2xlIGluIHRoZSBTYW5kYm94IG5vIGxvbmdlciBhcHBlYXJzIHRvIHdvcmssIG11c3QgYmUgYVxuICAgICAgLy8gYnV0dG9uIHJvbGUuXG4gICAgICBzZXRSb2xlKCdidXR0b24nKTtcbiAgICB9XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHNldEFjdGl2ZUVsZW1lbnRPblRhYik7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBzZXRBY3RpdmVFbGVtZW50T25UYWIpO1xuICAgIH07XG4gIH0sIFtdKTtcbiAgY29uc3QgcmVzdFByb3BzID0ge1xuICAgIHJlZixcbiAgICB0YWJJbmRleDogMCxcbiAgICAvLyBSb2xlIGlzIG9ubHkgZm9yIFZvaWNlT3ZlclxuICAgIHJvbGUsXG4gICAgJ2FyaWEtaGlkZGVuJzogcm9sZSA/IHVuZGVmaW5lZCA6IHRydWUsXG4gICAgW2NyZWF0ZUF0dHJpYnV0ZSgnZm9jdXMtZ3VhcmQnKV06ICcnLFxuICAgIHN0eWxlOiBISURERU5fU1RZTEVTXG4gIH07XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcInNwYW5cIiwgX2V4dGVuZHMoe30sIHByb3BzLCByZXN0UHJvcHMpKTtcbn0pO1xuXG5jb25zdCBQb3J0YWxDb250ZXh0ID0gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUNvbnRleHQobnVsbCk7XG5jb25zdCBhdHRyID0gLyojX19QVVJFX18qL2NyZWF0ZUF0dHJpYnV0ZSgncG9ydGFsJyk7XG4vKipcbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9GbG9hdGluZ1BvcnRhbCN1c2VmbG9hdGluZ3BvcnRhbG5vZGVcbiAqL1xuZnVuY3Rpb24gdXNlRmxvYXRpbmdQb3J0YWxOb2RlKHByb3BzKSB7XG4gIGlmIChwcm9wcyA9PT0gdm9pZCAwKSB7XG4gICAgcHJvcHMgPSB7fTtcbiAgfVxuICBjb25zdCB7XG4gICAgaWQsXG4gICAgcm9vdFxuICB9ID0gcHJvcHM7XG4gIGNvbnN0IHVuaXF1ZUlkID0gdXNlSWQoKTtcbiAgY29uc3QgcG9ydGFsQ29udGV4dCA9IHVzZVBvcnRhbENvbnRleHQoKTtcbiAgY29uc3QgW3BvcnRhbE5vZGUsIHNldFBvcnRhbE5vZGVdID0gUmVhY3QudXNlU3RhdGUobnVsbCk7XG4gIGNvbnN0IHBvcnRhbE5vZGVSZWYgPSBSZWFjdC51c2VSZWYobnVsbCk7XG4gIGluZGV4KCgpID0+IHtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgcG9ydGFsTm9kZSA9PSBudWxsIHx8IHBvcnRhbE5vZGUucmVtb3ZlKCk7XG4gICAgICAvLyBBbGxvdyB0aGUgc3Vic2VxdWVudCBsYXlvdXQgZWZmZWN0cyB0byBjcmVhdGUgYSBuZXcgbm9kZSBvbiB1cGRhdGVzLlxuICAgICAgLy8gVGhlIHBvcnRhbCBub2RlIHdpbGwgc3RpbGwgYmUgY2xlYW5lZCB1cCBvbiB1bm1vdW50LlxuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2Zsb2F0aW5nLXVpL2Zsb2F0aW5nLXVpL2lzc3Vlcy8yNDU0XG4gICAgICBxdWV1ZU1pY3JvdGFzaygoKSA9PiB7XG4gICAgICAgIHBvcnRhbE5vZGVSZWYuY3VycmVudCA9IG51bGw7XG4gICAgICB9KTtcbiAgICB9O1xuICB9LCBbcG9ydGFsTm9kZV0pO1xuICBpbmRleCgoKSA9PiB7XG4gICAgLy8gV2FpdCBmb3IgdGhlIHVuaXF1ZUlkIHRvIGJlIGdlbmVyYXRlZCBiZWZvcmUgY3JlYXRpbmcgdGhlIHBvcnRhbCBub2RlIGluXG4gICAgLy8gUmVhY3QgPDE4ICh1c2luZyBgdXNlRmxvYXRpbmdJZGAgaW5zdGVhZCBvZiB0aGUgbmF0aXZlIGB1c2VJZGApLlxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mbG9hdGluZy11aS9mbG9hdGluZy11aS9pc3N1ZXMvMjc3OFxuICAgIGlmICghdW5pcXVlSWQpIHJldHVybjtcbiAgICBpZiAocG9ydGFsTm9kZVJlZi5jdXJyZW50KSByZXR1cm47XG4gICAgY29uc3QgZXhpc3RpbmdJZFJvb3QgPSBpZCA/IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGlkKSA6IG51bGw7XG4gICAgaWYgKCFleGlzdGluZ0lkUm9vdCkgcmV0dXJuO1xuICAgIGNvbnN0IHN1YlJvb3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBzdWJSb290LmlkID0gdW5pcXVlSWQ7XG4gICAgc3ViUm9vdC5zZXRBdHRyaWJ1dGUoYXR0ciwgJycpO1xuICAgIGV4aXN0aW5nSWRSb290LmFwcGVuZENoaWxkKHN1YlJvb3QpO1xuICAgIHBvcnRhbE5vZGVSZWYuY3VycmVudCA9IHN1YlJvb3Q7XG4gICAgc2V0UG9ydGFsTm9kZShzdWJSb290KTtcbiAgfSwgW2lkLCB1bmlxdWVJZF0pO1xuICBpbmRleCgoKSA9PiB7XG4gICAgLy8gV2FpdCBmb3IgdGhlIHJvb3QgdG8gZXhpc3QgYmVmb3JlIGNyZWF0aW5nIHRoZSBwb3J0YWwgbm9kZS4gVGhlIHJvb3QgbXVzdFxuICAgIC8vIGJlIHN0b3JlZCBpbiBzdGF0ZSwgbm90IGEgcmVmLCBmb3IgdGhpcyB0byB3b3JrIHJlYWN0aXZlbHkuXG4gICAgaWYgKHJvb3QgPT09IG51bGwpIHJldHVybjtcbiAgICBpZiAoIXVuaXF1ZUlkKSByZXR1cm47XG4gICAgaWYgKHBvcnRhbE5vZGVSZWYuY3VycmVudCkgcmV0dXJuO1xuICAgIGxldCBjb250YWluZXIgPSByb290IHx8IChwb3J0YWxDb250ZXh0ID09IG51bGwgPyB2b2lkIDAgOiBwb3J0YWxDb250ZXh0LnBvcnRhbE5vZGUpO1xuICAgIGlmIChjb250YWluZXIgJiYgIWlzRWxlbWVudChjb250YWluZXIpKSBjb250YWluZXIgPSBjb250YWluZXIuY3VycmVudDtcbiAgICBjb250YWluZXIgPSBjb250YWluZXIgfHwgZG9jdW1lbnQuYm9keTtcbiAgICBsZXQgaWRXcmFwcGVyID0gbnVsbDtcbiAgICBpZiAoaWQpIHtcbiAgICAgIGlkV3JhcHBlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgaWRXcmFwcGVyLmlkID0gaWQ7XG4gICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoaWRXcmFwcGVyKTtcbiAgICB9XG4gICAgY29uc3Qgc3ViUm9vdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHN1YlJvb3QuaWQgPSB1bmlxdWVJZDtcbiAgICBzdWJSb290LnNldEF0dHJpYnV0ZShhdHRyLCAnJyk7XG4gICAgY29udGFpbmVyID0gaWRXcmFwcGVyIHx8IGNvbnRhaW5lcjtcbiAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoc3ViUm9vdCk7XG4gICAgcG9ydGFsTm9kZVJlZi5jdXJyZW50ID0gc3ViUm9vdDtcbiAgICBzZXRQb3J0YWxOb2RlKHN1YlJvb3QpO1xuICB9LCBbaWQsIHJvb3QsIHVuaXF1ZUlkLCBwb3J0YWxDb250ZXh0XSk7XG4gIHJldHVybiBwb3J0YWxOb2RlO1xufVxuLyoqXG4gKiBQb3J0YWxzIHRoZSBmbG9hdGluZyBlbGVtZW50IGludG8gYSBnaXZlbiBjb250YWluZXIgZWxlbWVudCDigJQgYnkgZGVmYXVsdCxcbiAqIG91dHNpZGUgb2YgdGhlIGFwcCByb290IGFuZCBpbnRvIHRoZSBib2R5LlxuICogVGhpcyBpcyBuZWNlc3NhcnkgdG8gZW5zdXJlIHRoZSBmbG9hdGluZyBlbGVtZW50IGNhbiBhcHBlYXIgb3V0c2lkZSBhbnlcbiAqIHBvdGVudGlhbCBwYXJlbnQgY29udGFpbmVycyB0aGF0IGNhdXNlIGNsaXBwaW5nIChzdWNoIGFzIGBvdmVyZmxvdzogaGlkZGVuYCksXG4gKiB3aGlsZSByZXRhaW5pbmcgaXRzIGxvY2F0aW9uIGluIHRoZSBSZWFjdCB0cmVlLlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL0Zsb2F0aW5nUG9ydGFsXG4gKi9cbmZ1bmN0aW9uIEZsb2F0aW5nUG9ydGFsKHByb3BzKSB7XG4gIGNvbnN0IHtcbiAgICBjaGlsZHJlbixcbiAgICBpZCxcbiAgICByb290LFxuICAgIHByZXNlcnZlVGFiT3JkZXIgPSB0cnVlXG4gIH0gPSBwcm9wcztcbiAgY29uc3QgcG9ydGFsTm9kZSA9IHVzZUZsb2F0aW5nUG9ydGFsTm9kZSh7XG4gICAgaWQsXG4gICAgcm9vdFxuICB9KTtcbiAgY29uc3QgW2ZvY3VzTWFuYWdlclN0YXRlLCBzZXRGb2N1c01hbmFnZXJTdGF0ZV0gPSBSZWFjdC51c2VTdGF0ZShudWxsKTtcbiAgY29uc3QgYmVmb3JlT3V0c2lkZVJlZiA9IFJlYWN0LnVzZVJlZihudWxsKTtcbiAgY29uc3QgYWZ0ZXJPdXRzaWRlUmVmID0gUmVhY3QudXNlUmVmKG51bGwpO1xuICBjb25zdCBiZWZvcmVJbnNpZGVSZWYgPSBSZWFjdC51c2VSZWYobnVsbCk7XG4gIGNvbnN0IGFmdGVySW5zaWRlUmVmID0gUmVhY3QudXNlUmVmKG51bGwpO1xuICBjb25zdCBtb2RhbCA9IGZvY3VzTWFuYWdlclN0YXRlID09IG51bGwgPyB2b2lkIDAgOiBmb2N1c01hbmFnZXJTdGF0ZS5tb2RhbDtcbiAgY29uc3Qgb3BlbiA9IGZvY3VzTWFuYWdlclN0YXRlID09IG51bGwgPyB2b2lkIDAgOiBmb2N1c01hbmFnZXJTdGF0ZS5vcGVuO1xuICBjb25zdCBzaG91bGRSZW5kZXJHdWFyZHMgPVxuICAvLyBUaGUgRm9jdXNNYW5hZ2VyIGFuZCB0aGVyZWZvcmUgZmxvYXRpbmcgZWxlbWVudCBhcmUgY3VycmVudGx5IG9wZW4vXG4gIC8vIHJlbmRlcmVkLlxuICAhIWZvY3VzTWFuYWdlclN0YXRlICYmXG4gIC8vIEd1YXJkcyBhcmUgb25seSBmb3Igbm9uLW1vZGFsIGZvY3VzIG1hbmFnZW1lbnQuXG4gICFmb2N1c01hbmFnZXJTdGF0ZS5tb2RhbCAmJlxuICAvLyBEb24ndCByZW5kZXIgaWYgdW5tb3VudCBpcyB0cmFuc2l0aW9uaW5nLlxuICBmb2N1c01hbmFnZXJTdGF0ZS5vcGVuICYmIHByZXNlcnZlVGFiT3JkZXIgJiYgISEocm9vdCB8fCBwb3J0YWxOb2RlKTtcblxuICAvLyBodHRwczovL2NvZGVzYW5kYm94LmlvL3MvdGFiYmFibGUtcG9ydGFsLWY0dG5nP2ZpbGU9L3NyYy9UYWJiYWJsZVBvcnRhbC50c3hcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIXBvcnRhbE5vZGUgfHwgIXByZXNlcnZlVGFiT3JkZXIgfHwgbW9kYWwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBNYWtlIHN1cmUgZWxlbWVudHMgaW5zaWRlIHRoZSBwb3J0YWwgZWxlbWVudCBhcmUgdGFiYmFibGUgb25seSB3aGVuIHRoZVxuICAgIC8vIHBvcnRhbCBoYXMgYWxyZWFkeSBiZWVuIGZvY3VzZWQsIGVpdGhlciBieSB0YWJiaW5nIGludG8gYSBmb2N1cyB0cmFwXG4gICAgLy8gZWxlbWVudCBvdXRzaWRlIG9yIHVzaW5nIHRoZSBtb3VzZS5cbiAgICBmdW5jdGlvbiBvbkZvY3VzKGV2ZW50KSB7XG4gICAgICBpZiAocG9ydGFsTm9kZSAmJiBpc091dHNpZGVFdmVudChldmVudCkpIHtcbiAgICAgICAgY29uc3QgZm9jdXNpbmcgPSBldmVudC50eXBlID09PSAnZm9jdXNpbic7XG4gICAgICAgIGNvbnN0IG1hbmFnZUZvY3VzID0gZm9jdXNpbmcgPyBlbmFibGVGb2N1c0luc2lkZSA6IGRpc2FibGVGb2N1c0luc2lkZTtcbiAgICAgICAgbWFuYWdlRm9jdXMocG9ydGFsTm9kZSk7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIExpc3RlbiB0byB0aGUgZXZlbnQgb24gdGhlIGNhcHR1cmUgcGhhc2Ugc28gdGhleSBydW4gYmVmb3JlIHRoZSBmb2N1c1xuICAgIC8vIHRyYXAgZWxlbWVudHMgb25Gb2N1cyBwcm9wIGlzIGNhbGxlZC5cbiAgICBwb3J0YWxOb2RlLmFkZEV2ZW50TGlzdGVuZXIoJ2ZvY3VzaW4nLCBvbkZvY3VzLCB0cnVlKTtcbiAgICBwb3J0YWxOb2RlLmFkZEV2ZW50TGlzdGVuZXIoJ2ZvY3Vzb3V0Jywgb25Gb2N1cywgdHJ1ZSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHBvcnRhbE5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcignZm9jdXNpbicsIG9uRm9jdXMsIHRydWUpO1xuICAgICAgcG9ydGFsTm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKCdmb2N1c291dCcsIG9uRm9jdXMsIHRydWUpO1xuICAgIH07XG4gIH0sIFtwb3J0YWxOb2RlLCBwcmVzZXJ2ZVRhYk9yZGVyLCBtb2RhbF0pO1xuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghcG9ydGFsTm9kZSkgcmV0dXJuO1xuICAgIGlmIChvcGVuKSByZXR1cm47XG4gICAgZW5hYmxlRm9jdXNJbnNpZGUocG9ydGFsTm9kZSk7XG4gIH0sIFtvcGVuLCBwb3J0YWxOb2RlXSk7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChQb3J0YWxDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgdmFsdWU6IFJlYWN0LnVzZU1lbW8oKCkgPT4gKHtcbiAgICAgIHByZXNlcnZlVGFiT3JkZXIsXG4gICAgICBiZWZvcmVPdXRzaWRlUmVmLFxuICAgICAgYWZ0ZXJPdXRzaWRlUmVmLFxuICAgICAgYmVmb3JlSW5zaWRlUmVmLFxuICAgICAgYWZ0ZXJJbnNpZGVSZWYsXG4gICAgICBwb3J0YWxOb2RlLFxuICAgICAgc2V0Rm9jdXNNYW5hZ2VyU3RhdGVcbiAgICB9KSwgW3ByZXNlcnZlVGFiT3JkZXIsIHBvcnRhbE5vZGVdKVxuICB9LCBzaG91bGRSZW5kZXJHdWFyZHMgJiYgcG9ydGFsTm9kZSAmJiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChGb2N1c0d1YXJkLCB7XG4gICAgXCJkYXRhLXR5cGVcIjogXCJvdXRzaWRlXCIsXG4gICAgcmVmOiBiZWZvcmVPdXRzaWRlUmVmLFxuICAgIG9uRm9jdXM6IGV2ZW50ID0+IHtcbiAgICAgIGlmIChpc091dHNpZGVFdmVudChldmVudCwgcG9ydGFsTm9kZSkpIHtcbiAgICAgICAgdmFyIF9iZWZvcmVJbnNpZGVSZWYkY3VycjtcbiAgICAgICAgKF9iZWZvcmVJbnNpZGVSZWYkY3VyciA9IGJlZm9yZUluc2lkZVJlZi5jdXJyZW50KSA9PSBudWxsIHx8IF9iZWZvcmVJbnNpZGVSZWYkY3Vyci5mb2N1cygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgcHJldlRhYmJhYmxlID0gZ2V0UHJldmlvdXNUYWJiYWJsZSgpIHx8IChmb2N1c01hbmFnZXJTdGF0ZSA9PSBudWxsID8gdm9pZCAwIDogZm9jdXNNYW5hZ2VyU3RhdGUucmVmcy5kb21SZWZlcmVuY2UuY3VycmVudCk7XG4gICAgICAgIHByZXZUYWJiYWJsZSA9PSBudWxsIHx8IHByZXZUYWJiYWJsZS5mb2N1cygpO1xuICAgICAgfVxuICAgIH1cbiAgfSksIHNob3VsZFJlbmRlckd1YXJkcyAmJiBwb3J0YWxOb2RlICYmIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwic3BhblwiLCB7XG4gICAgXCJhcmlhLW93bnNcIjogcG9ydGFsTm9kZS5pZCxcbiAgICBzdHlsZTogSElEREVOX1NUWUxFU1xuICB9KSwgcG9ydGFsTm9kZSAmJiAvKiNfX1BVUkVfXyovUmVhY3RET00uY3JlYXRlUG9ydGFsKGNoaWxkcmVuLCBwb3J0YWxOb2RlKSwgc2hvdWxkUmVuZGVyR3VhcmRzICYmIHBvcnRhbE5vZGUgJiYgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoRm9jdXNHdWFyZCwge1xuICAgIFwiZGF0YS10eXBlXCI6IFwib3V0c2lkZVwiLFxuICAgIHJlZjogYWZ0ZXJPdXRzaWRlUmVmLFxuICAgIG9uRm9jdXM6IGV2ZW50ID0+IHtcbiAgICAgIGlmIChpc091dHNpZGVFdmVudChldmVudCwgcG9ydGFsTm9kZSkpIHtcbiAgICAgICAgdmFyIF9hZnRlckluc2lkZVJlZiRjdXJyZTtcbiAgICAgICAgKF9hZnRlckluc2lkZVJlZiRjdXJyZSA9IGFmdGVySW5zaWRlUmVmLmN1cnJlbnQpID09IG51bGwgfHwgX2FmdGVySW5zaWRlUmVmJGN1cnJlLmZvY3VzKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBuZXh0VGFiYmFibGUgPSBnZXROZXh0VGFiYmFibGUoKSB8fCAoZm9jdXNNYW5hZ2VyU3RhdGUgPT0gbnVsbCA/IHZvaWQgMCA6IGZvY3VzTWFuYWdlclN0YXRlLnJlZnMuZG9tUmVmZXJlbmNlLmN1cnJlbnQpO1xuICAgICAgICBuZXh0VGFiYmFibGUgPT0gbnVsbCB8fCBuZXh0VGFiYmFibGUuZm9jdXMoKTtcbiAgICAgICAgKGZvY3VzTWFuYWdlclN0YXRlID09IG51bGwgPyB2b2lkIDAgOiBmb2N1c01hbmFnZXJTdGF0ZS5jbG9zZU9uRm9jdXNPdXQpICYmIChmb2N1c01hbmFnZXJTdGF0ZSA9PSBudWxsID8gdm9pZCAwIDogZm9jdXNNYW5hZ2VyU3RhdGUub25PcGVuQ2hhbmdlKGZhbHNlLCBldmVudC5uYXRpdmVFdmVudCwgJ2ZvY3VzLW91dCcpKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pKTtcbn1cbmNvbnN0IHVzZVBvcnRhbENvbnRleHQgPSAoKSA9PiBSZWFjdC51c2VDb250ZXh0KFBvcnRhbENvbnRleHQpO1xuXG5jb25zdCBGT0NVU0FCTEVfQVRUUklCVVRFID0gJ2RhdGEtZmxvYXRpbmctdWktZm9jdXNhYmxlJztcbmZ1bmN0aW9uIGdldEZsb2F0aW5nRm9jdXNFbGVtZW50KGZsb2F0aW5nRWxlbWVudCkge1xuICBpZiAoIWZsb2F0aW5nRWxlbWVudCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIC8vIFRyeSB0byBmaW5kIHRoZSBlbGVtZW50IHRoYXQgaGFzIGB7Li4uZ2V0RmxvYXRpbmdQcm9wcygpfWAgc3ByZWFkIG9uIGl0LlxuICAvLyBUaGlzIGluZGljYXRlcyB0aGUgZmxvYXRpbmcgZWxlbWVudCBpcyBhY3RpbmcgYXMgYSBwb3NpdGlvbmluZyB3cmFwcGVyLCBhbmRcbiAgLy8gc28gZm9jdXMgc2hvdWxkIGJlIG1hbmFnZWQgb24gdGhlIGNoaWxkIGVsZW1lbnQgd2l0aCB0aGUgZXZlbnQgaGFuZGxlcnMgYW5kXG4gIC8vIGFyaWEgcHJvcHMuXG4gIHJldHVybiBmbG9hdGluZ0VsZW1lbnQuaGFzQXR0cmlidXRlKEZPQ1VTQUJMRV9BVFRSSUJVVEUpID8gZmxvYXRpbmdFbGVtZW50IDogZmxvYXRpbmdFbGVtZW50LnF1ZXJ5U2VsZWN0b3IoXCJbXCIgKyBGT0NVU0FCTEVfQVRUUklCVVRFICsgXCJdXCIpIHx8IGZsb2F0aW5nRWxlbWVudDtcbn1cblxuY29uc3QgTElTVF9MSU1JVCA9IDIwO1xubGV0IHByZXZpb3VzbHlGb2N1c2VkRWxlbWVudHMgPSBbXTtcbmZ1bmN0aW9uIGFkZFByZXZpb3VzbHlGb2N1c2VkRWxlbWVudChlbGVtZW50KSB7XG4gIHByZXZpb3VzbHlGb2N1c2VkRWxlbWVudHMgPSBwcmV2aW91c2x5Rm9jdXNlZEVsZW1lbnRzLmZpbHRlcihlbCA9PiBlbC5pc0Nvbm5lY3RlZCk7XG4gIGxldCB0YWJiYWJsZUVsID0gZWxlbWVudDtcbiAgaWYgKCF0YWJiYWJsZUVsIHx8IGdldE5vZGVOYW1lKHRhYmJhYmxlRWwpID09PSAnYm9keScpIHJldHVybjtcbiAgaWYgKCFpc1RhYmJhYmxlKHRhYmJhYmxlRWwsIGdldFRhYmJhYmxlT3B0aW9ucygpKSkge1xuICAgIGNvbnN0IHRhYmJhYmxlQ2hpbGQgPSB0YWJiYWJsZSh0YWJiYWJsZUVsLCBnZXRUYWJiYWJsZU9wdGlvbnMoKSlbMF07XG4gICAgaWYgKHRhYmJhYmxlQ2hpbGQpIHtcbiAgICAgIHRhYmJhYmxlRWwgPSB0YWJiYWJsZUNoaWxkO1xuICAgIH1cbiAgfVxuICBwcmV2aW91c2x5Rm9jdXNlZEVsZW1lbnRzLnB1c2godGFiYmFibGVFbCk7XG4gIGlmIChwcmV2aW91c2x5Rm9jdXNlZEVsZW1lbnRzLmxlbmd0aCA+IExJU1RfTElNSVQpIHtcbiAgICBwcmV2aW91c2x5Rm9jdXNlZEVsZW1lbnRzID0gcHJldmlvdXNseUZvY3VzZWRFbGVtZW50cy5zbGljZSgtTElTVF9MSU1JVCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldFByZXZpb3VzbHlGb2N1c2VkRWxlbWVudCgpIHtcbiAgcmV0dXJuIHByZXZpb3VzbHlGb2N1c2VkRWxlbWVudHMuc2xpY2UoKS5yZXZlcnNlKCkuZmluZChlbCA9PiBlbC5pc0Nvbm5lY3RlZCk7XG59XG5jb25zdCBWaXN1YWxseUhpZGRlbkRpc21pc3MgPSAvKiNfX1BVUkVfXyovUmVhY3QuZm9yd2FyZFJlZihmdW5jdGlvbiBWaXN1YWxseUhpZGRlbkRpc21pc3MocHJvcHMsIHJlZikge1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJidXR0b25cIiwgX2V4dGVuZHMoe30sIHByb3BzLCB7XG4gICAgdHlwZTogXCJidXR0b25cIixcbiAgICByZWY6IHJlZixcbiAgICB0YWJJbmRleDogLTEsXG4gICAgc3R5bGU6IEhJRERFTl9TVFlMRVNcbiAgfSkpO1xufSk7XG4vKipcbiAqIFByb3ZpZGVzIGZvY3VzIG1hbmFnZW1lbnQgZm9yIHRoZSBmbG9hdGluZyBlbGVtZW50LlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL0Zsb2F0aW5nRm9jdXNNYW5hZ2VyXG4gKi9cbmZ1bmN0aW9uIEZsb2F0aW5nRm9jdXNNYW5hZ2VyKHByb3BzKSB7XG4gIGNvbnN0IHtcbiAgICBjb250ZXh0LFxuICAgIGNoaWxkcmVuLFxuICAgIGRpc2FibGVkID0gZmFsc2UsXG4gICAgb3JkZXIgPSBbJ2NvbnRlbnQnXSxcbiAgICBndWFyZHM6IF9ndWFyZHMgPSB0cnVlLFxuICAgIGluaXRpYWxGb2N1cyA9IDAsXG4gICAgcmV0dXJuRm9jdXMgPSB0cnVlLFxuICAgIHJlc3RvcmVGb2N1cyA9IGZhbHNlLFxuICAgIG1vZGFsID0gdHJ1ZSxcbiAgICB2aXN1YWxseUhpZGRlbkRpc21pc3MgPSBmYWxzZSxcbiAgICBjbG9zZU9uRm9jdXNPdXQgPSB0cnVlXG4gIH0gPSBwcm9wcztcbiAgY29uc3Qge1xuICAgIG9wZW4sXG4gICAgcmVmcyxcbiAgICBub2RlSWQsXG4gICAgb25PcGVuQ2hhbmdlLFxuICAgIGV2ZW50cyxcbiAgICBkYXRhUmVmLFxuICAgIGZsb2F0aW5nSWQsXG4gICAgZWxlbWVudHM6IHtcbiAgICAgIGRvbVJlZmVyZW5jZSxcbiAgICAgIGZsb2F0aW5nXG4gICAgfVxuICB9ID0gY29udGV4dDtcbiAgY29uc3QgaWdub3JlSW5pdGlhbEZvY3VzID0gdHlwZW9mIGluaXRpYWxGb2N1cyA9PT0gJ251bWJlcicgJiYgaW5pdGlhbEZvY3VzIDwgMDtcbiAgLy8gSWYgdGhlIHJlZmVyZW5jZSBpcyBhIGNvbWJvYm94IGFuZCBpcyB0eXBlYWJsZSAoZS5nLiBpbnB1dC90ZXh0YXJlYSksXG4gIC8vIHRoZXJlIGFyZSBkaWZmZXJlbnQgZm9jdXMgc2VtYW50aWNzLiBUaGUgZ3VhcmRzIHNob3VsZCBub3QgYmUgcmVuZGVyZWQsIGJ1dFxuICAvLyBhcmlhLWhpZGRlbiBzaG91bGQgYmUgYXBwbGllZCB0byBhbGwgbm9kZXMgc3RpbGwuIEZ1cnRoZXIsIHRoZSB2aXN1YWxseVxuICAvLyBoaWRkZW4gZGlzbWlzcyBidXR0b24gc2hvdWxkIG9ubHkgYXBwZWFyIGF0IHRoZSBlbmQgb2YgdGhlIGxpc3QsIG5vdCB0aGVcbiAgLy8gc3RhcnQuXG4gIGNvbnN0IGlzVW50cmFwcGVkVHlwZWFibGVDb21ib2JveCA9IGlzVHlwZWFibGVDb21ib2JveChkb21SZWZlcmVuY2UpICYmIGlnbm9yZUluaXRpYWxGb2N1cztcblxuICAvLyBGb3JjZSB0aGUgZ3VhcmRzIHRvIGJlIHJlbmRlcmVkIGlmIHRoZSBgaW5lcnRgIGF0dHJpYnV0ZSBpcyBub3Qgc3VwcG9ydGVkLlxuICBjb25zdCBndWFyZHMgPSBzdXBwb3J0c0luZXJ0KCkgPyBfZ3VhcmRzIDogdHJ1ZTtcbiAgY29uc3Qgb3JkZXJSZWYgPSB1c2VMYXRlc3RSZWYob3JkZXIpO1xuICBjb25zdCBpbml0aWFsRm9jdXNSZWYgPSB1c2VMYXRlc3RSZWYoaW5pdGlhbEZvY3VzKTtcbiAgY29uc3QgcmV0dXJuRm9jdXNSZWYgPSB1c2VMYXRlc3RSZWYocmV0dXJuRm9jdXMpO1xuICBjb25zdCB0cmVlID0gdXNlRmxvYXRpbmdUcmVlKCk7XG4gIGNvbnN0IHBvcnRhbENvbnRleHQgPSB1c2VQb3J0YWxDb250ZXh0KCk7XG4gIGNvbnN0IHN0YXJ0RGlzbWlzc0J1dHRvblJlZiA9IFJlYWN0LnVzZVJlZihudWxsKTtcbiAgY29uc3QgZW5kRGlzbWlzc0J1dHRvblJlZiA9IFJlYWN0LnVzZVJlZihudWxsKTtcbiAgY29uc3QgcHJldmVudFJldHVybkZvY3VzUmVmID0gUmVhY3QudXNlUmVmKGZhbHNlKTtcbiAgY29uc3QgaXNQb2ludGVyRG93blJlZiA9IFJlYWN0LnVzZVJlZihmYWxzZSk7XG4gIGNvbnN0IHRhYmJhYmxlSW5kZXhSZWYgPSBSZWFjdC51c2VSZWYoLTEpO1xuICBjb25zdCBpc0luc2lkZVBvcnRhbCA9IHBvcnRhbENvbnRleHQgIT0gbnVsbDtcbiAgY29uc3QgZmxvYXRpbmdGb2N1c0VsZW1lbnQgPSBnZXRGbG9hdGluZ0ZvY3VzRWxlbWVudChmbG9hdGluZyk7XG4gIGNvbnN0IGdldFRhYmJhYmxlQ29udGVudCA9IHVzZUVmZmVjdEV2ZW50KGZ1bmN0aW9uIChjb250YWluZXIpIHtcbiAgICBpZiAoY29udGFpbmVyID09PSB2b2lkIDApIHtcbiAgICAgIGNvbnRhaW5lciA9IGZsb2F0aW5nRm9jdXNFbGVtZW50O1xuICAgIH1cbiAgICByZXR1cm4gY29udGFpbmVyID8gdGFiYmFibGUoY29udGFpbmVyLCBnZXRUYWJiYWJsZU9wdGlvbnMoKSkgOiBbXTtcbiAgfSk7XG4gIGNvbnN0IGdldFRhYmJhYmxlRWxlbWVudHMgPSB1c2VFZmZlY3RFdmVudChjb250YWluZXIgPT4ge1xuICAgIGNvbnN0IGNvbnRlbnQgPSBnZXRUYWJiYWJsZUNvbnRlbnQoY29udGFpbmVyKTtcbiAgICByZXR1cm4gb3JkZXJSZWYuY3VycmVudC5tYXAodHlwZSA9PiB7XG4gICAgICBpZiAoZG9tUmVmZXJlbmNlICYmIHR5cGUgPT09ICdyZWZlcmVuY2UnKSB7XG4gICAgICAgIHJldHVybiBkb21SZWZlcmVuY2U7XG4gICAgICB9XG4gICAgICBpZiAoZmxvYXRpbmdGb2N1c0VsZW1lbnQgJiYgdHlwZSA9PT0gJ2Zsb2F0aW5nJykge1xuICAgICAgICByZXR1cm4gZmxvYXRpbmdGb2N1c0VsZW1lbnQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gY29udGVudDtcbiAgICB9KS5maWx0ZXIoQm9vbGVhbikuZmxhdCgpO1xuICB9KTtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoZGlzYWJsZWQpIHJldHVybjtcbiAgICBpZiAoIW1vZGFsKSByZXR1cm47XG4gICAgZnVuY3Rpb24gb25LZXlEb3duKGV2ZW50KSB7XG4gICAgICBpZiAoZXZlbnQua2V5ID09PSAnVGFiJykge1xuICAgICAgICAvLyBUaGUgZm9jdXMgZ3VhcmRzIGhhdmUgbm90aGluZyB0byBmb2N1cywgc28gd2UgbmVlZCB0byBzdG9wIHRoZSBldmVudC5cbiAgICAgICAgaWYgKGNvbnRhaW5zKGZsb2F0aW5nRm9jdXNFbGVtZW50LCBhY3RpdmVFbGVtZW50KGdldERvY3VtZW50KGZsb2F0aW5nRm9jdXNFbGVtZW50KSkpICYmIGdldFRhYmJhYmxlQ29udGVudCgpLmxlbmd0aCA9PT0gMCAmJiAhaXNVbnRyYXBwZWRUeXBlYWJsZUNvbWJvYm94KSB7XG4gICAgICAgICAgc3RvcEV2ZW50KGV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBlbHMgPSBnZXRUYWJiYWJsZUVsZW1lbnRzKCk7XG4gICAgICAgIGNvbnN0IHRhcmdldCA9IGdldFRhcmdldChldmVudCk7XG4gICAgICAgIGlmIChvcmRlclJlZi5jdXJyZW50WzBdID09PSAncmVmZXJlbmNlJyAmJiB0YXJnZXQgPT09IGRvbVJlZmVyZW5jZSkge1xuICAgICAgICAgIHN0b3BFdmVudChldmVudCk7XG4gICAgICAgICAgaWYgKGV2ZW50LnNoaWZ0S2V5KSB7XG4gICAgICAgICAgICBlbnF1ZXVlRm9jdXMoZWxzW2Vscy5sZW5ndGggLSAxXSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVucXVldWVGb2N1cyhlbHNbMV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAob3JkZXJSZWYuY3VycmVudFsxXSA9PT0gJ2Zsb2F0aW5nJyAmJiB0YXJnZXQgPT09IGZsb2F0aW5nRm9jdXNFbGVtZW50ICYmIGV2ZW50LnNoaWZ0S2V5KSB7XG4gICAgICAgICAgc3RvcEV2ZW50KGV2ZW50KTtcbiAgICAgICAgICBlbnF1ZXVlRm9jdXMoZWxzWzBdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBkb2MgPSBnZXREb2N1bWVudChmbG9hdGluZ0ZvY3VzRWxlbWVudCk7XG4gICAgZG9jLmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBvbktleURvd24pO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBkb2MucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIG9uS2V5RG93bik7XG4gICAgfTtcbiAgfSwgW2Rpc2FibGVkLCBkb21SZWZlcmVuY2UsIGZsb2F0aW5nRm9jdXNFbGVtZW50LCBtb2RhbCwgb3JkZXJSZWYsIGlzVW50cmFwcGVkVHlwZWFibGVDb21ib2JveCwgZ2V0VGFiYmFibGVDb250ZW50LCBnZXRUYWJiYWJsZUVsZW1lbnRzXSk7XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGRpc2FibGVkKSByZXR1cm47XG4gICAgaWYgKCFmbG9hdGluZykgcmV0dXJuO1xuICAgIGZ1bmN0aW9uIGhhbmRsZUZvY3VzSW4oZXZlbnQpIHtcbiAgICAgIGNvbnN0IHRhcmdldCA9IGdldFRhcmdldChldmVudCk7XG4gICAgICBjb25zdCB0YWJiYWJsZUNvbnRlbnQgPSBnZXRUYWJiYWJsZUNvbnRlbnQoKTtcbiAgICAgIGNvbnN0IHRhYmJhYmxlSW5kZXggPSB0YWJiYWJsZUNvbnRlbnQuaW5kZXhPZih0YXJnZXQpO1xuICAgICAgaWYgKHRhYmJhYmxlSW5kZXggIT09IC0xKSB7XG4gICAgICAgIHRhYmJhYmxlSW5kZXhSZWYuY3VycmVudCA9IHRhYmJhYmxlSW5kZXg7XG4gICAgICB9XG4gICAgfVxuICAgIGZsb2F0aW5nLmFkZEV2ZW50TGlzdGVuZXIoJ2ZvY3VzaW4nLCBoYW5kbGVGb2N1c0luKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgZmxvYXRpbmcucmVtb3ZlRXZlbnRMaXN0ZW5lcignZm9jdXNpbicsIGhhbmRsZUZvY3VzSW4pO1xuICAgIH07XG4gIH0sIFtkaXNhYmxlZCwgZmxvYXRpbmcsIGdldFRhYmJhYmxlQ29udGVudF0pO1xuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChkaXNhYmxlZCkgcmV0dXJuO1xuICAgIGlmICghY2xvc2VPbkZvY3VzT3V0KSByZXR1cm47XG5cbiAgICAvLyBJbiBTYWZhcmksIGJ1dHRvbnMgbG9zZSBmb2N1cyB3aGVuIHByZXNzaW5nIHRoZW0uXG4gICAgZnVuY3Rpb24gaGFuZGxlUG9pbnRlckRvd24oKSB7XG4gICAgICBpc1BvaW50ZXJEb3duUmVmLmN1cnJlbnQgPSB0cnVlO1xuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGlzUG9pbnRlckRvd25SZWYuY3VycmVudCA9IGZhbHNlO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGhhbmRsZUZvY3VzT3V0c2lkZShldmVudCkge1xuICAgICAgY29uc3QgcmVsYXRlZFRhcmdldCA9IGV2ZW50LnJlbGF0ZWRUYXJnZXQ7XG4gICAgICBxdWV1ZU1pY3JvdGFzaygoKSA9PiB7XG4gICAgICAgIGNvbnN0IG1vdmVkVG9VbnJlbGF0ZWROb2RlID0gIShjb250YWlucyhkb21SZWZlcmVuY2UsIHJlbGF0ZWRUYXJnZXQpIHx8IGNvbnRhaW5zKGZsb2F0aW5nLCByZWxhdGVkVGFyZ2V0KSB8fCBjb250YWlucyhyZWxhdGVkVGFyZ2V0LCBmbG9hdGluZykgfHwgY29udGFpbnMocG9ydGFsQ29udGV4dCA9PSBudWxsID8gdm9pZCAwIDogcG9ydGFsQ29udGV4dC5wb3J0YWxOb2RlLCByZWxhdGVkVGFyZ2V0KSB8fCByZWxhdGVkVGFyZ2V0ICE9IG51bGwgJiYgcmVsYXRlZFRhcmdldC5oYXNBdHRyaWJ1dGUoY3JlYXRlQXR0cmlidXRlKCdmb2N1cy1ndWFyZCcpKSB8fCB0cmVlICYmIChnZXRDaGlsZHJlbih0cmVlLm5vZGVzUmVmLmN1cnJlbnQsIG5vZGVJZCkuZmluZChub2RlID0+IHtcbiAgICAgICAgICB2YXIgX25vZGUkY29udGV4dCwgX25vZGUkY29udGV4dDI7XG4gICAgICAgICAgcmV0dXJuIGNvbnRhaW5zKChfbm9kZSRjb250ZXh0ID0gbm9kZS5jb250ZXh0KSA9PSBudWxsID8gdm9pZCAwIDogX25vZGUkY29udGV4dC5lbGVtZW50cy5mbG9hdGluZywgcmVsYXRlZFRhcmdldCkgfHwgY29udGFpbnMoKF9ub2RlJGNvbnRleHQyID0gbm9kZS5jb250ZXh0KSA9PSBudWxsID8gdm9pZCAwIDogX25vZGUkY29udGV4dDIuZWxlbWVudHMuZG9tUmVmZXJlbmNlLCByZWxhdGVkVGFyZ2V0KTtcbiAgICAgICAgfSkgfHwgZ2V0QW5jZXN0b3JzKHRyZWUubm9kZXNSZWYuY3VycmVudCwgbm9kZUlkKS5maW5kKG5vZGUgPT4ge1xuICAgICAgICAgIHZhciBfbm9kZSRjb250ZXh0MywgX25vZGUkY29udGV4dDQ7XG4gICAgICAgICAgcmV0dXJuICgoX25vZGUkY29udGV4dDMgPSBub2RlLmNvbnRleHQpID09IG51bGwgPyB2b2lkIDAgOiBfbm9kZSRjb250ZXh0My5lbGVtZW50cy5mbG9hdGluZykgPT09IHJlbGF0ZWRUYXJnZXQgfHwgKChfbm9kZSRjb250ZXh0NCA9IG5vZGUuY29udGV4dCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9ub2RlJGNvbnRleHQ0LmVsZW1lbnRzLmRvbVJlZmVyZW5jZSkgPT09IHJlbGF0ZWRUYXJnZXQ7XG4gICAgICAgIH0pKSk7XG5cbiAgICAgICAgLy8gUmVzdG9yZSBmb2N1cyB0byB0aGUgcHJldmlvdXMgdGFiYmFibGUgZWxlbWVudCBpbmRleCB0byBwcmV2ZW50XG4gICAgICAgIC8vIGZvY3VzIGZyb20gYmVpbmcgbG9zdCBvdXRzaWRlIHRoZSBmbG9hdGluZyB0cmVlLlxuICAgICAgICBpZiAocmVzdG9yZUZvY3VzICYmIG1vdmVkVG9VbnJlbGF0ZWROb2RlICYmIGFjdGl2ZUVsZW1lbnQoZ2V0RG9jdW1lbnQoZmxvYXRpbmdGb2N1c0VsZW1lbnQpKSA9PT0gZ2V0RG9jdW1lbnQoZmxvYXRpbmdGb2N1c0VsZW1lbnQpLmJvZHkpIHtcbiAgICAgICAgICAvLyBMZXQgYEZsb2F0aW5nUG9ydGFsYCBlZmZlY3Qga25vd3MgdGhhdCBmb2N1cyBpcyBzdGlsbCBpbnNpZGUgdGhlXG4gICAgICAgICAgLy8gZmxvYXRpbmcgdHJlZS5cbiAgICAgICAgICBpZiAoaXNIVE1MRWxlbWVudChmbG9hdGluZ0ZvY3VzRWxlbWVudCkpIHtcbiAgICAgICAgICAgIGZsb2F0aW5nRm9jdXNFbGVtZW50LmZvY3VzKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IHByZXZUYWJiYWJsZUluZGV4ID0gdGFiYmFibGVJbmRleFJlZi5jdXJyZW50O1xuICAgICAgICAgIGNvbnN0IHRhYmJhYmxlQ29udGVudCA9IGdldFRhYmJhYmxlQ29udGVudCgpO1xuICAgICAgICAgIGNvbnN0IG5vZGVUb0ZvY3VzID0gdGFiYmFibGVDb250ZW50W3ByZXZUYWJiYWJsZUluZGV4XSB8fCB0YWJiYWJsZUNvbnRlbnRbdGFiYmFibGVDb250ZW50Lmxlbmd0aCAtIDFdIHx8IGZsb2F0aW5nRm9jdXNFbGVtZW50O1xuICAgICAgICAgIGlmIChpc0hUTUxFbGVtZW50KG5vZGVUb0ZvY3VzKSkge1xuICAgICAgICAgICAgbm9kZVRvRm9jdXMuZm9jdXMoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBGb2N1cyBkaWQgbm90IG1vdmUgaW5zaWRlIHRoZSBmbG9hdGluZyB0cmVlLCBhbmQgdGhlcmUgYXJlIG5vIHRhYmJhYmxlXG4gICAgICAgIC8vIHBvcnRhbCBndWFyZHMgdG8gaGFuZGxlIGNsb3NpbmcuXG4gICAgICAgIGlmICgoaXNVbnRyYXBwZWRUeXBlYWJsZUNvbWJvYm94ID8gdHJ1ZSA6ICFtb2RhbCkgJiYgcmVsYXRlZFRhcmdldCAmJiBtb3ZlZFRvVW5yZWxhdGVkTm9kZSAmJiAhaXNQb2ludGVyRG93blJlZi5jdXJyZW50ICYmXG4gICAgICAgIC8vIEZpeCBSZWFjdCAxOCBTdHJpY3QgTW9kZSByZXR1cm5Gb2N1cyBkdWUgdG8gZG91YmxlIHJlbmRlcmluZy5cbiAgICAgICAgcmVsYXRlZFRhcmdldCAhPT0gZ2V0UHJldmlvdXNseUZvY3VzZWRFbGVtZW50KCkpIHtcbiAgICAgICAgICBwcmV2ZW50UmV0dXJuRm9jdXNSZWYuY3VycmVudCA9IHRydWU7XG4gICAgICAgICAgb25PcGVuQ2hhbmdlKGZhbHNlLCBldmVudCwgJ2ZvY3VzLW91dCcpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKGZsb2F0aW5nICYmIGlzSFRNTEVsZW1lbnQoZG9tUmVmZXJlbmNlKSkge1xuICAgICAgZG9tUmVmZXJlbmNlLmFkZEV2ZW50TGlzdGVuZXIoJ2ZvY3Vzb3V0JywgaGFuZGxlRm9jdXNPdXRzaWRlKTtcbiAgICAgIGRvbVJlZmVyZW5jZS5hZGRFdmVudExpc3RlbmVyKCdwb2ludGVyZG93bicsIGhhbmRsZVBvaW50ZXJEb3duKTtcbiAgICAgIGZsb2F0aW5nLmFkZEV2ZW50TGlzdGVuZXIoJ2ZvY3Vzb3V0JywgaGFuZGxlRm9jdXNPdXRzaWRlKTtcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIGRvbVJlZmVyZW5jZS5yZW1vdmVFdmVudExpc3RlbmVyKCdmb2N1c291dCcsIGhhbmRsZUZvY3VzT3V0c2lkZSk7XG4gICAgICAgIGRvbVJlZmVyZW5jZS5yZW1vdmVFdmVudExpc3RlbmVyKCdwb2ludGVyZG93bicsIGhhbmRsZVBvaW50ZXJEb3duKTtcbiAgICAgICAgZmxvYXRpbmcucmVtb3ZlRXZlbnRMaXN0ZW5lcignZm9jdXNvdXQnLCBoYW5kbGVGb2N1c091dHNpZGUpO1xuICAgICAgfTtcbiAgICB9XG4gIH0sIFtkaXNhYmxlZCwgZG9tUmVmZXJlbmNlLCBmbG9hdGluZywgZmxvYXRpbmdGb2N1c0VsZW1lbnQsIG1vZGFsLCBub2RlSWQsIHRyZWUsIHBvcnRhbENvbnRleHQsIG9uT3BlbkNoYW5nZSwgY2xvc2VPbkZvY3VzT3V0LCByZXN0b3JlRm9jdXMsIGdldFRhYmJhYmxlQ29udGVudCwgaXNVbnRyYXBwZWRUeXBlYWJsZUNvbWJvYm94XSk7XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgdmFyIF9wb3J0YWxDb250ZXh0JHBvcnRhbDtcbiAgICBpZiAoZGlzYWJsZWQpIHJldHVybjtcblxuICAgIC8vIERvbid0IGhpZGUgcG9ydGFscyBuZXN0ZWQgd2l0aGluIHRoZSBwYXJlbnQgcG9ydGFsLlxuICAgIGNvbnN0IHBvcnRhbE5vZGVzID0gQXJyYXkuZnJvbSgocG9ydGFsQ29udGV4dCA9PSBudWxsIHx8IChfcG9ydGFsQ29udGV4dCRwb3J0YWwgPSBwb3J0YWxDb250ZXh0LnBvcnRhbE5vZGUpID09IG51bGwgPyB2b2lkIDAgOiBfcG9ydGFsQ29udGV4dCRwb3J0YWwucXVlcnlTZWxlY3RvckFsbChcIltcIiArIGNyZWF0ZUF0dHJpYnV0ZSgncG9ydGFsJykgKyBcIl1cIikpIHx8IFtdKTtcbiAgICBpZiAoZmxvYXRpbmcpIHtcbiAgICAgIGNvbnN0IGluc2lkZUVsZW1lbnRzID0gW2Zsb2F0aW5nLCAuLi5wb3J0YWxOb2Rlcywgc3RhcnREaXNtaXNzQnV0dG9uUmVmLmN1cnJlbnQsIGVuZERpc21pc3NCdXR0b25SZWYuY3VycmVudCwgb3JkZXJSZWYuY3VycmVudC5pbmNsdWRlcygncmVmZXJlbmNlJykgfHwgaXNVbnRyYXBwZWRUeXBlYWJsZUNvbWJvYm94ID8gZG9tUmVmZXJlbmNlIDogbnVsbF0uZmlsdGVyKHggPT4geCAhPSBudWxsKTtcbiAgICAgIGNvbnN0IGNsZWFudXAgPSBtb2RhbCB8fCBpc1VudHJhcHBlZFR5cGVhYmxlQ29tYm9ib3ggPyBtYXJrT3RoZXJzKGluc2lkZUVsZW1lbnRzLCBndWFyZHMsICFndWFyZHMpIDogbWFya090aGVycyhpbnNpZGVFbGVtZW50cyk7XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBjbGVhbnVwKCk7XG4gICAgICB9O1xuICAgIH1cbiAgfSwgW2Rpc2FibGVkLCBkb21SZWZlcmVuY2UsIGZsb2F0aW5nLCBtb2RhbCwgb3JkZXJSZWYsIHBvcnRhbENvbnRleHQsIGlzVW50cmFwcGVkVHlwZWFibGVDb21ib2JveCwgZ3VhcmRzXSk7XG4gIGluZGV4KCgpID0+IHtcbiAgICBpZiAoZGlzYWJsZWQgfHwgIWlzSFRNTEVsZW1lbnQoZmxvYXRpbmdGb2N1c0VsZW1lbnQpKSByZXR1cm47XG4gICAgY29uc3QgZG9jID0gZ2V0RG9jdW1lbnQoZmxvYXRpbmdGb2N1c0VsZW1lbnQpO1xuICAgIGNvbnN0IHByZXZpb3VzbHlGb2N1c2VkRWxlbWVudCA9IGFjdGl2ZUVsZW1lbnQoZG9jKTtcblxuICAgIC8vIFdhaXQgZm9yIGFueSBsYXlvdXQgZWZmZWN0IHN0YXRlIHNldHRlcnMgdG8gZXhlY3V0ZSB0byBzZXQgYHRhYkluZGV4YC5cbiAgICBxdWV1ZU1pY3JvdGFzaygoKSA9PiB7XG4gICAgICBjb25zdCBmb2N1c2FibGVFbGVtZW50cyA9IGdldFRhYmJhYmxlRWxlbWVudHMoZmxvYXRpbmdGb2N1c0VsZW1lbnQpO1xuICAgICAgY29uc3QgaW5pdGlhbEZvY3VzVmFsdWUgPSBpbml0aWFsRm9jdXNSZWYuY3VycmVudDtcbiAgICAgIGNvbnN0IGVsVG9Gb2N1cyA9ICh0eXBlb2YgaW5pdGlhbEZvY3VzVmFsdWUgPT09ICdudW1iZXInID8gZm9jdXNhYmxlRWxlbWVudHNbaW5pdGlhbEZvY3VzVmFsdWVdIDogaW5pdGlhbEZvY3VzVmFsdWUuY3VycmVudCkgfHwgZmxvYXRpbmdGb2N1c0VsZW1lbnQ7XG4gICAgICBjb25zdCBmb2N1c0FscmVhZHlJbnNpZGVGbG9hdGluZ0VsID0gY29udGFpbnMoZmxvYXRpbmdGb2N1c0VsZW1lbnQsIHByZXZpb3VzbHlGb2N1c2VkRWxlbWVudCk7XG4gICAgICBpZiAoIWlnbm9yZUluaXRpYWxGb2N1cyAmJiAhZm9jdXNBbHJlYWR5SW5zaWRlRmxvYXRpbmdFbCAmJiBvcGVuKSB7XG4gICAgICAgIGVucXVldWVGb2N1cyhlbFRvRm9jdXMsIHtcbiAgICAgICAgICBwcmV2ZW50U2Nyb2xsOiBlbFRvRm9jdXMgPT09IGZsb2F0aW5nRm9jdXNFbGVtZW50XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9LCBbZGlzYWJsZWQsIG9wZW4sIGZsb2F0aW5nRm9jdXNFbGVtZW50LCBpZ25vcmVJbml0aWFsRm9jdXMsIGdldFRhYmJhYmxlRWxlbWVudHMsIGluaXRpYWxGb2N1c1JlZl0pO1xuICBpbmRleCgoKSA9PiB7XG4gICAgaWYgKGRpc2FibGVkIHx8ICFmbG9hdGluZ0ZvY3VzRWxlbWVudCkgcmV0dXJuO1xuICAgIGxldCBwcmV2ZW50UmV0dXJuRm9jdXNTY3JvbGwgPSBmYWxzZTtcbiAgICBjb25zdCBkb2MgPSBnZXREb2N1bWVudChmbG9hdGluZ0ZvY3VzRWxlbWVudCk7XG4gICAgY29uc3QgcHJldmlvdXNseUZvY3VzZWRFbGVtZW50ID0gYWN0aXZlRWxlbWVudChkb2MpO1xuICAgIGNvbnN0IGNvbnRleHREYXRhID0gZGF0YVJlZi5jdXJyZW50O1xuICAgIGxldCBvcGVuRXZlbnQgPSBjb250ZXh0RGF0YS5vcGVuRXZlbnQ7XG4gICAgYWRkUHJldmlvdXNseUZvY3VzZWRFbGVtZW50KHByZXZpb3VzbHlGb2N1c2VkRWxlbWVudCk7XG5cbiAgICAvLyBEaXNtaXNzaW5nIHZpYSBvdXRzaWRlIHByZXNzIHNob3VsZCBhbHdheXMgaWdub3JlIGByZXR1cm5Gb2N1c2AgdG9cbiAgICAvLyBwcmV2ZW50IHVud2FudGVkIHNjcm9sbGluZy5cbiAgICBmdW5jdGlvbiBvbk9wZW5DaGFuZ2UoX3JlZikge1xuICAgICAgbGV0IHtcbiAgICAgICAgb3BlbixcbiAgICAgICAgcmVhc29uLFxuICAgICAgICBldmVudCxcbiAgICAgICAgbmVzdGVkXG4gICAgICB9ID0gX3JlZjtcbiAgICAgIGlmIChvcGVuKSB7XG4gICAgICAgIG9wZW5FdmVudCA9IGV2ZW50O1xuICAgICAgfVxuICAgICAgaWYgKHJlYXNvbiA9PT0gJ2VzY2FwZS1rZXknICYmIHJlZnMuZG9tUmVmZXJlbmNlLmN1cnJlbnQpIHtcbiAgICAgICAgYWRkUHJldmlvdXNseUZvY3VzZWRFbGVtZW50KHJlZnMuZG9tUmVmZXJlbmNlLmN1cnJlbnQpO1xuICAgICAgfVxuICAgICAgaWYgKHJlYXNvbiA9PT0gJ2hvdmVyJyAmJiBldmVudC50eXBlID09PSAnbW91c2VsZWF2ZScpIHtcbiAgICAgICAgcHJldmVudFJldHVybkZvY3VzUmVmLmN1cnJlbnQgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKHJlYXNvbiAhPT0gJ291dHNpZGUtcHJlc3MnKSByZXR1cm47XG4gICAgICBpZiAobmVzdGVkKSB7XG4gICAgICAgIHByZXZlbnRSZXR1cm5Gb2N1c1JlZi5jdXJyZW50ID0gZmFsc2U7XG4gICAgICAgIHByZXZlbnRSZXR1cm5Gb2N1c1Njcm9sbCA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcmV2ZW50UmV0dXJuRm9jdXNSZWYuY3VycmVudCA9ICEoaXNWaXJ0dWFsQ2xpY2soZXZlbnQpIHx8IGlzVmlydHVhbFBvaW50ZXJFdmVudChldmVudCkpO1xuICAgICAgfVxuICAgIH1cbiAgICBldmVudHMub24oJ29wZW5jaGFuZ2UnLCBvbk9wZW5DaGFuZ2UpO1xuICAgIGNvbnN0IGZhbGxiYWNrRWwgPSBkb2MuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICAgIGZhbGxiYWNrRWwuc2V0QXR0cmlidXRlKCd0YWJpbmRleCcsICctMScpO1xuICAgIGZhbGxiYWNrRWwuc2V0QXR0cmlidXRlKCdhcmlhLWhpZGRlbicsICd0cnVlJyk7XG4gICAgT2JqZWN0LmFzc2lnbihmYWxsYmFja0VsLnN0eWxlLCBISURERU5fU1RZTEVTKTtcbiAgICBpZiAoaXNJbnNpZGVQb3J0YWwgJiYgZG9tUmVmZXJlbmNlKSB7XG4gICAgICBkb21SZWZlcmVuY2UuaW5zZXJ0QWRqYWNlbnRFbGVtZW50KCdhZnRlcmVuZCcsIGZhbGxiYWNrRWwpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRSZXR1cm5FbGVtZW50KCkge1xuICAgICAgaWYgKHR5cGVvZiByZXR1cm5Gb2N1c1JlZi5jdXJyZW50ID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgcmV0dXJuIGdldFByZXZpb3VzbHlGb2N1c2VkRWxlbWVudCgpIHx8IGZhbGxiYWNrRWw7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmV0dXJuRm9jdXNSZWYuY3VycmVudC5jdXJyZW50IHx8IGZhbGxiYWNrRWw7XG4gICAgfVxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBldmVudHMub2ZmKCdvcGVuY2hhbmdlJywgb25PcGVuQ2hhbmdlKTtcbiAgICAgIGNvbnN0IGFjdGl2ZUVsID0gYWN0aXZlRWxlbWVudChkb2MpO1xuICAgICAgY29uc3QgaXNGb2N1c0luc2lkZUZsb2F0aW5nVHJlZSA9IGNvbnRhaW5zKGZsb2F0aW5nLCBhY3RpdmVFbCkgfHwgdHJlZSAmJiBnZXRDaGlsZHJlbih0cmVlLm5vZGVzUmVmLmN1cnJlbnQsIG5vZGVJZCkuc29tZShub2RlID0+IHtcbiAgICAgICAgdmFyIF9ub2RlJGNvbnRleHQ1O1xuICAgICAgICByZXR1cm4gY29udGFpbnMoKF9ub2RlJGNvbnRleHQ1ID0gbm9kZS5jb250ZXh0KSA9PSBudWxsID8gdm9pZCAwIDogX25vZGUkY29udGV4dDUuZWxlbWVudHMuZmxvYXRpbmcsIGFjdGl2ZUVsKTtcbiAgICAgIH0pO1xuICAgICAgY29uc3Qgc2hvdWxkRm9jdXNSZWZlcmVuY2UgPSBpc0ZvY3VzSW5zaWRlRmxvYXRpbmdUcmVlIHx8IG9wZW5FdmVudCAmJiBbJ2NsaWNrJywgJ21vdXNlZG93biddLmluY2x1ZGVzKG9wZW5FdmVudC50eXBlKTtcbiAgICAgIGlmIChzaG91bGRGb2N1c1JlZmVyZW5jZSAmJiByZWZzLmRvbVJlZmVyZW5jZS5jdXJyZW50KSB7XG4gICAgICAgIGFkZFByZXZpb3VzbHlGb2N1c2VkRWxlbWVudChyZWZzLmRvbVJlZmVyZW5jZS5jdXJyZW50KTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJldHVybkVsZW1lbnQgPSBnZXRSZXR1cm5FbGVtZW50KCk7XG4gICAgICBxdWV1ZU1pY3JvdGFzaygoKSA9PiB7XG4gICAgICAgIGlmIChcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICAgICAgICByZXR1cm5Gb2N1c1JlZi5jdXJyZW50ICYmICFwcmV2ZW50UmV0dXJuRm9jdXNSZWYuY3VycmVudCAmJiBpc0hUTUxFbGVtZW50KHJldHVybkVsZW1lbnQpICYmIChcbiAgICAgICAgLy8gSWYgdGhlIGZvY3VzIG1vdmVkIHNvbWV3aGVyZSBlbHNlIGFmdGVyIG1vdW50LCBhdm9pZCByZXR1cm5pbmcgZm9jdXNcbiAgICAgICAgLy8gc2luY2UgaXQgbGlrZWx5IGVudGVyZWQgYSBkaWZmZXJlbnQgZWxlbWVudCB3aGljaCBzaG91bGQgYmVcbiAgICAgICAgLy8gcmVzcGVjdGVkOiBodHRwczovL2dpdGh1Yi5jb20vZmxvYXRpbmctdWkvZmxvYXRpbmctdWkvaXNzdWVzLzI2MDdcbiAgICAgICAgcmV0dXJuRWxlbWVudCAhPT0gYWN0aXZlRWwgJiYgYWN0aXZlRWwgIT09IGRvYy5ib2R5ID8gaXNGb2N1c0luc2lkZUZsb2F0aW5nVHJlZSA6IHRydWUpKSB7XG4gICAgICAgICAgcmV0dXJuRWxlbWVudC5mb2N1cyh7XG4gICAgICAgICAgICBwcmV2ZW50U2Nyb2xsOiBwcmV2ZW50UmV0dXJuRm9jdXNTY3JvbGxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBmYWxsYmFja0VsLnJlbW92ZSgpO1xuICAgICAgfSk7XG4gICAgfTtcbiAgfSwgW2Rpc2FibGVkLCBmbG9hdGluZywgZmxvYXRpbmdGb2N1c0VsZW1lbnQsIHJldHVybkZvY3VzUmVmLCBkYXRhUmVmLCByZWZzLCBldmVudHMsIHRyZWUsIG5vZGVJZCwgaXNJbnNpZGVQb3J0YWwsIGRvbVJlZmVyZW5jZV0pO1xuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIC8vIFRoZSBgcmV0dXJuRm9jdXNgIGNsZWFudXAgYmVoYXZpb3IgaXMgaW5zaWRlIGEgbWljcm90YXNrOyBlbnN1cmUgd2VcbiAgICAvLyB3YWl0IGZvciBpdCB0byBjb21wbGV0ZSBiZWZvcmUgcmVzZXR0aW5nIHRoZSBmbGFnLlxuICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IHtcbiAgICAgIHByZXZlbnRSZXR1cm5Gb2N1c1JlZi5jdXJyZW50ID0gZmFsc2U7XG4gICAgfSk7XG4gIH0sIFtkaXNhYmxlZF0pO1xuXG4gIC8vIFN5bmNocm9uaXplIHRoZSBgY29udGV4dGAgJiBgbW9kYWxgIHZhbHVlIHRvIHRoZSBGbG9hdGluZ1BvcnRhbCBjb250ZXh0LlxuICAvLyBJdCB3aWxsIGRlY2lkZSB3aGV0aGVyIG9yIG5vdCBpdCBuZWVkcyB0byByZW5kZXIgaXRzIG93biBndWFyZHMuXG4gIGluZGV4KCgpID0+IHtcbiAgICBpZiAoZGlzYWJsZWQpIHJldHVybjtcbiAgICBpZiAoIXBvcnRhbENvbnRleHQpIHJldHVybjtcbiAgICBwb3J0YWxDb250ZXh0LnNldEZvY3VzTWFuYWdlclN0YXRlKHtcbiAgICAgIG1vZGFsLFxuICAgICAgY2xvc2VPbkZvY3VzT3V0LFxuICAgICAgb3BlbixcbiAgICAgIG9uT3BlbkNoYW5nZSxcbiAgICAgIHJlZnNcbiAgICB9KTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgcG9ydGFsQ29udGV4dC5zZXRGb2N1c01hbmFnZXJTdGF0ZShudWxsKTtcbiAgICB9O1xuICB9LCBbZGlzYWJsZWQsIHBvcnRhbENvbnRleHQsIG1vZGFsLCBvcGVuLCBvbk9wZW5DaGFuZ2UsIHJlZnMsIGNsb3NlT25Gb2N1c091dF0pO1xuICBpbmRleCgoKSA9PiB7XG4gICAgaWYgKGRpc2FibGVkKSByZXR1cm47XG4gICAgaWYgKCFmbG9hdGluZ0ZvY3VzRWxlbWVudCkgcmV0dXJuO1xuICAgIGlmICh0eXBlb2YgTXV0YXRpb25PYnNlcnZlciAhPT0gJ2Z1bmN0aW9uJykgcmV0dXJuO1xuICAgIGlmIChpZ25vcmVJbml0aWFsRm9jdXMpIHJldHVybjtcbiAgICBjb25zdCBoYW5kbGVNdXRhdGlvbiA9ICgpID0+IHtcbiAgICAgIGNvbnN0IHRhYkluZGV4ID0gZmxvYXRpbmdGb2N1c0VsZW1lbnQuZ2V0QXR0cmlidXRlKCd0YWJpbmRleCcpO1xuICAgICAgY29uc3QgdGFiYmFibGVDb250ZW50ID0gZ2V0VGFiYmFibGVDb250ZW50KCk7XG4gICAgICBjb25zdCBhY3RpdmVFbCA9IGFjdGl2ZUVsZW1lbnQoZ2V0RG9jdW1lbnQoZmxvYXRpbmcpKTtcbiAgICAgIGNvbnN0IHRhYmJhYmxlSW5kZXggPSB0YWJiYWJsZUNvbnRlbnQuaW5kZXhPZihhY3RpdmVFbCk7XG4gICAgICBpZiAodGFiYmFibGVJbmRleCAhPT0gLTEpIHtcbiAgICAgICAgdGFiYmFibGVJbmRleFJlZi5jdXJyZW50ID0gdGFiYmFibGVJbmRleDtcbiAgICAgIH1cbiAgICAgIGlmIChvcmRlclJlZi5jdXJyZW50LmluY2x1ZGVzKCdmbG9hdGluZycpIHx8IGFjdGl2ZUVsICE9PSByZWZzLmRvbVJlZmVyZW5jZS5jdXJyZW50ICYmIHRhYmJhYmxlQ29udGVudC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgaWYgKHRhYkluZGV4ICE9PSAnMCcpIHtcbiAgICAgICAgICBmbG9hdGluZ0ZvY3VzRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3RhYmluZGV4JywgJzAnKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0YWJJbmRleCAhPT0gJy0xJykge1xuICAgICAgICBmbG9hdGluZ0ZvY3VzRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3RhYmluZGV4JywgJy0xJyk7XG4gICAgICB9XG4gICAgfTtcbiAgICBoYW5kbGVNdXRhdGlvbigpO1xuICAgIGNvbnN0IG9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoaGFuZGxlTXV0YXRpb24pO1xuICAgIG9ic2VydmVyLm9ic2VydmUoZmxvYXRpbmdGb2N1c0VsZW1lbnQsIHtcbiAgICAgIGNoaWxkTGlzdDogdHJ1ZSxcbiAgICAgIHN1YnRyZWU6IHRydWUsXG4gICAgICBhdHRyaWJ1dGVzOiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIG9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICB9O1xuICB9LCBbZGlzYWJsZWQsIGZsb2F0aW5nLCBmbG9hdGluZ0ZvY3VzRWxlbWVudCwgcmVmcywgb3JkZXJSZWYsIGdldFRhYmJhYmxlQ29udGVudCwgaWdub3JlSW5pdGlhbEZvY3VzXSk7XG4gIGZ1bmN0aW9uIHJlbmRlckRpc21pc3NCdXR0b24obG9jYXRpb24pIHtcbiAgICBpZiAoZGlzYWJsZWQgfHwgIXZpc3VhbGx5SGlkZGVuRGlzbWlzcyB8fCAhbW9kYWwpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoVmlzdWFsbHlIaWRkZW5EaXNtaXNzLCB7XG4gICAgICByZWY6IGxvY2F0aW9uID09PSAnc3RhcnQnID8gc3RhcnREaXNtaXNzQnV0dG9uUmVmIDogZW5kRGlzbWlzc0J1dHRvblJlZixcbiAgICAgIG9uQ2xpY2s6IGV2ZW50ID0+IG9uT3BlbkNoYW5nZShmYWxzZSwgZXZlbnQubmF0aXZlRXZlbnQpXG4gICAgfSwgdHlwZW9mIHZpc3VhbGx5SGlkZGVuRGlzbWlzcyA9PT0gJ3N0cmluZycgPyB2aXN1YWxseUhpZGRlbkRpc21pc3MgOiAnRGlzbWlzcycpO1xuICB9XG4gIGNvbnN0IHNob3VsZFJlbmRlckd1YXJkcyA9ICFkaXNhYmxlZCAmJiBndWFyZHMgJiYgKG1vZGFsID8gIWlzVW50cmFwcGVkVHlwZWFibGVDb21ib2JveCA6IHRydWUpICYmIChpc0luc2lkZVBvcnRhbCB8fCBtb2RhbCk7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChSZWFjdC5GcmFnbWVudCwgbnVsbCwgc2hvdWxkUmVuZGVyR3VhcmRzICYmIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KEZvY3VzR3VhcmQsIHtcbiAgICBcImRhdGEtdHlwZVwiOiBcImluc2lkZVwiLFxuICAgIHJlZjogcG9ydGFsQ29udGV4dCA9PSBudWxsID8gdm9pZCAwIDogcG9ydGFsQ29udGV4dC5iZWZvcmVJbnNpZGVSZWYsXG4gICAgb25Gb2N1czogZXZlbnQgPT4ge1xuICAgICAgaWYgKG1vZGFsKSB7XG4gICAgICAgIGNvbnN0IGVscyA9IGdldFRhYmJhYmxlRWxlbWVudHMoKTtcbiAgICAgICAgZW5xdWV1ZUZvY3VzKG9yZGVyWzBdID09PSAncmVmZXJlbmNlJyA/IGVsc1swXSA6IGVsc1tlbHMubGVuZ3RoIC0gMV0pO1xuICAgICAgfSBlbHNlIGlmIChwb3J0YWxDb250ZXh0ICE9IG51bGwgJiYgcG9ydGFsQ29udGV4dC5wcmVzZXJ2ZVRhYk9yZGVyICYmIHBvcnRhbENvbnRleHQucG9ydGFsTm9kZSkge1xuICAgICAgICBwcmV2ZW50UmV0dXJuRm9jdXNSZWYuY3VycmVudCA9IGZhbHNlO1xuICAgICAgICBpZiAoaXNPdXRzaWRlRXZlbnQoZXZlbnQsIHBvcnRhbENvbnRleHQucG9ydGFsTm9kZSkpIHtcbiAgICAgICAgICBjb25zdCBuZXh0VGFiYmFibGUgPSBnZXROZXh0VGFiYmFibGUoKSB8fCBkb21SZWZlcmVuY2U7XG4gICAgICAgICAgbmV4dFRhYmJhYmxlID09IG51bGwgfHwgbmV4dFRhYmJhYmxlLmZvY3VzKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIF9wb3J0YWxDb250ZXh0JGJlZm9yZTtcbiAgICAgICAgICAoX3BvcnRhbENvbnRleHQkYmVmb3JlID0gcG9ydGFsQ29udGV4dC5iZWZvcmVPdXRzaWRlUmVmLmN1cnJlbnQpID09IG51bGwgfHwgX3BvcnRhbENvbnRleHQkYmVmb3JlLmZvY3VzKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0pLCAhaXNVbnRyYXBwZWRUeXBlYWJsZUNvbWJvYm94ICYmIHJlbmRlckRpc21pc3NCdXR0b24oJ3N0YXJ0JyksIGNoaWxkcmVuLCByZW5kZXJEaXNtaXNzQnV0dG9uKCdlbmQnKSwgc2hvdWxkUmVuZGVyR3VhcmRzICYmIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KEZvY3VzR3VhcmQsIHtcbiAgICBcImRhdGEtdHlwZVwiOiBcImluc2lkZVwiLFxuICAgIHJlZjogcG9ydGFsQ29udGV4dCA9PSBudWxsID8gdm9pZCAwIDogcG9ydGFsQ29udGV4dC5hZnRlckluc2lkZVJlZixcbiAgICBvbkZvY3VzOiBldmVudCA9PiB7XG4gICAgICBpZiAobW9kYWwpIHtcbiAgICAgICAgZW5xdWV1ZUZvY3VzKGdldFRhYmJhYmxlRWxlbWVudHMoKVswXSk7XG4gICAgICB9IGVsc2UgaWYgKHBvcnRhbENvbnRleHQgIT0gbnVsbCAmJiBwb3J0YWxDb250ZXh0LnByZXNlcnZlVGFiT3JkZXIgJiYgcG9ydGFsQ29udGV4dC5wb3J0YWxOb2RlKSB7XG4gICAgICAgIGlmIChjbG9zZU9uRm9jdXNPdXQpIHtcbiAgICAgICAgICBwcmV2ZW50UmV0dXJuRm9jdXNSZWYuY3VycmVudCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzT3V0c2lkZUV2ZW50KGV2ZW50LCBwb3J0YWxDb250ZXh0LnBvcnRhbE5vZGUpKSB7XG4gICAgICAgICAgY29uc3QgcHJldlRhYmJhYmxlID0gZ2V0UHJldmlvdXNUYWJiYWJsZSgpIHx8IGRvbVJlZmVyZW5jZTtcbiAgICAgICAgICBwcmV2VGFiYmFibGUgPT0gbnVsbCB8fCBwcmV2VGFiYmFibGUuZm9jdXMoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgX3BvcnRhbENvbnRleHQkYWZ0ZXJPO1xuICAgICAgICAgIChfcG9ydGFsQ29udGV4dCRhZnRlck8gPSBwb3J0YWxDb250ZXh0LmFmdGVyT3V0c2lkZVJlZi5jdXJyZW50KSA9PSBudWxsIHx8IF9wb3J0YWxDb250ZXh0JGFmdGVyTy5mb2N1cygpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9KSk7XG59XG5cbmxldCBsb2NrQ291bnQgPSAwO1xuZnVuY3Rpb24gZW5hYmxlU2Nyb2xsTG9jaygpIHtcbiAgY29uc3QgaXNJT1MgPSAvaVAoaG9uZXxhZHxvZCl8aU9TLy50ZXN0KGdldFBsYXRmb3JtKCkpO1xuICBjb25zdCBib2R5U3R5bGUgPSBkb2N1bWVudC5ib2R5LnN0eWxlO1xuICAvLyBSVEwgPGJvZHk+IHNjcm9sbGJhclxuICBjb25zdCBzY3JvbGxiYXJYID0gTWF0aC5yb3VuZChkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdCkgKyBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsTGVmdDtcbiAgY29uc3QgcGFkZGluZ1Byb3AgPSBzY3JvbGxiYXJYID8gJ3BhZGRpbmdMZWZ0JyA6ICdwYWRkaW5nUmlnaHQnO1xuICBjb25zdCBzY3JvbGxiYXJXaWR0aCA9IHdpbmRvdy5pbm5lcldpZHRoIC0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoO1xuICBjb25zdCBzY3JvbGxYID0gYm9keVN0eWxlLmxlZnQgPyBwYXJzZUZsb2F0KGJvZHlTdHlsZS5sZWZ0KSA6IHdpbmRvdy5zY3JvbGxYO1xuICBjb25zdCBzY3JvbGxZID0gYm9keVN0eWxlLnRvcCA/IHBhcnNlRmxvYXQoYm9keVN0eWxlLnRvcCkgOiB3aW5kb3cuc2Nyb2xsWTtcbiAgYm9keVN0eWxlLm92ZXJmbG93ID0gJ2hpZGRlbic7XG4gIGlmIChzY3JvbGxiYXJXaWR0aCkge1xuICAgIGJvZHlTdHlsZVtwYWRkaW5nUHJvcF0gPSBzY3JvbGxiYXJXaWR0aCArIFwicHhcIjtcbiAgfVxuXG4gIC8vIE9ubHkgaU9TIGRvZXNuJ3QgcmVzcGVjdCBgb3ZlcmZsb3c6IGhpZGRlbmAgb24gZG9jdW1lbnQuYm9keSwgYW5kIHRoaXNcbiAgLy8gdGVjaG5pcXVlIGhhcyBmZXdlciBzaWRlIGVmZmVjdHMuXG4gIGlmIChpc0lPUykge1xuICAgIHZhciBfd2luZG93JHZpc3VhbFZpZXdwb3IsIF93aW5kb3ckdmlzdWFsVmlld3BvcjI7XG4gICAgLy8gaU9TIDEyIGRvZXMgbm90IHN1cHBvcnQgYHZpc3VhbFZpZXdwb3J0YC5cbiAgICBjb25zdCBvZmZzZXRMZWZ0ID0gKChfd2luZG93JHZpc3VhbFZpZXdwb3IgPSB3aW5kb3cudmlzdWFsVmlld3BvcnQpID09IG51bGwgPyB2b2lkIDAgOiBfd2luZG93JHZpc3VhbFZpZXdwb3Iub2Zmc2V0TGVmdCkgfHwgMDtcbiAgICBjb25zdCBvZmZzZXRUb3AgPSAoKF93aW5kb3ckdmlzdWFsVmlld3BvcjIgPSB3aW5kb3cudmlzdWFsVmlld3BvcnQpID09IG51bGwgPyB2b2lkIDAgOiBfd2luZG93JHZpc3VhbFZpZXdwb3IyLm9mZnNldFRvcCkgfHwgMDtcbiAgICBPYmplY3QuYXNzaWduKGJvZHlTdHlsZSwge1xuICAgICAgcG9zaXRpb246ICdmaXhlZCcsXG4gICAgICB0b3A6IC0oc2Nyb2xsWSAtIE1hdGguZmxvb3Iob2Zmc2V0VG9wKSkgKyBcInB4XCIsXG4gICAgICBsZWZ0OiAtKHNjcm9sbFggLSBNYXRoLmZsb29yKG9mZnNldExlZnQpKSArIFwicHhcIixcbiAgICAgIHJpZ2h0OiAnMCdcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gKCkgPT4ge1xuICAgIE9iamVjdC5hc3NpZ24oYm9keVN0eWxlLCB7XG4gICAgICBvdmVyZmxvdzogJycsXG4gICAgICBbcGFkZGluZ1Byb3BdOiAnJ1xuICAgIH0pO1xuICAgIGlmIChpc0lPUykge1xuICAgICAgT2JqZWN0LmFzc2lnbihib2R5U3R5bGUsIHtcbiAgICAgICAgcG9zaXRpb246ICcnLFxuICAgICAgICB0b3A6ICcnLFxuICAgICAgICBsZWZ0OiAnJyxcbiAgICAgICAgcmlnaHQ6ICcnXG4gICAgICB9KTtcbiAgICAgIHdpbmRvdy5zY3JvbGxUbyhzY3JvbGxYLCBzY3JvbGxZKTtcbiAgICB9XG4gIH07XG59XG5sZXQgY2xlYW51cCA9ICgpID0+IHt9O1xuXG4vKipcbiAqIFByb3ZpZGVzIGJhc2Ugc3R5bGluZyBmb3IgYSBmaXhlZCBvdmVybGF5IGVsZW1lbnQgdG8gZGltIGNvbnRlbnQgb3IgYmxvY2tcbiAqIHBvaW50ZXIgZXZlbnRzIGJlaGluZCBhIGZsb2F0aW5nIGVsZW1lbnQuXG4gKiBJdCdzIGEgcmVndWxhciBgPGRpdj5gLCBzbyBpdCBjYW4gYmUgc3R5bGVkIHZpYSBhbnkgQ1NTIHNvbHV0aW9uIHlvdSBwcmVmZXIuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvRmxvYXRpbmdPdmVybGF5XG4gKi9cbmNvbnN0IEZsb2F0aW5nT3ZlcmxheSA9IC8qI19fUFVSRV9fKi9SZWFjdC5mb3J3YXJkUmVmKGZ1bmN0aW9uIEZsb2F0aW5nT3ZlcmxheShwcm9wcywgcmVmKSB7XG4gIGNvbnN0IHtcbiAgICBsb2NrU2Nyb2xsID0gZmFsc2UsXG4gICAgLi4ucmVzdFxuICB9ID0gcHJvcHM7XG4gIGluZGV4KCgpID0+IHtcbiAgICBpZiAoIWxvY2tTY3JvbGwpIHJldHVybjtcbiAgICBsb2NrQ291bnQrKztcbiAgICBpZiAobG9ja0NvdW50ID09PSAxKSB7XG4gICAgICBjbGVhbnVwID0gZW5hYmxlU2Nyb2xsTG9jaygpO1xuICAgIH1cbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgbG9ja0NvdW50LS07XG4gICAgICBpZiAobG9ja0NvdW50ID09PSAwKSB7XG4gICAgICAgIGNsZWFudXAoKTtcbiAgICAgIH1cbiAgICB9O1xuICB9LCBbbG9ja1Njcm9sbF0pO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgX2V4dGVuZHMoe1xuICAgIHJlZjogcmVmXG4gIH0sIHJlc3QsIHtcbiAgICBzdHlsZToge1xuICAgICAgcG9zaXRpb246ICdmaXhlZCcsXG4gICAgICBvdmVyZmxvdzogJ2F1dG8nLFxuICAgICAgdG9wOiAwLFxuICAgICAgcmlnaHQ6IDAsXG4gICAgICBib3R0b206IDAsXG4gICAgICBsZWZ0OiAwLFxuICAgICAgLi4ucmVzdC5zdHlsZVxuICAgIH1cbiAgfSkpO1xufSk7XG5cbmZ1bmN0aW9uIGlzQnV0dG9uVGFyZ2V0KGV2ZW50KSB7XG4gIHJldHVybiBpc0hUTUxFbGVtZW50KGV2ZW50LnRhcmdldCkgJiYgZXZlbnQudGFyZ2V0LnRhZ05hbWUgPT09ICdCVVRUT04nO1xufVxuZnVuY3Rpb24gaXNTcGFjZUlnbm9yZWQoZWxlbWVudCkge1xuICByZXR1cm4gaXNUeXBlYWJsZUVsZW1lbnQoZWxlbWVudCk7XG59XG4vKipcbiAqIE9wZW5zIG9yIGNsb3NlcyB0aGUgZmxvYXRpbmcgZWxlbWVudCB3aGVuIGNsaWNraW5nIHRoZSByZWZlcmVuY2UgZWxlbWVudC5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy91c2VDbGlja1xuICovXG5mdW5jdGlvbiB1c2VDbGljayhjb250ZXh0LCBwcm9wcykge1xuICBpZiAocHJvcHMgPT09IHZvaWQgMCkge1xuICAgIHByb3BzID0ge307XG4gIH1cbiAgY29uc3Qge1xuICAgIG9wZW4sXG4gICAgb25PcGVuQ2hhbmdlLFxuICAgIGRhdGFSZWYsXG4gICAgZWxlbWVudHM6IHtcbiAgICAgIGRvbVJlZmVyZW5jZVxuICAgIH1cbiAgfSA9IGNvbnRleHQ7XG4gIGNvbnN0IHtcbiAgICBlbmFibGVkID0gdHJ1ZSxcbiAgICBldmVudDogZXZlbnRPcHRpb24gPSAnY2xpY2snLFxuICAgIHRvZ2dsZSA9IHRydWUsXG4gICAgaWdub3JlTW91c2UgPSBmYWxzZSxcbiAgICBrZXlib2FyZEhhbmRsZXJzID0gdHJ1ZSxcbiAgICBzdGlja0lmT3BlbiA9IHRydWVcbiAgfSA9IHByb3BzO1xuICBjb25zdCBwb2ludGVyVHlwZVJlZiA9IFJlYWN0LnVzZVJlZigpO1xuICBjb25zdCBkaWRLZXlEb3duUmVmID0gUmVhY3QudXNlUmVmKGZhbHNlKTtcbiAgY29uc3QgcmVmZXJlbmNlID0gUmVhY3QudXNlTWVtbygoKSA9PiAoe1xuICAgIG9uUG9pbnRlckRvd24oZXZlbnQpIHtcbiAgICAgIHBvaW50ZXJUeXBlUmVmLmN1cnJlbnQgPSBldmVudC5wb2ludGVyVHlwZTtcbiAgICB9LFxuICAgIG9uTW91c2VEb3duKGV2ZW50KSB7XG4gICAgICBjb25zdCBwb2ludGVyVHlwZSA9IHBvaW50ZXJUeXBlUmVmLmN1cnJlbnQ7XG5cbiAgICAgIC8vIElnbm9yZSBhbGwgYnV0dG9ucyBleGNlcHQgZm9yIHRoZSBcIm1haW5cIiBidXR0b24uXG4gICAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvTW91c2VFdmVudC9idXR0b25cbiAgICAgIGlmIChldmVudC5idXR0b24gIT09IDApIHJldHVybjtcbiAgICAgIGlmIChldmVudE9wdGlvbiA9PT0gJ2NsaWNrJykgcmV0dXJuO1xuICAgICAgaWYgKGlzTW91c2VMaWtlUG9pbnRlclR5cGUocG9pbnRlclR5cGUsIHRydWUpICYmIGlnbm9yZU1vdXNlKSByZXR1cm47XG4gICAgICBpZiAob3BlbiAmJiB0b2dnbGUgJiYgKGRhdGFSZWYuY3VycmVudC5vcGVuRXZlbnQgJiYgc3RpY2tJZk9wZW4gPyBkYXRhUmVmLmN1cnJlbnQub3BlbkV2ZW50LnR5cGUgPT09ICdtb3VzZWRvd24nIDogdHJ1ZSkpIHtcbiAgICAgICAgb25PcGVuQ2hhbmdlKGZhbHNlLCBldmVudC5uYXRpdmVFdmVudCwgJ2NsaWNrJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBQcmV2ZW50IHN0ZWFsaW5nIGZvY3VzIGZyb20gdGhlIGZsb2F0aW5nIGVsZW1lbnRcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgb25PcGVuQ2hhbmdlKHRydWUsIGV2ZW50Lm5hdGl2ZUV2ZW50LCAnY2xpY2snKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIG9uQ2xpY2soZXZlbnQpIHtcbiAgICAgIGNvbnN0IHBvaW50ZXJUeXBlID0gcG9pbnRlclR5cGVSZWYuY3VycmVudDtcbiAgICAgIGlmIChldmVudE9wdGlvbiA9PT0gJ21vdXNlZG93bicgJiYgcG9pbnRlclR5cGVSZWYuY3VycmVudCkge1xuICAgICAgICBwb2ludGVyVHlwZVJlZi5jdXJyZW50ID0gdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoaXNNb3VzZUxpa2VQb2ludGVyVHlwZShwb2ludGVyVHlwZSwgdHJ1ZSkgJiYgaWdub3JlTW91c2UpIHJldHVybjtcbiAgICAgIGlmIChvcGVuICYmIHRvZ2dsZSAmJiAoZGF0YVJlZi5jdXJyZW50Lm9wZW5FdmVudCAmJiBzdGlja0lmT3BlbiA/IGRhdGFSZWYuY3VycmVudC5vcGVuRXZlbnQudHlwZSA9PT0gJ2NsaWNrJyA6IHRydWUpKSB7XG4gICAgICAgIG9uT3BlbkNoYW5nZShmYWxzZSwgZXZlbnQubmF0aXZlRXZlbnQsICdjbGljaycpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb25PcGVuQ2hhbmdlKHRydWUsIGV2ZW50Lm5hdGl2ZUV2ZW50LCAnY2xpY2snKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIG9uS2V5RG93bihldmVudCkge1xuICAgICAgcG9pbnRlclR5cGVSZWYuY3VycmVudCA9IHVuZGVmaW5lZDtcbiAgICAgIGlmIChldmVudC5kZWZhdWx0UHJldmVudGVkIHx8ICFrZXlib2FyZEhhbmRsZXJzIHx8IGlzQnV0dG9uVGFyZ2V0KGV2ZW50KSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoZXZlbnQua2V5ID09PSAnICcgJiYgIWlzU3BhY2VJZ25vcmVkKGRvbVJlZmVyZW5jZSkpIHtcbiAgICAgICAgLy8gUHJldmVudCBzY3JvbGxpbmdcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgZGlkS2V5RG93blJlZi5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChldmVudC5rZXkgPT09ICdFbnRlcicpIHtcbiAgICAgICAgaWYgKG9wZW4gJiYgdG9nZ2xlKSB7XG4gICAgICAgICAgb25PcGVuQ2hhbmdlKGZhbHNlLCBldmVudC5uYXRpdmVFdmVudCwgJ2NsaWNrJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb25PcGVuQ2hhbmdlKHRydWUsIGV2ZW50Lm5hdGl2ZUV2ZW50LCAnY2xpY2snKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgb25LZXlVcChldmVudCkge1xuICAgICAgaWYgKGV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQgfHwgIWtleWJvYXJkSGFuZGxlcnMgfHwgaXNCdXR0b25UYXJnZXQoZXZlbnQpIHx8IGlzU3BhY2VJZ25vcmVkKGRvbVJlZmVyZW5jZSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGV2ZW50LmtleSA9PT0gJyAnICYmIGRpZEtleURvd25SZWYuY3VycmVudCkge1xuICAgICAgICBkaWRLZXlEb3duUmVmLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgICAgaWYgKG9wZW4gJiYgdG9nZ2xlKSB7XG4gICAgICAgICAgb25PcGVuQ2hhbmdlKGZhbHNlLCBldmVudC5uYXRpdmVFdmVudCwgJ2NsaWNrJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb25PcGVuQ2hhbmdlKHRydWUsIGV2ZW50Lm5hdGl2ZUV2ZW50LCAnY2xpY2snKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSksIFtkYXRhUmVmLCBkb21SZWZlcmVuY2UsIGV2ZW50T3B0aW9uLCBpZ25vcmVNb3VzZSwga2V5Ym9hcmRIYW5kbGVycywgb25PcGVuQ2hhbmdlLCBvcGVuLCBzdGlja0lmT3BlbiwgdG9nZ2xlXSk7XG4gIHJldHVybiBSZWFjdC51c2VNZW1vKCgpID0+IGVuYWJsZWQgPyB7XG4gICAgcmVmZXJlbmNlXG4gIH0gOiB7fSwgW2VuYWJsZWQsIHJlZmVyZW5jZV0pO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVWaXJ0dWFsRWxlbWVudChkb21FbGVtZW50LCBkYXRhKSB7XG4gIGxldCBvZmZzZXRYID0gbnVsbDtcbiAgbGV0IG9mZnNldFkgPSBudWxsO1xuICBsZXQgaXNBdXRvVXBkYXRlRXZlbnQgPSBmYWxzZTtcbiAgcmV0dXJuIHtcbiAgICBjb250ZXh0RWxlbWVudDogZG9tRWxlbWVudCB8fCB1bmRlZmluZWQsXG4gICAgZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkge1xuICAgICAgdmFyIF9kYXRhJGRhdGFSZWYkY3VycmVudDtcbiAgICAgIGNvbnN0IGRvbVJlY3QgPSAoZG9tRWxlbWVudCA9PSBudWxsID8gdm9pZCAwIDogZG9tRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSkgfHwge1xuICAgICAgICB3aWR0aDogMCxcbiAgICAgICAgaGVpZ2h0OiAwLFxuICAgICAgICB4OiAwLFxuICAgICAgICB5OiAwXG4gICAgICB9O1xuICAgICAgY29uc3QgaXNYQXhpcyA9IGRhdGEuYXhpcyA9PT0gJ3gnIHx8IGRhdGEuYXhpcyA9PT0gJ2JvdGgnO1xuICAgICAgY29uc3QgaXNZQXhpcyA9IGRhdGEuYXhpcyA9PT0gJ3knIHx8IGRhdGEuYXhpcyA9PT0gJ2JvdGgnO1xuICAgICAgY29uc3QgY2FuVHJhY2tDdXJzb3JPbkF1dG9VcGRhdGUgPSBbJ21vdXNlZW50ZXInLCAnbW91c2Vtb3ZlJ10uaW5jbHVkZXMoKChfZGF0YSRkYXRhUmVmJGN1cnJlbnQgPSBkYXRhLmRhdGFSZWYuY3VycmVudC5vcGVuRXZlbnQpID09IG51bGwgPyB2b2lkIDAgOiBfZGF0YSRkYXRhUmVmJGN1cnJlbnQudHlwZSkgfHwgJycpICYmIGRhdGEucG9pbnRlclR5cGUgIT09ICd0b3VjaCc7XG4gICAgICBsZXQgd2lkdGggPSBkb21SZWN0LndpZHRoO1xuICAgICAgbGV0IGhlaWdodCA9IGRvbVJlY3QuaGVpZ2h0O1xuICAgICAgbGV0IHggPSBkb21SZWN0Lng7XG4gICAgICBsZXQgeSA9IGRvbVJlY3QueTtcbiAgICAgIGlmIChvZmZzZXRYID09IG51bGwgJiYgZGF0YS54ICYmIGlzWEF4aXMpIHtcbiAgICAgICAgb2Zmc2V0WCA9IGRvbVJlY3QueCAtIGRhdGEueDtcbiAgICAgIH1cbiAgICAgIGlmIChvZmZzZXRZID09IG51bGwgJiYgZGF0YS55ICYmIGlzWUF4aXMpIHtcbiAgICAgICAgb2Zmc2V0WSA9IGRvbVJlY3QueSAtIGRhdGEueTtcbiAgICAgIH1cbiAgICAgIHggLT0gb2Zmc2V0WCB8fCAwO1xuICAgICAgeSAtPSBvZmZzZXRZIHx8IDA7XG4gICAgICB3aWR0aCA9IDA7XG4gICAgICBoZWlnaHQgPSAwO1xuICAgICAgaWYgKCFpc0F1dG9VcGRhdGVFdmVudCB8fCBjYW5UcmFja0N1cnNvck9uQXV0b1VwZGF0ZSkge1xuICAgICAgICB3aWR0aCA9IGRhdGEuYXhpcyA9PT0gJ3knID8gZG9tUmVjdC53aWR0aCA6IDA7XG4gICAgICAgIGhlaWdodCA9IGRhdGEuYXhpcyA9PT0gJ3gnID8gZG9tUmVjdC5oZWlnaHQgOiAwO1xuICAgICAgICB4ID0gaXNYQXhpcyAmJiBkYXRhLnggIT0gbnVsbCA/IGRhdGEueCA6IHg7XG4gICAgICAgIHkgPSBpc1lBeGlzICYmIGRhdGEueSAhPSBudWxsID8gZGF0YS55IDogeTtcbiAgICAgIH0gZWxzZSBpZiAoaXNBdXRvVXBkYXRlRXZlbnQgJiYgIWNhblRyYWNrQ3Vyc29yT25BdXRvVXBkYXRlKSB7XG4gICAgICAgIGhlaWdodCA9IGRhdGEuYXhpcyA9PT0gJ3gnID8gZG9tUmVjdC5oZWlnaHQgOiBoZWlnaHQ7XG4gICAgICAgIHdpZHRoID0gZGF0YS5heGlzID09PSAneScgPyBkb21SZWN0LndpZHRoIDogd2lkdGg7XG4gICAgICB9XG4gICAgICBpc0F1dG9VcGRhdGVFdmVudCA9IHRydWU7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB3aWR0aCxcbiAgICAgICAgaGVpZ2h0LFxuICAgICAgICB4LFxuICAgICAgICB5LFxuICAgICAgICB0b3A6IHksXG4gICAgICAgIHJpZ2h0OiB4ICsgd2lkdGgsXG4gICAgICAgIGJvdHRvbTogeSArIGhlaWdodCxcbiAgICAgICAgbGVmdDogeFxuICAgICAgfTtcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBpc01vdXNlQmFzZWRFdmVudChldmVudCkge1xuICByZXR1cm4gZXZlbnQgIT0gbnVsbCAmJiBldmVudC5jbGllbnRYICE9IG51bGw7XG59XG4vKipcbiAqIFBvc2l0aW9ucyB0aGUgZmxvYXRpbmcgZWxlbWVudCByZWxhdGl2ZSB0byBhIGNsaWVudCBwb2ludCAoaW4gdGhlIHZpZXdwb3J0KSxcbiAqIHN1Y2ggYXMgdGhlIG1vdXNlIHBvc2l0aW9uLiBCeSBkZWZhdWx0LCBpdCBmb2xsb3dzIHRoZSBtb3VzZSBjdXJzb3IuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvdXNlQ2xpZW50UG9pbnRcbiAqL1xuZnVuY3Rpb24gdXNlQ2xpZW50UG9pbnQoY29udGV4dCwgcHJvcHMpIHtcbiAgaWYgKHByb3BzID09PSB2b2lkIDApIHtcbiAgICBwcm9wcyA9IHt9O1xuICB9XG4gIGNvbnN0IHtcbiAgICBvcGVuLFxuICAgIGRhdGFSZWYsXG4gICAgZWxlbWVudHM6IHtcbiAgICAgIGZsb2F0aW5nLFxuICAgICAgZG9tUmVmZXJlbmNlXG4gICAgfSxcbiAgICByZWZzXG4gIH0gPSBjb250ZXh0O1xuICBjb25zdCB7XG4gICAgZW5hYmxlZCA9IHRydWUsXG4gICAgYXhpcyA9ICdib3RoJyxcbiAgICB4ID0gbnVsbCxcbiAgICB5ID0gbnVsbFxuICB9ID0gcHJvcHM7XG4gIGNvbnN0IGluaXRpYWxSZWYgPSBSZWFjdC51c2VSZWYoZmFsc2UpO1xuICBjb25zdCBjbGVhbnVwTGlzdGVuZXJSZWYgPSBSZWFjdC51c2VSZWYobnVsbCk7XG4gIGNvbnN0IFtwb2ludGVyVHlwZSwgc2V0UG9pbnRlclR5cGVdID0gUmVhY3QudXNlU3RhdGUoKTtcbiAgY29uc3QgW3JlYWN0aXZlLCBzZXRSZWFjdGl2ZV0gPSBSZWFjdC51c2VTdGF0ZShbXSk7XG4gIGNvbnN0IHNldFJlZmVyZW5jZSA9IHVzZUVmZmVjdEV2ZW50KCh4LCB5KSA9PiB7XG4gICAgaWYgKGluaXRpYWxSZWYuY3VycmVudCkgcmV0dXJuO1xuXG4gICAgLy8gUHJldmVudCBzZXR0aW5nIGlmIHRoZSBvcGVuIGV2ZW50IHdhcyBub3QgYSBtb3VzZS1saWtlIG9uZVxuICAgIC8vIChlLmcuIGZvY3VzIHRvIG9wZW4sIHRoZW4gaG92ZXIgb3ZlciB0aGUgcmVmZXJlbmNlIGVsZW1lbnQpLlxuICAgIC8vIE9ubHkgYXBwbHkgaWYgdGhlIGV2ZW50IGV4aXN0cy5cbiAgICBpZiAoZGF0YVJlZi5jdXJyZW50Lm9wZW5FdmVudCAmJiAhaXNNb3VzZUJhc2VkRXZlbnQoZGF0YVJlZi5jdXJyZW50Lm9wZW5FdmVudCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmVmcy5zZXRQb3NpdGlvblJlZmVyZW5jZShjcmVhdGVWaXJ0dWFsRWxlbWVudChkb21SZWZlcmVuY2UsIHtcbiAgICAgIHgsXG4gICAgICB5LFxuICAgICAgYXhpcyxcbiAgICAgIGRhdGFSZWYsXG4gICAgICBwb2ludGVyVHlwZVxuICAgIH0pKTtcbiAgfSk7XG4gIGNvbnN0IGhhbmRsZVJlZmVyZW5jZUVudGVyT3JNb3ZlID0gdXNlRWZmZWN0RXZlbnQoZXZlbnQgPT4ge1xuICAgIGlmICh4ICE9IG51bGwgfHwgeSAhPSBudWxsKSByZXR1cm47XG4gICAgaWYgKCFvcGVuKSB7XG4gICAgICBzZXRSZWZlcmVuY2UoZXZlbnQuY2xpZW50WCwgZXZlbnQuY2xpZW50WSk7XG4gICAgfSBlbHNlIGlmICghY2xlYW51cExpc3RlbmVyUmVmLmN1cnJlbnQpIHtcbiAgICAgIC8vIElmIHRoZXJlJ3Mgbm8gY2xlYW51cCwgdGhlcmUncyBubyBsaXN0ZW5lciwgYnV0IHdlIHdhbnQgdG8gZW5zdXJlXG4gICAgICAvLyB3ZSBhZGQgdGhlIGxpc3RlbmVyIGlmIHRoZSBjdXJzb3IgbGFuZGVkIG9uIHRoZSBmbG9hdGluZyBlbGVtZW50IGFuZFxuICAgICAgLy8gdGhlbiBiYWNrIG9uIHRoZSByZWZlcmVuY2UgKGkuZS4gaXQncyBpbnRlcmFjdGl2ZSkuXG4gICAgICBzZXRSZWFjdGl2ZShbXSk7XG4gICAgfVxuICB9KTtcblxuICAvLyBJZiB0aGUgcG9pbnRlciBpcyBhIG1vdXNlLWxpa2UgcG9pbnRlciwgd2Ugd2FudCB0byBjb250aW51ZSBmb2xsb3dpbmcgdGhlXG4gIC8vIG1vdXNlIGV2ZW4gaWYgdGhlIGZsb2F0aW5nIGVsZW1lbnQgaXMgdHJhbnNpdGlvbmluZyBvdXQuIE9uIHRvdWNoXG4gIC8vIGRldmljZXMsIHRoaXMgaXMgdW5kZXNpcmFibGUgYmVjYXVzZSB0aGUgZmxvYXRpbmcgZWxlbWVudCB3aWxsIG1vdmUgdG9cbiAgLy8gdGhlIGRpc21pc3NhbCB0b3VjaCBwb2ludC5cbiAgY29uc3Qgb3BlbkNoZWNrID0gaXNNb3VzZUxpa2VQb2ludGVyVHlwZShwb2ludGVyVHlwZSkgPyBmbG9hdGluZyA6IG9wZW47XG4gIGNvbnN0IGFkZExpc3RlbmVyID0gUmVhY3QudXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIC8vIEV4cGxpY2l0bHkgc3BlY2lmaWVkIGB4YC9geWAgY29vcmRpbmF0ZXMgc2hvdWxkbid0IGFkZCBhIGxpc3RlbmVyLlxuICAgIGlmICghb3BlbkNoZWNrIHx8ICFlbmFibGVkIHx8IHggIT0gbnVsbCB8fCB5ICE9IG51bGwpIHJldHVybjtcbiAgICBjb25zdCB3aW4gPSBnZXRXaW5kb3coZmxvYXRpbmcpO1xuICAgIGZ1bmN0aW9uIGhhbmRsZU1vdXNlTW92ZShldmVudCkge1xuICAgICAgY29uc3QgdGFyZ2V0ID0gZ2V0VGFyZ2V0KGV2ZW50KTtcbiAgICAgIGlmICghY29udGFpbnMoZmxvYXRpbmcsIHRhcmdldCkpIHtcbiAgICAgICAgc2V0UmVmZXJlbmNlKGV2ZW50LmNsaWVudFgsIGV2ZW50LmNsaWVudFkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2luLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIGhhbmRsZU1vdXNlTW92ZSk7XG4gICAgICAgIGNsZWFudXBMaXN0ZW5lclJlZi5jdXJyZW50ID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFkYXRhUmVmLmN1cnJlbnQub3BlbkV2ZW50IHx8IGlzTW91c2VCYXNlZEV2ZW50KGRhdGFSZWYuY3VycmVudC5vcGVuRXZlbnQpKSB7XG4gICAgICB3aW4uYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgaGFuZGxlTW91c2VNb3ZlKTtcbiAgICAgIGNvbnN0IGNsZWFudXAgPSAoKSA9PiB7XG4gICAgICAgIHdpbi5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBoYW5kbGVNb3VzZU1vdmUpO1xuICAgICAgICBjbGVhbnVwTGlzdGVuZXJSZWYuY3VycmVudCA9IG51bGw7XG4gICAgICB9O1xuICAgICAgY2xlYW51cExpc3RlbmVyUmVmLmN1cnJlbnQgPSBjbGVhbnVwO1xuICAgICAgcmV0dXJuIGNsZWFudXA7XG4gICAgfVxuICAgIHJlZnMuc2V0UG9zaXRpb25SZWZlcmVuY2UoZG9tUmVmZXJlbmNlKTtcbiAgfSwgW29wZW5DaGVjaywgZW5hYmxlZCwgeCwgeSwgZmxvYXRpbmcsIGRhdGFSZWYsIHJlZnMsIGRvbVJlZmVyZW5jZSwgc2V0UmVmZXJlbmNlXSk7XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgcmV0dXJuIGFkZExpc3RlbmVyKCk7XG4gIH0sIFthZGRMaXN0ZW5lciwgcmVhY3RpdmVdKTtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoZW5hYmxlZCAmJiAhZmxvYXRpbmcpIHtcbiAgICAgIGluaXRpYWxSZWYuY3VycmVudCA9IGZhbHNlO1xuICAgIH1cbiAgfSwgW2VuYWJsZWQsIGZsb2F0aW5nXSk7XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFlbmFibGVkICYmIG9wZW4pIHtcbiAgICAgIGluaXRpYWxSZWYuY3VycmVudCA9IHRydWU7XG4gICAgfVxuICB9LCBbZW5hYmxlZCwgb3Blbl0pO1xuICBpbmRleCgoKSA9PiB7XG4gICAgaWYgKGVuYWJsZWQgJiYgKHggIT0gbnVsbCB8fCB5ICE9IG51bGwpKSB7XG4gICAgICBpbml0aWFsUmVmLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgIHNldFJlZmVyZW5jZSh4LCB5KTtcbiAgICB9XG4gIH0sIFtlbmFibGVkLCB4LCB5LCBzZXRSZWZlcmVuY2VdKTtcbiAgY29uc3QgcmVmZXJlbmNlID0gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgZnVuY3Rpb24gc2V0UG9pbnRlclR5cGVSZWYoX3JlZikge1xuICAgICAgbGV0IHtcbiAgICAgICAgcG9pbnRlclR5cGVcbiAgICAgIH0gPSBfcmVmO1xuICAgICAgc2V0UG9pbnRlclR5cGUocG9pbnRlclR5cGUpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgb25Qb2ludGVyRG93bjogc2V0UG9pbnRlclR5cGVSZWYsXG4gICAgICBvblBvaW50ZXJFbnRlcjogc2V0UG9pbnRlclR5cGVSZWYsXG4gICAgICBvbk1vdXNlTW92ZTogaGFuZGxlUmVmZXJlbmNlRW50ZXJPck1vdmUsXG4gICAgICBvbk1vdXNlRW50ZXI6IGhhbmRsZVJlZmVyZW5jZUVudGVyT3JNb3ZlXG4gICAgfTtcbiAgfSwgW2hhbmRsZVJlZmVyZW5jZUVudGVyT3JNb3ZlXSk7XG4gIHJldHVybiBSZWFjdC51c2VNZW1vKCgpID0+IGVuYWJsZWQgPyB7XG4gICAgcmVmZXJlbmNlXG4gIH0gOiB7fSwgW2VuYWJsZWQsIHJlZmVyZW5jZV0pO1xufVxuXG5jb25zdCBidWJibGVIYW5kbGVyS2V5cyA9IHtcbiAgcG9pbnRlcmRvd246ICdvblBvaW50ZXJEb3duJyxcbiAgbW91c2Vkb3duOiAnb25Nb3VzZURvd24nLFxuICBjbGljazogJ29uQ2xpY2snXG59O1xuY29uc3QgY2FwdHVyZUhhbmRsZXJLZXlzID0ge1xuICBwb2ludGVyZG93bjogJ29uUG9pbnRlckRvd25DYXB0dXJlJyxcbiAgbW91c2Vkb3duOiAnb25Nb3VzZURvd25DYXB0dXJlJyxcbiAgY2xpY2s6ICdvbkNsaWNrQ2FwdHVyZSdcbn07XG5jb25zdCBub3JtYWxpemVQcm9wID0gbm9ybWFsaXphYmxlID0+IHtcbiAgdmFyIF9ub3JtYWxpemFibGUkZXNjYXBlSywgX25vcm1hbGl6YWJsZSRvdXRzaWRlO1xuICByZXR1cm4ge1xuICAgIGVzY2FwZUtleTogdHlwZW9mIG5vcm1hbGl6YWJsZSA9PT0gJ2Jvb2xlYW4nID8gbm9ybWFsaXphYmxlIDogKF9ub3JtYWxpemFibGUkZXNjYXBlSyA9IG5vcm1hbGl6YWJsZSA9PSBudWxsID8gdm9pZCAwIDogbm9ybWFsaXphYmxlLmVzY2FwZUtleSkgIT0gbnVsbCA/IF9ub3JtYWxpemFibGUkZXNjYXBlSyA6IGZhbHNlLFxuICAgIG91dHNpZGVQcmVzczogdHlwZW9mIG5vcm1hbGl6YWJsZSA9PT0gJ2Jvb2xlYW4nID8gbm9ybWFsaXphYmxlIDogKF9ub3JtYWxpemFibGUkb3V0c2lkZSA9IG5vcm1hbGl6YWJsZSA9PSBudWxsID8gdm9pZCAwIDogbm9ybWFsaXphYmxlLm91dHNpZGVQcmVzcykgIT0gbnVsbCA/IF9ub3JtYWxpemFibGUkb3V0c2lkZSA6IHRydWVcbiAgfTtcbn07XG4vKipcbiAqIENsb3NlcyB0aGUgZmxvYXRpbmcgZWxlbWVudCB3aGVuIGEgZGlzbWlzc2FsIGlzIHJlcXVlc3RlZCDigJQgYnkgZGVmYXVsdCwgd2hlblxuICogdGhlIHVzZXIgcHJlc3NlcyB0aGUgYGVzY2FwZWAga2V5IG9yIG91dHNpZGUgb2YgdGhlIGZsb2F0aW5nIGVsZW1lbnQuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvdXNlRGlzbWlzc1xuICovXG5mdW5jdGlvbiB1c2VEaXNtaXNzKGNvbnRleHQsIHByb3BzKSB7XG4gIGlmIChwcm9wcyA9PT0gdm9pZCAwKSB7XG4gICAgcHJvcHMgPSB7fTtcbiAgfVxuICBjb25zdCB7XG4gICAgb3BlbixcbiAgICBvbk9wZW5DaGFuZ2UsXG4gICAgZWxlbWVudHMsXG4gICAgZGF0YVJlZlxuICB9ID0gY29udGV4dDtcbiAgY29uc3Qge1xuICAgIGVuYWJsZWQgPSB0cnVlLFxuICAgIGVzY2FwZUtleSA9IHRydWUsXG4gICAgb3V0c2lkZVByZXNzOiB1bnN0YWJsZV9vdXRzaWRlUHJlc3MgPSB0cnVlLFxuICAgIG91dHNpZGVQcmVzc0V2ZW50ID0gJ3BvaW50ZXJkb3duJyxcbiAgICByZWZlcmVuY2VQcmVzcyA9IGZhbHNlLFxuICAgIHJlZmVyZW5jZVByZXNzRXZlbnQgPSAncG9pbnRlcmRvd24nLFxuICAgIGFuY2VzdG9yU2Nyb2xsID0gZmFsc2UsXG4gICAgYnViYmxlcyxcbiAgICBjYXB0dXJlXG4gIH0gPSBwcm9wcztcbiAgY29uc3QgdHJlZSA9IHVzZUZsb2F0aW5nVHJlZSgpO1xuICBjb25zdCBvdXRzaWRlUHJlc3NGbiA9IHVzZUVmZmVjdEV2ZW50KHR5cGVvZiB1bnN0YWJsZV9vdXRzaWRlUHJlc3MgPT09ICdmdW5jdGlvbicgPyB1bnN0YWJsZV9vdXRzaWRlUHJlc3MgOiAoKSA9PiBmYWxzZSk7XG4gIGNvbnN0IG91dHNpZGVQcmVzcyA9IHR5cGVvZiB1bnN0YWJsZV9vdXRzaWRlUHJlc3MgPT09ICdmdW5jdGlvbicgPyBvdXRzaWRlUHJlc3NGbiA6IHVuc3RhYmxlX291dHNpZGVQcmVzcztcbiAgY29uc3QgaW5zaWRlUmVhY3RUcmVlUmVmID0gUmVhY3QudXNlUmVmKGZhbHNlKTtcbiAgY29uc3QgZW5kZWRPclN0YXJ0ZWRJbnNpZGVSZWYgPSBSZWFjdC51c2VSZWYoZmFsc2UpO1xuICBjb25zdCB7XG4gICAgZXNjYXBlS2V5OiBlc2NhcGVLZXlCdWJibGVzLFxuICAgIG91dHNpZGVQcmVzczogb3V0c2lkZVByZXNzQnViYmxlc1xuICB9ID0gbm9ybWFsaXplUHJvcChidWJibGVzKTtcbiAgY29uc3Qge1xuICAgIGVzY2FwZUtleTogZXNjYXBlS2V5Q2FwdHVyZSxcbiAgICBvdXRzaWRlUHJlc3M6IG91dHNpZGVQcmVzc0NhcHR1cmVcbiAgfSA9IG5vcm1hbGl6ZVByb3AoY2FwdHVyZSk7XG4gIGNvbnN0IGlzQ29tcG9zaW5nUmVmID0gUmVhY3QudXNlUmVmKGZhbHNlKTtcbiAgY29uc3QgY2xvc2VPbkVzY2FwZUtleURvd24gPSB1c2VFZmZlY3RFdmVudChldmVudCA9PiB7XG4gICAgdmFyIF9kYXRhUmVmJGN1cnJlbnQkZmxvYTtcbiAgICBpZiAoIW9wZW4gfHwgIWVuYWJsZWQgfHwgIWVzY2FwZUtleSB8fCBldmVudC5rZXkgIT09ICdFc2NhcGUnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gV2FpdCB1bnRpbCBJTUUgaXMgc2V0dGxlZC4gUHJlc3NpbmcgYEVzY2FwZWAgd2hpbGUgY29tcG9zaW5nIHNob3VsZFxuICAgIC8vIGNsb3NlIHRoZSBjb21wb3NlIG1lbnUsIGJ1dCBub3QgdGhlIGZsb2F0aW5nIGVsZW1lbnQuXG4gICAgaWYgKGlzQ29tcG9zaW5nUmVmLmN1cnJlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgbm9kZUlkID0gKF9kYXRhUmVmJGN1cnJlbnQkZmxvYSA9IGRhdGFSZWYuY3VycmVudC5mbG9hdGluZ0NvbnRleHQpID09IG51bGwgPyB2b2lkIDAgOiBfZGF0YVJlZiRjdXJyZW50JGZsb2Eubm9kZUlkO1xuICAgIGNvbnN0IGNoaWxkcmVuID0gdHJlZSA/IGdldENoaWxkcmVuKHRyZWUubm9kZXNSZWYuY3VycmVudCwgbm9kZUlkKSA6IFtdO1xuICAgIGlmICghZXNjYXBlS2V5QnViYmxlcykge1xuICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICBpZiAoY2hpbGRyZW4ubGVuZ3RoID4gMCkge1xuICAgICAgICBsZXQgc2hvdWxkRGlzbWlzcyA9IHRydWU7XG4gICAgICAgIGNoaWxkcmVuLmZvckVhY2goY2hpbGQgPT4ge1xuICAgICAgICAgIHZhciBfY2hpbGQkY29udGV4dDtcbiAgICAgICAgICBpZiAoKF9jaGlsZCRjb250ZXh0ID0gY2hpbGQuY29udGV4dCkgIT0gbnVsbCAmJiBfY2hpbGQkY29udGV4dC5vcGVuICYmICFjaGlsZC5jb250ZXh0LmRhdGFSZWYuY3VycmVudC5fX2VzY2FwZUtleUJ1YmJsZXMpIHtcbiAgICAgICAgICAgIHNob3VsZERpc21pc3MgPSBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIXNob3VsZERpc21pc3MpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgb25PcGVuQ2hhbmdlKGZhbHNlLCBpc1JlYWN0RXZlbnQoZXZlbnQpID8gZXZlbnQubmF0aXZlRXZlbnQgOiBldmVudCwgJ2VzY2FwZS1rZXknKTtcbiAgfSk7XG4gIGNvbnN0IGNsb3NlT25Fc2NhcGVLZXlEb3duQ2FwdHVyZSA9IHVzZUVmZmVjdEV2ZW50KGV2ZW50ID0+IHtcbiAgICB2YXIgX2dldFRhcmdldDI7XG4gICAgY29uc3QgY2FsbGJhY2sgPSAoKSA9PiB7XG4gICAgICB2YXIgX2dldFRhcmdldDtcbiAgICAgIGNsb3NlT25Fc2NhcGVLZXlEb3duKGV2ZW50KTtcbiAgICAgIChfZ2V0VGFyZ2V0ID0gZ2V0VGFyZ2V0KGV2ZW50KSkgPT0gbnVsbCB8fCBfZ2V0VGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBjYWxsYmFjayk7XG4gICAgfTtcbiAgICAoX2dldFRhcmdldDIgPSBnZXRUYXJnZXQoZXZlbnQpKSA9PSBudWxsIHx8IF9nZXRUYXJnZXQyLmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBjYWxsYmFjayk7XG4gIH0pO1xuICBjb25zdCBjbG9zZU9uUHJlc3NPdXRzaWRlID0gdXNlRWZmZWN0RXZlbnQoZXZlbnQgPT4ge1xuICAgIHZhciBfZGF0YVJlZiRjdXJyZW50JGZsb2EyO1xuICAgIC8vIEdpdmVuIGRldmVsb3BlcnMgY2FuIHN0b3AgdGhlIHByb3BhZ2F0aW9uIG9mIHRoZSBzeW50aGV0aWMgZXZlbnQsXG4gICAgLy8gd2UgY2FuIG9ubHkgYmUgY29uZmlkZW50IHdpdGggYSBwb3NpdGl2ZSB2YWx1ZS5cbiAgICBjb25zdCBpbnNpZGVSZWFjdFRyZWUgPSBpbnNpZGVSZWFjdFRyZWVSZWYuY3VycmVudDtcbiAgICBpbnNpZGVSZWFjdFRyZWVSZWYuY3VycmVudCA9IGZhbHNlO1xuXG4gICAgLy8gV2hlbiBjbGljayBvdXRzaWRlIGlzIGxhenkgKGBjbGlja2AgZXZlbnQpLCBoYW5kbGUgZHJhZ2dpbmcuXG4gICAgLy8gRG9uJ3QgY2xvc2UgaWY6XG4gICAgLy8gLSBUaGUgY2xpY2sgc3RhcnRlZCBpbnNpZGUgdGhlIGZsb2F0aW5nIGVsZW1lbnQuXG4gICAgLy8gLSBUaGUgY2xpY2sgZW5kZWQgaW5zaWRlIHRoZSBmbG9hdGluZyBlbGVtZW50LlxuICAgIGNvbnN0IGVuZGVkT3JTdGFydGVkSW5zaWRlID0gZW5kZWRPclN0YXJ0ZWRJbnNpZGVSZWYuY3VycmVudDtcbiAgICBlbmRlZE9yU3RhcnRlZEluc2lkZVJlZi5jdXJyZW50ID0gZmFsc2U7XG4gICAgaWYgKG91dHNpZGVQcmVzc0V2ZW50ID09PSAnY2xpY2snICYmIGVuZGVkT3JTdGFydGVkSW5zaWRlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChpbnNpZGVSZWFjdFRyZWUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBvdXRzaWRlUHJlc3MgPT09ICdmdW5jdGlvbicgJiYgIW91dHNpZGVQcmVzcyhldmVudCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgdGFyZ2V0ID0gZ2V0VGFyZ2V0KGV2ZW50KTtcbiAgICBjb25zdCBpbmVydFNlbGVjdG9yID0gXCJbXCIgKyBjcmVhdGVBdHRyaWJ1dGUoJ2luZXJ0JykgKyBcIl1cIjtcbiAgICBjb25zdCBtYXJrZXJzID0gZ2V0RG9jdW1lbnQoZWxlbWVudHMuZmxvYXRpbmcpLnF1ZXJ5U2VsZWN0b3JBbGwoaW5lcnRTZWxlY3Rvcik7XG4gICAgbGV0IHRhcmdldFJvb3RBbmNlc3RvciA9IGlzRWxlbWVudCh0YXJnZXQpID8gdGFyZ2V0IDogbnVsbDtcbiAgICB3aGlsZSAodGFyZ2V0Um9vdEFuY2VzdG9yICYmICFpc0xhc3RUcmF2ZXJzYWJsZU5vZGUodGFyZ2V0Um9vdEFuY2VzdG9yKSkge1xuICAgICAgY29uc3QgbmV4dFBhcmVudCA9IGdldFBhcmVudE5vZGUodGFyZ2V0Um9vdEFuY2VzdG9yKTtcbiAgICAgIGlmIChpc0xhc3RUcmF2ZXJzYWJsZU5vZGUobmV4dFBhcmVudCkgfHwgIWlzRWxlbWVudChuZXh0UGFyZW50KSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHRhcmdldFJvb3RBbmNlc3RvciA9IG5leHRQYXJlbnQ7XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgaWYgdGhlIGNsaWNrIG9jY3VycmVkIG9uIGEgdGhpcmQtcGFydHkgZWxlbWVudCBpbmplY3RlZCBhZnRlciB0aGVcbiAgICAvLyBmbG9hdGluZyBlbGVtZW50IHJlbmRlcmVkLlxuICAgIGlmIChtYXJrZXJzLmxlbmd0aCAmJiBpc0VsZW1lbnQodGFyZ2V0KSAmJiAhaXNSb290RWxlbWVudCh0YXJnZXQpICYmXG4gICAgLy8gQ2xpY2tlZCBvbiBhIGRpcmVjdCBhbmNlc3RvciAoZS5nLiBGbG9hdGluZ092ZXJsYXkpLlxuICAgICFjb250YWlucyh0YXJnZXQsIGVsZW1lbnRzLmZsb2F0aW5nKSAmJlxuICAgIC8vIElmIHRoZSB0YXJnZXQgcm9vdCBlbGVtZW50IGNvbnRhaW5zIG5vbmUgb2YgdGhlIG1hcmtlcnMsIHRoZW4gdGhlXG4gICAgLy8gZWxlbWVudCB3YXMgaW5qZWN0ZWQgYWZ0ZXIgdGhlIGZsb2F0aW5nIGVsZW1lbnQgcmVuZGVyZWQuXG4gICAgQXJyYXkuZnJvbShtYXJrZXJzKS5ldmVyeShtYXJrZXIgPT4gIWNvbnRhaW5zKHRhcmdldFJvb3RBbmNlc3RvciwgbWFya2VyKSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBDaGVjayBpZiB0aGUgY2xpY2sgb2NjdXJyZWQgb24gdGhlIHNjcm9sbGJhclxuICAgIGlmIChpc0hUTUxFbGVtZW50KHRhcmdldCkgJiYgZmxvYXRpbmcpIHtcbiAgICAgIC8vIEluIEZpcmVmb3gsIGB0YXJnZXQuc2Nyb2xsV2lkdGggPiB0YXJnZXQuY2xpZW50V2lkdGhgIGZvciBpbmxpbmVcbiAgICAgIC8vIGVsZW1lbnRzLlxuICAgICAgY29uc3QgY2FuU2Nyb2xsWCA9IHRhcmdldC5jbGllbnRXaWR0aCA+IDAgJiYgdGFyZ2V0LnNjcm9sbFdpZHRoID4gdGFyZ2V0LmNsaWVudFdpZHRoO1xuICAgICAgY29uc3QgY2FuU2Nyb2xsWSA9IHRhcmdldC5jbGllbnRIZWlnaHQgPiAwICYmIHRhcmdldC5zY3JvbGxIZWlnaHQgPiB0YXJnZXQuY2xpZW50SGVpZ2h0O1xuICAgICAgbGV0IHhDb25kID0gY2FuU2Nyb2xsWSAmJiBldmVudC5vZmZzZXRYID4gdGFyZ2V0LmNsaWVudFdpZHRoO1xuXG4gICAgICAvLyBJbiBzb21lIGJyb3dzZXJzIGl0IGlzIHBvc3NpYmxlIHRvIGNoYW5nZSB0aGUgPGJvZHk+IChvciB3aW5kb3cpXG4gICAgICAvLyBzY3JvbGxiYXIgdG8gdGhlIGxlZnQgc2lkZSwgYnV0IGlzIHZlcnkgcmFyZSBhbmQgaXMgZGlmZmljdWx0IHRvXG4gICAgICAvLyBjaGVjayBmb3IuIFBsdXMsIGZvciBtb2RhbCBkaWFsb2dzIHdpdGggYmFja2Ryb3BzLCBpdCBpcyBtb3JlXG4gICAgICAvLyBpbXBvcnRhbnQgdGhhdCB0aGUgYmFja2Ryb3AgaXMgY2hlY2tlZCBidXQgbm90IHNvIG11Y2ggdGhlIHdpbmRvdy5cbiAgICAgIGlmIChjYW5TY3JvbGxZKSB7XG4gICAgICAgIGNvbnN0IGlzUlRMID0gZ2V0Q29tcHV0ZWRTdHlsZSh0YXJnZXQpLmRpcmVjdGlvbiA9PT0gJ3J0bCc7XG4gICAgICAgIGlmIChpc1JUTCkge1xuICAgICAgICAgIHhDb25kID0gZXZlbnQub2Zmc2V0WCA8PSB0YXJnZXQub2Zmc2V0V2lkdGggLSB0YXJnZXQuY2xpZW50V2lkdGg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh4Q29uZCB8fCBjYW5TY3JvbGxYICYmIGV2ZW50Lm9mZnNldFkgPiB0YXJnZXQuY2xpZW50SGVpZ2h0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3Qgbm9kZUlkID0gKF9kYXRhUmVmJGN1cnJlbnQkZmxvYTIgPSBkYXRhUmVmLmN1cnJlbnQuZmxvYXRpbmdDb250ZXh0KSA9PSBudWxsID8gdm9pZCAwIDogX2RhdGFSZWYkY3VycmVudCRmbG9hMi5ub2RlSWQ7XG4gICAgY29uc3QgdGFyZ2V0SXNJbnNpZGVDaGlsZHJlbiA9IHRyZWUgJiYgZ2V0Q2hpbGRyZW4odHJlZS5ub2Rlc1JlZi5jdXJyZW50LCBub2RlSWQpLnNvbWUobm9kZSA9PiB7XG4gICAgICB2YXIgX25vZGUkY29udGV4dDtcbiAgICAgIHJldHVybiBpc0V2ZW50VGFyZ2V0V2l0aGluKGV2ZW50LCAoX25vZGUkY29udGV4dCA9IG5vZGUuY29udGV4dCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9ub2RlJGNvbnRleHQuZWxlbWVudHMuZmxvYXRpbmcpO1xuICAgIH0pO1xuICAgIGlmIChpc0V2ZW50VGFyZ2V0V2l0aGluKGV2ZW50LCBlbGVtZW50cy5mbG9hdGluZykgfHwgaXNFdmVudFRhcmdldFdpdGhpbihldmVudCwgZWxlbWVudHMuZG9tUmVmZXJlbmNlKSB8fCB0YXJnZXRJc0luc2lkZUNoaWxkcmVuKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGNoaWxkcmVuID0gdHJlZSA/IGdldENoaWxkcmVuKHRyZWUubm9kZXNSZWYuY3VycmVudCwgbm9kZUlkKSA6IFtdO1xuICAgIGlmIChjaGlsZHJlbi5sZW5ndGggPiAwKSB7XG4gICAgICBsZXQgc2hvdWxkRGlzbWlzcyA9IHRydWU7XG4gICAgICBjaGlsZHJlbi5mb3JFYWNoKGNoaWxkID0+IHtcbiAgICAgICAgdmFyIF9jaGlsZCRjb250ZXh0MjtcbiAgICAgICAgaWYgKChfY2hpbGQkY29udGV4dDIgPSBjaGlsZC5jb250ZXh0KSAhPSBudWxsICYmIF9jaGlsZCRjb250ZXh0Mi5vcGVuICYmICFjaGlsZC5jb250ZXh0LmRhdGFSZWYuY3VycmVudC5fX291dHNpZGVQcmVzc0J1YmJsZXMpIHtcbiAgICAgICAgICBzaG91bGREaXNtaXNzID0gZmFsc2U7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGlmICghc2hvdWxkRGlzbWlzcykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIG9uT3BlbkNoYW5nZShmYWxzZSwgZXZlbnQsICdvdXRzaWRlLXByZXNzJyk7XG4gIH0pO1xuICBjb25zdCBjbG9zZU9uUHJlc3NPdXRzaWRlQ2FwdHVyZSA9IHVzZUVmZmVjdEV2ZW50KGV2ZW50ID0+IHtcbiAgICB2YXIgX2dldFRhcmdldDQ7XG4gICAgY29uc3QgY2FsbGJhY2sgPSAoKSA9PiB7XG4gICAgICB2YXIgX2dldFRhcmdldDM7XG4gICAgICBjbG9zZU9uUHJlc3NPdXRzaWRlKGV2ZW50KTtcbiAgICAgIChfZ2V0VGFyZ2V0MyA9IGdldFRhcmdldChldmVudCkpID09IG51bGwgfHwgX2dldFRhcmdldDMucmVtb3ZlRXZlbnRMaXN0ZW5lcihvdXRzaWRlUHJlc3NFdmVudCwgY2FsbGJhY2spO1xuICAgIH07XG4gICAgKF9nZXRUYXJnZXQ0ID0gZ2V0VGFyZ2V0KGV2ZW50KSkgPT0gbnVsbCB8fCBfZ2V0VGFyZ2V0NC5hZGRFdmVudExpc3RlbmVyKG91dHNpZGVQcmVzc0V2ZW50LCBjYWxsYmFjayk7XG4gIH0pO1xuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghb3BlbiB8fCAhZW5hYmxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkYXRhUmVmLmN1cnJlbnQuX19lc2NhcGVLZXlCdWJibGVzID0gZXNjYXBlS2V5QnViYmxlcztcbiAgICBkYXRhUmVmLmN1cnJlbnQuX19vdXRzaWRlUHJlc3NCdWJibGVzID0gb3V0c2lkZVByZXNzQnViYmxlcztcbiAgICBsZXQgY29tcG9zaXRpb25UaW1lb3V0ID0gLTE7XG4gICAgZnVuY3Rpb24gb25TY3JvbGwoZXZlbnQpIHtcbiAgICAgIG9uT3BlbkNoYW5nZShmYWxzZSwgZXZlbnQsICdhbmNlc3Rvci1zY3JvbGwnKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaGFuZGxlQ29tcG9zaXRpb25TdGFydCgpIHtcbiAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQoY29tcG9zaXRpb25UaW1lb3V0KTtcbiAgICAgIGlzQ29tcG9zaW5nUmVmLmN1cnJlbnQgPSB0cnVlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBoYW5kbGVDb21wb3NpdGlvbkVuZCgpIHtcbiAgICAgIC8vIFNhZmFyaSBmaXJlcyBgY29tcG9zaXRpb25lbmRgIGJlZm9yZSBga2V5ZG93bmAsIHNvIHdlIG5lZWQgdG8gd2FpdFxuICAgICAgLy8gdW50aWwgdGhlIG5leHQgdGljayB0byBzZXQgYGlzQ29tcG9zaW5nYCB0byBgZmFsc2VgLlxuICAgICAgLy8gaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTE2NTAwNFxuICAgICAgY29tcG9zaXRpb25UaW1lb3V0ID0gd2luZG93LnNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBpc0NvbXBvc2luZ1JlZi5jdXJyZW50ID0gZmFsc2U7XG4gICAgICB9LFxuICAgICAgLy8gMG1zIG9yIDFtcyBkb24ndCB3b3JrIGluIFNhZmFyaS4gNW1zIGFwcGVhcnMgdG8gY29uc2lzdGVudGx5IHdvcmsuXG4gICAgICAvLyBPbmx5IGFwcGx5IHRvIFdlYktpdCBmb3IgdGhlIHRlc3QgdG8gcmVtYWluIDBtcy5cbiAgICAgIGlzV2ViS2l0KCkgPyA1IDogMCk7XG4gICAgfVxuICAgIGNvbnN0IGRvYyA9IGdldERvY3VtZW50KGVsZW1lbnRzLmZsb2F0aW5nKTtcbiAgICBpZiAoZXNjYXBlS2V5KSB7XG4gICAgICBkb2MuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIGVzY2FwZUtleUNhcHR1cmUgPyBjbG9zZU9uRXNjYXBlS2V5RG93bkNhcHR1cmUgOiBjbG9zZU9uRXNjYXBlS2V5RG93biwgZXNjYXBlS2V5Q2FwdHVyZSk7XG4gICAgICBkb2MuYWRkRXZlbnRMaXN0ZW5lcignY29tcG9zaXRpb25zdGFydCcsIGhhbmRsZUNvbXBvc2l0aW9uU3RhcnQpO1xuICAgICAgZG9jLmFkZEV2ZW50TGlzdGVuZXIoJ2NvbXBvc2l0aW9uZW5kJywgaGFuZGxlQ29tcG9zaXRpb25FbmQpO1xuICAgIH1cbiAgICBvdXRzaWRlUHJlc3MgJiYgZG9jLmFkZEV2ZW50TGlzdGVuZXIob3V0c2lkZVByZXNzRXZlbnQsIG91dHNpZGVQcmVzc0NhcHR1cmUgPyBjbG9zZU9uUHJlc3NPdXRzaWRlQ2FwdHVyZSA6IGNsb3NlT25QcmVzc091dHNpZGUsIG91dHNpZGVQcmVzc0NhcHR1cmUpO1xuICAgIGxldCBhbmNlc3RvcnMgPSBbXTtcbiAgICBpZiAoYW5jZXN0b3JTY3JvbGwpIHtcbiAgICAgIGlmIChpc0VsZW1lbnQoZWxlbWVudHMuZG9tUmVmZXJlbmNlKSkge1xuICAgICAgICBhbmNlc3RvcnMgPSBnZXRPdmVyZmxvd0FuY2VzdG9ycyhlbGVtZW50cy5kb21SZWZlcmVuY2UpO1xuICAgICAgfVxuICAgICAgaWYgKGlzRWxlbWVudChlbGVtZW50cy5mbG9hdGluZykpIHtcbiAgICAgICAgYW5jZXN0b3JzID0gYW5jZXN0b3JzLmNvbmNhdChnZXRPdmVyZmxvd0FuY2VzdG9ycyhlbGVtZW50cy5mbG9hdGluZykpO1xuICAgICAgfVxuICAgICAgaWYgKCFpc0VsZW1lbnQoZWxlbWVudHMucmVmZXJlbmNlKSAmJiBlbGVtZW50cy5yZWZlcmVuY2UgJiYgZWxlbWVudHMucmVmZXJlbmNlLmNvbnRleHRFbGVtZW50KSB7XG4gICAgICAgIGFuY2VzdG9ycyA9IGFuY2VzdG9ycy5jb25jYXQoZ2V0T3ZlcmZsb3dBbmNlc3RvcnMoZWxlbWVudHMucmVmZXJlbmNlLmNvbnRleHRFbGVtZW50KSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gSWdub3JlIHRoZSB2aXN1YWwgdmlld3BvcnQgZm9yIHNjcm9sbGluZyBkaXNtaXNzYWwgKGFsbG93IHBpbmNoLXpvb20pXG4gICAgYW5jZXN0b3JzID0gYW5jZXN0b3JzLmZpbHRlcihhbmNlc3RvciA9PiB7XG4gICAgICB2YXIgX2RvYyRkZWZhdWx0VmlldztcbiAgICAgIHJldHVybiBhbmNlc3RvciAhPT0gKChfZG9jJGRlZmF1bHRWaWV3ID0gZG9jLmRlZmF1bHRWaWV3KSA9PSBudWxsID8gdm9pZCAwIDogX2RvYyRkZWZhdWx0Vmlldy52aXN1YWxWaWV3cG9ydCk7XG4gICAgfSk7XG4gICAgYW5jZXN0b3JzLmZvckVhY2goYW5jZXN0b3IgPT4ge1xuICAgICAgYW5jZXN0b3IuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgb25TY3JvbGwsIHtcbiAgICAgICAgcGFzc2l2ZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGlmIChlc2NhcGVLZXkpIHtcbiAgICAgICAgZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBlc2NhcGVLZXlDYXB0dXJlID8gY2xvc2VPbkVzY2FwZUtleURvd25DYXB0dXJlIDogY2xvc2VPbkVzY2FwZUtleURvd24sIGVzY2FwZUtleUNhcHR1cmUpO1xuICAgICAgICBkb2MucmVtb3ZlRXZlbnRMaXN0ZW5lcignY29tcG9zaXRpb25zdGFydCcsIGhhbmRsZUNvbXBvc2l0aW9uU3RhcnQpO1xuICAgICAgICBkb2MucmVtb3ZlRXZlbnRMaXN0ZW5lcignY29tcG9zaXRpb25lbmQnLCBoYW5kbGVDb21wb3NpdGlvbkVuZCk7XG4gICAgICB9XG4gICAgICBvdXRzaWRlUHJlc3MgJiYgZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIob3V0c2lkZVByZXNzRXZlbnQsIG91dHNpZGVQcmVzc0NhcHR1cmUgPyBjbG9zZU9uUHJlc3NPdXRzaWRlQ2FwdHVyZSA6IGNsb3NlT25QcmVzc091dHNpZGUsIG91dHNpZGVQcmVzc0NhcHR1cmUpO1xuICAgICAgYW5jZXN0b3JzLmZvckVhY2goYW5jZXN0b3IgPT4ge1xuICAgICAgICBhbmNlc3Rvci5yZW1vdmVFdmVudExpc3RlbmVyKCdzY3JvbGwnLCBvblNjcm9sbCk7XG4gICAgICB9KTtcbiAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQoY29tcG9zaXRpb25UaW1lb3V0KTtcbiAgICB9O1xuICB9LCBbZGF0YVJlZiwgZWxlbWVudHMsIGVzY2FwZUtleSwgb3V0c2lkZVByZXNzLCBvdXRzaWRlUHJlc3NFdmVudCwgb3Blbiwgb25PcGVuQ2hhbmdlLCBhbmNlc3RvclNjcm9sbCwgZW5hYmxlZCwgZXNjYXBlS2V5QnViYmxlcywgb3V0c2lkZVByZXNzQnViYmxlcywgY2xvc2VPbkVzY2FwZUtleURvd24sIGVzY2FwZUtleUNhcHR1cmUsIGNsb3NlT25Fc2NhcGVLZXlEb3duQ2FwdHVyZSwgY2xvc2VPblByZXNzT3V0c2lkZSwgb3V0c2lkZVByZXNzQ2FwdHVyZSwgY2xvc2VPblByZXNzT3V0c2lkZUNhcHR1cmVdKTtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBpbnNpZGVSZWFjdFRyZWVSZWYuY3VycmVudCA9IGZhbHNlO1xuICB9LCBbb3V0c2lkZVByZXNzLCBvdXRzaWRlUHJlc3NFdmVudF0pO1xuICBjb25zdCByZWZlcmVuY2UgPSBSZWFjdC51c2VNZW1vKCgpID0+ICh7XG4gICAgb25LZXlEb3duOiBjbG9zZU9uRXNjYXBlS2V5RG93bixcbiAgICBbYnViYmxlSGFuZGxlcktleXNbcmVmZXJlbmNlUHJlc3NFdmVudF1dOiBldmVudCA9PiB7XG4gICAgICBpZiAocmVmZXJlbmNlUHJlc3MpIHtcbiAgICAgICAgb25PcGVuQ2hhbmdlKGZhbHNlLCBldmVudC5uYXRpdmVFdmVudCwgJ3JlZmVyZW5jZS1wcmVzcycpO1xuICAgICAgfVxuICAgIH1cbiAgfSksIFtjbG9zZU9uRXNjYXBlS2V5RG93biwgb25PcGVuQ2hhbmdlLCByZWZlcmVuY2VQcmVzcywgcmVmZXJlbmNlUHJlc3NFdmVudF0pO1xuICBjb25zdCBmbG9hdGluZyA9IFJlYWN0LnVzZU1lbW8oKCkgPT4gKHtcbiAgICBvbktleURvd246IGNsb3NlT25Fc2NhcGVLZXlEb3duLFxuICAgIG9uTW91c2VEb3duKCkge1xuICAgICAgZW5kZWRPclN0YXJ0ZWRJbnNpZGVSZWYuY3VycmVudCA9IHRydWU7XG4gICAgfSxcbiAgICBvbk1vdXNlVXAoKSB7XG4gICAgICBlbmRlZE9yU3RhcnRlZEluc2lkZVJlZi5jdXJyZW50ID0gdHJ1ZTtcbiAgICB9LFxuICAgIFtjYXB0dXJlSGFuZGxlcktleXNbb3V0c2lkZVByZXNzRXZlbnRdXTogKCkgPT4ge1xuICAgICAgaW5zaWRlUmVhY3RUcmVlUmVmLmN1cnJlbnQgPSB0cnVlO1xuICAgIH1cbiAgfSksIFtjbG9zZU9uRXNjYXBlS2V5RG93biwgb3V0c2lkZVByZXNzRXZlbnRdKTtcbiAgcmV0dXJuIFJlYWN0LnVzZU1lbW8oKCkgPT4gZW5hYmxlZCA/IHtcbiAgICByZWZlcmVuY2UsXG4gICAgZmxvYXRpbmdcbiAgfSA6IHt9LCBbZW5hYmxlZCwgcmVmZXJlbmNlLCBmbG9hdGluZ10pO1xufVxuXG5mdW5jdGlvbiB1c2VGbG9hdGluZ1Jvb3RDb250ZXh0KG9wdGlvbnMpIHtcbiAgY29uc3Qge1xuICAgIG9wZW4gPSBmYWxzZSxcbiAgICBvbk9wZW5DaGFuZ2U6IG9uT3BlbkNoYW5nZVByb3AsXG4gICAgZWxlbWVudHM6IGVsZW1lbnRzUHJvcFxuICB9ID0gb3B0aW9ucztcbiAgY29uc3QgZmxvYXRpbmdJZCA9IHVzZUlkKCk7XG4gIGNvbnN0IGRhdGFSZWYgPSBSZWFjdC51c2VSZWYoe30pO1xuICBjb25zdCBbZXZlbnRzXSA9IFJlYWN0LnVzZVN0YXRlKCgpID0+IGNyZWF0ZVB1YlN1YigpKTtcbiAgY29uc3QgbmVzdGVkID0gdXNlRmxvYXRpbmdQYXJlbnROb2RlSWQoKSAhPSBudWxsO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgY29uc3Qgb3B0aW9uRG9tUmVmZXJlbmNlID0gZWxlbWVudHNQcm9wLnJlZmVyZW5jZTtcbiAgICBpZiAob3B0aW9uRG9tUmVmZXJlbmNlICYmICFpc0VsZW1lbnQob3B0aW9uRG9tUmVmZXJlbmNlKSkge1xuICAgICAgZXJyb3IoJ0Nhbm5vdCBwYXNzIGEgdmlydHVhbCBlbGVtZW50IHRvIHRoZSBgZWxlbWVudHMucmVmZXJlbmNlYCBvcHRpb24sJywgJ2FzIGl0IG11c3QgYmUgYSByZWFsIERPTSBlbGVtZW50LiBVc2UgYHJlZnMuc2V0UG9zaXRpb25SZWZlcmVuY2UoKWAnLCAnaW5zdGVhZC4nKTtcbiAgICB9XG4gIH1cbiAgY29uc3QgW3Bvc2l0aW9uUmVmZXJlbmNlLCBzZXRQb3NpdGlvblJlZmVyZW5jZV0gPSBSZWFjdC51c2VTdGF0ZShlbGVtZW50c1Byb3AucmVmZXJlbmNlKTtcbiAgY29uc3Qgb25PcGVuQ2hhbmdlID0gdXNlRWZmZWN0RXZlbnQoKG9wZW4sIGV2ZW50LCByZWFzb24pID0+IHtcbiAgICBkYXRhUmVmLmN1cnJlbnQub3BlbkV2ZW50ID0gb3BlbiA/IGV2ZW50IDogdW5kZWZpbmVkO1xuICAgIGV2ZW50cy5lbWl0KCdvcGVuY2hhbmdlJywge1xuICAgICAgb3BlbixcbiAgICAgIGV2ZW50LFxuICAgICAgcmVhc29uLFxuICAgICAgbmVzdGVkXG4gICAgfSk7XG4gICAgb25PcGVuQ2hhbmdlUHJvcCA9PSBudWxsIHx8IG9uT3BlbkNoYW5nZVByb3Aob3BlbiwgZXZlbnQsIHJlYXNvbik7XG4gIH0pO1xuICBjb25zdCByZWZzID0gUmVhY3QudXNlTWVtbygoKSA9PiAoe1xuICAgIHNldFBvc2l0aW9uUmVmZXJlbmNlXG4gIH0pLCBbXSk7XG4gIGNvbnN0IGVsZW1lbnRzID0gUmVhY3QudXNlTWVtbygoKSA9PiAoe1xuICAgIHJlZmVyZW5jZTogcG9zaXRpb25SZWZlcmVuY2UgfHwgZWxlbWVudHNQcm9wLnJlZmVyZW5jZSB8fCBudWxsLFxuICAgIGZsb2F0aW5nOiBlbGVtZW50c1Byb3AuZmxvYXRpbmcgfHwgbnVsbCxcbiAgICBkb21SZWZlcmVuY2U6IGVsZW1lbnRzUHJvcC5yZWZlcmVuY2VcbiAgfSksIFtwb3NpdGlvblJlZmVyZW5jZSwgZWxlbWVudHNQcm9wLnJlZmVyZW5jZSwgZWxlbWVudHNQcm9wLmZsb2F0aW5nXSk7XG4gIHJldHVybiBSZWFjdC51c2VNZW1vKCgpID0+ICh7XG4gICAgZGF0YVJlZixcbiAgICBvcGVuLFxuICAgIG9uT3BlbkNoYW5nZSxcbiAgICBlbGVtZW50cyxcbiAgICBldmVudHMsXG4gICAgZmxvYXRpbmdJZCxcbiAgICByZWZzXG4gIH0pLCBbb3Blbiwgb25PcGVuQ2hhbmdlLCBlbGVtZW50cywgZXZlbnRzLCBmbG9hdGluZ0lkLCByZWZzXSk7XG59XG5cbi8qKlxuICogUHJvdmlkZXMgZGF0YSB0byBwb3NpdGlvbiBhIGZsb2F0aW5nIGVsZW1lbnQgYW5kIGNvbnRleHQgdG8gYWRkIGludGVyYWN0aW9ucy5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy91c2VGbG9hdGluZ1xuICovXG5mdW5jdGlvbiB1c2VGbG9hdGluZyhvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cbiAgY29uc3Qge1xuICAgIG5vZGVJZFxuICB9ID0gb3B0aW9ucztcbiAgY29uc3QgaW50ZXJuYWxSb290Q29udGV4dCA9IHVzZUZsb2F0aW5nUm9vdENvbnRleHQoe1xuICAgIC4uLm9wdGlvbnMsXG4gICAgZWxlbWVudHM6IHtcbiAgICAgIHJlZmVyZW5jZTogbnVsbCxcbiAgICAgIGZsb2F0aW5nOiBudWxsLFxuICAgICAgLi4ub3B0aW9ucy5lbGVtZW50c1xuICAgIH1cbiAgfSk7XG4gIGNvbnN0IHJvb3RDb250ZXh0ID0gb3B0aW9ucy5yb290Q29udGV4dCB8fCBpbnRlcm5hbFJvb3RDb250ZXh0O1xuICBjb25zdCBjb21wdXRlZEVsZW1lbnRzID0gcm9vdENvbnRleHQuZWxlbWVudHM7XG4gIGNvbnN0IFtfZG9tUmVmZXJlbmNlLCBzZXREb21SZWZlcmVuY2VdID0gUmVhY3QudXNlU3RhdGUobnVsbCk7XG4gIGNvbnN0IFtwb3NpdGlvblJlZmVyZW5jZSwgX3NldFBvc2l0aW9uUmVmZXJlbmNlXSA9IFJlYWN0LnVzZVN0YXRlKG51bGwpO1xuICBjb25zdCBvcHRpb25Eb21SZWZlcmVuY2UgPSBjb21wdXRlZEVsZW1lbnRzID09IG51bGwgPyB2b2lkIDAgOiBjb21wdXRlZEVsZW1lbnRzLmRvbVJlZmVyZW5jZTtcbiAgY29uc3QgZG9tUmVmZXJlbmNlID0gb3B0aW9uRG9tUmVmZXJlbmNlIHx8IF9kb21SZWZlcmVuY2U7XG4gIGNvbnN0IGRvbVJlZmVyZW5jZVJlZiA9IFJlYWN0LnVzZVJlZihudWxsKTtcbiAgY29uc3QgdHJlZSA9IHVzZUZsb2F0aW5nVHJlZSgpO1xuICBpbmRleCgoKSA9PiB7XG4gICAgaWYgKGRvbVJlZmVyZW5jZSkge1xuICAgICAgZG9tUmVmZXJlbmNlUmVmLmN1cnJlbnQgPSBkb21SZWZlcmVuY2U7XG4gICAgfVxuICB9LCBbZG9tUmVmZXJlbmNlXSk7XG4gIGNvbnN0IHBvc2l0aW9uID0gdXNlRmxvYXRpbmckMSh7XG4gICAgLi4ub3B0aW9ucyxcbiAgICBlbGVtZW50czoge1xuICAgICAgLi4uY29tcHV0ZWRFbGVtZW50cyxcbiAgICAgIC4uLihwb3NpdGlvblJlZmVyZW5jZSAmJiB7XG4gICAgICAgIHJlZmVyZW5jZTogcG9zaXRpb25SZWZlcmVuY2VcbiAgICAgIH0pXG4gICAgfVxuICB9KTtcbiAgY29uc3Qgc2V0UG9zaXRpb25SZWZlcmVuY2UgPSBSZWFjdC51c2VDYWxsYmFjayhub2RlID0+IHtcbiAgICBjb25zdCBjb21wdXRlZFBvc2l0aW9uUmVmZXJlbmNlID0gaXNFbGVtZW50KG5vZGUpID8ge1xuICAgICAgZ2V0Qm91bmRpbmdDbGllbnRSZWN0OiAoKSA9PiBub2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLFxuICAgICAgY29udGV4dEVsZW1lbnQ6IG5vZGVcbiAgICB9IDogbm9kZTtcbiAgICAvLyBTdG9yZSB0aGUgcG9zaXRpb25SZWZlcmVuY2UgaW4gc3RhdGUgaWYgdGhlIERPTSByZWZlcmVuY2UgaXMgc3BlY2lmaWVkIGV4dGVybmFsbHkgdmlhIHRoZVxuICAgIC8vIGBlbGVtZW50cy5yZWZlcmVuY2VgIG9wdGlvbi4gVGhpcyBlbnN1cmVzIHRoYXQgaXQgd29uJ3QgYmUgb3ZlcnJpZGRlbiBvbiBmdXR1cmUgcmVuZGVycy5cbiAgICBfc2V0UG9zaXRpb25SZWZlcmVuY2UoY29tcHV0ZWRQb3NpdGlvblJlZmVyZW5jZSk7XG4gICAgcG9zaXRpb24ucmVmcy5zZXRSZWZlcmVuY2UoY29tcHV0ZWRQb3NpdGlvblJlZmVyZW5jZSk7XG4gIH0sIFtwb3NpdGlvbi5yZWZzXSk7XG4gIGNvbnN0IHNldFJlZmVyZW5jZSA9IFJlYWN0LnVzZUNhbGxiYWNrKG5vZGUgPT4ge1xuICAgIGlmIChpc0VsZW1lbnQobm9kZSkgfHwgbm9kZSA9PT0gbnVsbCkge1xuICAgICAgZG9tUmVmZXJlbmNlUmVmLmN1cnJlbnQgPSBub2RlO1xuICAgICAgc2V0RG9tUmVmZXJlbmNlKG5vZGUpO1xuICAgIH1cblxuICAgIC8vIEJhY2t3YXJkcy1jb21wYXRpYmlsaXR5IGZvciBwYXNzaW5nIGEgdmlydHVhbCBlbGVtZW50IHRvIGByZWZlcmVuY2VgXG4gICAgLy8gYWZ0ZXIgaXQgaGFzIHNldCB0aGUgRE9NIHJlZmVyZW5jZS5cbiAgICBpZiAoaXNFbGVtZW50KHBvc2l0aW9uLnJlZnMucmVmZXJlbmNlLmN1cnJlbnQpIHx8IHBvc2l0aW9uLnJlZnMucmVmZXJlbmNlLmN1cnJlbnQgPT09IG51bGwgfHxcbiAgICAvLyBEb24ndCBhbGxvdyBzZXR0aW5nIHZpcnR1YWwgZWxlbWVudHMgdXNpbmcgdGhlIG9sZCB0ZWNobmlxdWUgYmFjayB0b1xuICAgIC8vIGBudWxsYCB0byBzdXBwb3J0IGBwb3NpdGlvblJlZmVyZW5jZWAgKyBhbiB1bnN0YWJsZSBgcmVmZXJlbmNlYFxuICAgIC8vIGNhbGxiYWNrIHJlZi5cbiAgICBub2RlICE9PSBudWxsICYmICFpc0VsZW1lbnQobm9kZSkpIHtcbiAgICAgIHBvc2l0aW9uLnJlZnMuc2V0UmVmZXJlbmNlKG5vZGUpO1xuICAgIH1cbiAgfSwgW3Bvc2l0aW9uLnJlZnNdKTtcbiAgY29uc3QgcmVmcyA9IFJlYWN0LnVzZU1lbW8oKCkgPT4gKHtcbiAgICAuLi5wb3NpdGlvbi5yZWZzLFxuICAgIHNldFJlZmVyZW5jZSxcbiAgICBzZXRQb3NpdGlvblJlZmVyZW5jZSxcbiAgICBkb21SZWZlcmVuY2U6IGRvbVJlZmVyZW5jZVJlZlxuICB9KSwgW3Bvc2l0aW9uLnJlZnMsIHNldFJlZmVyZW5jZSwgc2V0UG9zaXRpb25SZWZlcmVuY2VdKTtcbiAgY29uc3QgZWxlbWVudHMgPSBSZWFjdC51c2VNZW1vKCgpID0+ICh7XG4gICAgLi4ucG9zaXRpb24uZWxlbWVudHMsXG4gICAgZG9tUmVmZXJlbmNlOiBkb21SZWZlcmVuY2VcbiAgfSksIFtwb3NpdGlvbi5lbGVtZW50cywgZG9tUmVmZXJlbmNlXSk7XG4gIGNvbnN0IGNvbnRleHQgPSBSZWFjdC51c2VNZW1vKCgpID0+ICh7XG4gICAgLi4ucG9zaXRpb24sXG4gICAgLi4ucm9vdENvbnRleHQsXG4gICAgcmVmcyxcbiAgICBlbGVtZW50cyxcbiAgICBub2RlSWRcbiAgfSksIFtwb3NpdGlvbiwgcmVmcywgZWxlbWVudHMsIG5vZGVJZCwgcm9vdENvbnRleHRdKTtcbiAgaW5kZXgoKCkgPT4ge1xuICAgIHJvb3RDb250ZXh0LmRhdGFSZWYuY3VycmVudC5mbG9hdGluZ0NvbnRleHQgPSBjb250ZXh0O1xuICAgIGNvbnN0IG5vZGUgPSB0cmVlID09IG51bGwgPyB2b2lkIDAgOiB0cmVlLm5vZGVzUmVmLmN1cnJlbnQuZmluZChub2RlID0+IG5vZGUuaWQgPT09IG5vZGVJZCk7XG4gICAgaWYgKG5vZGUpIHtcbiAgICAgIG5vZGUuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIFJlYWN0LnVzZU1lbW8oKCkgPT4gKHtcbiAgICAuLi5wb3NpdGlvbixcbiAgICBjb250ZXh0LFxuICAgIHJlZnMsXG4gICAgZWxlbWVudHNcbiAgfSksIFtwb3NpdGlvbiwgcmVmcywgZWxlbWVudHMsIGNvbnRleHRdKTtcbn1cblxuLyoqXG4gKiBPcGVucyB0aGUgZmxvYXRpbmcgZWxlbWVudCB3aGlsZSB0aGUgcmVmZXJlbmNlIGVsZW1lbnQgaGFzIGZvY3VzLCBsaWtlIENTU1xuICogYDpmb2N1c2AuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvdXNlRm9jdXNcbiAqL1xuZnVuY3Rpb24gdXNlRm9jdXMoY29udGV4dCwgcHJvcHMpIHtcbiAgaWYgKHByb3BzID09PSB2b2lkIDApIHtcbiAgICBwcm9wcyA9IHt9O1xuICB9XG4gIGNvbnN0IHtcbiAgICBvcGVuLFxuICAgIG9uT3BlbkNoYW5nZSxcbiAgICBldmVudHMsXG4gICAgZGF0YVJlZixcbiAgICBlbGVtZW50c1xuICB9ID0gY29udGV4dDtcbiAgY29uc3Qge1xuICAgIGVuYWJsZWQgPSB0cnVlLFxuICAgIHZpc2libGVPbmx5ID0gdHJ1ZVxuICB9ID0gcHJvcHM7XG4gIGNvbnN0IGJsb2NrRm9jdXNSZWYgPSBSZWFjdC51c2VSZWYoZmFsc2UpO1xuICBjb25zdCB0aW1lb3V0UmVmID0gUmVhY3QudXNlUmVmKCk7XG4gIGNvbnN0IGtleWJvYXJkTW9kYWxpdHlSZWYgPSBSZWFjdC51c2VSZWYodHJ1ZSk7XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFlbmFibGVkKSByZXR1cm47XG4gICAgY29uc3Qgd2luID0gZ2V0V2luZG93KGVsZW1lbnRzLmRvbVJlZmVyZW5jZSk7XG5cbiAgICAvLyBJZiB0aGUgcmVmZXJlbmNlIHdhcyBmb2N1c2VkIGFuZCB0aGUgdXNlciBsZWZ0IHRoZSB0YWIvd2luZG93LCBhbmQgdGhlXG4gICAgLy8gZmxvYXRpbmcgZWxlbWVudCB3YXMgbm90IG9wZW4sIHRoZSBmb2N1cyBzaG91bGQgYmUgYmxvY2tlZCB3aGVuIHRoZXlcbiAgICAvLyByZXR1cm4gdG8gdGhlIHRhYi93aW5kb3cuXG4gICAgZnVuY3Rpb24gb25CbHVyKCkge1xuICAgICAgaWYgKCFvcGVuICYmIGlzSFRNTEVsZW1lbnQoZWxlbWVudHMuZG9tUmVmZXJlbmNlKSAmJiBlbGVtZW50cy5kb21SZWZlcmVuY2UgPT09IGFjdGl2ZUVsZW1lbnQoZ2V0RG9jdW1lbnQoZWxlbWVudHMuZG9tUmVmZXJlbmNlKSkpIHtcbiAgICAgICAgYmxvY2tGb2N1c1JlZi5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gb25LZXlEb3duKCkge1xuICAgICAga2V5Ym9hcmRNb2RhbGl0eVJlZi5jdXJyZW50ID0gdHJ1ZTtcbiAgICB9XG4gICAgd2luLmFkZEV2ZW50TGlzdGVuZXIoJ2JsdXInLCBvbkJsdXIpO1xuICAgIHdpbi5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgb25LZXlEb3duLCB0cnVlKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgd2luLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2JsdXInLCBvbkJsdXIpO1xuICAgICAgd2luLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBvbktleURvd24sIHRydWUpO1xuICAgIH07XG4gIH0sIFtlbGVtZW50cy5kb21SZWZlcmVuY2UsIG9wZW4sIGVuYWJsZWRdKTtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIWVuYWJsZWQpIHJldHVybjtcbiAgICBmdW5jdGlvbiBvbk9wZW5DaGFuZ2UoX3JlZikge1xuICAgICAgbGV0IHtcbiAgICAgICAgcmVhc29uXG4gICAgICB9ID0gX3JlZjtcbiAgICAgIGlmIChyZWFzb24gPT09ICdyZWZlcmVuY2UtcHJlc3MnIHx8IHJlYXNvbiA9PT0gJ2VzY2FwZS1rZXknKSB7XG4gICAgICAgIGJsb2NrRm9jdXNSZWYuY3VycmVudCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIGV2ZW50cy5vbignb3BlbmNoYW5nZScsIG9uT3BlbkNoYW5nZSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGV2ZW50cy5vZmYoJ29wZW5jaGFuZ2UnLCBvbk9wZW5DaGFuZ2UpO1xuICAgIH07XG4gIH0sIFtldmVudHMsIGVuYWJsZWRdKTtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRSZWYuY3VycmVudCk7XG4gICAgfTtcbiAgfSwgW10pO1xuICBjb25zdCByZWZlcmVuY2UgPSBSZWFjdC51c2VNZW1vKCgpID0+ICh7XG4gICAgb25Qb2ludGVyRG93bihldmVudCkge1xuICAgICAgaWYgKGlzVmlydHVhbFBvaW50ZXJFdmVudChldmVudC5uYXRpdmVFdmVudCkpIHJldHVybjtcbiAgICAgIGtleWJvYXJkTW9kYWxpdHlSZWYuY3VycmVudCA9IGZhbHNlO1xuICAgIH0sXG4gICAgb25Nb3VzZUxlYXZlKCkge1xuICAgICAgYmxvY2tGb2N1c1JlZi5jdXJyZW50ID0gZmFsc2U7XG4gICAgfSxcbiAgICBvbkZvY3VzKGV2ZW50KSB7XG4gICAgICBpZiAoYmxvY2tGb2N1c1JlZi5jdXJyZW50KSByZXR1cm47XG4gICAgICBjb25zdCB0YXJnZXQgPSBnZXRUYXJnZXQoZXZlbnQubmF0aXZlRXZlbnQpO1xuICAgICAgaWYgKHZpc2libGVPbmx5ICYmIGlzRWxlbWVudCh0YXJnZXQpKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gTWFjIFNhZmFyaSB1bnJlbGlhYmx5IG1hdGNoZXMgYDpmb2N1cy12aXNpYmxlYCBvbiB0aGUgcmVmZXJlbmNlXG4gICAgICAgICAgLy8gaWYgZm9jdXMgd2FzIG91dHNpZGUgdGhlIHBhZ2UgaW5pdGlhbGx5IC0gdXNlIHRoZSBmYWxsYmFja1xuICAgICAgICAgIC8vIGluc3RlYWQuXG4gICAgICAgICAgaWYgKGlzU2FmYXJpKCkgJiYgaXNNYWMoKSkgdGhyb3cgRXJyb3IoKTtcbiAgICAgICAgICBpZiAoIXRhcmdldC5tYXRjaGVzKCc6Zm9jdXMtdmlzaWJsZScpKSByZXR1cm47XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAvLyBPbGQgYnJvd3NlcnMgd2lsbCB0aHJvdyBhbiBlcnJvciB3aGVuIHVzaW5nIGA6Zm9jdXMtdmlzaWJsZWAuXG4gICAgICAgICAgaWYgKCFrZXlib2FyZE1vZGFsaXR5UmVmLmN1cnJlbnQgJiYgIWlzVHlwZWFibGVFbGVtZW50KHRhcmdldCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG9uT3BlbkNoYW5nZSh0cnVlLCBldmVudC5uYXRpdmVFdmVudCwgJ2ZvY3VzJyk7XG4gICAgfSxcbiAgICBvbkJsdXIoZXZlbnQpIHtcbiAgICAgIGJsb2NrRm9jdXNSZWYuY3VycmVudCA9IGZhbHNlO1xuICAgICAgY29uc3QgcmVsYXRlZFRhcmdldCA9IGV2ZW50LnJlbGF0ZWRUYXJnZXQ7XG4gICAgICBjb25zdCBuYXRpdmVFdmVudCA9IGV2ZW50Lm5hdGl2ZUV2ZW50O1xuXG4gICAgICAvLyBIaXQgdGhlIG5vbi1tb2RhbCBmb2N1cyBtYW5hZ2VtZW50IHBvcnRhbCBndWFyZC4gRm9jdXMgd2lsbCBiZVxuICAgICAgLy8gbW92ZWQgaW50byB0aGUgZmxvYXRpbmcgZWxlbWVudCBpbW1lZGlhdGVseSBhZnRlci5cbiAgICAgIGNvbnN0IG1vdmVkVG9Gb2N1c0d1YXJkID0gaXNFbGVtZW50KHJlbGF0ZWRUYXJnZXQpICYmIHJlbGF0ZWRUYXJnZXQuaGFzQXR0cmlidXRlKGNyZWF0ZUF0dHJpYnV0ZSgnZm9jdXMtZ3VhcmQnKSkgJiYgcmVsYXRlZFRhcmdldC5nZXRBdHRyaWJ1dGUoJ2RhdGEtdHlwZScpID09PSAnb3V0c2lkZSc7XG5cbiAgICAgIC8vIFdhaXQgZm9yIHRoZSB3aW5kb3cgYmx1ciBsaXN0ZW5lciB0byBmaXJlLlxuICAgICAgdGltZW91dFJlZi5jdXJyZW50ID0gd2luZG93LnNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICB2YXIgX2RhdGFSZWYkY3VycmVudCRmbG9hO1xuICAgICAgICBjb25zdCBhY3RpdmVFbCA9IGFjdGl2ZUVsZW1lbnQoZWxlbWVudHMuZG9tUmVmZXJlbmNlID8gZWxlbWVudHMuZG9tUmVmZXJlbmNlLm93bmVyRG9jdW1lbnQgOiBkb2N1bWVudCk7XG5cbiAgICAgICAgLy8gRm9jdXMgbGVmdCB0aGUgcGFnZSwga2VlcCBpdCBvcGVuLlxuICAgICAgICBpZiAoIXJlbGF0ZWRUYXJnZXQgJiYgYWN0aXZlRWwgPT09IGVsZW1lbnRzLmRvbVJlZmVyZW5jZSkgcmV0dXJuO1xuXG4gICAgICAgIC8vIFdoZW4gZm9jdXNpbmcgdGhlIHJlZmVyZW5jZSBlbGVtZW50IChlLmcuIHJlZ3VsYXIgY2xpY2spLCB0aGVuXG4gICAgICAgIC8vIGNsaWNraW5nIGludG8gdGhlIGZsb2F0aW5nIGVsZW1lbnQsIHByZXZlbnQgaXQgZnJvbSBoaWRpbmcuXG4gICAgICAgIC8vIE5vdGU6IGl0IG11c3QgYmUgZm9jdXNhYmxlLCBlLmcuIGB0YWJpbmRleD1cIi0xXCJgLlxuICAgICAgICAvLyBXZSBjYW4gbm90IHJlbHkgb24gcmVsYXRlZFRhcmdldCB0byBwb2ludCB0byB0aGUgY29ycmVjdCBlbGVtZW50XG4gICAgICAgIC8vIGFzIGl0IHdpbGwgb25seSBwb2ludCB0byB0aGUgc2hhZG93IGhvc3Qgb2YgdGhlIG5ld2x5IGZvY3VzZWQgZWxlbWVudFxuICAgICAgICAvLyBhbmQgbm90IHRoZSBlbGVtZW50IHRoYXQgYWN0dWFsbHkgaGFzIHJlY2VpdmVkIGZvY3VzIGlmIGl0IGlzIGxvY2F0ZWRcbiAgICAgICAgLy8gaW5zaWRlIGEgc2hhZG93IHJvb3QuXG4gICAgICAgIGlmIChjb250YWlucygoX2RhdGFSZWYkY3VycmVudCRmbG9hID0gZGF0YVJlZi5jdXJyZW50LmZsb2F0aW5nQ29udGV4dCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9kYXRhUmVmJGN1cnJlbnQkZmxvYS5yZWZzLmZsb2F0aW5nLmN1cnJlbnQsIGFjdGl2ZUVsKSB8fCBjb250YWlucyhlbGVtZW50cy5kb21SZWZlcmVuY2UsIGFjdGl2ZUVsKSB8fCBtb3ZlZFRvRm9jdXNHdWFyZCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBvbk9wZW5DaGFuZ2UoZmFsc2UsIG5hdGl2ZUV2ZW50LCAnZm9jdXMnKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSksIFtkYXRhUmVmLCBlbGVtZW50cy5kb21SZWZlcmVuY2UsIG9uT3BlbkNoYW5nZSwgdmlzaWJsZU9ubHldKTtcbiAgcmV0dXJuIFJlYWN0LnVzZU1lbW8oKCkgPT4gZW5hYmxlZCA/IHtcbiAgICByZWZlcmVuY2VcbiAgfSA6IHt9LCBbZW5hYmxlZCwgcmVmZXJlbmNlXSk7XG59XG5cbmNvbnN0IEFDVElWRV9LRVkgPSAnYWN0aXZlJztcbmNvbnN0IFNFTEVDVEVEX0tFWSA9ICdzZWxlY3RlZCc7XG5mdW5jdGlvbiBtZXJnZVByb3BzKHVzZXJQcm9wcywgcHJvcHNMaXN0LCBlbGVtZW50S2V5KSB7XG4gIGNvbnN0IG1hcCA9IG5ldyBNYXAoKTtcbiAgY29uc3QgaXNJdGVtID0gZWxlbWVudEtleSA9PT0gJ2l0ZW0nO1xuICBsZXQgZG9tVXNlclByb3BzID0gdXNlclByb3BzO1xuICBpZiAoaXNJdGVtICYmIHVzZXJQcm9wcykge1xuICAgIGNvbnN0IHtcbiAgICAgIFtBQ1RJVkVfS0VZXTogXyxcbiAgICAgIFtTRUxFQ1RFRF9LRVldOiBfXyxcbiAgICAgIC4uLnZhbGlkUHJvcHNcbiAgICB9ID0gdXNlclByb3BzO1xuICAgIGRvbVVzZXJQcm9wcyA9IHZhbGlkUHJvcHM7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICAuLi4oZWxlbWVudEtleSA9PT0gJ2Zsb2F0aW5nJyAmJiB7XG4gICAgICB0YWJJbmRleDogLTEsXG4gICAgICBbRk9DVVNBQkxFX0FUVFJJQlVURV06ICcnXG4gICAgfSksXG4gICAgLi4uZG9tVXNlclByb3BzLFxuICAgIC4uLnByb3BzTGlzdC5tYXAodmFsdWUgPT4ge1xuICAgICAgY29uc3QgcHJvcHNPckdldFByb3BzID0gdmFsdWUgPyB2YWx1ZVtlbGVtZW50S2V5XSA6IG51bGw7XG4gICAgICBpZiAodHlwZW9mIHByb3BzT3JHZXRQcm9wcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gdXNlclByb3BzID8gcHJvcHNPckdldFByb3BzKHVzZXJQcm9wcykgOiBudWxsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHByb3BzT3JHZXRQcm9wcztcbiAgICB9KS5jb25jYXQodXNlclByb3BzKS5yZWR1Y2UoKGFjYywgcHJvcHMpID0+IHtcbiAgICAgIGlmICghcHJvcHMpIHtcbiAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgIH1cbiAgICAgIE9iamVjdC5lbnRyaWVzKHByb3BzKS5mb3JFYWNoKF9yZWYgPT4ge1xuICAgICAgICBsZXQgW2tleSwgdmFsdWVdID0gX3JlZjtcbiAgICAgICAgaWYgKGlzSXRlbSAmJiBbQUNUSVZFX0tFWSwgU0VMRUNURURfS0VZXS5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChrZXkuaW5kZXhPZignb24nKSA9PT0gMCkge1xuICAgICAgICAgIGlmICghbWFwLmhhcyhrZXkpKSB7XG4gICAgICAgICAgICBtYXAuc2V0KGtleSwgW10pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB2YXIgX21hcCRnZXQ7XG4gICAgICAgICAgICAoX21hcCRnZXQgPSBtYXAuZ2V0KGtleSkpID09IG51bGwgfHwgX21hcCRnZXQucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICBhY2Nba2V5XSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgdmFyIF9tYXAkZ2V0MjtcbiAgICAgICAgICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgICAgICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gKF9tYXAkZ2V0MiA9IG1hcC5nZXQoa2V5KSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9tYXAkZ2V0Mi5tYXAoZm4gPT4gZm4oLi4uYXJncykpLmZpbmQodmFsID0+IHZhbCAhPT0gdW5kZWZpbmVkKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFjY1trZXldID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGFjYztcbiAgICB9LCB7fSlcbiAgfTtcbn1cbi8qKlxuICogTWVyZ2VzIGFuIGFycmF5IG9mIGludGVyYWN0aW9uIGhvb2tzJyBwcm9wcyBpbnRvIHByb3AgZ2V0dGVycywgYWxsb3dpbmdcbiAqIGV2ZW50IGhhbmRsZXIgZnVuY3Rpb25zIHRvIGJlIGNvbXBvc2VkIHRvZ2V0aGVyIHdpdGhvdXQgb3ZlcndyaXRpbmcgb25lXG4gKiBhbm90aGVyLlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL3VzZUludGVyYWN0aW9uc1xuICovXG5mdW5jdGlvbiB1c2VJbnRlcmFjdGlvbnMocHJvcHNMaXN0KSB7XG4gIGlmIChwcm9wc0xpc3QgPT09IHZvaWQgMCkge1xuICAgIHByb3BzTGlzdCA9IFtdO1xuICB9XG4gIGNvbnN0IHJlZmVyZW5jZURlcHMgPSBwcm9wc0xpc3QubWFwKGtleSA9PiBrZXkgPT0gbnVsbCA/IHZvaWQgMCA6IGtleS5yZWZlcmVuY2UpO1xuICBjb25zdCBmbG9hdGluZ0RlcHMgPSBwcm9wc0xpc3QubWFwKGtleSA9PiBrZXkgPT0gbnVsbCA/IHZvaWQgMCA6IGtleS5mbG9hdGluZyk7XG4gIGNvbnN0IGl0ZW1EZXBzID0gcHJvcHNMaXN0Lm1hcChrZXkgPT4ga2V5ID09IG51bGwgPyB2b2lkIDAgOiBrZXkuaXRlbSk7XG4gIGNvbnN0IGdldFJlZmVyZW5jZVByb3BzID0gUmVhY3QudXNlQ2FsbGJhY2sodXNlclByb3BzID0+IG1lcmdlUHJvcHModXNlclByb3BzLCBwcm9wc0xpc3QsICdyZWZlcmVuY2UnKSxcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICByZWZlcmVuY2VEZXBzKTtcbiAgY29uc3QgZ2V0RmxvYXRpbmdQcm9wcyA9IFJlYWN0LnVzZUNhbGxiYWNrKHVzZXJQcm9wcyA9PiBtZXJnZVByb3BzKHVzZXJQcm9wcywgcHJvcHNMaXN0LCAnZmxvYXRpbmcnKSxcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICBmbG9hdGluZ0RlcHMpO1xuICBjb25zdCBnZXRJdGVtUHJvcHMgPSBSZWFjdC51c2VDYWxsYmFjayh1c2VyUHJvcHMgPT4gbWVyZ2VQcm9wcyh1c2VyUHJvcHMsIHByb3BzTGlzdCwgJ2l0ZW0nKSxcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICBpdGVtRGVwcyk7XG4gIHJldHVybiBSZWFjdC51c2VNZW1vKCgpID0+ICh7XG4gICAgZ2V0UmVmZXJlbmNlUHJvcHMsXG4gICAgZ2V0RmxvYXRpbmdQcm9wcyxcbiAgICBnZXRJdGVtUHJvcHNcbiAgfSksIFtnZXRSZWZlcmVuY2VQcm9wcywgZ2V0RmxvYXRpbmdQcm9wcywgZ2V0SXRlbVByb3BzXSk7XG59XG5cbmxldCBpc1ByZXZlbnRTY3JvbGxTdXBwb3J0ZWQgPSBmYWxzZTtcbmZ1bmN0aW9uIGRvU3dpdGNoKG9yaWVudGF0aW9uLCB2ZXJ0aWNhbCwgaG9yaXpvbnRhbCkge1xuICBzd2l0Y2ggKG9yaWVudGF0aW9uKSB7XG4gICAgY2FzZSAndmVydGljYWwnOlxuICAgICAgcmV0dXJuIHZlcnRpY2FsO1xuICAgIGNhc2UgJ2hvcml6b250YWwnOlxuICAgICAgcmV0dXJuIGhvcml6b250YWw7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiB2ZXJ0aWNhbCB8fCBob3Jpem9udGFsO1xuICB9XG59XG5mdW5jdGlvbiBpc01haW5PcmllbnRhdGlvbktleShrZXksIG9yaWVudGF0aW9uKSB7XG4gIGNvbnN0IHZlcnRpY2FsID0ga2V5ID09PSBBUlJPV19VUCB8fCBrZXkgPT09IEFSUk9XX0RPV047XG4gIGNvbnN0IGhvcml6b250YWwgPSBrZXkgPT09IEFSUk9XX0xFRlQgfHwga2V5ID09PSBBUlJPV19SSUdIVDtcbiAgcmV0dXJuIGRvU3dpdGNoKG9yaWVudGF0aW9uLCB2ZXJ0aWNhbCwgaG9yaXpvbnRhbCk7XG59XG5mdW5jdGlvbiBpc01haW5PcmllbnRhdGlvblRvRW5kS2V5KGtleSwgb3JpZW50YXRpb24sIHJ0bCkge1xuICBjb25zdCB2ZXJ0aWNhbCA9IGtleSA9PT0gQVJST1dfRE9XTjtcbiAgY29uc3QgaG9yaXpvbnRhbCA9IHJ0bCA/IGtleSA9PT0gQVJST1dfTEVGVCA6IGtleSA9PT0gQVJST1dfUklHSFQ7XG4gIHJldHVybiBkb1N3aXRjaChvcmllbnRhdGlvbiwgdmVydGljYWwsIGhvcml6b250YWwpIHx8IGtleSA9PT0gJ0VudGVyJyB8fCBrZXkgPT09ICcgJyB8fCBrZXkgPT09ICcnO1xufVxuZnVuY3Rpb24gaXNDcm9zc09yaWVudGF0aW9uT3BlbktleShrZXksIG9yaWVudGF0aW9uLCBydGwpIHtcbiAgY29uc3QgdmVydGljYWwgPSBydGwgPyBrZXkgPT09IEFSUk9XX0xFRlQgOiBrZXkgPT09IEFSUk9XX1JJR0hUO1xuICBjb25zdCBob3Jpem9udGFsID0ga2V5ID09PSBBUlJPV19ET1dOO1xuICByZXR1cm4gZG9Td2l0Y2gob3JpZW50YXRpb24sIHZlcnRpY2FsLCBob3Jpem9udGFsKTtcbn1cbmZ1bmN0aW9uIGlzQ3Jvc3NPcmllbnRhdGlvbkNsb3NlS2V5KGtleSwgb3JpZW50YXRpb24sIHJ0bCkge1xuICBjb25zdCB2ZXJ0aWNhbCA9IHJ0bCA/IGtleSA9PT0gQVJST1dfUklHSFQgOiBrZXkgPT09IEFSUk9XX0xFRlQ7XG4gIGNvbnN0IGhvcml6b250YWwgPSBrZXkgPT09IEFSUk9XX1VQO1xuICByZXR1cm4gZG9Td2l0Y2gob3JpZW50YXRpb24sIHZlcnRpY2FsLCBob3Jpem9udGFsKTtcbn1cbi8qKlxuICogQWRkcyBhcnJvdyBrZXktYmFzZWQgbmF2aWdhdGlvbiBvZiBhIGxpc3Qgb2YgaXRlbXMsIGVpdGhlciB1c2luZyByZWFsIERPTVxuICogZm9jdXMgb3IgdmlydHVhbCBmb2N1cy5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy91c2VMaXN0TmF2aWdhdGlvblxuICovXG5mdW5jdGlvbiB1c2VMaXN0TmF2aWdhdGlvbihjb250ZXh0LCBwcm9wcykge1xuICBjb25zdCB7XG4gICAgb3BlbixcbiAgICBvbk9wZW5DaGFuZ2UsXG4gICAgZWxlbWVudHNcbiAgfSA9IGNvbnRleHQ7XG4gIGNvbnN0IHtcbiAgICBsaXN0UmVmLFxuICAgIGFjdGl2ZUluZGV4LFxuICAgIG9uTmF2aWdhdGU6IHVuc3RhYmxlX29uTmF2aWdhdGUgPSAoKSA9PiB7fSxcbiAgICBlbmFibGVkID0gdHJ1ZSxcbiAgICBzZWxlY3RlZEluZGV4ID0gbnVsbCxcbiAgICBhbGxvd0VzY2FwZSA9IGZhbHNlLFxuICAgIGxvb3AgPSBmYWxzZSxcbiAgICBuZXN0ZWQgPSBmYWxzZSxcbiAgICBydGwgPSBmYWxzZSxcbiAgICB2aXJ0dWFsID0gZmFsc2UsXG4gICAgZm9jdXNJdGVtT25PcGVuID0gJ2F1dG8nLFxuICAgIGZvY3VzSXRlbU9uSG92ZXIgPSB0cnVlLFxuICAgIG9wZW5PbkFycm93S2V5RG93biA9IHRydWUsXG4gICAgZGlzYWJsZWRJbmRpY2VzID0gdW5kZWZpbmVkLFxuICAgIG9yaWVudGF0aW9uID0gJ3ZlcnRpY2FsJyxcbiAgICBjb2xzID0gMSxcbiAgICBzY3JvbGxJdGVtSW50b1ZpZXcgPSB0cnVlLFxuICAgIHZpcnR1YWxJdGVtUmVmLFxuICAgIGl0ZW1TaXplcyxcbiAgICBkZW5zZSA9IGZhbHNlXG4gIH0gPSBwcm9wcztcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIGlmIChhbGxvd0VzY2FwZSkge1xuICAgICAgaWYgKCFsb29wKSB7XG4gICAgICAgIHdhcm4oJ2B1c2VMaXN0TmF2aWdhdGlvbmAgbG9vcGluZyBtdXN0IGJlIGVuYWJsZWQgdG8gYWxsb3cgZXNjYXBpbmcuJyk7XG4gICAgICB9XG4gICAgICBpZiAoIXZpcnR1YWwpIHtcbiAgICAgICAgd2FybignYHVzZUxpc3ROYXZpZ2F0aW9uYCBtdXN0IGJlIHZpcnR1YWwgdG8gYWxsb3cgZXNjYXBpbmcuJyk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChvcmllbnRhdGlvbiA9PT0gJ3ZlcnRpY2FsJyAmJiBjb2xzID4gMSkge1xuICAgICAgd2FybignSW4gZ3JpZCBsaXN0IG5hdmlnYXRpb24gbW9kZSAoYGNvbHNgID4gMSksIHRoZSBgb3JpZW50YXRpb25gIHNob3VsZCcsICdiZSBlaXRoZXIgXCJob3Jpem9udGFsXCIgb3IgXCJib3RoXCIuJyk7XG4gICAgfVxuICB9XG4gIGNvbnN0IGZsb2F0aW5nRm9jdXNFbGVtZW50ID0gZ2V0RmxvYXRpbmdGb2N1c0VsZW1lbnQoZWxlbWVudHMuZmxvYXRpbmcpO1xuICBjb25zdCBmbG9hdGluZ0ZvY3VzRWxlbWVudFJlZiA9IHVzZUxhdGVzdFJlZihmbG9hdGluZ0ZvY3VzRWxlbWVudCk7XG4gIGNvbnN0IHBhcmVudElkID0gdXNlRmxvYXRpbmdQYXJlbnROb2RlSWQoKTtcbiAgY29uc3QgdHJlZSA9IHVzZUZsb2F0aW5nVHJlZSgpO1xuICBjb25zdCBvbk5hdmlnYXRlID0gdXNlRWZmZWN0RXZlbnQodW5zdGFibGVfb25OYXZpZ2F0ZSk7XG4gIGNvbnN0IHR5cGVhYmxlQ29tYm9ib3hSZWZlcmVuY2UgPSBpc1R5cGVhYmxlQ29tYm9ib3goZWxlbWVudHMuZG9tUmVmZXJlbmNlKTtcbiAgY29uc3QgZm9jdXNJdGVtT25PcGVuUmVmID0gUmVhY3QudXNlUmVmKGZvY3VzSXRlbU9uT3Blbik7XG4gIGNvbnN0IGluZGV4UmVmID0gUmVhY3QudXNlUmVmKHNlbGVjdGVkSW5kZXggIT0gbnVsbCA/IHNlbGVjdGVkSW5kZXggOiAtMSk7XG4gIGNvbnN0IGtleVJlZiA9IFJlYWN0LnVzZVJlZihudWxsKTtcbiAgY29uc3QgaXNQb2ludGVyTW9kYWxpdHlSZWYgPSBSZWFjdC51c2VSZWYodHJ1ZSk7XG4gIGNvbnN0IHByZXZpb3VzT25OYXZpZ2F0ZVJlZiA9IFJlYWN0LnVzZVJlZihvbk5hdmlnYXRlKTtcbiAgY29uc3QgcHJldmlvdXNNb3VudGVkUmVmID0gUmVhY3QudXNlUmVmKCEhZWxlbWVudHMuZmxvYXRpbmcpO1xuICBjb25zdCBwcmV2aW91c09wZW5SZWYgPSBSZWFjdC51c2VSZWYob3Blbik7XG4gIGNvbnN0IGZvcmNlU3luY0ZvY3VzID0gUmVhY3QudXNlUmVmKGZhbHNlKTtcbiAgY29uc3QgZm9yY2VTY3JvbGxJbnRvVmlld1JlZiA9IFJlYWN0LnVzZVJlZihmYWxzZSk7XG4gIGNvbnN0IGRpc2FibGVkSW5kaWNlc1JlZiA9IHVzZUxhdGVzdFJlZihkaXNhYmxlZEluZGljZXMpO1xuICBjb25zdCBsYXRlc3RPcGVuUmVmID0gdXNlTGF0ZXN0UmVmKG9wZW4pO1xuICBjb25zdCBzY3JvbGxJdGVtSW50b1ZpZXdSZWYgPSB1c2VMYXRlc3RSZWYoc2Nyb2xsSXRlbUludG9WaWV3KTtcbiAgY29uc3Qgc2VsZWN0ZWRJbmRleFJlZiA9IHVzZUxhdGVzdFJlZihzZWxlY3RlZEluZGV4KTtcbiAgY29uc3QgW2FjdGl2ZUlkLCBzZXRBY3RpdmVJZF0gPSBSZWFjdC51c2VTdGF0ZSgpO1xuICBjb25zdCBbdmlydHVhbElkLCBzZXRWaXJ0dWFsSWRdID0gUmVhY3QudXNlU3RhdGUoKTtcbiAgY29uc3QgZm9jdXNJdGVtID0gdXNlRWZmZWN0RXZlbnQoZnVuY3Rpb24gKGxpc3RSZWYsIGluZGV4UmVmLCBmb3JjZVNjcm9sbEludG9WaWV3KSB7XG4gICAgaWYgKGZvcmNlU2Nyb2xsSW50b1ZpZXcgPT09IHZvaWQgMCkge1xuICAgICAgZm9yY2VTY3JvbGxJbnRvVmlldyA9IGZhbHNlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBydW5Gb2N1cyhpdGVtKSB7XG4gICAgICBpZiAodmlydHVhbCkge1xuICAgICAgICBzZXRBY3RpdmVJZChpdGVtLmlkKTtcbiAgICAgICAgdHJlZSA9PSBudWxsIHx8IHRyZWUuZXZlbnRzLmVtaXQoJ3ZpcnR1YWxmb2N1cycsIGl0ZW0pO1xuICAgICAgICBpZiAodmlydHVhbEl0ZW1SZWYpIHtcbiAgICAgICAgICB2aXJ0dWFsSXRlbVJlZi5jdXJyZW50ID0gaXRlbTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZW5xdWV1ZUZvY3VzKGl0ZW0sIHtcbiAgICAgICAgICBwcmV2ZW50U2Nyb2xsOiB0cnVlLFxuICAgICAgICAgIC8vIE1hYyBTYWZhcmkgZG9lcyBub3QgbW92ZSB0aGUgdmlydHVhbCBjdXJzb3IgdW5sZXNzIHRoZSBmb2N1cyBjYWxsXG4gICAgICAgICAgLy8gaXMgc3luYy4gSG93ZXZlciwgZm9yIHRoZSB2ZXJ5IGZpcnN0IGZvY3VzIGNhbGwsIHdlIG5lZWQgdG8gd2FpdFxuICAgICAgICAgIC8vIGZvciB0aGUgcG9zaXRpb24gdG8gYmUgcmVhZHkgaW4gb3JkZXIgdG8gcHJldmVudCB1bndhbnRlZFxuICAgICAgICAgIC8vIHNjcm9sbGluZy4gVGhpcyBtZWFucyB0aGUgdmlydHVhbCBjdXJzb3Igd2lsbCBub3QgbW92ZSB0byB0aGUgZmlyc3RcbiAgICAgICAgICAvLyBpdGVtIHdoZW4gZmlyc3Qgb3BlbmluZyB0aGUgZmxvYXRpbmcgZWxlbWVudCwgYnV0IHdpbGwgb25cbiAgICAgICAgICAvLyBzdWJzZXF1ZW50IGNhbGxzLiBgcHJldmVudFNjcm9sbGAgaXMgc3VwcG9ydGVkIGluIG1vZGVybiBTYWZhcmksXG4gICAgICAgICAgLy8gc28gd2UgY2FuIHVzZSB0aGF0IGluc3RlYWQuXG4gICAgICAgICAgLy8gaU9TIFNhZmFyaSBtdXN0IGJlIGFzeW5jIG9yIHRoZSBmaXJzdCBpdGVtIHdpbGwgbm90IGJlIGZvY3VzZWQuXG4gICAgICAgICAgc3luYzogaXNNYWMoKSAmJiBpc1NhZmFyaSgpID8gaXNQcmV2ZW50U2Nyb2xsU3VwcG9ydGVkIHx8IGZvcmNlU3luY0ZvY3VzLmN1cnJlbnQgOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgaW5pdGlhbEl0ZW0gPSBsaXN0UmVmLmN1cnJlbnRbaW5kZXhSZWYuY3VycmVudF07XG4gICAgaWYgKGluaXRpYWxJdGVtKSB7XG4gICAgICBydW5Gb2N1cyhpbml0aWFsSXRlbSk7XG4gICAgfVxuICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICBjb25zdCB3YWl0ZWRJdGVtID0gbGlzdFJlZi5jdXJyZW50W2luZGV4UmVmLmN1cnJlbnRdIHx8IGluaXRpYWxJdGVtO1xuICAgICAgaWYgKCF3YWl0ZWRJdGVtKSByZXR1cm47XG4gICAgICBpZiAoIWluaXRpYWxJdGVtKSB7XG4gICAgICAgIHJ1bkZvY3VzKHdhaXRlZEl0ZW0pO1xuICAgICAgfVxuICAgICAgY29uc3Qgc2Nyb2xsSW50b1ZpZXdPcHRpb25zID0gc2Nyb2xsSXRlbUludG9WaWV3UmVmLmN1cnJlbnQ7XG4gICAgICBjb25zdCBzaG91bGRTY3JvbGxJbnRvVmlldyA9IHNjcm9sbEludG9WaWV3T3B0aW9ucyAmJiBpdGVtICYmIChmb3JjZVNjcm9sbEludG9WaWV3IHx8ICFpc1BvaW50ZXJNb2RhbGl0eVJlZi5jdXJyZW50KTtcbiAgICAgIGlmIChzaG91bGRTY3JvbGxJbnRvVmlldykge1xuICAgICAgICAvLyBKU0RPTSBkb2Vzbid0IHN1cHBvcnQgYC5zY3JvbGxJbnRvVmlldygpYCBidXQgaXQncyB3aWRlbHkgc3VwcG9ydGVkXG4gICAgICAgIC8vIGJ5IGFsbCBicm93c2Vycy5cbiAgICAgICAgd2FpdGVkSXRlbS5zY3JvbGxJbnRvVmlldyA9PSBudWxsIHx8IHdhaXRlZEl0ZW0uc2Nyb2xsSW50b1ZpZXcodHlwZW9mIHNjcm9sbEludG9WaWV3T3B0aW9ucyA9PT0gJ2Jvb2xlYW4nID8ge1xuICAgICAgICAgIGJsb2NrOiAnbmVhcmVzdCcsXG4gICAgICAgICAgaW5saW5lOiAnbmVhcmVzdCdcbiAgICAgICAgfSA6IHNjcm9sbEludG9WaWV3T3B0aW9ucyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xuICBpbmRleCgoKSA9PiB7XG4gICAgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JykuZm9jdXMoe1xuICAgICAgZ2V0IHByZXZlbnRTY3JvbGwoKSB7XG4gICAgICAgIGlzUHJldmVudFNjcm9sbFN1cHBvcnRlZCA9IHRydWU7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSwgW10pO1xuXG4gIC8vIFN5bmMgYHNlbGVjdGVkSW5kZXhgIHRvIGJlIHRoZSBgYWN0aXZlSW5kZXhgIHVwb24gb3BlbmluZyB0aGUgZmxvYXRpbmdcbiAgLy8gZWxlbWVudC4gQWxzbywgcmVzZXQgYGFjdGl2ZUluZGV4YCB1cG9uIGNsb3NpbmcgdGhlIGZsb2F0aW5nIGVsZW1lbnQuXG4gIGluZGV4KCgpID0+IHtcbiAgICBpZiAoIWVuYWJsZWQpIHJldHVybjtcbiAgICBpZiAob3BlbiAmJiBlbGVtZW50cy5mbG9hdGluZykge1xuICAgICAgaWYgKGZvY3VzSXRlbU9uT3BlblJlZi5jdXJyZW50ICYmIHNlbGVjdGVkSW5kZXggIT0gbnVsbCkge1xuICAgICAgICAvLyBSZWdhcmRsZXNzIG9mIHRoZSBwb2ludGVyIG1vZGFsaXR5LCB3ZSB3YW50IHRvIGVuc3VyZSB0aGUgc2VsZWN0ZWRcbiAgICAgICAgLy8gaXRlbSBjb21lcyBpbnRvIHZpZXcgd2hlbiB0aGUgZmxvYXRpbmcgZWxlbWVudCBpcyBvcGVuZWQuXG4gICAgICAgIGZvcmNlU2Nyb2xsSW50b1ZpZXdSZWYuY3VycmVudCA9IHRydWU7XG4gICAgICAgIGluZGV4UmVmLmN1cnJlbnQgPSBzZWxlY3RlZEluZGV4O1xuICAgICAgICBvbk5hdmlnYXRlKHNlbGVjdGVkSW5kZXgpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocHJldmlvdXNNb3VudGVkUmVmLmN1cnJlbnQpIHtcbiAgICAgIC8vIFNpbmNlIHRoZSB1c2VyIGNhbiBzcGVjaWZ5IGBvbk5hdmlnYXRlYCBjb25kaXRpb25hbGx5XG4gICAgICAvLyAob25OYXZpZ2F0ZTogb3BlbiA/IHNldEFjdGl2ZUluZGV4IDogc2V0U2VsZWN0ZWRJbmRleCksXG4gICAgICAvLyB3ZSBzdG9yZSBhbmQgY2FsbCB0aGUgcHJldmlvdXMgZnVuY3Rpb24uXG4gICAgICBpbmRleFJlZi5jdXJyZW50ID0gLTE7XG4gICAgICBwcmV2aW91c09uTmF2aWdhdGVSZWYuY3VycmVudChudWxsKTtcbiAgICB9XG4gIH0sIFtlbmFibGVkLCBvcGVuLCBlbGVtZW50cy5mbG9hdGluZywgc2VsZWN0ZWRJbmRleCwgb25OYXZpZ2F0ZV0pO1xuXG4gIC8vIFN5bmMgYGFjdGl2ZUluZGV4YCB0byBiZSB0aGUgZm9jdXNlZCBpdGVtIHdoaWxlIHRoZSBmbG9hdGluZyBlbGVtZW50IGlzXG4gIC8vIG9wZW4uXG4gIGluZGV4KCgpID0+IHtcbiAgICBpZiAoIWVuYWJsZWQpIHJldHVybjtcbiAgICBpZiAob3BlbiAmJiBlbGVtZW50cy5mbG9hdGluZykge1xuICAgICAgaWYgKGFjdGl2ZUluZGV4ID09IG51bGwpIHtcbiAgICAgICAgZm9yY2VTeW5jRm9jdXMuY3VycmVudCA9IGZhbHNlO1xuICAgICAgICBpZiAoc2VsZWN0ZWRJbmRleFJlZi5jdXJyZW50ICE9IG51bGwpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBSZXNldCB3aGlsZSB0aGUgZmxvYXRpbmcgZWxlbWVudCB3YXMgb3BlbiAoZS5nLiB0aGUgbGlzdCBjaGFuZ2VkKS5cbiAgICAgICAgaWYgKHByZXZpb3VzTW91bnRlZFJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgaW5kZXhSZWYuY3VycmVudCA9IC0xO1xuICAgICAgICAgIGZvY3VzSXRlbShsaXN0UmVmLCBpbmRleFJlZik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJbml0aWFsIHN5bmMuXG4gICAgICAgIGlmICgoIXByZXZpb3VzT3BlblJlZi5jdXJyZW50IHx8ICFwcmV2aW91c01vdW50ZWRSZWYuY3VycmVudCkgJiYgZm9jdXNJdGVtT25PcGVuUmVmLmN1cnJlbnQgJiYgKGtleVJlZi5jdXJyZW50ICE9IG51bGwgfHwgZm9jdXNJdGVtT25PcGVuUmVmLmN1cnJlbnQgPT09IHRydWUgJiYga2V5UmVmLmN1cnJlbnQgPT0gbnVsbCkpIHtcbiAgICAgICAgICBsZXQgcnVucyA9IDA7XG4gICAgICAgICAgY29uc3Qgd2FpdEZvckxpc3RQb3B1bGF0ZWQgPSAoKSA9PiB7XG4gICAgICAgICAgICBpZiAobGlzdFJlZi5jdXJyZW50WzBdID09IG51bGwpIHtcbiAgICAgICAgICAgICAgLy8gQXZvaWQgbGV0dGluZyB0aGUgYnJvd3NlciBwYWludCBpZiBwb3NzaWJsZSBvbiB0aGUgZmlyc3QgdHJ5LFxuICAgICAgICAgICAgICAvLyBvdGhlcndpc2UgdXNlIHJBRi4gRG9uJ3QgdHJ5IG1vcmUgdGhhbiB0d2ljZSwgc2luY2Ugc29tZXRoaW5nXG4gICAgICAgICAgICAgIC8vIGlzIHdyb25nIG90aGVyd2lzZS5cbiAgICAgICAgICAgICAgaWYgKHJ1bnMgPCAyKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2NoZWR1bGVyID0gcnVucyA/IHJlcXVlc3RBbmltYXRpb25GcmFtZSA6IHF1ZXVlTWljcm90YXNrO1xuICAgICAgICAgICAgICAgIHNjaGVkdWxlcih3YWl0Rm9yTGlzdFBvcHVsYXRlZCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcnVucysrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaW5kZXhSZWYuY3VycmVudCA9IGtleVJlZi5jdXJyZW50ID09IG51bGwgfHwgaXNNYWluT3JpZW50YXRpb25Ub0VuZEtleShrZXlSZWYuY3VycmVudCwgb3JpZW50YXRpb24sIHJ0bCkgfHwgbmVzdGVkID8gZ2V0TWluSW5kZXgobGlzdFJlZiwgZGlzYWJsZWRJbmRpY2VzUmVmLmN1cnJlbnQpIDogZ2V0TWF4SW5kZXgobGlzdFJlZiwgZGlzYWJsZWRJbmRpY2VzUmVmLmN1cnJlbnQpO1xuICAgICAgICAgICAgICBrZXlSZWYuY3VycmVudCA9IG51bGw7XG4gICAgICAgICAgICAgIG9uTmF2aWdhdGUoaW5kZXhSZWYuY3VycmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgICB3YWl0Rm9yTGlzdFBvcHVsYXRlZCgpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKCFpc0luZGV4T3V0T2ZCb3VuZHMobGlzdFJlZiwgYWN0aXZlSW5kZXgpKSB7XG4gICAgICAgIGluZGV4UmVmLmN1cnJlbnQgPSBhY3RpdmVJbmRleDtcbiAgICAgICAgZm9jdXNJdGVtKGxpc3RSZWYsIGluZGV4UmVmLCBmb3JjZVNjcm9sbEludG9WaWV3UmVmLmN1cnJlbnQpO1xuICAgICAgICBmb3JjZVNjcm9sbEludG9WaWV3UmVmLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIFtlbmFibGVkLCBvcGVuLCBlbGVtZW50cy5mbG9hdGluZywgYWN0aXZlSW5kZXgsIHNlbGVjdGVkSW5kZXhSZWYsIG5lc3RlZCwgbGlzdFJlZiwgb3JpZW50YXRpb24sIHJ0bCwgb25OYXZpZ2F0ZSwgZm9jdXNJdGVtLCBkaXNhYmxlZEluZGljZXNSZWZdKTtcblxuICAvLyBFbnN1cmUgdGhlIHBhcmVudCBmbG9hdGluZyBlbGVtZW50IGhhcyBmb2N1cyB3aGVuIGEgbmVzdGVkIGNoaWxkIGNsb3Nlc1xuICAvLyB0byBhbGxvdyBhcnJvdyBrZXkgbmF2aWdhdGlvbiB0byB3b3JrIGFmdGVyIHRoZSBwb2ludGVyIGxlYXZlcyB0aGUgY2hpbGQuXG4gIGluZGV4KCgpID0+IHtcbiAgICB2YXIgX25vZGVzJGZpbmQ7XG4gICAgaWYgKCFlbmFibGVkIHx8IGVsZW1lbnRzLmZsb2F0aW5nIHx8ICF0cmVlIHx8IHZpcnR1YWwgfHwgIXByZXZpb3VzTW91bnRlZFJlZi5jdXJyZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG5vZGVzID0gdHJlZS5ub2Rlc1JlZi5jdXJyZW50O1xuICAgIGNvbnN0IHBhcmVudCA9IChfbm9kZXMkZmluZCA9IG5vZGVzLmZpbmQobm9kZSA9PiBub2RlLmlkID09PSBwYXJlbnRJZCkpID09IG51bGwgfHwgKF9ub2RlcyRmaW5kID0gX25vZGVzJGZpbmQuY29udGV4dCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9ub2RlcyRmaW5kLmVsZW1lbnRzLmZsb2F0aW5nO1xuICAgIGNvbnN0IGFjdGl2ZUVsID0gYWN0aXZlRWxlbWVudChnZXREb2N1bWVudChlbGVtZW50cy5mbG9hdGluZykpO1xuICAgIGNvbnN0IHRyZWVDb250YWluc0FjdGl2ZUVsID0gbm9kZXMuc29tZShub2RlID0+IG5vZGUuY29udGV4dCAmJiBjb250YWlucyhub2RlLmNvbnRleHQuZWxlbWVudHMuZmxvYXRpbmcsIGFjdGl2ZUVsKSk7XG4gICAgaWYgKHBhcmVudCAmJiAhdHJlZUNvbnRhaW5zQWN0aXZlRWwgJiYgaXNQb2ludGVyTW9kYWxpdHlSZWYuY3VycmVudCkge1xuICAgICAgcGFyZW50LmZvY3VzKHtcbiAgICAgICAgcHJldmVudFNjcm9sbDogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuICB9LCBbZW5hYmxlZCwgZWxlbWVudHMuZmxvYXRpbmcsIHRyZWUsIHBhcmVudElkLCB2aXJ0dWFsXSk7XG4gIGluZGV4KCgpID0+IHtcbiAgICBpZiAoIWVuYWJsZWQpIHJldHVybjtcbiAgICBpZiAoIXRyZWUpIHJldHVybjtcbiAgICBpZiAoIXZpcnR1YWwpIHJldHVybjtcbiAgICBpZiAocGFyZW50SWQpIHJldHVybjtcbiAgICBmdW5jdGlvbiBoYW5kbGVWaXJ0dWFsRm9jdXMoaXRlbSkge1xuICAgICAgc2V0VmlydHVhbElkKGl0ZW0uaWQpO1xuICAgICAgaWYgKHZpcnR1YWxJdGVtUmVmKSB7XG4gICAgICAgIHZpcnR1YWxJdGVtUmVmLmN1cnJlbnQgPSBpdGVtO1xuICAgICAgfVxuICAgIH1cbiAgICB0cmVlLmV2ZW50cy5vbigndmlydHVhbGZvY3VzJywgaGFuZGxlVmlydHVhbEZvY3VzKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgdHJlZS5ldmVudHMub2ZmKCd2aXJ0dWFsZm9jdXMnLCBoYW5kbGVWaXJ0dWFsRm9jdXMpO1xuICAgIH07XG4gIH0sIFtlbmFibGVkLCB0cmVlLCB2aXJ0dWFsLCBwYXJlbnRJZCwgdmlydHVhbEl0ZW1SZWZdKTtcbiAgaW5kZXgoKCkgPT4ge1xuICAgIHByZXZpb3VzT25OYXZpZ2F0ZVJlZi5jdXJyZW50ID0gb25OYXZpZ2F0ZTtcbiAgICBwcmV2aW91c01vdW50ZWRSZWYuY3VycmVudCA9ICEhZWxlbWVudHMuZmxvYXRpbmc7XG4gIH0pO1xuICBpbmRleCgoKSA9PiB7XG4gICAgaWYgKCFvcGVuKSB7XG4gICAgICBrZXlSZWYuY3VycmVudCA9IG51bGw7XG4gICAgfVxuICB9LCBbb3Blbl0pO1xuICBpbmRleCgoKSA9PiB7XG4gICAgcHJldmlvdXNPcGVuUmVmLmN1cnJlbnQgPSBvcGVuO1xuICB9LCBbb3Blbl0pO1xuICBjb25zdCBoYXNBY3RpdmVJbmRleCA9IGFjdGl2ZUluZGV4ICE9IG51bGw7XG4gIGNvbnN0IGl0ZW0gPSBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICBmdW5jdGlvbiBzeW5jQ3VycmVudFRhcmdldChjdXJyZW50VGFyZ2V0KSB7XG4gICAgICBpZiAoIW9wZW4pIHJldHVybjtcbiAgICAgIGNvbnN0IGluZGV4ID0gbGlzdFJlZi5jdXJyZW50LmluZGV4T2YoY3VycmVudFRhcmdldCk7XG4gICAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgIG9uTmF2aWdhdGUoaW5kZXgpO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBwcm9wcyA9IHtcbiAgICAgIG9uRm9jdXMoX3JlZikge1xuICAgICAgICBsZXQge1xuICAgICAgICAgIGN1cnJlbnRUYXJnZXRcbiAgICAgICAgfSA9IF9yZWY7XG4gICAgICAgIHN5bmNDdXJyZW50VGFyZ2V0KGN1cnJlbnRUYXJnZXQpO1xuICAgICAgfSxcbiAgICAgIG9uQ2xpY2s6IF9yZWYyID0+IHtcbiAgICAgICAgbGV0IHtcbiAgICAgICAgICBjdXJyZW50VGFyZ2V0XG4gICAgICAgIH0gPSBfcmVmMjtcbiAgICAgICAgcmV0dXJuIGN1cnJlbnRUYXJnZXQuZm9jdXMoe1xuICAgICAgICAgIHByZXZlbnRTY3JvbGw6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgLy8gU2FmYXJpXG4gICAgICAuLi4oZm9jdXNJdGVtT25Ib3ZlciAmJiB7XG4gICAgICAgIG9uTW91c2VNb3ZlKF9yZWYzKSB7XG4gICAgICAgICAgbGV0IHtcbiAgICAgICAgICAgIGN1cnJlbnRUYXJnZXRcbiAgICAgICAgICB9ID0gX3JlZjM7XG4gICAgICAgICAgc3luY0N1cnJlbnRUYXJnZXQoY3VycmVudFRhcmdldCk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uUG9pbnRlckxlYXZlKF9yZWY0KSB7XG4gICAgICAgICAgbGV0IHtcbiAgICAgICAgICAgIHBvaW50ZXJUeXBlXG4gICAgICAgICAgfSA9IF9yZWY0O1xuICAgICAgICAgIGlmICghaXNQb2ludGVyTW9kYWxpdHlSZWYuY3VycmVudCB8fCBwb2ludGVyVHlwZSA9PT0gJ3RvdWNoJykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpbmRleFJlZi5jdXJyZW50ID0gLTE7XG4gICAgICAgICAgZm9jdXNJdGVtKGxpc3RSZWYsIGluZGV4UmVmKTtcbiAgICAgICAgICBvbk5hdmlnYXRlKG51bGwpO1xuICAgICAgICAgIGlmICghdmlydHVhbCkge1xuICAgICAgICAgICAgZW5xdWV1ZUZvY3VzKGZsb2F0aW5nRm9jdXNFbGVtZW50UmVmLmN1cnJlbnQsIHtcbiAgICAgICAgICAgICAgcHJldmVudFNjcm9sbDogdHJ1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH07XG4gICAgcmV0dXJuIHByb3BzO1xuICB9LCBbb3BlbiwgZmxvYXRpbmdGb2N1c0VsZW1lbnRSZWYsIGZvY3VzSXRlbSwgZm9jdXNJdGVtT25Ib3ZlciwgbGlzdFJlZiwgb25OYXZpZ2F0ZSwgdmlydHVhbF0pO1xuICBjb25zdCBjb21tb25PbktleURvd24gPSB1c2VFZmZlY3RFdmVudChldmVudCA9PiB7XG4gICAgaXNQb2ludGVyTW9kYWxpdHlSZWYuY3VycmVudCA9IGZhbHNlO1xuICAgIGZvcmNlU3luY0ZvY3VzLmN1cnJlbnQgPSB0cnVlO1xuXG4gICAgLy8gV2hlbiBjb21wb3NpbmcgYSBjaGFyYWN0ZXIsIENocm9tZSBmaXJlcyBBcnJvd0Rvd24gdHdpY2UuIEZpcmVmb3gvU2FmYXJpXG4gICAgLy8gZG9uJ3QgYXBwZWFyIHRvIHN1ZmZlciBmcm9tIHRoaXMuIGBldmVudC5pc0NvbXBvc2luZ2AgaXMgYXZvaWRlZCBkdWUgdG9cbiAgICAvLyBTYWZhcmkgbm90IHN1cHBvcnRpbmcgaXQgcHJvcGVybHkgKGFsdGhvdWdoIGl0J3Mgbm90IG5lZWRlZCBpbiB0aGUgZmlyc3RcbiAgICAvLyBwbGFjZSBmb3IgU2FmYXJpLCBqdXN0IGF2b2lkaW5nIGFueSBwb3NzaWJsZSBpc3N1ZXMpLlxuICAgIGlmIChldmVudC53aGljaCA9PT0gMjI5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gSWYgdGhlIGZsb2F0aW5nIGVsZW1lbnQgaXMgYW5pbWF0aW5nIG91dCwgaWdub3JlIG5hdmlnYXRpb24uIE90aGVyd2lzZSxcbiAgICAvLyB0aGUgYGFjdGl2ZUluZGV4YCBnZXRzIHNldCB0byAwIGRlc3BpdGUgbm90IGJlaW5nIG9wZW4gc28gdGhlIG5leHQgdGltZVxuICAgIC8vIHRoZSB1c2VyIEFycm93RG93bnMsIHRoZSBmaXJzdCBpdGVtIHdvbid0IGJlIGZvY3VzZWQuXG4gICAgaWYgKCFsYXRlc3RPcGVuUmVmLmN1cnJlbnQgJiYgZXZlbnQuY3VycmVudFRhcmdldCA9PT0gZmxvYXRpbmdGb2N1c0VsZW1lbnRSZWYuY3VycmVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAobmVzdGVkICYmIGlzQ3Jvc3NPcmllbnRhdGlvbkNsb3NlS2V5KGV2ZW50LmtleSwgb3JpZW50YXRpb24sIHJ0bCkpIHtcbiAgICAgIHN0b3BFdmVudChldmVudCk7XG4gICAgICBvbk9wZW5DaGFuZ2UoZmFsc2UsIGV2ZW50Lm5hdGl2ZUV2ZW50LCAnbGlzdC1uYXZpZ2F0aW9uJyk7XG4gICAgICBpZiAoaXNIVE1MRWxlbWVudChlbGVtZW50cy5kb21SZWZlcmVuY2UpKSB7XG4gICAgICAgIGlmICh2aXJ0dWFsKSB7XG4gICAgICAgICAgdHJlZSA9PSBudWxsIHx8IHRyZWUuZXZlbnRzLmVtaXQoJ3ZpcnR1YWxmb2N1cycsIGVsZW1lbnRzLmRvbVJlZmVyZW5jZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZWxlbWVudHMuZG9tUmVmZXJlbmNlLmZvY3VzKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY3VycmVudEluZGV4ID0gaW5kZXhSZWYuY3VycmVudDtcbiAgICBjb25zdCBtaW5JbmRleCA9IGdldE1pbkluZGV4KGxpc3RSZWYsIGRpc2FibGVkSW5kaWNlcyk7XG4gICAgY29uc3QgbWF4SW5kZXggPSBnZXRNYXhJbmRleChsaXN0UmVmLCBkaXNhYmxlZEluZGljZXMpO1xuICAgIGlmICghdHlwZWFibGVDb21ib2JveFJlZmVyZW5jZSkge1xuICAgICAgaWYgKGV2ZW50LmtleSA9PT0gJ0hvbWUnKSB7XG4gICAgICAgIHN0b3BFdmVudChldmVudCk7XG4gICAgICAgIGluZGV4UmVmLmN1cnJlbnQgPSBtaW5JbmRleDtcbiAgICAgICAgb25OYXZpZ2F0ZShpbmRleFJlZi5jdXJyZW50KTtcbiAgICAgIH1cbiAgICAgIGlmIChldmVudC5rZXkgPT09ICdFbmQnKSB7XG4gICAgICAgIHN0b3BFdmVudChldmVudCk7XG4gICAgICAgIGluZGV4UmVmLmN1cnJlbnQgPSBtYXhJbmRleDtcbiAgICAgICAgb25OYXZpZ2F0ZShpbmRleFJlZi5jdXJyZW50KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBHcmlkIG5hdmlnYXRpb24uXG4gICAgaWYgKGNvbHMgPiAxKSB7XG4gICAgICBjb25zdCBzaXplcyA9IGl0ZW1TaXplcyB8fCBBcnJheS5mcm9tKHtcbiAgICAgICAgbGVuZ3RoOiBsaXN0UmVmLmN1cnJlbnQubGVuZ3RoXG4gICAgICB9LCAoKSA9PiAoe1xuICAgICAgICB3aWR0aDogMSxcbiAgICAgICAgaGVpZ2h0OiAxXG4gICAgICB9KSk7XG4gICAgICAvLyBUbyBjYWxjdWxhdGUgbW92ZW1lbnRzIG9uIHRoZSBncmlkLCB3ZSB1c2UgaHlwb3RoZXRpY2FsIGNlbGwgaW5kaWNlc1xuICAgICAgLy8gYXMgaWYgZXZlcnkgaXRlbSB3YXMgMXgxLCB0aGVuIGNvbnZlcnQgYmFjayB0byByZWFsIGluZGljZXMuXG4gICAgICBjb25zdCBjZWxsTWFwID0gYnVpbGRDZWxsTWFwKHNpemVzLCBjb2xzLCBkZW5zZSk7XG4gICAgICBjb25zdCBtaW5HcmlkSW5kZXggPSBjZWxsTWFwLmZpbmRJbmRleChpbmRleCA9PiBpbmRleCAhPSBudWxsICYmICFpc0Rpc2FibGVkKGxpc3RSZWYuY3VycmVudCwgaW5kZXgsIGRpc2FibGVkSW5kaWNlcykpO1xuICAgICAgLy8gbGFzdCBlbmFibGVkIGluZGV4XG4gICAgICBjb25zdCBtYXhHcmlkSW5kZXggPSBjZWxsTWFwLnJlZHVjZSgoZm91bmRJbmRleCwgaW5kZXgsIGNlbGxJbmRleCkgPT4gaW5kZXggIT0gbnVsbCAmJiAhaXNEaXNhYmxlZChsaXN0UmVmLmN1cnJlbnQsIGluZGV4LCBkaXNhYmxlZEluZGljZXMpID8gY2VsbEluZGV4IDogZm91bmRJbmRleCwgLTEpO1xuICAgICAgY29uc3QgaW5kZXggPSBjZWxsTWFwW2dldEdyaWROYXZpZ2F0ZWRJbmRleCh7XG4gICAgICAgIGN1cnJlbnQ6IGNlbGxNYXAubWFwKGl0ZW1JbmRleCA9PiBpdGVtSW5kZXggIT0gbnVsbCA/IGxpc3RSZWYuY3VycmVudFtpdGVtSW5kZXhdIDogbnVsbClcbiAgICAgIH0sIHtcbiAgICAgICAgZXZlbnQsXG4gICAgICAgIG9yaWVudGF0aW9uLFxuICAgICAgICBsb29wLFxuICAgICAgICBydGwsXG4gICAgICAgIGNvbHMsXG4gICAgICAgIC8vIHRyZWF0IHVuZGVmaW5lZCAoZW1wdHkgZ3JpZCBzcGFjZXMpIGFzIGRpc2FibGVkIGluZGljZXMgc28gd2VcbiAgICAgICAgLy8gZG9uJ3QgZW5kIHVwIGluIHRoZW1cbiAgICAgICAgZGlzYWJsZWRJbmRpY2VzOiBnZXRDZWxsSW5kaWNlcyhbLi4uKGRpc2FibGVkSW5kaWNlcyB8fCBsaXN0UmVmLmN1cnJlbnQubWFwKChfLCBpbmRleCkgPT4gaXNEaXNhYmxlZChsaXN0UmVmLmN1cnJlbnQsIGluZGV4KSA/IGluZGV4IDogdW5kZWZpbmVkKSksIHVuZGVmaW5lZF0sIGNlbGxNYXApLFxuICAgICAgICBtaW5JbmRleDogbWluR3JpZEluZGV4LFxuICAgICAgICBtYXhJbmRleDogbWF4R3JpZEluZGV4LFxuICAgICAgICBwcmV2SW5kZXg6IGdldENlbGxJbmRleE9mQ29ybmVyKGluZGV4UmVmLmN1cnJlbnQgPiBtYXhJbmRleCA/IG1pbkluZGV4IDogaW5kZXhSZWYuY3VycmVudCwgc2l6ZXMsIGNlbGxNYXAsIGNvbHMsXG4gICAgICAgIC8vIHVzZSBhIGNvcm5lciBtYXRjaGluZyB0aGUgZWRnZSBjbG9zZXN0IHRvIHRoZSBkaXJlY3Rpb25cbiAgICAgICAgLy8gd2UncmUgbW92aW5nIGluIHNvIHdlIGRvbid0IGVuZCB1cCBpbiB0aGUgc2FtZSBpdGVtLiBQcmVmZXJcbiAgICAgICAgLy8gdG9wL2xlZnQgb3ZlciBib3R0b20vcmlnaHQuXG4gICAgICAgIGV2ZW50LmtleSA9PT0gQVJST1dfRE9XTiA/ICdibCcgOiBldmVudC5rZXkgPT09IChydGwgPyBBUlJPV19MRUZUIDogQVJST1dfUklHSFQpID8gJ3RyJyA6ICd0bCcpLFxuICAgICAgICBzdG9wRXZlbnQ6IHRydWVcbiAgICAgIH0pXTtcbiAgICAgIGlmIChpbmRleCAhPSBudWxsKSB7XG4gICAgICAgIGluZGV4UmVmLmN1cnJlbnQgPSBpbmRleDtcbiAgICAgICAgb25OYXZpZ2F0ZShpbmRleFJlZi5jdXJyZW50KTtcbiAgICAgIH1cbiAgICAgIGlmIChvcmllbnRhdGlvbiA9PT0gJ2JvdGgnKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGlzTWFpbk9yaWVudGF0aW9uS2V5KGV2ZW50LmtleSwgb3JpZW50YXRpb24pKSB7XG4gICAgICBzdG9wRXZlbnQoZXZlbnQpO1xuXG4gICAgICAvLyBSZXNldCB0aGUgaW5kZXggaWYgbm8gaXRlbSBpcyBmb2N1c2VkLlxuICAgICAgaWYgKG9wZW4gJiYgIXZpcnR1YWwgJiYgYWN0aXZlRWxlbWVudChldmVudC5jdXJyZW50VGFyZ2V0Lm93bmVyRG9jdW1lbnQpID09PSBldmVudC5jdXJyZW50VGFyZ2V0KSB7XG4gICAgICAgIGluZGV4UmVmLmN1cnJlbnQgPSBpc01haW5PcmllbnRhdGlvblRvRW5kS2V5KGV2ZW50LmtleSwgb3JpZW50YXRpb24sIHJ0bCkgPyBtaW5JbmRleCA6IG1heEluZGV4O1xuICAgICAgICBvbk5hdmlnYXRlKGluZGV4UmVmLmN1cnJlbnQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoaXNNYWluT3JpZW50YXRpb25Ub0VuZEtleShldmVudC5rZXksIG9yaWVudGF0aW9uLCBydGwpKSB7XG4gICAgICAgIGlmIChsb29wKSB7XG4gICAgICAgICAgaW5kZXhSZWYuY3VycmVudCA9IGN1cnJlbnRJbmRleCA+PSBtYXhJbmRleCA/IGFsbG93RXNjYXBlICYmIGN1cnJlbnRJbmRleCAhPT0gbGlzdFJlZi5jdXJyZW50Lmxlbmd0aCA/IC0xIDogbWluSW5kZXggOiBmaW5kTm9uRGlzYWJsZWRJbmRleChsaXN0UmVmLCB7XG4gICAgICAgICAgICBzdGFydGluZ0luZGV4OiBjdXJyZW50SW5kZXgsXG4gICAgICAgICAgICBkaXNhYmxlZEluZGljZXNcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpbmRleFJlZi5jdXJyZW50ID0gTWF0aC5taW4obWF4SW5kZXgsIGZpbmROb25EaXNhYmxlZEluZGV4KGxpc3RSZWYsIHtcbiAgICAgICAgICAgIHN0YXJ0aW5nSW5kZXg6IGN1cnJlbnRJbmRleCxcbiAgICAgICAgICAgIGRpc2FibGVkSW5kaWNlc1xuICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGxvb3ApIHtcbiAgICAgICAgICBpbmRleFJlZi5jdXJyZW50ID0gY3VycmVudEluZGV4IDw9IG1pbkluZGV4ID8gYWxsb3dFc2NhcGUgJiYgY3VycmVudEluZGV4ICE9PSAtMSA/IGxpc3RSZWYuY3VycmVudC5sZW5ndGggOiBtYXhJbmRleCA6IGZpbmROb25EaXNhYmxlZEluZGV4KGxpc3RSZWYsIHtcbiAgICAgICAgICAgIHN0YXJ0aW5nSW5kZXg6IGN1cnJlbnRJbmRleCxcbiAgICAgICAgICAgIGRlY3JlbWVudDogdHJ1ZSxcbiAgICAgICAgICAgIGRpc2FibGVkSW5kaWNlc1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGluZGV4UmVmLmN1cnJlbnQgPSBNYXRoLm1heChtaW5JbmRleCwgZmluZE5vbkRpc2FibGVkSW5kZXgobGlzdFJlZiwge1xuICAgICAgICAgICAgc3RhcnRpbmdJbmRleDogY3VycmVudEluZGV4LFxuICAgICAgICAgICAgZGVjcmVtZW50OiB0cnVlLFxuICAgICAgICAgICAgZGlzYWJsZWRJbmRpY2VzXG4gICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoaXNJbmRleE91dE9mQm91bmRzKGxpc3RSZWYsIGluZGV4UmVmLmN1cnJlbnQpKSB7XG4gICAgICAgIG9uTmF2aWdhdGUobnVsbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvbk5hdmlnYXRlKGluZGV4UmVmLmN1cnJlbnQpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIGNvbnN0IGFyaWFBY3RpdmVEZXNjZW5kYW50UHJvcCA9IFJlYWN0LnVzZU1lbW8oKCkgPT4ge1xuICAgIHJldHVybiB2aXJ0dWFsICYmIG9wZW4gJiYgaGFzQWN0aXZlSW5kZXggJiYge1xuICAgICAgJ2FyaWEtYWN0aXZlZGVzY2VuZGFudCc6IHZpcnR1YWxJZCB8fCBhY3RpdmVJZFxuICAgIH07XG4gIH0sIFt2aXJ0dWFsLCBvcGVuLCBoYXNBY3RpdmVJbmRleCwgdmlydHVhbElkLCBhY3RpdmVJZF0pO1xuICBjb25zdCBmbG9hdGluZyA9IFJlYWN0LnVzZU1lbW8oKCkgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICAnYXJpYS1vcmllbnRhdGlvbic6IG9yaWVudGF0aW9uID09PSAnYm90aCcgPyB1bmRlZmluZWQgOiBvcmllbnRhdGlvbixcbiAgICAgIC4uLighaXNUeXBlYWJsZUNvbWJvYm94KGVsZW1lbnRzLmRvbVJlZmVyZW5jZSkgJiYgYXJpYUFjdGl2ZURlc2NlbmRhbnRQcm9wKSxcbiAgICAgIG9uS2V5RG93bjogY29tbW9uT25LZXlEb3duLFxuICAgICAgb25Qb2ludGVyTW92ZSgpIHtcbiAgICAgICAgaXNQb2ludGVyTW9kYWxpdHlSZWYuY3VycmVudCA9IHRydWU7XG4gICAgICB9XG4gICAgfTtcbiAgfSwgW2FyaWFBY3RpdmVEZXNjZW5kYW50UHJvcCwgY29tbW9uT25LZXlEb3duLCBlbGVtZW50cy5kb21SZWZlcmVuY2UsIG9yaWVudGF0aW9uXSk7XG4gIGNvbnN0IHJlZmVyZW5jZSA9IFJlYWN0LnVzZU1lbW8oKCkgPT4ge1xuICAgIGZ1bmN0aW9uIGNoZWNrVmlydHVhbE1vdXNlKGV2ZW50KSB7XG4gICAgICBpZiAoZm9jdXNJdGVtT25PcGVuID09PSAnYXV0bycgJiYgaXNWaXJ0dWFsQ2xpY2soZXZlbnQubmF0aXZlRXZlbnQpKSB7XG4gICAgICAgIGZvY3VzSXRlbU9uT3BlblJlZi5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gY2hlY2tWaXJ0dWFsUG9pbnRlcihldmVudCkge1xuICAgICAgLy8gYHBvaW50ZXJkb3duYCBmaXJlcyBmaXJzdCwgcmVzZXQgdGhlIHN0YXRlIHRoZW4gcGVyZm9ybSB0aGUgY2hlY2tzLlxuICAgICAgZm9jdXNJdGVtT25PcGVuUmVmLmN1cnJlbnQgPSBmb2N1c0l0ZW1Pbk9wZW47XG4gICAgICBpZiAoZm9jdXNJdGVtT25PcGVuID09PSAnYXV0bycgJiYgaXNWaXJ0dWFsUG9pbnRlckV2ZW50KGV2ZW50Lm5hdGl2ZUV2ZW50KSkge1xuICAgICAgICBmb2N1c0l0ZW1Pbk9wZW5SZWYuY3VycmVudCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAuLi5hcmlhQWN0aXZlRGVzY2VuZGFudFByb3AsXG4gICAgICBvbktleURvd24oZXZlbnQpIHtcbiAgICAgICAgaXNQb2ludGVyTW9kYWxpdHlSZWYuY3VycmVudCA9IGZhbHNlO1xuICAgICAgICBjb25zdCBpc0Fycm93S2V5ID0gZXZlbnQua2V5LnN0YXJ0c1dpdGgoJ0Fycm93Jyk7XG4gICAgICAgIGNvbnN0IGlzSG9tZU9yRW5kS2V5ID0gWydIb21lJywgJ0VuZCddLmluY2x1ZGVzKGV2ZW50LmtleSk7XG4gICAgICAgIGNvbnN0IGlzTW92ZUtleSA9IGlzQXJyb3dLZXkgfHwgaXNIb21lT3JFbmRLZXk7XG4gICAgICAgIGNvbnN0IGlzQ3Jvc3NPcGVuS2V5ID0gaXNDcm9zc09yaWVudGF0aW9uT3BlbktleShldmVudC5rZXksIG9yaWVudGF0aW9uLCBydGwpO1xuICAgICAgICBjb25zdCBpc0Nyb3NzQ2xvc2VLZXkgPSBpc0Nyb3NzT3JpZW50YXRpb25DbG9zZUtleShldmVudC5rZXksIG9yaWVudGF0aW9uLCBydGwpO1xuICAgICAgICBjb25zdCBpc01haW5LZXkgPSBpc01haW5PcmllbnRhdGlvbktleShldmVudC5rZXksIG9yaWVudGF0aW9uKTtcbiAgICAgICAgY29uc3QgaXNOYXZpZ2F0aW9uS2V5ID0gKG5lc3RlZCA/IGlzQ3Jvc3NPcGVuS2V5IDogaXNNYWluS2V5KSB8fCBldmVudC5rZXkgPT09ICdFbnRlcicgfHwgZXZlbnQua2V5LnRyaW0oKSA9PT0gJyc7XG4gICAgICAgIGlmICh2aXJ0dWFsICYmIG9wZW4pIHtcbiAgICAgICAgICBjb25zdCByb290Tm9kZSA9IHRyZWUgPT0gbnVsbCA/IHZvaWQgMCA6IHRyZWUubm9kZXNSZWYuY3VycmVudC5maW5kKG5vZGUgPT4gbm9kZS5wYXJlbnRJZCA9PSBudWxsKTtcbiAgICAgICAgICBjb25zdCBkZWVwZXN0Tm9kZSA9IHRyZWUgJiYgcm9vdE5vZGUgPyBnZXREZWVwZXN0Tm9kZSh0cmVlLm5vZGVzUmVmLmN1cnJlbnQsIHJvb3ROb2RlLmlkKSA6IG51bGw7XG4gICAgICAgICAgaWYgKGlzTW92ZUtleSAmJiBkZWVwZXN0Tm9kZSAmJiB2aXJ0dWFsSXRlbVJlZikge1xuICAgICAgICAgICAgY29uc3QgZXZlbnRPYmplY3QgPSBuZXcgS2V5Ym9hcmRFdmVudCgna2V5ZG93bicsIHtcbiAgICAgICAgICAgICAga2V5OiBldmVudC5rZXksXG4gICAgICAgICAgICAgIGJ1YmJsZXM6IHRydWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKGlzQ3Jvc3NPcGVuS2V5IHx8IGlzQ3Jvc3NDbG9zZUtleSkge1xuICAgICAgICAgICAgICB2YXIgX2RlZXBlc3ROb2RlJGNvbnRleHQsIF9kZWVwZXN0Tm9kZSRjb250ZXh0MjtcbiAgICAgICAgICAgICAgY29uc3QgaXNDdXJyZW50VGFyZ2V0ID0gKChfZGVlcGVzdE5vZGUkY29udGV4dCA9IGRlZXBlc3ROb2RlLmNvbnRleHQpID09IG51bGwgPyB2b2lkIDAgOiBfZGVlcGVzdE5vZGUkY29udGV4dC5lbGVtZW50cy5kb21SZWZlcmVuY2UpID09PSBldmVudC5jdXJyZW50VGFyZ2V0O1xuICAgICAgICAgICAgICBjb25zdCBkaXNwYXRjaEl0ZW0gPSBpc0Nyb3NzQ2xvc2VLZXkgJiYgIWlzQ3VycmVudFRhcmdldCA/IChfZGVlcGVzdE5vZGUkY29udGV4dDIgPSBkZWVwZXN0Tm9kZS5jb250ZXh0KSA9PSBudWxsID8gdm9pZCAwIDogX2RlZXBlc3ROb2RlJGNvbnRleHQyLmVsZW1lbnRzLmRvbVJlZmVyZW5jZSA6IGlzQ3Jvc3NPcGVuS2V5ID8gbGlzdFJlZi5jdXJyZW50LmZpbmQoaXRlbSA9PiAoaXRlbSA9PSBudWxsID8gdm9pZCAwIDogaXRlbS5pZCkgPT09IGFjdGl2ZUlkKSA6IG51bGw7XG4gICAgICAgICAgICAgIGlmIChkaXNwYXRjaEl0ZW0pIHtcbiAgICAgICAgICAgICAgICBzdG9wRXZlbnQoZXZlbnQpO1xuICAgICAgICAgICAgICAgIGRpc3BhdGNoSXRlbS5kaXNwYXRjaEV2ZW50KGV2ZW50T2JqZWN0KTtcbiAgICAgICAgICAgICAgICBzZXRWaXJ0dWFsSWQodW5kZWZpbmVkKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKChpc01haW5LZXkgfHwgaXNIb21lT3JFbmRLZXkpICYmIGRlZXBlc3ROb2RlLmNvbnRleHQpIHtcbiAgICAgICAgICAgICAgaWYgKGRlZXBlc3ROb2RlLmNvbnRleHQub3BlbiAmJiBkZWVwZXN0Tm9kZS5wYXJlbnRJZCAmJiBldmVudC5jdXJyZW50VGFyZ2V0ICE9PSBkZWVwZXN0Tm9kZS5jb250ZXh0LmVsZW1lbnRzLmRvbVJlZmVyZW5jZSkge1xuICAgICAgICAgICAgICAgIHZhciBfZGVlcGVzdE5vZGUkY29udGV4dCQ7XG4gICAgICAgICAgICAgICAgc3RvcEV2ZW50KGV2ZW50KTtcbiAgICAgICAgICAgICAgICAoX2RlZXBlc3ROb2RlJGNvbnRleHQkID0gZGVlcGVzdE5vZGUuY29udGV4dC5lbGVtZW50cy5kb21SZWZlcmVuY2UpID09IG51bGwgfHwgX2RlZXBlc3ROb2RlJGNvbnRleHQkLmRpc3BhdGNoRXZlbnQoZXZlbnRPYmplY3QpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gY29tbW9uT25LZXlEb3duKGV2ZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIGEgZmxvYXRpbmcgZWxlbWVudCBzaG91bGQgbm90IG9wZW4gb24gYXJyb3cga2V5IGRvd24sIGF2b2lkXG4gICAgICAgIC8vIHNldHRpbmcgYGFjdGl2ZUluZGV4YCB3aGlsZSBpdCdzIGNsb3NlZC5cbiAgICAgICAgaWYgKCFvcGVuICYmICFvcGVuT25BcnJvd0tleURvd24gJiYgaXNBcnJvd0tleSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNOYXZpZ2F0aW9uS2V5KSB7XG4gICAgICAgICAga2V5UmVmLmN1cnJlbnQgPSBuZXN0ZWQgJiYgaXNNYWluS2V5ID8gbnVsbCA6IGV2ZW50LmtleTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobmVzdGVkKSB7XG4gICAgICAgICAgaWYgKGlzQ3Jvc3NPcGVuS2V5KSB7XG4gICAgICAgICAgICBzdG9wRXZlbnQoZXZlbnQpO1xuICAgICAgICAgICAgaWYgKG9wZW4pIHtcbiAgICAgICAgICAgICAgaW5kZXhSZWYuY3VycmVudCA9IGdldE1pbkluZGV4KGxpc3RSZWYsIGRpc2FibGVkSW5kaWNlc1JlZi5jdXJyZW50KTtcbiAgICAgICAgICAgICAgb25OYXZpZ2F0ZShpbmRleFJlZi5jdXJyZW50KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG9uT3BlbkNoYW5nZSh0cnVlLCBldmVudC5uYXRpdmVFdmVudCwgJ2xpc3QtbmF2aWdhdGlvbicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzTWFpbktleSkge1xuICAgICAgICAgIGlmIChzZWxlY3RlZEluZGV4ICE9IG51bGwpIHtcbiAgICAgICAgICAgIGluZGV4UmVmLmN1cnJlbnQgPSBzZWxlY3RlZEluZGV4O1xuICAgICAgICAgIH1cbiAgICAgICAgICBzdG9wRXZlbnQoZXZlbnQpO1xuICAgICAgICAgIGlmICghb3BlbiAmJiBvcGVuT25BcnJvd0tleURvd24pIHtcbiAgICAgICAgICAgIG9uT3BlbkNoYW5nZSh0cnVlLCBldmVudC5uYXRpdmVFdmVudCwgJ2xpc3QtbmF2aWdhdGlvbicpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb21tb25PbktleURvd24oZXZlbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAob3Blbikge1xuICAgICAgICAgICAgb25OYXZpZ2F0ZShpbmRleFJlZi5jdXJyZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBvbkZvY3VzKCkge1xuICAgICAgICBpZiAob3BlbiAmJiAhdmlydHVhbCkge1xuICAgICAgICAgIG9uTmF2aWdhdGUobnVsbCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBvblBvaW50ZXJEb3duOiBjaGVja1ZpcnR1YWxQb2ludGVyLFxuICAgICAgb25Nb3VzZURvd246IGNoZWNrVmlydHVhbE1vdXNlLFxuICAgICAgb25DbGljazogY2hlY2tWaXJ0dWFsTW91c2VcbiAgICB9O1xuICB9LCBbYWN0aXZlSWQsIGFyaWFBY3RpdmVEZXNjZW5kYW50UHJvcCwgY29tbW9uT25LZXlEb3duLCBkaXNhYmxlZEluZGljZXNSZWYsIGZvY3VzSXRlbU9uT3BlbiwgbGlzdFJlZiwgbmVzdGVkLCBvbk5hdmlnYXRlLCBvbk9wZW5DaGFuZ2UsIG9wZW4sIG9wZW5PbkFycm93S2V5RG93biwgb3JpZW50YXRpb24sIHJ0bCwgc2VsZWN0ZWRJbmRleCwgdHJlZSwgdmlydHVhbCwgdmlydHVhbEl0ZW1SZWZdKTtcbiAgcmV0dXJuIFJlYWN0LnVzZU1lbW8oKCkgPT4gZW5hYmxlZCA/IHtcbiAgICByZWZlcmVuY2UsXG4gICAgZmxvYXRpbmcsXG4gICAgaXRlbVxuICB9IDoge30sIFtlbmFibGVkLCByZWZlcmVuY2UsIGZsb2F0aW5nLCBpdGVtXSk7XG59XG5cbmNvbnN0IGNvbXBvbmVudFJvbGVUb0FyaWFSb2xlTWFwID0gLyojX19QVVJFX18qL25ldyBNYXAoW1snc2VsZWN0JywgJ2xpc3Rib3gnXSwgWydjb21ib2JveCcsICdsaXN0Ym94J10sIFsnbGFiZWwnLCBmYWxzZV1dKTtcblxuLyoqXG4gKiBBZGRzIGJhc2Ugc2NyZWVuIHJlYWRlciBwcm9wcyB0byB0aGUgcmVmZXJlbmNlIGFuZCBmbG9hdGluZyBlbGVtZW50cyBmb3IgYVxuICogZ2l2ZW4gZmxvYXRpbmcgZWxlbWVudCBgcm9sZWAuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvdXNlUm9sZVxuICovXG5mdW5jdGlvbiB1c2VSb2xlKGNvbnRleHQsIHByb3BzKSB7XG4gIHZhciBfY29tcG9uZW50Um9sZVRvQXJpYVI7XG4gIGlmIChwcm9wcyA9PT0gdm9pZCAwKSB7XG4gICAgcHJvcHMgPSB7fTtcbiAgfVxuICBjb25zdCB7XG4gICAgb3BlbixcbiAgICBmbG9hdGluZ0lkXG4gIH0gPSBjb250ZXh0O1xuICBjb25zdCB7XG4gICAgZW5hYmxlZCA9IHRydWUsXG4gICAgcm9sZSA9ICdkaWFsb2cnXG4gIH0gPSBwcm9wcztcbiAgY29uc3QgYXJpYVJvbGUgPSAoX2NvbXBvbmVudFJvbGVUb0FyaWFSID0gY29tcG9uZW50Um9sZVRvQXJpYVJvbGVNYXAuZ2V0KHJvbGUpKSAhPSBudWxsID8gX2NvbXBvbmVudFJvbGVUb0FyaWFSIDogcm9sZTtcbiAgY29uc3QgcmVmZXJlbmNlSWQgPSB1c2VJZCgpO1xuICBjb25zdCBwYXJlbnRJZCA9IHVzZUZsb2F0aW5nUGFyZW50Tm9kZUlkKCk7XG4gIGNvbnN0IGlzTmVzdGVkID0gcGFyZW50SWQgIT0gbnVsbDtcbiAgY29uc3QgcmVmZXJlbmNlID0gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgaWYgKGFyaWFSb2xlID09PSAndG9vbHRpcCcgfHwgcm9sZSA9PT0gJ2xhYmVsJykge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgW1wiYXJpYS1cIiArIChyb2xlID09PSAnbGFiZWwnID8gJ2xhYmVsbGVkYnknIDogJ2Rlc2NyaWJlZGJ5JyldOiBvcGVuID8gZmxvYXRpbmdJZCA6IHVuZGVmaW5lZFxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICdhcmlhLWV4cGFuZGVkJzogb3BlbiA/ICd0cnVlJyA6ICdmYWxzZScsXG4gICAgICAnYXJpYS1oYXNwb3B1cCc6IGFyaWFSb2xlID09PSAnYWxlcnRkaWFsb2cnID8gJ2RpYWxvZycgOiBhcmlhUm9sZSxcbiAgICAgICdhcmlhLWNvbnRyb2xzJzogb3BlbiA/IGZsb2F0aW5nSWQgOiB1bmRlZmluZWQsXG4gICAgICAuLi4oYXJpYVJvbGUgPT09ICdsaXN0Ym94JyAmJiB7XG4gICAgICAgIHJvbGU6ICdjb21ib2JveCdcbiAgICAgIH0pLFxuICAgICAgLi4uKGFyaWFSb2xlID09PSAnbWVudScgJiYge1xuICAgICAgICBpZDogcmVmZXJlbmNlSWRcbiAgICAgIH0pLFxuICAgICAgLi4uKGFyaWFSb2xlID09PSAnbWVudScgJiYgaXNOZXN0ZWQgJiYge1xuICAgICAgICByb2xlOiAnbWVudWl0ZW0nXG4gICAgICB9KSxcbiAgICAgIC4uLihyb2xlID09PSAnc2VsZWN0JyAmJiB7XG4gICAgICAgICdhcmlhLWF1dG9jb21wbGV0ZSc6ICdub25lJ1xuICAgICAgfSksXG4gICAgICAuLi4ocm9sZSA9PT0gJ2NvbWJvYm94JyAmJiB7XG4gICAgICAgICdhcmlhLWF1dG9jb21wbGV0ZSc6ICdsaXN0J1xuICAgICAgfSlcbiAgICB9O1xuICB9LCBbYXJpYVJvbGUsIGZsb2F0aW5nSWQsIGlzTmVzdGVkLCBvcGVuLCByZWZlcmVuY2VJZCwgcm9sZV0pO1xuICBjb25zdCBmbG9hdGluZyA9IFJlYWN0LnVzZU1lbW8oKCkgPT4ge1xuICAgIGNvbnN0IGZsb2F0aW5nUHJvcHMgPSB7XG4gICAgICBpZDogZmxvYXRpbmdJZCxcbiAgICAgIC4uLihhcmlhUm9sZSAmJiB7XG4gICAgICAgIHJvbGU6IGFyaWFSb2xlXG4gICAgICB9KVxuICAgIH07XG4gICAgaWYgKGFyaWFSb2xlID09PSAndG9vbHRpcCcgfHwgcm9sZSA9PT0gJ2xhYmVsJykge1xuICAgICAgcmV0dXJuIGZsb2F0aW5nUHJvcHM7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAuLi5mbG9hdGluZ1Byb3BzLFxuICAgICAgLi4uKGFyaWFSb2xlID09PSAnbWVudScgJiYge1xuICAgICAgICAnYXJpYS1sYWJlbGxlZGJ5JzogcmVmZXJlbmNlSWRcbiAgICAgIH0pXG4gICAgfTtcbiAgfSwgW2FyaWFSb2xlLCBmbG9hdGluZ0lkLCByZWZlcmVuY2VJZCwgcm9sZV0pO1xuICBjb25zdCBpdGVtID0gUmVhY3QudXNlQ2FsbGJhY2soX3JlZiA9PiB7XG4gICAgbGV0IHtcbiAgICAgIGFjdGl2ZSxcbiAgICAgIHNlbGVjdGVkXG4gICAgfSA9IF9yZWY7XG4gICAgY29uc3QgY29tbW9uUHJvcHMgPSB7XG4gICAgICByb2xlOiAnb3B0aW9uJyxcbiAgICAgIC4uLihhY3RpdmUgJiYge1xuICAgICAgICBpZDogZmxvYXRpbmdJZCArIFwiLW9wdGlvblwiXG4gICAgICB9KVxuICAgIH07XG5cbiAgICAvLyBGb3IgYG1lbnVgLCB3ZSBhcmUgdW5hYmxlIHRvIHRlbGwgaWYgdGhlIGl0ZW0gaXMgYSBgbWVudWl0ZW1yYWRpb2BcbiAgICAvLyBvciBgbWVudWl0ZW1jaGVja2JveGAuIEZvciBiYWNrd2FyZHMtY29tcGF0aWJpbGl0eSByZWFzb25zLCBhbHNvXG4gICAgLy8gYXZvaWQgZGVmYXVsdGluZyB0byBgbWVudWl0ZW1gIGFzIGl0IG1heSBvdmVyd3JpdGUgY3VzdG9tIHJvbGUgcHJvcHMuXG4gICAgc3dpdGNoIChyb2xlKSB7XG4gICAgICBjYXNlICdzZWxlY3QnOlxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIC4uLmNvbW1vblByb3BzLFxuICAgICAgICAgICdhcmlhLXNlbGVjdGVkJzogYWN0aXZlICYmIHNlbGVjdGVkXG4gICAgICAgIH07XG4gICAgICBjYXNlICdjb21ib2JveCc6XG4gICAgICAgIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uY29tbW9uUHJvcHMsXG4gICAgICAgICAgICAuLi4oYWN0aXZlICYmIHtcbiAgICAgICAgICAgICAgJ2FyaWEtc2VsZWN0ZWQnOiB0cnVlXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHt9O1xuICB9LCBbZmxvYXRpbmdJZCwgcm9sZV0pO1xuICByZXR1cm4gUmVhY3QudXNlTWVtbygoKSA9PiBlbmFibGVkID8ge1xuICAgIHJlZmVyZW5jZSxcbiAgICBmbG9hdGluZyxcbiAgICBpdGVtXG4gIH0gOiB7fSwgW2VuYWJsZWQsIHJlZmVyZW5jZSwgZmxvYXRpbmcsIGl0ZW1dKTtcbn1cblxuLy8gQ29udmVydHMgYSBKUyBzdHlsZSBrZXkgbGlrZSBgYmFja2dyb3VuZENvbG9yYCB0byBhIENTUyB0cmFuc2l0aW9uLXByb3BlcnR5XG4vLyBsaWtlIGBiYWNrZ3JvdW5kLWNvbG9yYC5cbmNvbnN0IGNhbWVsQ2FzZVRvS2ViYWJDYXNlID0gc3RyID0+IHN0ci5yZXBsYWNlKC9bQS1aXSsoPyFbYS16XSl8W0EtWl0vZywgKCQsIG9mcykgPT4gKG9mcyA/ICctJyA6ICcnKSArICQudG9Mb3dlckNhc2UoKSk7XG5mdW5jdGlvbiBleGVjV2l0aEFyZ3NPclJldHVybih2YWx1ZU9yRm4sIGFyZ3MpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZU9yRm4gPT09ICdmdW5jdGlvbicgPyB2YWx1ZU9yRm4oYXJncykgOiB2YWx1ZU9yRm47XG59XG5mdW5jdGlvbiB1c2VEZWxheVVubW91bnQob3BlbiwgZHVyYXRpb25Ncykge1xuICBjb25zdCBbaXNNb3VudGVkLCBzZXRJc01vdW50ZWRdID0gUmVhY3QudXNlU3RhdGUob3Blbik7XG4gIGlmIChvcGVuICYmICFpc01vdW50ZWQpIHtcbiAgICBzZXRJc01vdW50ZWQodHJ1ZSk7XG4gIH1cbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIW9wZW4gJiYgaXNNb3VudGVkKSB7XG4gICAgICBjb25zdCB0aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiBzZXRJc01vdW50ZWQoZmFsc2UpLCBkdXJhdGlvbk1zKTtcbiAgICAgIHJldHVybiAoKSA9PiBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgfVxuICB9LCBbb3BlbiwgaXNNb3VudGVkLCBkdXJhdGlvbk1zXSk7XG4gIHJldHVybiBpc01vdW50ZWQ7XG59XG4vKipcbiAqIFByb3ZpZGVzIGEgc3RhdHVzIHN0cmluZyB0byBhcHBseSBDU1MgdHJhbnNpdGlvbnMgdG8gYSBmbG9hdGluZyBlbGVtZW50LFxuICogY29ycmVjdGx5IGhhbmRsaW5nIHBsYWNlbWVudC1hd2FyZSB0cmFuc2l0aW9ucy5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy91c2VUcmFuc2l0aW9uI3VzZXRyYW5zaXRpb25zdGF0dXNcbiAqL1xuZnVuY3Rpb24gdXNlVHJhbnNpdGlvblN0YXR1cyhjb250ZXh0LCBwcm9wcykge1xuICBpZiAocHJvcHMgPT09IHZvaWQgMCkge1xuICAgIHByb3BzID0ge307XG4gIH1cbiAgY29uc3Qge1xuICAgIG9wZW4sXG4gICAgZWxlbWVudHM6IHtcbiAgICAgIGZsb2F0aW5nXG4gICAgfVxuICB9ID0gY29udGV4dDtcbiAgY29uc3Qge1xuICAgIGR1cmF0aW9uID0gMjUwXG4gIH0gPSBwcm9wcztcbiAgY29uc3QgaXNOdW1iZXJEdXJhdGlvbiA9IHR5cGVvZiBkdXJhdGlvbiA9PT0gJ251bWJlcic7XG4gIGNvbnN0IGNsb3NlRHVyYXRpb24gPSAoaXNOdW1iZXJEdXJhdGlvbiA/IGR1cmF0aW9uIDogZHVyYXRpb24uY2xvc2UpIHx8IDA7XG4gIGNvbnN0IFtzdGF0dXMsIHNldFN0YXR1c10gPSBSZWFjdC51c2VTdGF0ZSgndW5tb3VudGVkJyk7XG4gIGNvbnN0IGlzTW91bnRlZCA9IHVzZURlbGF5VW5tb3VudChvcGVuLCBjbG9zZUR1cmF0aW9uKTtcbiAgaWYgKCFpc01vdW50ZWQgJiYgc3RhdHVzID09PSAnY2xvc2UnKSB7XG4gICAgc2V0U3RhdHVzKCd1bm1vdW50ZWQnKTtcbiAgfVxuICBpbmRleCgoKSA9PiB7XG4gICAgaWYgKCFmbG9hdGluZykgcmV0dXJuO1xuICAgIGlmIChvcGVuKSB7XG4gICAgICBzZXRTdGF0dXMoJ2luaXRpYWwnKTtcbiAgICAgIGNvbnN0IGZyYW1lID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgc2V0U3RhdHVzKCdvcGVuJyk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKGZyYW1lKTtcbiAgICAgIH07XG4gICAgfVxuICAgIHNldFN0YXR1cygnY2xvc2UnKTtcbiAgfSwgW29wZW4sIGZsb2F0aW5nXSk7XG4gIHJldHVybiB7XG4gICAgaXNNb3VudGVkLFxuICAgIHN0YXR1c1xuICB9O1xufVxuLyoqXG4gKiBQcm92aWRlcyBzdHlsZXMgdG8gYXBwbHkgQ1NTIHRyYW5zaXRpb25zIHRvIGEgZmxvYXRpbmcgZWxlbWVudCwgY29ycmVjdGx5XG4gKiBoYW5kbGluZyBwbGFjZW1lbnQtYXdhcmUgdHJhbnNpdGlvbnMuIFdyYXBwZXIgYXJvdW5kIGB1c2VUcmFuc2l0aW9uU3RhdHVzYC5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy91c2VUcmFuc2l0aW9uI3VzZXRyYW5zaXRpb25zdHlsZXNcbiAqL1xuZnVuY3Rpb24gdXNlVHJhbnNpdGlvblN0eWxlcyhjb250ZXh0LCBwcm9wcykge1xuICBpZiAocHJvcHMgPT09IHZvaWQgMCkge1xuICAgIHByb3BzID0ge307XG4gIH1cbiAgY29uc3Qge1xuICAgIGluaXRpYWw6IHVuc3RhYmxlX2luaXRpYWwgPSB7XG4gICAgICBvcGFjaXR5OiAwXG4gICAgfSxcbiAgICBvcGVuOiB1bnN0YWJsZV9vcGVuLFxuICAgIGNsb3NlOiB1bnN0YWJsZV9jbG9zZSxcbiAgICBjb21tb246IHVuc3RhYmxlX2NvbW1vbixcbiAgICBkdXJhdGlvbiA9IDI1MFxuICB9ID0gcHJvcHM7XG4gIGNvbnN0IHBsYWNlbWVudCA9IGNvbnRleHQucGxhY2VtZW50O1xuICBjb25zdCBzaWRlID0gcGxhY2VtZW50LnNwbGl0KCctJylbMF07XG4gIGNvbnN0IGZuQXJncyA9IFJlYWN0LnVzZU1lbW8oKCkgPT4gKHtcbiAgICBzaWRlLFxuICAgIHBsYWNlbWVudFxuICB9KSwgW3NpZGUsIHBsYWNlbWVudF0pO1xuICBjb25zdCBpc051bWJlckR1cmF0aW9uID0gdHlwZW9mIGR1cmF0aW9uID09PSAnbnVtYmVyJztcbiAgY29uc3Qgb3BlbkR1cmF0aW9uID0gKGlzTnVtYmVyRHVyYXRpb24gPyBkdXJhdGlvbiA6IGR1cmF0aW9uLm9wZW4pIHx8IDA7XG4gIGNvbnN0IGNsb3NlRHVyYXRpb24gPSAoaXNOdW1iZXJEdXJhdGlvbiA/IGR1cmF0aW9uIDogZHVyYXRpb24uY2xvc2UpIHx8IDA7XG4gIGNvbnN0IFtzdHlsZXMsIHNldFN0eWxlc10gPSBSZWFjdC51c2VTdGF0ZSgoKSA9PiAoe1xuICAgIC4uLmV4ZWNXaXRoQXJnc09yUmV0dXJuKHVuc3RhYmxlX2NvbW1vbiwgZm5BcmdzKSxcbiAgICAuLi5leGVjV2l0aEFyZ3NPclJldHVybih1bnN0YWJsZV9pbml0aWFsLCBmbkFyZ3MpXG4gIH0pKTtcbiAgY29uc3Qge1xuICAgIGlzTW91bnRlZCxcbiAgICBzdGF0dXNcbiAgfSA9IHVzZVRyYW5zaXRpb25TdGF0dXMoY29udGV4dCwge1xuICAgIGR1cmF0aW9uXG4gIH0pO1xuICBjb25zdCBpbml0aWFsUmVmID0gdXNlTGF0ZXN0UmVmKHVuc3RhYmxlX2luaXRpYWwpO1xuICBjb25zdCBvcGVuUmVmID0gdXNlTGF0ZXN0UmVmKHVuc3RhYmxlX29wZW4pO1xuICBjb25zdCBjbG9zZVJlZiA9IHVzZUxhdGVzdFJlZih1bnN0YWJsZV9jbG9zZSk7XG4gIGNvbnN0IGNvbW1vblJlZiA9IHVzZUxhdGVzdFJlZih1bnN0YWJsZV9jb21tb24pO1xuICBpbmRleCgoKSA9PiB7XG4gICAgY29uc3QgaW5pdGlhbFN0eWxlcyA9IGV4ZWNXaXRoQXJnc09yUmV0dXJuKGluaXRpYWxSZWYuY3VycmVudCwgZm5BcmdzKTtcbiAgICBjb25zdCBjbG9zZVN0eWxlcyA9IGV4ZWNXaXRoQXJnc09yUmV0dXJuKGNsb3NlUmVmLmN1cnJlbnQsIGZuQXJncyk7XG4gICAgY29uc3QgY29tbW9uU3R5bGVzID0gZXhlY1dpdGhBcmdzT3JSZXR1cm4oY29tbW9uUmVmLmN1cnJlbnQsIGZuQXJncyk7XG4gICAgY29uc3Qgb3BlblN0eWxlcyA9IGV4ZWNXaXRoQXJnc09yUmV0dXJuKG9wZW5SZWYuY3VycmVudCwgZm5BcmdzKSB8fCBPYmplY3Qua2V5cyhpbml0aWFsU3R5bGVzKS5yZWR1Y2UoKGFjYywga2V5KSA9PiB7XG4gICAgICBhY2Nba2V5XSA9ICcnO1xuICAgICAgcmV0dXJuIGFjYztcbiAgICB9LCB7fSk7XG4gICAgaWYgKHN0YXR1cyA9PT0gJ2luaXRpYWwnKSB7XG4gICAgICBzZXRTdHlsZXMoc3R5bGVzID0+ICh7XG4gICAgICAgIHRyYW5zaXRpb25Qcm9wZXJ0eTogc3R5bGVzLnRyYW5zaXRpb25Qcm9wZXJ0eSxcbiAgICAgICAgLi4uY29tbW9uU3R5bGVzLFxuICAgICAgICAuLi5pbml0aWFsU3R5bGVzXG4gICAgICB9KSk7XG4gICAgfVxuICAgIGlmIChzdGF0dXMgPT09ICdvcGVuJykge1xuICAgICAgc2V0U3R5bGVzKHtcbiAgICAgICAgdHJhbnNpdGlvblByb3BlcnR5OiBPYmplY3Qua2V5cyhvcGVuU3R5bGVzKS5tYXAoY2FtZWxDYXNlVG9LZWJhYkNhc2UpLmpvaW4oJywnKSxcbiAgICAgICAgdHJhbnNpdGlvbkR1cmF0aW9uOiBvcGVuRHVyYXRpb24gKyBcIm1zXCIsXG4gICAgICAgIC4uLmNvbW1vblN0eWxlcyxcbiAgICAgICAgLi4ub3BlblN0eWxlc1xuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChzdGF0dXMgPT09ICdjbG9zZScpIHtcbiAgICAgIGNvbnN0IHN0eWxlcyA9IGNsb3NlU3R5bGVzIHx8IGluaXRpYWxTdHlsZXM7XG4gICAgICBzZXRTdHlsZXMoe1xuICAgICAgICB0cmFuc2l0aW9uUHJvcGVydHk6IE9iamVjdC5rZXlzKHN0eWxlcykubWFwKGNhbWVsQ2FzZVRvS2ViYWJDYXNlKS5qb2luKCcsJyksXG4gICAgICAgIHRyYW5zaXRpb25EdXJhdGlvbjogY2xvc2VEdXJhdGlvbiArIFwibXNcIixcbiAgICAgICAgLi4uY29tbW9uU3R5bGVzLFxuICAgICAgICAuLi5zdHlsZXNcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwgW2Nsb3NlRHVyYXRpb24sIGNsb3NlUmVmLCBpbml0aWFsUmVmLCBvcGVuUmVmLCBjb21tb25SZWYsIG9wZW5EdXJhdGlvbiwgc3RhdHVzLCBmbkFyZ3NdKTtcbiAgcmV0dXJuIHtcbiAgICBpc01vdW50ZWQsXG4gICAgc3R5bGVzXG4gIH07XG59XG5cbi8qKlxuICogUHJvdmlkZXMgYSBtYXRjaGluZyBjYWxsYmFjayB0aGF0IGNhbiBiZSB1c2VkIHRvIGZvY3VzIGFuIGl0ZW0gYXMgdGhlIHVzZXJcbiAqIHR5cGVzLCBvZnRlbiB1c2VkIGluIHRhbmRlbSB3aXRoIGB1c2VMaXN0TmF2aWdhdGlvbigpYC5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy91c2VUeXBlYWhlYWRcbiAqL1xuZnVuY3Rpb24gdXNlVHlwZWFoZWFkKGNvbnRleHQsIHByb3BzKSB7XG4gIHZhciBfcmVmO1xuICBjb25zdCB7XG4gICAgb3BlbixcbiAgICBkYXRhUmVmXG4gIH0gPSBjb250ZXh0O1xuICBjb25zdCB7XG4gICAgbGlzdFJlZixcbiAgICBhY3RpdmVJbmRleCxcbiAgICBvbk1hdGNoOiB1bnN0YWJsZV9vbk1hdGNoLFxuICAgIG9uVHlwaW5nQ2hhbmdlOiB1bnN0YWJsZV9vblR5cGluZ0NoYW5nZSxcbiAgICBlbmFibGVkID0gdHJ1ZSxcbiAgICBmaW5kTWF0Y2ggPSBudWxsLFxuICAgIHJlc2V0TXMgPSA3NTAsXG4gICAgaWdub3JlS2V5cyA9IFtdLFxuICAgIHNlbGVjdGVkSW5kZXggPSBudWxsXG4gIH0gPSBwcm9wcztcbiAgY29uc3QgdGltZW91dElkUmVmID0gUmVhY3QudXNlUmVmKCk7XG4gIGNvbnN0IHN0cmluZ1JlZiA9IFJlYWN0LnVzZVJlZignJyk7XG4gIGNvbnN0IHByZXZJbmRleFJlZiA9IFJlYWN0LnVzZVJlZigoX3JlZiA9IHNlbGVjdGVkSW5kZXggIT0gbnVsbCA/IHNlbGVjdGVkSW5kZXggOiBhY3RpdmVJbmRleCkgIT0gbnVsbCA/IF9yZWYgOiAtMSk7XG4gIGNvbnN0IG1hdGNoSW5kZXhSZWYgPSBSZWFjdC51c2VSZWYobnVsbCk7XG4gIGNvbnN0IG9uTWF0Y2ggPSB1c2VFZmZlY3RFdmVudCh1bnN0YWJsZV9vbk1hdGNoKTtcbiAgY29uc3Qgb25UeXBpbmdDaGFuZ2UgPSB1c2VFZmZlY3RFdmVudCh1bnN0YWJsZV9vblR5cGluZ0NoYW5nZSk7XG4gIGNvbnN0IGZpbmRNYXRjaFJlZiA9IHVzZUxhdGVzdFJlZihmaW5kTWF0Y2gpO1xuICBjb25zdCBpZ25vcmVLZXlzUmVmID0gdXNlTGF0ZXN0UmVmKGlnbm9yZUtleXMpO1xuICBpbmRleCgoKSA9PiB7XG4gICAgaWYgKG9wZW4pIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SWRSZWYuY3VycmVudCk7XG4gICAgICBtYXRjaEluZGV4UmVmLmN1cnJlbnQgPSBudWxsO1xuICAgICAgc3RyaW5nUmVmLmN1cnJlbnQgPSAnJztcbiAgICB9XG4gIH0sIFtvcGVuXSk7XG4gIGluZGV4KCgpID0+IHtcbiAgICAvLyBTeW5jIGFycm93IGtleSBuYXZpZ2F0aW9uIGJ1dCBub3QgdHlwZWFoZWFkIG5hdmlnYXRpb24uXG4gICAgaWYgKG9wZW4gJiYgc3RyaW5nUmVmLmN1cnJlbnQgPT09ICcnKSB7XG4gICAgICB2YXIgX3JlZjI7XG4gICAgICBwcmV2SW5kZXhSZWYuY3VycmVudCA9IChfcmVmMiA9IHNlbGVjdGVkSW5kZXggIT0gbnVsbCA/IHNlbGVjdGVkSW5kZXggOiBhY3RpdmVJbmRleCkgIT0gbnVsbCA/IF9yZWYyIDogLTE7XG4gICAgfVxuICB9LCBbb3Blbiwgc2VsZWN0ZWRJbmRleCwgYWN0aXZlSW5kZXhdKTtcbiAgY29uc3Qgc2V0VHlwaW5nQ2hhbmdlID0gdXNlRWZmZWN0RXZlbnQodmFsdWUgPT4ge1xuICAgIGlmICh2YWx1ZSkge1xuICAgICAgaWYgKCFkYXRhUmVmLmN1cnJlbnQudHlwaW5nKSB7XG4gICAgICAgIGRhdGFSZWYuY3VycmVudC50eXBpbmcgPSB2YWx1ZTtcbiAgICAgICAgb25UeXBpbmdDaGFuZ2UodmFsdWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoZGF0YVJlZi5jdXJyZW50LnR5cGluZykge1xuICAgICAgICBkYXRhUmVmLmN1cnJlbnQudHlwaW5nID0gdmFsdWU7XG4gICAgICAgIG9uVHlwaW5nQ2hhbmdlKHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICBjb25zdCBvbktleURvd24gPSB1c2VFZmZlY3RFdmVudChldmVudCA9PiB7XG4gICAgZnVuY3Rpb24gZ2V0TWF0Y2hpbmdJbmRleChsaXN0LCBvcmRlcmVkTGlzdCwgc3RyaW5nKSB7XG4gICAgICBjb25zdCBzdHIgPSBmaW5kTWF0Y2hSZWYuY3VycmVudCA/IGZpbmRNYXRjaFJlZi5jdXJyZW50KG9yZGVyZWRMaXN0LCBzdHJpbmcpIDogb3JkZXJlZExpc3QuZmluZCh0ZXh0ID0+ICh0ZXh0ID09IG51bGwgPyB2b2lkIDAgOiB0ZXh0LnRvTG9jYWxlTG93ZXJDYXNlKCkuaW5kZXhPZihzdHJpbmcudG9Mb2NhbGVMb3dlckNhc2UoKSkpID09PSAwKTtcbiAgICAgIHJldHVybiBzdHIgPyBsaXN0LmluZGV4T2Yoc3RyKSA6IC0xO1xuICAgIH1cbiAgICBjb25zdCBsaXN0Q29udGVudCA9IGxpc3RSZWYuY3VycmVudDtcbiAgICBpZiAoc3RyaW5nUmVmLmN1cnJlbnQubGVuZ3RoID4gMCAmJiBzdHJpbmdSZWYuY3VycmVudFswXSAhPT0gJyAnKSB7XG4gICAgICBpZiAoZ2V0TWF0Y2hpbmdJbmRleChsaXN0Q29udGVudCwgbGlzdENvbnRlbnQsIHN0cmluZ1JlZi5jdXJyZW50KSA9PT0gLTEpIHtcbiAgICAgICAgc2V0VHlwaW5nQ2hhbmdlKGZhbHNlKTtcbiAgICAgIH0gZWxzZSBpZiAoZXZlbnQua2V5ID09PSAnICcpIHtcbiAgICAgICAgc3RvcEV2ZW50KGV2ZW50KTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGxpc3RDb250ZW50ID09IG51bGwgfHwgaWdub3JlS2V5c1JlZi5jdXJyZW50LmluY2x1ZGVzKGV2ZW50LmtleSkgfHxcbiAgICAvLyBDaGFyYWN0ZXIga2V5LlxuICAgIGV2ZW50LmtleS5sZW5ndGggIT09IDEgfHxcbiAgICAvLyBNb2RpZmllciBrZXkuXG4gICAgZXZlbnQuY3RybEtleSB8fCBldmVudC5tZXRhS2V5IHx8IGV2ZW50LmFsdEtleSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAob3BlbiAmJiBldmVudC5rZXkgIT09ICcgJykge1xuICAgICAgc3RvcEV2ZW50KGV2ZW50KTtcbiAgICAgIHNldFR5cGluZ0NoYW5nZSh0cnVlKTtcbiAgICB9XG5cbiAgICAvLyBCYWlsIG91dCBpZiB0aGUgbGlzdCBjb250YWlucyBhIHdvcmQgbGlrZSBcImxsYW1hXCIgb3IgXCJhYXJvblwiLiBUT0RPOlxuICAgIC8vIGFsbG93IGl0IGluIHRoaXMgY2FzZSwgdG9vLlxuICAgIGNvbnN0IGFsbG93UmFwaWRTdWNjZXNzaW9uT2ZGaXJzdExldHRlciA9IGxpc3RDb250ZW50LmV2ZXJ5KHRleHQgPT4ge1xuICAgICAgdmFyIF90ZXh0JCwgX3RleHQkMjtcbiAgICAgIHJldHVybiB0ZXh0ID8gKChfdGV4dCQgPSB0ZXh0WzBdKSA9PSBudWxsID8gdm9pZCAwIDogX3RleHQkLnRvTG9jYWxlTG93ZXJDYXNlKCkpICE9PSAoKF90ZXh0JDIgPSB0ZXh0WzFdKSA9PSBudWxsID8gdm9pZCAwIDogX3RleHQkMi50b0xvY2FsZUxvd2VyQ2FzZSgpKSA6IHRydWU7XG4gICAgfSk7XG5cbiAgICAvLyBBbGxvd3MgdGhlIHVzZXIgdG8gY3ljbGUgdGhyb3VnaCBpdGVtcyB0aGF0IHN0YXJ0IHdpdGggdGhlIHNhbWUgbGV0dGVyXG4gICAgLy8gaW4gcmFwaWQgc3VjY2Vzc2lvbi5cbiAgICBpZiAoYWxsb3dSYXBpZFN1Y2Nlc3Npb25PZkZpcnN0TGV0dGVyICYmIHN0cmluZ1JlZi5jdXJyZW50ID09PSBldmVudC5rZXkpIHtcbiAgICAgIHN0cmluZ1JlZi5jdXJyZW50ID0gJyc7XG4gICAgICBwcmV2SW5kZXhSZWYuY3VycmVudCA9IG1hdGNoSW5kZXhSZWYuY3VycmVudDtcbiAgICB9XG4gICAgc3RyaW5nUmVmLmN1cnJlbnQgKz0gZXZlbnQua2V5O1xuICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SWRSZWYuY3VycmVudCk7XG4gICAgdGltZW91dElkUmVmLmN1cnJlbnQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHN0cmluZ1JlZi5jdXJyZW50ID0gJyc7XG4gICAgICBwcmV2SW5kZXhSZWYuY3VycmVudCA9IG1hdGNoSW5kZXhSZWYuY3VycmVudDtcbiAgICAgIHNldFR5cGluZ0NoYW5nZShmYWxzZSk7XG4gICAgfSwgcmVzZXRNcyk7XG4gICAgY29uc3QgcHJldkluZGV4ID0gcHJldkluZGV4UmVmLmN1cnJlbnQ7XG4gICAgY29uc3QgaW5kZXggPSBnZXRNYXRjaGluZ0luZGV4KGxpc3RDb250ZW50LCBbLi4ubGlzdENvbnRlbnQuc2xpY2UoKHByZXZJbmRleCB8fCAwKSArIDEpLCAuLi5saXN0Q29udGVudC5zbGljZSgwLCAocHJldkluZGV4IHx8IDApICsgMSldLCBzdHJpbmdSZWYuY3VycmVudCk7XG4gICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgb25NYXRjaChpbmRleCk7XG4gICAgICBtYXRjaEluZGV4UmVmLmN1cnJlbnQgPSBpbmRleDtcbiAgICB9IGVsc2UgaWYgKGV2ZW50LmtleSAhPT0gJyAnKSB7XG4gICAgICBzdHJpbmdSZWYuY3VycmVudCA9ICcnO1xuICAgICAgc2V0VHlwaW5nQ2hhbmdlKGZhbHNlKTtcbiAgICB9XG4gIH0pO1xuICBjb25zdCByZWZlcmVuY2UgPSBSZWFjdC51c2VNZW1vKCgpID0+ICh7XG4gICAgb25LZXlEb3duXG4gIH0pLCBbb25LZXlEb3duXSk7XG4gIGNvbnN0IGZsb2F0aW5nID0gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG9uS2V5RG93bixcbiAgICAgIG9uS2V5VXAoZXZlbnQpIHtcbiAgICAgICAgaWYgKGV2ZW50LmtleSA9PT0gJyAnKSB7XG4gICAgICAgICAgc2V0VHlwaW5nQ2hhbmdlKGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH0sIFtvbktleURvd24sIHNldFR5cGluZ0NoYW5nZV0pO1xuICByZXR1cm4gUmVhY3QudXNlTWVtbygoKSA9PiBlbmFibGVkID8ge1xuICAgIHJlZmVyZW5jZSxcbiAgICBmbG9hdGluZ1xuICB9IDoge30sIFtlbmFibGVkLCByZWZlcmVuY2UsIGZsb2F0aW5nXSk7XG59XG5cbmZ1bmN0aW9uIGdldEFyZ3NXaXRoQ3VzdG9tRmxvYXRpbmdIZWlnaHQoc3RhdGUsIGhlaWdodCkge1xuICByZXR1cm4ge1xuICAgIC4uLnN0YXRlLFxuICAgIHJlY3RzOiB7XG4gICAgICAuLi5zdGF0ZS5yZWN0cyxcbiAgICAgIGZsb2F0aW5nOiB7XG4gICAgICAgIC4uLnN0YXRlLnJlY3RzLmZsb2F0aW5nLFxuICAgICAgICBoZWlnaHRcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG4vKipcbiAqIFBvc2l0aW9ucyB0aGUgZmxvYXRpbmcgZWxlbWVudCBzdWNoIHRoYXQgYW4gaW5uZXIgZWxlbWVudCBpbnNpZGUgb2YgaXQgaXNcbiAqIGFuY2hvcmVkIHRvIHRoZSByZWZlcmVuY2UgZWxlbWVudC5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9pbm5lclxuICovXG5jb25zdCBpbm5lciA9IHByb3BzID0+ICh7XG4gIG5hbWU6ICdpbm5lcicsXG4gIG9wdGlvbnM6IHByb3BzLFxuICBhc3luYyBmbihzdGF0ZSkge1xuICAgIGNvbnN0IHtcbiAgICAgIGxpc3RSZWYsXG4gICAgICBvdmVyZmxvd1JlZixcbiAgICAgIG9uRmFsbGJhY2tDaGFuZ2UsXG4gICAgICBvZmZzZXQ6IGlubmVyT2Zmc2V0ID0gMCxcbiAgICAgIGluZGV4ID0gMCxcbiAgICAgIG1pbkl0ZW1zVmlzaWJsZSA9IDQsXG4gICAgICByZWZlcmVuY2VPdmVyZmxvd1RocmVzaG9sZCA9IDAsXG4gICAgICBzY3JvbGxSZWYsXG4gICAgICAuLi5kZXRlY3RPdmVyZmxvd09wdGlvbnNcbiAgICB9ID0gZXZhbHVhdGUocHJvcHMsIHN0YXRlKTtcbiAgICBjb25zdCB7XG4gICAgICByZWN0cyxcbiAgICAgIGVsZW1lbnRzOiB7XG4gICAgICAgIGZsb2F0aW5nXG4gICAgICB9XG4gICAgfSA9IHN0YXRlO1xuICAgIGNvbnN0IGl0ZW0gPSBsaXN0UmVmLmN1cnJlbnRbaW5kZXhdO1xuICAgIGNvbnN0IHNjcm9sbEVsID0gKHNjcm9sbFJlZiA9PSBudWxsID8gdm9pZCAwIDogc2Nyb2xsUmVmLmN1cnJlbnQpIHx8IGZsb2F0aW5nO1xuXG4gICAgLy8gVmFsaWQgY29tYmluYXRpb25zOlxuICAgIC8vIDEuIEZsb2F0aW5nIGVsZW1lbnQgaXMgdGhlIHNjcm9sbFJlZiBhbmQgaGFzIGEgYm9yZGVyIChkZWZhdWx0KVxuICAgIC8vIDIuIEZsb2F0aW5nIGVsZW1lbnQgaXMgbm90IHRoZSBzY3JvbGxSZWYsIGZsb2F0aW5nIGVsZW1lbnQgaGFzIGEgYm9yZGVyXG4gICAgLy8gMy4gRmxvYXRpbmcgZWxlbWVudCBpcyBub3QgdGhlIHNjcm9sbFJlZiwgc2Nyb2xsUmVmIGhhcyBhIGJvcmRlclxuICAgIC8vIEZsb2F0aW5nID4gey4uLmdldEZsb2F0aW5nUHJvcHMoKX0gd3JhcHBlciA+IHNjcm9sbFJlZiA+IGl0ZW1zIGlzIG5vdFxuICAgIC8vIGFsbG93ZWQgYXMgVm9pY2VPdmVyIGRvZXNuJ3Qgd29yay5cbiAgICBjb25zdCBjbGllbnRUb3AgPSBmbG9hdGluZy5jbGllbnRUb3AgfHwgc2Nyb2xsRWwuY2xpZW50VG9wO1xuICAgIGNvbnN0IGZsb2F0aW5nSXNCb3JkZXJlZCA9IGZsb2F0aW5nLmNsaWVudFRvcCAhPT0gMDtcbiAgICBjb25zdCBzY3JvbGxFbElzQm9yZGVyZWQgPSBzY3JvbGxFbC5jbGllbnRUb3AgIT09IDA7XG4gICAgY29uc3QgZmxvYXRpbmdJc1Njcm9sbEVsID0gZmxvYXRpbmcgPT09IHNjcm9sbEVsO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgIGlmICghc3RhdGUucGxhY2VtZW50LnN0YXJ0c1dpdGgoJ2JvdHRvbScpKSB7XG4gICAgICAgIHdhcm4oJ2BwbGFjZW1lbnRgIHNpZGUgbXVzdCBiZSBcImJvdHRvbVwiIHdoZW4gdXNpbmcgdGhlIGBpbm5lcmAnLCAnbWlkZGxld2FyZS4nKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFpdGVtKSB7XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuICAgIGNvbnN0IG5leHRBcmdzID0ge1xuICAgICAgLi4uc3RhdGUsXG4gICAgICAuLi4oYXdhaXQgb2Zmc2V0KC1pdGVtLm9mZnNldFRvcCAtIGZsb2F0aW5nLmNsaWVudFRvcCAtIHJlY3RzLnJlZmVyZW5jZS5oZWlnaHQgLyAyIC0gaXRlbS5vZmZzZXRIZWlnaHQgLyAyIC0gaW5uZXJPZmZzZXQpLmZuKHN0YXRlKSlcbiAgICB9O1xuICAgIGNvbnN0IG92ZXJmbG93ID0gYXdhaXQgZGV0ZWN0T3ZlcmZsb3coZ2V0QXJnc1dpdGhDdXN0b21GbG9hdGluZ0hlaWdodChuZXh0QXJncywgc2Nyb2xsRWwuc2Nyb2xsSGVpZ2h0ICsgY2xpZW50VG9wICsgZmxvYXRpbmcuY2xpZW50VG9wKSwgZGV0ZWN0T3ZlcmZsb3dPcHRpb25zKTtcbiAgICBjb25zdCByZWZPdmVyZmxvdyA9IGF3YWl0IGRldGVjdE92ZXJmbG93KG5leHRBcmdzLCB7XG4gICAgICAuLi5kZXRlY3RPdmVyZmxvd09wdGlvbnMsXG4gICAgICBlbGVtZW50Q29udGV4dDogJ3JlZmVyZW5jZSdcbiAgICB9KTtcbiAgICBjb25zdCBkaWZmWSA9IG1heCgwLCBvdmVyZmxvdy50b3ApO1xuICAgIGNvbnN0IG5leHRZID0gbmV4dEFyZ3MueSArIGRpZmZZO1xuICAgIGNvbnN0IGlzU2Nyb2xsYWJsZSA9IHNjcm9sbEVsLnNjcm9sbEhlaWdodCA+IHNjcm9sbEVsLmNsaWVudEhlaWdodDtcbiAgICBjb25zdCByb3VuZGVyID0gaXNTY3JvbGxhYmxlID8gdiA9PiB2IDogcm91bmQ7XG4gICAgY29uc3QgbWF4SGVpZ2h0ID0gcm91bmRlcihtYXgoMCwgc2Nyb2xsRWwuc2Nyb2xsSGVpZ2h0ICsgKGZsb2F0aW5nSXNCb3JkZXJlZCAmJiBmbG9hdGluZ0lzU2Nyb2xsRWwgfHwgc2Nyb2xsRWxJc0JvcmRlcmVkID8gY2xpZW50VG9wICogMiA6IDApIC0gZGlmZlkgLSBtYXgoMCwgb3ZlcmZsb3cuYm90dG9tKSkpO1xuICAgIHNjcm9sbEVsLnN0eWxlLm1heEhlaWdodCA9IG1heEhlaWdodCArIFwicHhcIjtcbiAgICBzY3JvbGxFbC5zY3JvbGxUb3AgPSBkaWZmWTtcblxuICAgIC8vIFRoZXJlIGlzIG5vdCBlbm91Z2ggc3BhY2UsIGZhbGxiYWNrIHRvIHN0YW5kYXJkIGFuY2hvcmVkIHBvc2l0aW9uaW5nXG4gICAgaWYgKG9uRmFsbGJhY2tDaGFuZ2UpIHtcbiAgICAgIGNvbnN0IHNob3VsZEZhbGxiYWNrID0gc2Nyb2xsRWwub2Zmc2V0SGVpZ2h0IDwgaXRlbS5vZmZzZXRIZWlnaHQgKiBtaW4obWluSXRlbXNWaXNpYmxlLCBsaXN0UmVmLmN1cnJlbnQubGVuZ3RoKSAtIDEgfHwgcmVmT3ZlcmZsb3cudG9wID49IC1yZWZlcmVuY2VPdmVyZmxvd1RocmVzaG9sZCB8fCByZWZPdmVyZmxvdy5ib3R0b20gPj0gLXJlZmVyZW5jZU92ZXJmbG93VGhyZXNob2xkO1xuICAgICAgUmVhY3RET00uZmx1c2hTeW5jKCgpID0+IG9uRmFsbGJhY2tDaGFuZ2Uoc2hvdWxkRmFsbGJhY2spKTtcbiAgICB9XG4gICAgaWYgKG92ZXJmbG93UmVmKSB7XG4gICAgICBvdmVyZmxvd1JlZi5jdXJyZW50ID0gYXdhaXQgZGV0ZWN0T3ZlcmZsb3coZ2V0QXJnc1dpdGhDdXN0b21GbG9hdGluZ0hlaWdodCh7XG4gICAgICAgIC4uLm5leHRBcmdzLFxuICAgICAgICB5OiBuZXh0WVxuICAgICAgfSwgc2Nyb2xsRWwub2Zmc2V0SGVpZ2h0ICsgY2xpZW50VG9wICsgZmxvYXRpbmcuY2xpZW50VG9wKSwgZGV0ZWN0T3ZlcmZsb3dPcHRpb25zKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHk6IG5leHRZXG4gICAgfTtcbiAgfVxufSk7XG4vKipcbiAqIENoYW5nZXMgdGhlIGBpbm5lcmAgbWlkZGxld2FyZSdzIGBvZmZzZXRgIHVwb24gYSBgd2hlZWxgIGV2ZW50IHRvXG4gKiBleHBhbmQgdGhlIGZsb2F0aW5nIGVsZW1lbnQncyBoZWlnaHQsIHJldmVhbGluZyBtb3JlIGxpc3QgaXRlbXMuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvaW5uZXJcbiAqL1xuZnVuY3Rpb24gdXNlSW5uZXJPZmZzZXQoY29udGV4dCwgcHJvcHMpIHtcbiAgY29uc3Qge1xuICAgIG9wZW4sXG4gICAgZWxlbWVudHNcbiAgfSA9IGNvbnRleHQ7XG4gIGNvbnN0IHtcbiAgICBlbmFibGVkID0gdHJ1ZSxcbiAgICBvdmVyZmxvd1JlZixcbiAgICBzY3JvbGxSZWYsXG4gICAgb25DaGFuZ2U6IHVuc3RhYmxlX29uQ2hhbmdlXG4gIH0gPSBwcm9wcztcbiAgY29uc3Qgb25DaGFuZ2UgPSB1c2VFZmZlY3RFdmVudCh1bnN0YWJsZV9vbkNoYW5nZSk7XG4gIGNvbnN0IGNvbnRyb2xsZWRTY3JvbGxpbmdSZWYgPSBSZWFjdC51c2VSZWYoZmFsc2UpO1xuICBjb25zdCBwcmV2U2Nyb2xsVG9wUmVmID0gUmVhY3QudXNlUmVmKG51bGwpO1xuICBjb25zdCBpbml0aWFsT3ZlcmZsb3dSZWYgPSBSZWFjdC51c2VSZWYobnVsbCk7XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFlbmFibGVkKSByZXR1cm47XG4gICAgZnVuY3Rpb24gb25XaGVlbChlKSB7XG4gICAgICBpZiAoZS5jdHJsS2V5IHx8ICFlbCB8fCBvdmVyZmxvd1JlZi5jdXJyZW50ID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgZFkgPSBlLmRlbHRhWTtcbiAgICAgIGNvbnN0IGlzQXRUb3AgPSBvdmVyZmxvd1JlZi5jdXJyZW50LnRvcCA+PSAtMC41O1xuICAgICAgY29uc3QgaXNBdEJvdHRvbSA9IG92ZXJmbG93UmVmLmN1cnJlbnQuYm90dG9tID49IC0wLjU7XG4gICAgICBjb25zdCByZW1haW5pbmdTY3JvbGwgPSBlbC5zY3JvbGxIZWlnaHQgLSBlbC5jbGllbnRIZWlnaHQ7XG4gICAgICBjb25zdCBzaWduID0gZFkgPCAwID8gLTEgOiAxO1xuICAgICAgY29uc3QgbWV0aG9kID0gZFkgPCAwID8gJ21heCcgOiAnbWluJztcbiAgICAgIGlmIChlbC5zY3JvbGxIZWlnaHQgPD0gZWwuY2xpZW50SGVpZ2h0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICghaXNBdFRvcCAmJiBkWSA+IDAgfHwgIWlzQXRCb3R0b20gJiYgZFkgPCAwKSB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgUmVhY3RET00uZmx1c2hTeW5jKCgpID0+IHtcbiAgICAgICAgICBvbkNoYW5nZShkID0+IGQgKyBNYXRoW21ldGhvZF0oZFksIHJlbWFpbmluZ1Njcm9sbCAqIHNpZ24pKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKC9maXJlZm94L2kudGVzdChnZXRVc2VyQWdlbnQoKSkpIHtcbiAgICAgICAgLy8gTmVlZGVkIHRvIHByb3BhZ2F0ZSBzY3JvbGxpbmcgZHVyaW5nIG1vbWVudHVtIHNjcm9sbGluZyBwaGFzZSBvbmNlXG4gICAgICAgIC8vIGl0IGdldHMgbGltaXRlZCBieSB0aGUgYm91bmRhcnkuIFVYIGltcHJvdmVtZW50LCBub3QgY3JpdGljYWwuXG4gICAgICAgIGVsLnNjcm9sbFRvcCArPSBkWTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgZWwgPSAoc2Nyb2xsUmVmID09IG51bGwgPyB2b2lkIDAgOiBzY3JvbGxSZWYuY3VycmVudCkgfHwgZWxlbWVudHMuZmxvYXRpbmc7XG4gICAgaWYgKG9wZW4gJiYgZWwpIHtcbiAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ3doZWVsJywgb25XaGVlbCk7XG5cbiAgICAgIC8vIFdhaXQgZm9yIHRoZSBwb3NpdGlvbiB0byBiZSByZWFkeS5cbiAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAgIHByZXZTY3JvbGxUb3BSZWYuY3VycmVudCA9IGVsLnNjcm9sbFRvcDtcbiAgICAgICAgaWYgKG92ZXJmbG93UmVmLmN1cnJlbnQgIT0gbnVsbCkge1xuICAgICAgICAgIGluaXRpYWxPdmVyZmxvd1JlZi5jdXJyZW50ID0ge1xuICAgICAgICAgICAgLi4ub3ZlcmZsb3dSZWYuY3VycmVudFxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgcHJldlNjcm9sbFRvcFJlZi5jdXJyZW50ID0gbnVsbDtcbiAgICAgICAgaW5pdGlhbE92ZXJmbG93UmVmLmN1cnJlbnQgPSBudWxsO1xuICAgICAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKCd3aGVlbCcsIG9uV2hlZWwpO1xuICAgICAgfTtcbiAgICB9XG4gIH0sIFtlbmFibGVkLCBvcGVuLCBlbGVtZW50cy5mbG9hdGluZywgb3ZlcmZsb3dSZWYsIHNjcm9sbFJlZiwgb25DaGFuZ2VdKTtcbiAgY29uc3QgZmxvYXRpbmcgPSBSZWFjdC51c2VNZW1vKCgpID0+ICh7XG4gICAgb25LZXlEb3duKCkge1xuICAgICAgY29udHJvbGxlZFNjcm9sbGluZ1JlZi5jdXJyZW50ID0gdHJ1ZTtcbiAgICB9LFxuICAgIG9uV2hlZWwoKSB7XG4gICAgICBjb250cm9sbGVkU2Nyb2xsaW5nUmVmLmN1cnJlbnQgPSBmYWxzZTtcbiAgICB9LFxuICAgIG9uUG9pbnRlck1vdmUoKSB7XG4gICAgICBjb250cm9sbGVkU2Nyb2xsaW5nUmVmLmN1cnJlbnQgPSBmYWxzZTtcbiAgICB9LFxuICAgIG9uU2Nyb2xsKCkge1xuICAgICAgY29uc3QgZWwgPSAoc2Nyb2xsUmVmID09IG51bGwgPyB2b2lkIDAgOiBzY3JvbGxSZWYuY3VycmVudCkgfHwgZWxlbWVudHMuZmxvYXRpbmc7XG4gICAgICBpZiAoIW92ZXJmbG93UmVmLmN1cnJlbnQgfHwgIWVsIHx8ICFjb250cm9sbGVkU2Nyb2xsaW5nUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHByZXZTY3JvbGxUb3BSZWYuY3VycmVudCAhPT0gbnVsbCkge1xuICAgICAgICBjb25zdCBzY3JvbGxEaWZmID0gZWwuc2Nyb2xsVG9wIC0gcHJldlNjcm9sbFRvcFJlZi5jdXJyZW50O1xuICAgICAgICBpZiAob3ZlcmZsb3dSZWYuY3VycmVudC5ib3R0b20gPCAtMC41ICYmIHNjcm9sbERpZmYgPCAtMSB8fCBvdmVyZmxvd1JlZi5jdXJyZW50LnRvcCA8IC0wLjUgJiYgc2Nyb2xsRGlmZiA+IDEpIHtcbiAgICAgICAgICBSZWFjdERPTS5mbHVzaFN5bmMoKCkgPT4gb25DaGFuZ2UoZCA9PiBkICsgc2Nyb2xsRGlmZikpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFtGaXJlZm94XSBXYWl0IGZvciB0aGUgaGVpZ2h0IGNoYW5nZSB0byBoYXZlIGJlZW4gYXBwbGllZC5cbiAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAgIHByZXZTY3JvbGxUb3BSZWYuY3VycmVudCA9IGVsLnNjcm9sbFRvcDtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSksIFtlbGVtZW50cy5mbG9hdGluZywgb25DaGFuZ2UsIG92ZXJmbG93UmVmLCBzY3JvbGxSZWZdKTtcbiAgcmV0dXJuIFJlYWN0LnVzZU1lbW8oKCkgPT4gZW5hYmxlZCA/IHtcbiAgICBmbG9hdGluZ1xuICB9IDoge30sIFtlbmFibGVkLCBmbG9hdGluZ10pO1xufVxuXG5mdW5jdGlvbiBpc1BvaW50SW5Qb2x5Z29uKHBvaW50LCBwb2x5Z29uKSB7XG4gIGNvbnN0IFt4LCB5XSA9IHBvaW50O1xuICBsZXQgaXNJbnNpZGUgPSBmYWxzZTtcbiAgY29uc3QgbGVuZ3RoID0gcG9seWdvbi5sZW5ndGg7XG4gIGZvciAobGV0IGkgPSAwLCBqID0gbGVuZ3RoIC0gMTsgaSA8IGxlbmd0aDsgaiA9IGkrKykge1xuICAgIGNvbnN0IFt4aSwgeWldID0gcG9seWdvbltpXSB8fCBbMCwgMF07XG4gICAgY29uc3QgW3hqLCB5al0gPSBwb2x5Z29uW2pdIHx8IFswLCAwXTtcbiAgICBjb25zdCBpbnRlcnNlY3QgPSB5aSA+PSB5ICE9PSB5aiA+PSB5ICYmIHggPD0gKHhqIC0geGkpICogKHkgLSB5aSkgLyAoeWogLSB5aSkgKyB4aTtcbiAgICBpZiAoaW50ZXJzZWN0KSB7XG4gICAgICBpc0luc2lkZSA9ICFpc0luc2lkZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGlzSW5zaWRlO1xufVxuZnVuY3Rpb24gaXNJbnNpZGUocG9pbnQsIHJlY3QpIHtcbiAgcmV0dXJuIHBvaW50WzBdID49IHJlY3QueCAmJiBwb2ludFswXSA8PSByZWN0LnggKyByZWN0LndpZHRoICYmIHBvaW50WzFdID49IHJlY3QueSAmJiBwb2ludFsxXSA8PSByZWN0LnkgKyByZWN0LmhlaWdodDtcbn1cbi8qKlxuICogR2VuZXJhdGVzIGEgc2FmZSBwb2x5Z29uIGFyZWEgdGhhdCB0aGUgdXNlciBjYW4gdHJhdmVyc2Ugd2l0aG91dCBjbG9zaW5nIHRoZVxuICogZmxvYXRpbmcgZWxlbWVudCBvbmNlIGxlYXZpbmcgdGhlIHJlZmVyZW5jZSBlbGVtZW50LlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL3VzZUhvdmVyI3NhZmVwb2x5Z29uXG4gKi9cbmZ1bmN0aW9uIHNhZmVQb2x5Z29uKG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuICBjb25zdCB7XG4gICAgYnVmZmVyID0gMC41LFxuICAgIGJsb2NrUG9pbnRlckV2ZW50cyA9IGZhbHNlLFxuICAgIHJlcXVpcmVJbnRlbnQgPSB0cnVlXG4gIH0gPSBvcHRpb25zO1xuICBsZXQgdGltZW91dElkO1xuICBsZXQgaGFzTGFuZGVkID0gZmFsc2U7XG4gIGxldCBsYXN0WCA9IG51bGw7XG4gIGxldCBsYXN0WSA9IG51bGw7XG4gIGxldCBsYXN0Q3Vyc29yVGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICBmdW5jdGlvbiBnZXRDdXJzb3JTcGVlZCh4LCB5KSB7XG4gICAgY29uc3QgY3VycmVudFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICBjb25zdCBlbGFwc2VkVGltZSA9IGN1cnJlbnRUaW1lIC0gbGFzdEN1cnNvclRpbWU7XG4gICAgaWYgKGxhc3RYID09PSBudWxsIHx8IGxhc3RZID09PSBudWxsIHx8IGVsYXBzZWRUaW1lID09PSAwKSB7XG4gICAgICBsYXN0WCA9IHg7XG4gICAgICBsYXN0WSA9IHk7XG4gICAgICBsYXN0Q3Vyc29yVGltZSA9IGN1cnJlbnRUaW1lO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IGRlbHRhWCA9IHggLSBsYXN0WDtcbiAgICBjb25zdCBkZWx0YVkgPSB5IC0gbGFzdFk7XG4gICAgY29uc3QgZGlzdGFuY2UgPSBNYXRoLnNxcnQoZGVsdGFYICogZGVsdGFYICsgZGVsdGFZICogZGVsdGFZKTtcbiAgICBjb25zdCBzcGVlZCA9IGRpc3RhbmNlIC8gZWxhcHNlZFRpbWU7IC8vIHB4IC8gbXNcblxuICAgIGxhc3RYID0geDtcbiAgICBsYXN0WSA9IHk7XG4gICAgbGFzdEN1cnNvclRpbWUgPSBjdXJyZW50VGltZTtcbiAgICByZXR1cm4gc3BlZWQ7XG4gIH1cbiAgY29uc3QgZm4gPSBfcmVmID0+IHtcbiAgICBsZXQge1xuICAgICAgeCxcbiAgICAgIHksXG4gICAgICBwbGFjZW1lbnQsXG4gICAgICBlbGVtZW50cyxcbiAgICAgIG9uQ2xvc2UsXG4gICAgICBub2RlSWQsXG4gICAgICB0cmVlXG4gICAgfSA9IF9yZWY7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIG9uTW91c2VNb3ZlKGV2ZW50KSB7XG4gICAgICBmdW5jdGlvbiBjbG9zZSgpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gICAgICAgIG9uQ2xvc2UoKTtcbiAgICAgIH1cbiAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SWQpO1xuICAgICAgaWYgKCFlbGVtZW50cy5kb21SZWZlcmVuY2UgfHwgIWVsZW1lbnRzLmZsb2F0aW5nIHx8IHBsYWNlbWVudCA9PSBudWxsIHx8IHggPT0gbnVsbCB8fCB5ID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3Qge1xuICAgICAgICBjbGllbnRYLFxuICAgICAgICBjbGllbnRZXG4gICAgICB9ID0gZXZlbnQ7XG4gICAgICBjb25zdCBjbGllbnRQb2ludCA9IFtjbGllbnRYLCBjbGllbnRZXTtcbiAgICAgIGNvbnN0IHRhcmdldCA9IGdldFRhcmdldChldmVudCk7XG4gICAgICBjb25zdCBpc0xlYXZlID0gZXZlbnQudHlwZSA9PT0gJ21vdXNlbGVhdmUnO1xuICAgICAgY29uc3QgaXNPdmVyRmxvYXRpbmdFbCA9IGNvbnRhaW5zKGVsZW1lbnRzLmZsb2F0aW5nLCB0YXJnZXQpO1xuICAgICAgY29uc3QgaXNPdmVyUmVmZXJlbmNlRWwgPSBjb250YWlucyhlbGVtZW50cy5kb21SZWZlcmVuY2UsIHRhcmdldCk7XG4gICAgICBjb25zdCByZWZSZWN0ID0gZWxlbWVudHMuZG9tUmVmZXJlbmNlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgY29uc3QgcmVjdCA9IGVsZW1lbnRzLmZsb2F0aW5nLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgY29uc3Qgc2lkZSA9IHBsYWNlbWVudC5zcGxpdCgnLScpWzBdO1xuICAgICAgY29uc3QgY3Vyc29yTGVhdmVGcm9tUmlnaHQgPSB4ID4gcmVjdC5yaWdodCAtIHJlY3Qud2lkdGggLyAyO1xuICAgICAgY29uc3QgY3Vyc29yTGVhdmVGcm9tQm90dG9tID0geSA+IHJlY3QuYm90dG9tIC0gcmVjdC5oZWlnaHQgLyAyO1xuICAgICAgY29uc3QgaXNPdmVyUmVmZXJlbmNlUmVjdCA9IGlzSW5zaWRlKGNsaWVudFBvaW50LCByZWZSZWN0KTtcbiAgICAgIGNvbnN0IGlzRmxvYXRpbmdXaWRlciA9IHJlY3Qud2lkdGggPiByZWZSZWN0LndpZHRoO1xuICAgICAgY29uc3QgaXNGbG9hdGluZ1RhbGxlciA9IHJlY3QuaGVpZ2h0ID4gcmVmUmVjdC5oZWlnaHQ7XG4gICAgICBjb25zdCBsZWZ0ID0gKGlzRmxvYXRpbmdXaWRlciA/IHJlZlJlY3QgOiByZWN0KS5sZWZ0O1xuICAgICAgY29uc3QgcmlnaHQgPSAoaXNGbG9hdGluZ1dpZGVyID8gcmVmUmVjdCA6IHJlY3QpLnJpZ2h0O1xuICAgICAgY29uc3QgdG9wID0gKGlzRmxvYXRpbmdUYWxsZXIgPyByZWZSZWN0IDogcmVjdCkudG9wO1xuICAgICAgY29uc3QgYm90dG9tID0gKGlzRmxvYXRpbmdUYWxsZXIgPyByZWZSZWN0IDogcmVjdCkuYm90dG9tO1xuICAgICAgaWYgKGlzT3ZlckZsb2F0aW5nRWwpIHtcbiAgICAgICAgaGFzTGFuZGVkID0gdHJ1ZTtcbiAgICAgICAgaWYgKCFpc0xlYXZlKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoaXNPdmVyUmVmZXJlbmNlRWwpIHtcbiAgICAgICAgaGFzTGFuZGVkID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAoaXNPdmVyUmVmZXJlbmNlRWwgJiYgIWlzTGVhdmUpIHtcbiAgICAgICAgaGFzTGFuZGVkID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBQcmV2ZW50IG92ZXJsYXBwaW5nIGZsb2F0aW5nIGVsZW1lbnQgZnJvbSBiZWluZyBzdHVjayBpbiBhbiBvcGVuLWNsb3NlXG4gICAgICAvLyBsb29wOiBodHRwczovL2dpdGh1Yi5jb20vZmxvYXRpbmctdWkvZmxvYXRpbmctdWkvaXNzdWVzLzE5MTBcbiAgICAgIGlmIChpc0xlYXZlICYmIGlzRWxlbWVudChldmVudC5yZWxhdGVkVGFyZ2V0KSAmJiBjb250YWlucyhlbGVtZW50cy5mbG9hdGluZywgZXZlbnQucmVsYXRlZFRhcmdldCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBJZiBhbnkgbmVzdGVkIGNoaWxkIGlzIG9wZW4sIGFib3J0LlxuICAgICAgaWYgKHRyZWUgJiYgZ2V0Q2hpbGRyZW4odHJlZS5ub2Rlc1JlZi5jdXJyZW50LCBub2RlSWQpLnNvbWUoX3JlZjIgPT4ge1xuICAgICAgICBsZXQge1xuICAgICAgICAgIGNvbnRleHRcbiAgICAgICAgfSA9IF9yZWYyO1xuICAgICAgICByZXR1cm4gY29udGV4dCA9PSBudWxsID8gdm9pZCAwIDogY29udGV4dC5vcGVuO1xuICAgICAgfSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBJZiB0aGUgcG9pbnRlciBpcyBsZWF2aW5nIGZyb20gdGhlIG9wcG9zaXRlIHNpZGUsIHRoZSBcImJ1ZmZlclwiIGxvZ2ljXG4gICAgICAvLyBjcmVhdGVzIGEgcG9pbnQgd2hlcmUgdGhlIGZsb2F0aW5nIGVsZW1lbnQgcmVtYWlucyBvcGVuLCBidXQgc2hvdWxkIGJlXG4gICAgICAvLyBpZ25vcmVkLlxuICAgICAgLy8gQSBjb25zdGFudCBvZiAxIGhhbmRsZXMgZmxvYXRpbmcgcG9pbnQgcm91bmRpbmcgZXJyb3JzLlxuICAgICAgaWYgKHNpZGUgPT09ICd0b3AnICYmIHkgPj0gcmVmUmVjdC5ib3R0b20gLSAxIHx8IHNpZGUgPT09ICdib3R0b20nICYmIHkgPD0gcmVmUmVjdC50b3AgKyAxIHx8IHNpZGUgPT09ICdsZWZ0JyAmJiB4ID49IHJlZlJlY3QucmlnaHQgLSAxIHx8IHNpZGUgPT09ICdyaWdodCcgJiYgeCA8PSByZWZSZWN0LmxlZnQgKyAxKSB7XG4gICAgICAgIHJldHVybiBjbG9zZSgpO1xuICAgICAgfVxuXG4gICAgICAvLyBJZ25vcmUgd2hlbiB0aGUgY3Vyc29yIGlzIHdpdGhpbiB0aGUgcmVjdGFuZ3VsYXIgdHJvdWdoIGJldHdlZW4gdGhlXG4gICAgICAvLyB0d28gZWxlbWVudHMuIFNpbmNlIHRoZSB0cmlhbmdsZSBpcyBjcmVhdGVkIGZyb20gdGhlIGN1cnNvciBwb2ludCxcbiAgICAgIC8vIHdoaWNoIGNhbiBzdGFydCBiZXlvbmQgdGhlIHJlZiBlbGVtZW50J3MgZWRnZSwgdHJhdmVyc2luZyBiYWNrIGFuZFxuICAgICAgLy8gZm9ydGggZnJvbSB0aGUgcmVmIHRvIHRoZSBmbG9hdGluZyBlbGVtZW50IGNhbiBjYXVzZSBpdCB0byBjbG9zZS4gVGhpc1xuICAgICAgLy8gZW5zdXJlcyBpdCBhbHdheXMgcmVtYWlucyBvcGVuIGluIHRoYXQgY2FzZS5cbiAgICAgIGxldCByZWN0UG9seSA9IFtdO1xuICAgICAgc3dpdGNoIChzaWRlKSB7XG4gICAgICAgIGNhc2UgJ3RvcCc6XG4gICAgICAgICAgcmVjdFBvbHkgPSBbW2xlZnQsIHJlZlJlY3QudG9wICsgMV0sIFtsZWZ0LCByZWN0LmJvdHRvbSAtIDFdLCBbcmlnaHQsIHJlY3QuYm90dG9tIC0gMV0sIFtyaWdodCwgcmVmUmVjdC50b3AgKyAxXV07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2JvdHRvbSc6XG4gICAgICAgICAgcmVjdFBvbHkgPSBbW2xlZnQsIHJlY3QudG9wICsgMV0sIFtsZWZ0LCByZWZSZWN0LmJvdHRvbSAtIDFdLCBbcmlnaHQsIHJlZlJlY3QuYm90dG9tIC0gMV0sIFtyaWdodCwgcmVjdC50b3AgKyAxXV07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2xlZnQnOlxuICAgICAgICAgIHJlY3RQb2x5ID0gW1tyZWN0LnJpZ2h0IC0gMSwgYm90dG9tXSwgW3JlY3QucmlnaHQgLSAxLCB0b3BdLCBbcmVmUmVjdC5sZWZ0ICsgMSwgdG9wXSwgW3JlZlJlY3QubGVmdCArIDEsIGJvdHRvbV1dO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdyaWdodCc6XG4gICAgICAgICAgcmVjdFBvbHkgPSBbW3JlZlJlY3QucmlnaHQgLSAxLCBib3R0b21dLCBbcmVmUmVjdC5yaWdodCAtIDEsIHRvcF0sIFtyZWN0LmxlZnQgKyAxLCB0b3BdLCBbcmVjdC5sZWZ0ICsgMSwgYm90dG9tXV07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBnZXRQb2x5Z29uKF9yZWYzKSB7XG4gICAgICAgIGxldCBbeCwgeV0gPSBfcmVmMztcbiAgICAgICAgc3dpdGNoIChzaWRlKSB7XG4gICAgICAgICAgY2FzZSAndG9wJzpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgY29uc3QgY3Vyc29yUG9pbnRPbmUgPSBbaXNGbG9hdGluZ1dpZGVyID8geCArIGJ1ZmZlciAvIDIgOiBjdXJzb3JMZWF2ZUZyb21SaWdodCA/IHggKyBidWZmZXIgKiA0IDogeCAtIGJ1ZmZlciAqIDQsIHkgKyBidWZmZXIgKyAxXTtcbiAgICAgICAgICAgICAgY29uc3QgY3Vyc29yUG9pbnRUd28gPSBbaXNGbG9hdGluZ1dpZGVyID8geCAtIGJ1ZmZlciAvIDIgOiBjdXJzb3JMZWF2ZUZyb21SaWdodCA/IHggKyBidWZmZXIgKiA0IDogeCAtIGJ1ZmZlciAqIDQsIHkgKyBidWZmZXIgKyAxXTtcbiAgICAgICAgICAgICAgY29uc3QgY29tbW9uUG9pbnRzID0gW1tyZWN0LmxlZnQsIGN1cnNvckxlYXZlRnJvbVJpZ2h0ID8gcmVjdC5ib3R0b20gLSBidWZmZXIgOiBpc0Zsb2F0aW5nV2lkZXIgPyByZWN0LmJvdHRvbSAtIGJ1ZmZlciA6IHJlY3QudG9wXSwgW3JlY3QucmlnaHQsIGN1cnNvckxlYXZlRnJvbVJpZ2h0ID8gaXNGbG9hdGluZ1dpZGVyID8gcmVjdC5ib3R0b20gLSBidWZmZXIgOiByZWN0LnRvcCA6IHJlY3QuYm90dG9tIC0gYnVmZmVyXV07XG4gICAgICAgICAgICAgIHJldHVybiBbY3Vyc29yUG9pbnRPbmUsIGN1cnNvclBvaW50VHdvLCAuLi5jb21tb25Qb2ludHNdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgJ2JvdHRvbSc6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGNvbnN0IGN1cnNvclBvaW50T25lID0gW2lzRmxvYXRpbmdXaWRlciA/IHggKyBidWZmZXIgLyAyIDogY3Vyc29yTGVhdmVGcm9tUmlnaHQgPyB4ICsgYnVmZmVyICogNCA6IHggLSBidWZmZXIgKiA0LCB5IC0gYnVmZmVyXTtcbiAgICAgICAgICAgICAgY29uc3QgY3Vyc29yUG9pbnRUd28gPSBbaXNGbG9hdGluZ1dpZGVyID8geCAtIGJ1ZmZlciAvIDIgOiBjdXJzb3JMZWF2ZUZyb21SaWdodCA/IHggKyBidWZmZXIgKiA0IDogeCAtIGJ1ZmZlciAqIDQsIHkgLSBidWZmZXJdO1xuICAgICAgICAgICAgICBjb25zdCBjb21tb25Qb2ludHMgPSBbW3JlY3QubGVmdCwgY3Vyc29yTGVhdmVGcm9tUmlnaHQgPyByZWN0LnRvcCArIGJ1ZmZlciA6IGlzRmxvYXRpbmdXaWRlciA/IHJlY3QudG9wICsgYnVmZmVyIDogcmVjdC5ib3R0b21dLCBbcmVjdC5yaWdodCwgY3Vyc29yTGVhdmVGcm9tUmlnaHQgPyBpc0Zsb2F0aW5nV2lkZXIgPyByZWN0LnRvcCArIGJ1ZmZlciA6IHJlY3QuYm90dG9tIDogcmVjdC50b3AgKyBidWZmZXJdXTtcbiAgICAgICAgICAgICAgcmV0dXJuIFtjdXJzb3JQb2ludE9uZSwgY3Vyc29yUG9pbnRUd28sIC4uLmNvbW1vblBvaW50c107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSAnbGVmdCc6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGNvbnN0IGN1cnNvclBvaW50T25lID0gW3ggKyBidWZmZXIgKyAxLCBpc0Zsb2F0aW5nVGFsbGVyID8geSArIGJ1ZmZlciAvIDIgOiBjdXJzb3JMZWF2ZUZyb21Cb3R0b20gPyB5ICsgYnVmZmVyICogNCA6IHkgLSBidWZmZXIgKiA0XTtcbiAgICAgICAgICAgICAgY29uc3QgY3Vyc29yUG9pbnRUd28gPSBbeCArIGJ1ZmZlciArIDEsIGlzRmxvYXRpbmdUYWxsZXIgPyB5IC0gYnVmZmVyIC8gMiA6IGN1cnNvckxlYXZlRnJvbUJvdHRvbSA/IHkgKyBidWZmZXIgKiA0IDogeSAtIGJ1ZmZlciAqIDRdO1xuICAgICAgICAgICAgICBjb25zdCBjb21tb25Qb2ludHMgPSBbW2N1cnNvckxlYXZlRnJvbUJvdHRvbSA/IHJlY3QucmlnaHQgLSBidWZmZXIgOiBpc0Zsb2F0aW5nVGFsbGVyID8gcmVjdC5yaWdodCAtIGJ1ZmZlciA6IHJlY3QubGVmdCwgcmVjdC50b3BdLCBbY3Vyc29yTGVhdmVGcm9tQm90dG9tID8gaXNGbG9hdGluZ1RhbGxlciA/IHJlY3QucmlnaHQgLSBidWZmZXIgOiByZWN0LmxlZnQgOiByZWN0LnJpZ2h0IC0gYnVmZmVyLCByZWN0LmJvdHRvbV1dO1xuICAgICAgICAgICAgICByZXR1cm4gWy4uLmNvbW1vblBvaW50cywgY3Vyc29yUG9pbnRPbmUsIGN1cnNvclBvaW50VHdvXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlICdyaWdodCc6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGNvbnN0IGN1cnNvclBvaW50T25lID0gW3ggLSBidWZmZXIsIGlzRmxvYXRpbmdUYWxsZXIgPyB5ICsgYnVmZmVyIC8gMiA6IGN1cnNvckxlYXZlRnJvbUJvdHRvbSA/IHkgKyBidWZmZXIgKiA0IDogeSAtIGJ1ZmZlciAqIDRdO1xuICAgICAgICAgICAgICBjb25zdCBjdXJzb3JQb2ludFR3byA9IFt4IC0gYnVmZmVyLCBpc0Zsb2F0aW5nVGFsbGVyID8geSAtIGJ1ZmZlciAvIDIgOiBjdXJzb3JMZWF2ZUZyb21Cb3R0b20gPyB5ICsgYnVmZmVyICogNCA6IHkgLSBidWZmZXIgKiA0XTtcbiAgICAgICAgICAgICAgY29uc3QgY29tbW9uUG9pbnRzID0gW1tjdXJzb3JMZWF2ZUZyb21Cb3R0b20gPyByZWN0LmxlZnQgKyBidWZmZXIgOiBpc0Zsb2F0aW5nVGFsbGVyID8gcmVjdC5sZWZ0ICsgYnVmZmVyIDogcmVjdC5yaWdodCwgcmVjdC50b3BdLCBbY3Vyc29yTGVhdmVGcm9tQm90dG9tID8gaXNGbG9hdGluZ1RhbGxlciA/IHJlY3QubGVmdCArIGJ1ZmZlciA6IHJlY3QucmlnaHQgOiByZWN0LmxlZnQgKyBidWZmZXIsIHJlY3QuYm90dG9tXV07XG4gICAgICAgICAgICAgIHJldHVybiBbY3Vyc29yUG9pbnRPbmUsIGN1cnNvclBvaW50VHdvLCAuLi5jb21tb25Qb2ludHNdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoaXNQb2ludEluUG9seWdvbihbY2xpZW50WCwgY2xpZW50WV0sIHJlY3RQb2x5KSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoaGFzTGFuZGVkICYmICFpc092ZXJSZWZlcmVuY2VSZWN0KSB7XG4gICAgICAgIHJldHVybiBjbG9zZSgpO1xuICAgICAgfVxuICAgICAgaWYgKCFpc0xlYXZlICYmIHJlcXVpcmVJbnRlbnQpIHtcbiAgICAgICAgY29uc3QgY3Vyc29yU3BlZWQgPSBnZXRDdXJzb3JTcGVlZChldmVudC5jbGllbnRYLCBldmVudC5jbGllbnRZKTtcbiAgICAgICAgY29uc3QgY3Vyc29yU3BlZWRUaHJlc2hvbGQgPSAwLjE7XG4gICAgICAgIGlmIChjdXJzb3JTcGVlZCAhPT0gbnVsbCAmJiBjdXJzb3JTcGVlZCA8IGN1cnNvclNwZWVkVGhyZXNob2xkKSB7XG4gICAgICAgICAgcmV0dXJuIGNsb3NlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghaXNQb2ludEluUG9seWdvbihbY2xpZW50WCwgY2xpZW50WV0sIGdldFBvbHlnb24oW3gsIHldKSkpIHtcbiAgICAgICAgY2xvc2UoKTtcbiAgICAgIH0gZWxzZSBpZiAoIWhhc0xhbmRlZCAmJiByZXF1aXJlSW50ZW50KSB7XG4gICAgICAgIHRpbWVvdXRJZCA9IHdpbmRvdy5zZXRUaW1lb3V0KGNsb3NlLCA0MCk7XG4gICAgICB9XG4gICAgfTtcbiAgfTtcbiAgZm4uX19vcHRpb25zID0ge1xuICAgIGJsb2NrUG9pbnRlckV2ZW50c1xuICB9O1xuICByZXR1cm4gZm47XG59XG5cbmV4cG9ydCB7IENvbXBvc2l0ZSwgQ29tcG9zaXRlSXRlbSwgRmxvYXRpbmdBcnJvdywgRmxvYXRpbmdEZWxheUdyb3VwLCBGbG9hdGluZ0ZvY3VzTWFuYWdlciwgRmxvYXRpbmdMaXN0LCBGbG9hdGluZ05vZGUsIEZsb2F0aW5nT3ZlcmxheSwgRmxvYXRpbmdQb3J0YWwsIEZsb2F0aW5nVHJlZSwgaW5uZXIsIHNhZmVQb2x5Z29uLCB1c2VDbGljaywgdXNlQ2xpZW50UG9pbnQsIHVzZURlbGF5R3JvdXAsIHVzZURlbGF5R3JvdXBDb250ZXh0LCB1c2VEaXNtaXNzLCB1c2VGbG9hdGluZywgdXNlRmxvYXRpbmdOb2RlSWQsIHVzZUZsb2F0aW5nUGFyZW50Tm9kZUlkLCB1c2VGbG9hdGluZ1BvcnRhbE5vZGUsIHVzZUZsb2F0aW5nUm9vdENvbnRleHQsIHVzZUZsb2F0aW5nVHJlZSwgdXNlRm9jdXMsIHVzZUhvdmVyLCB1c2VJZCwgdXNlSW5uZXJPZmZzZXQsIHVzZUludGVyYWN0aW9ucywgdXNlTGlzdEl0ZW0sIHVzZUxpc3ROYXZpZ2F0aW9uLCB1c2VNZXJnZVJlZnMsIHVzZVJvbGUsIHVzZVRyYW5zaXRpb25TdGF0dXMsIHVzZVRyYW5zaXRpb25TdHlsZXMsIHVzZVR5cGVhaGVhZCB9O1xuIl0sIm5hbWVzIjpbIlJlYWN0IiwidXNlTGF5b3V0RWZmZWN0IiwidXNlRWZmZWN0IiwidXNlUmVmIiwic3RvcEV2ZW50IiwiZ2V0RG9jdW1lbnQiLCJpc01vdXNlTGlrZVBvaW50ZXJUeXBlIiwiY29udGFpbnMiLCJhY3RpdmVFbGVtZW50IiwiaXNTYWZhcmkiLCJpc1R5cGVhYmxlQ29tYm9ib3giLCJpc1ZpcnR1YWxDbGljayIsImlzVmlydHVhbFBvaW50ZXJFdmVudCIsImdldFRhcmdldCIsImdldFBsYXRmb3JtIiwiaXNUeXBlYWJsZUVsZW1lbnQiLCJpc1JlYWN0RXZlbnQiLCJpc1Jvb3RFbGVtZW50IiwiaXNFdmVudFRhcmdldFdpdGhpbiIsImlzTWFjIiwiZ2V0VXNlckFnZW50IiwiZmxvb3IiLCJldmFsdWF0ZSIsIm1heCIsIm1pbiIsInJvdW5kIiwiZ2V0Q29tcHV0ZWRTdHlsZSIsImlzRWxlbWVudCIsImdldE5vZGVOYW1lIiwiaXNIVE1MRWxlbWVudCIsImdldFdpbmRvdyIsImlzTGFzdFRyYXZlcnNhYmxlTm9kZSIsImdldFBhcmVudE5vZGUiLCJpc1dlYktpdCIsInRhYmJhYmxlIiwiaXNUYWJiYWJsZSIsIlJlYWN0RE9NIiwiZ2V0T3ZlcmZsb3dBbmNlc3RvcnMiLCJ1c2VGbG9hdGluZyIsInVzZUZsb2F0aW5nJDEiLCJvZmZzZXQiLCJkZXRlY3RPdmVyZmxvdyIsImFycm93IiwiYXV0b1BsYWNlbWVudCIsImF1dG9VcGRhdGUiLCJjb21wdXRlUG9zaXRpb24iLCJmbGlwIiwiaGlkZSIsImlubGluZSIsImxpbWl0U2hpZnQiLCJwbGF0Zm9ybSIsInNoaWZ0Iiwic2l6ZSIsInVzZU1lcmdlUmVmcyIsInJlZnMiLCJ1c2VNZW1vIiwiZXZlcnkiLCJyZWYiLCJ2YWx1ZSIsImZvckVhY2giLCJjdXJyZW50IiwiU2FmZVJlYWN0IiwidXNlSW5zZXJ0aW9uRWZmZWN0IiwidXNlU2FmZUluc2VydGlvbkVmZmVjdCIsImZuIiwidXNlRWZmZWN0RXZlbnQiLCJjYWxsYmFjayIsInByb2Nlc3MiLCJFcnJvciIsInVzZUNhbGxiYWNrIiwiX2xlbiIsImFyZ3VtZW50cyIsImxlbmd0aCIsImFyZ3MiLCJBcnJheSIsIl9rZXkiLCJBUlJPV19VUCIsIkFSUk9XX0RPV04iLCJBUlJPV19MRUZUIiwiQVJST1dfUklHSFQiLCJpc0RpZmZlcmVudFJvdyIsImluZGV4IiwiY29scyIsInByZXZSb3ciLCJNYXRoIiwiaXNJbmRleE91dE9mQm91bmRzIiwibGlzdFJlZiIsImdldE1pbkluZGV4IiwiZGlzYWJsZWRJbmRpY2VzIiwiZmluZE5vbkRpc2FibGVkSW5kZXgiLCJnZXRNYXhJbmRleCIsImRlY3JlbWVudCIsInN0YXJ0aW5nSW5kZXgiLCJfdGVtcCIsImFtb3VudCIsImxpc3QiLCJpc0Rpc2FibGVkIiwiZ2V0R3JpZE5hdmlnYXRlZEluZGV4IiwiZWxlbWVudHNSZWYiLCJfcmVmIiwiZXZlbnQiLCJvcmllbnRhdGlvbiIsImxvb3AiLCJydGwiLCJtaW5JbmRleCIsIm1heEluZGV4IiwicHJldkluZGV4Iiwic3RvcCIsIm5leHRJbmRleCIsImtleSIsImNvbCIsIm1heENvbCIsImxhc3RSb3ciLCJidWlsZENlbGxNYXAiLCJzaXplcyIsImRlbnNlIiwiY2VsbE1hcCIsInN0YXJ0SW5kZXgiLCJfcmVmMiIsIndpZHRoIiwiaGVpZ2h0IiwiaXRlbVBsYWNlZCIsInRhcmdldENlbGxzIiwiaSIsImoiLCJwdXNoIiwiY2VsbCIsImdldENlbGxJbmRleE9mQ29ybmVyIiwiY29ybmVyIiwiZmlyc3RDZWxsSW5kZXgiLCJpbmRleE9mIiwic2l6ZUl0ZW0iLCJsYXN0SW5kZXhPZiIsImdldENlbGxJbmRpY2VzIiwiaW5kaWNlcyIsImZsYXRNYXAiLCJjZWxsSW5kZXgiLCJpbmNsdWRlcyIsImVsZW1lbnQiLCJoYXNBdHRyaWJ1dGUiLCJnZXRBdHRyaWJ1dGUiLCJkb2N1bWVudCIsInNvcnRCeURvY3VtZW50UG9zaXRpb24iLCJhIiwiYiIsInBvc2l0aW9uIiwiY29tcGFyZURvY3VtZW50UG9zaXRpb24iLCJOb2RlIiwiRE9DVU1FTlRfUE9TSVRJT05fRk9MTE9XSU5HIiwiRE9DVU1FTlRfUE9TSVRJT05fQ09OVEFJTkVEX0JZIiwiRE9DVU1FTlRfUE9TSVRJT05fUFJFQ0VESU5HIiwiRE9DVU1FTlRfUE9TSVRJT05fQ09OVEFJTlMiLCJhcmVNYXBzRXF1YWwiLCJtYXAxIiwibWFwMiIsImVudHJpZXMiLCJnZXQiLCJGbG9hdGluZ0xpc3RDb250ZXh0IiwiY3JlYXRlQ29udGV4dCIsInJlZ2lzdGVyIiwidW5yZWdpc3RlciIsIm1hcCIsIk1hcCIsIkZsb2F0aW5nTGlzdCIsInByb3BzIiwiY2hpbGRyZW4iLCJsYWJlbHNSZWYiLCJzZXRNYXAiLCJ1c2VTdGF0ZSIsIm5vZGUiLCJwcmV2TWFwIiwic2V0IiwiZGVsZXRlIiwibmV3TWFwIiwibm9kZXMiLCJmcm9tIiwia2V5cyIsInNvcnQiLCJjcmVhdGVFbGVtZW50IiwiUHJvdmlkZXIiLCJ1c2VMaXN0SXRlbSIsImxhYmVsIiwidXNlQ29udGV4dCIsImluZGV4JDEiLCJzZXRJbmRleCIsImNvbXBvbmVudFJlZiIsIl9ub2RlJHRleHRDb250ZW50IiwiaXNMYWJlbERlZmluZWQiLCJ1bmRlZmluZWQiLCJ0ZXh0Q29udGVudCIsInJlbmRlckpzeCIsInJlbmRlciIsImNvbXB1dGVkUHJvcHMiLCJjbG9uZUVsZW1lbnQiLCJDb21wb3NpdGVDb250ZXh0IiwiYWN0aXZlSW5kZXgiLCJvbk5hdmlnYXRlIiwiaG9yaXpvbnRhbEtleXMiLCJ2ZXJ0aWNhbEtleXMiLCJhbGxLZXlzIiwiQ29tcG9zaXRlIiwiZm9yd2FyZFJlZiIsImZvcndhcmRlZFJlZiIsImV4dGVybmFsQWN0aXZlSW5kZXgiLCJleHRlcm5hbFNldEFjdGl2ZUluZGV4IiwiaXRlbVNpemVzIiwiZG9tUHJvcHMiLCJpbnRlcm5hbEFjdGl2ZUluZGV4IiwiaW50ZXJuYWxTZXRBY3RpdmVJbmRleCIsInJlbmRlckVsZW1lbnRQcm9wcyIsImNvbnRleHRWYWx1ZSIsImlzR3JpZCIsImhhbmRsZUtleURvd24iLCJob3Jpem9udGFsRW5kS2V5IiwiaG9yaXpvbnRhbFN0YXJ0S2V5IiwibWluR3JpZEluZGV4IiwiZmluZEluZGV4IiwibWF4R3JpZEluZGV4IiwicmVkdWNlIiwiZm91bmRJbmRleCIsIm1heWJlTmV4dEluZGV4IiwiaXRlbUluZGV4IiwiXyIsInRvRW5kS2V5cyIsImhvcml6b250YWwiLCJ2ZXJ0aWNhbCIsImJvdGgiLCJ0b1N0YXJ0S2V5cyIsInByZXZlbnRlZEtleXMiLCJfZWxlbWVudHNSZWYkY3VycmVudCQiLCJzdG9wUHJvcGFnYXRpb24iLCJwcmV2ZW50RGVmYXVsdCIsImZvY3VzIiwib25LZXlEb3duIiwiZSIsIkNvbXBvc2l0ZUl0ZW0iLCJtZXJnZWRSZWYiLCJpc0FjdGl2ZSIsInRhYkluZGV4Iiwib25Gb2N1cyIsIl9leHRlbmRzIiwiT2JqZWN0IiwiYXNzaWduIiwiYmluZCIsInRhcmdldCIsInNvdXJjZSIsInByb3RvdHlwZSIsImhhc093blByb3BlcnR5IiwiY2FsbCIsImFwcGx5Iiwic2VydmVySGFuZG9mZkNvbXBsZXRlIiwiY291bnQiLCJnZW5JZCIsInJhbmRvbSIsInRvU3RyaW5nIiwic2xpY2UiLCJ1c2VGbG9hdGluZ0lkIiwiaWQiLCJzZXRJZCIsInVzZVJlYWN0SWQiLCJ1c2VJZCIsImRldk1lc3NhZ2VTZXQiLCJTZXQiLCJ3YXJuIiwiX2Rldk1lc3NhZ2VTZXQiLCJtZXNzYWdlcyIsIm1lc3NhZ2UiLCJqb2luIiwiaGFzIiwiX2Rldk1lc3NhZ2VTZXQyIiwiYWRkIiwiY29uc29sZSIsImVycm9yIiwiX2Rldk1lc3NhZ2VTZXQzIiwiX2xlbjIiLCJfa2V5MiIsIl9kZXZNZXNzYWdlU2V0NCIsIkZsb2F0aW5nQXJyb3ciLCJjb250ZXh0IiwicGxhY2VtZW50IiwiZWxlbWVudHMiLCJmbG9hdGluZyIsIm1pZGRsZXdhcmVEYXRhIiwidGlwUmFkaXVzIiwic3Ryb2tlV2lkdGgiLCJzdGF0aWNPZmZzZXQiLCJzdHJva2UiLCJkIiwic3R5bGUiLCJ0cmFuc2Zvcm0iLCJyZXN0U3R5bGUiLCJyZXN0IiwiY2xpcFBhdGhJZCIsImlzUlRMIiwic2V0SXNSVEwiLCJkaXJlY3Rpb24iLCJzaWRlIiwiYWxpZ25tZW50Iiwic3BsaXQiLCJpc1ZlcnRpY2FsU2lkZSIsImNvbXB1dGVkU3RhdGljT2Zmc2V0IiwieCIsInkiLCJjb21wdXRlZFN0cm9rZVdpZHRoIiwiaGFsZlN0cm9rZVdpZHRoIiwic3ZnWCIsInN2Z1kiLCJpc0N1c3RvbVNoYXBlIiwieU9mZnNldFByb3AiLCJ4T2Zmc2V0UHJvcCIsImFycm93WCIsImFycm93WSIsImRWYWx1ZSIsInJvdGF0aW9uIiwidG9wIiwibGVmdCIsImJvdHRvbSIsInJpZ2h0Iiwidmlld0JveCIsInBvaW50ZXJFdmVudHMiLCJmaWx0ZXIiLCJ0IiwiY2xpcFBhdGgiLCJmaWxsIiwiY3JlYXRlUHViU3ViIiwiZW1pdCIsImRhdGEiLCJfbWFwJGdldCIsImhhbmRsZXIiLCJvbiIsImxpc3RlbmVyIiwib2ZmIiwiX21hcCRnZXQyIiwibCIsIkZsb2F0aW5nTm9kZUNvbnRleHQiLCJGbG9hdGluZ1RyZWVDb250ZXh0IiwidXNlRmxvYXRpbmdQYXJlbnROb2RlSWQiLCJfUmVhY3QkdXNlQ29udGV4dCIsInVzZUZsb2F0aW5nVHJlZSIsInVzZUZsb2F0aW5nTm9kZUlkIiwiY3VzdG9tUGFyZW50SWQiLCJ0cmVlIiwicmVhY3RQYXJlbnRJZCIsInBhcmVudElkIiwiYWRkTm9kZSIsInJlbW92ZU5vZGUiLCJGbG9hdGluZ05vZGUiLCJGbG9hdGluZ1RyZWUiLCJub2Rlc1JlZiIsIm4iLCJldmVudHMiLCJjcmVhdGVBdHRyaWJ1dGUiLCJuYW1lIiwidXNlTGF0ZXN0UmVmIiwic2FmZVBvbHlnb25JZGVudGlmaWVyIiwiZ2V0RGVsYXkiLCJwcm9wIiwicG9pbnRlclR5cGUiLCJ1c2VIb3ZlciIsIm9wZW4iLCJvbk9wZW5DaGFuZ2UiLCJkYXRhUmVmIiwiZW5hYmxlZCIsImRlbGF5IiwiaGFuZGxlQ2xvc2UiLCJtb3VzZU9ubHkiLCJyZXN0TXMiLCJtb3ZlIiwiaGFuZGxlQ2xvc2VSZWYiLCJkZWxheVJlZiIsIm9wZW5SZWYiLCJwb2ludGVyVHlwZVJlZiIsInRpbWVvdXRSZWYiLCJoYW5kbGVyUmVmIiwicmVzdFRpbWVvdXRSZWYiLCJibG9ja01vdXNlTW92ZVJlZiIsInBlcmZvcm1lZFBvaW50ZXJFdmVudHNNdXRhdGlvblJlZiIsInVuYmluZE1vdXNlTW92ZVJlZiIsInJlc3RUaW1lb3V0UGVuZGluZ1JlZiIsImlzSG92ZXJPcGVuIiwiX2RhdGFSZWYkY3VycmVudCRvcGVuIiwidHlwZSIsIm9wZW5FdmVudCIsImNsZWFyVGltZW91dCIsIm9uTGVhdmUiLCJodG1sIiwiZG9jdW1lbnRFbGVtZW50IiwiYWRkRXZlbnRMaXN0ZW5lciIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJjbG9zZVdpdGhEZWxheSIsInJ1bkVsc2VCcmFuY2giLCJyZWFzb24iLCJjbG9zZURlbGF5Iiwid2luZG93Iiwic2V0VGltZW91dCIsImNsZWFudXBNb3VzZU1vdmVIYW5kbGVyIiwiY2xlYXJQb2ludGVyRXZlbnRzIiwiYm9keSIsInJlbW92ZUF0dHJpYnV0ZSIsImlzQ2xpY2tMaWtlT3BlbkV2ZW50Iiwib25Nb3VzZUVudGVyIiwib3BlbkRlbGF5Iiwib25Nb3VzZUxlYXZlIiwiZG9jIiwiZmxvYXRpbmdDb250ZXh0IiwiY2xpZW50WCIsImNsaWVudFkiLCJvbkNsb3NlIiwic2hvdWxkQ2xvc2UiLCJyZWxhdGVkVGFyZ2V0Iiwib25TY3JvbGxNb3VzZUxlYXZlIiwiZG9tUmVmZXJlbmNlIiwiX2VsZW1lbnRzJGZsb2F0aW5nIiwib25jZSIsIl9lbGVtZW50cyRmbG9hdGluZzIiLCJfaGFuZGxlQ2xvc2VSZWYkY3VycmUiLCJfX29wdGlvbnMiLCJibG9ja1BvaW50ZXJFdmVudHMiLCJmbG9hdGluZ0VsIiwiX3RyZWUkbm9kZXNSZWYkY3VycmVuIiwic2V0QXR0cmlidXRlIiwicGFyZW50RmxvYXRpbmciLCJmaW5kIiwicmVmZXJlbmNlIiwic2V0UG9pbnRlclJlZiIsIm9uUG9pbnRlckRvd24iLCJvblBvaW50ZXJFbnRlciIsIm9uTW91c2VNb3ZlIiwibmF0aXZlRXZlbnQiLCJoYW5kbGVNb3VzZU1vdmUiLCJtb3ZlbWVudFgiLCJtb3ZlbWVudFkiLCJOT09QIiwiRmxvYXRpbmdEZWxheUdyb3VwQ29udGV4dCIsImluaXRpYWxEZWxheSIsInRpbWVvdXRNcyIsImN1cnJlbnRJZCIsInNldEN1cnJlbnRJZCIsInNldFN0YXRlIiwiaXNJbnN0YW50UGhhc2UiLCJ1c2VEZWxheUdyb3VwQ29udGV4dCIsIkZsb2F0aW5nRGVsYXlHcm91cCIsInN0YXRlIiwidXNlUmVkdWNlciIsInByZXYiLCJuZXh0IiwiaW5pdGlhbEN1cnJlbnRJZFJlZiIsInVzZURlbGF5R3JvdXAiLCJvcHRpb25zIiwiZmxvYXRpbmdJZCIsIm9wdGlvbklkIiwiZ3JvdXBDb250ZXh0IiwiY2xvc2UiLCJ1bnNldCIsInRpbWVvdXQiLCJyYWZJZCIsImVucXVldWVGb2N1cyIsImVsIiwicHJldmVudFNjcm9sbCIsImNhbmNlbFByZXZpb3VzIiwic3luYyIsImNhbmNlbEFuaW1hdGlvbkZyYW1lIiwiZXhlYyIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsImdldEFuY2VzdG9ycyIsIl9ub2RlcyRmaW5kIiwiYWxsQW5jZXN0b3JzIiwiY3VycmVudFBhcmVudElkIiwiY3VycmVudE5vZGUiLCJjb25jYXQiLCJnZXRDaGlsZHJlbiIsImFsbENoaWxkcmVuIiwiX25vZGUkY29udGV4dCIsImN1cnJlbnRDaGlsZHJlbiIsIl9jdXJyZW50Q2hpbGRyZW4iLCJzb21lIiwiX25vZGUkY29udGV4dDIiLCJnZXREZWVwZXN0Tm9kZSIsImRlZXBlc3ROb2RlSWQiLCJtYXhEZXB0aCIsImZpbmREZWVwZXN0Iiwibm9kZUlkIiwiZGVwdGgiLCJjaGlsZCIsImNvdW50ZXJNYXAiLCJXZWFrTWFwIiwidW5jb250cm9sbGVkRWxlbWVudHNTZXQiLCJXZWFrU2V0IiwibWFya2VyTWFwIiwibG9ja0NvdW50JDEiLCJzdXBwb3J0c0luZXJ0IiwiSFRNTEVsZW1lbnQiLCJ1bndyYXBIb3N0IiwiaG9zdCIsInBhcmVudE5vZGUiLCJjb3JyZWN0RWxlbWVudHMiLCJwYXJlbnQiLCJ0YXJnZXRzIiwiY29ycmVjdGVkVGFyZ2V0IiwiYXBwbHlBdHRyaWJ1dGVUb090aGVycyIsInVuY29ycmVjdGVkQXZvaWRFbGVtZW50cyIsImFyaWFIaWRkZW4iLCJpbmVydCIsIm1hcmtlck5hbWUiLCJjb250cm9sQXR0cmlidXRlIiwiYXZvaWRFbGVtZW50cyIsImVsZW1lbnRzVG9LZWVwIiwiZWxlbWVudHNUb1N0b3AiLCJoaWRkZW5FbGVtZW50cyIsIm1hcmtlckNvdW50ZXIiLCJrZWVwIiwiZGVlcCIsImNsZWFyIiwiYXR0ciIsImFscmVhZHlIaWRkZW4iLCJjb3VudGVyVmFsdWUiLCJtYXJrZXJWYWx1ZSIsIm1hcmtPdGhlcnMiLCJxdWVyeVNlbGVjdG9yQWxsIiwiZ2V0VGFiYmFibGVPcHRpb25zIiwiZ2V0U2hhZG93Um9vdCIsImRpc3BsYXlDaGVjayIsIlJlc2l6ZU9ic2VydmVyIiwiZ2V0VGFiYmFibGVJbiIsImNvbnRhaW5lciIsImFsbFRhYmJhYmxlIiwicmV2ZXJzZSIsIm5leHRUYWJiYWJsZUVsZW1lbnRzIiwiZ2V0TmV4dFRhYmJhYmxlIiwiZ2V0UHJldmlvdXNUYWJiYWJsZSIsImlzT3V0c2lkZUV2ZW50IiwiY29udGFpbmVyRWxlbWVudCIsImN1cnJlbnRUYXJnZXQiLCJkaXNhYmxlRm9jdXNJbnNpZGUiLCJ0YWJiYWJsZUVsZW1lbnRzIiwiZGF0YXNldCIsInRhYmluZGV4IiwiZW5hYmxlRm9jdXNJbnNpZGUiLCJISURERU5fU1RZTEVTIiwiYm9yZGVyIiwiY2xpcCIsIm1hcmdpbiIsIm92ZXJmbG93IiwicGFkZGluZyIsIndoaXRlU3BhY2UiLCJ0aW1lb3V0SWQiLCJzZXRBY3RpdmVFbGVtZW50T25UYWIiLCJGb2N1c0d1YXJkIiwicm9sZSIsInNldFJvbGUiLCJyZXN0UHJvcHMiLCJQb3J0YWxDb250ZXh0IiwidXNlRmxvYXRpbmdQb3J0YWxOb2RlIiwicm9vdCIsInVuaXF1ZUlkIiwicG9ydGFsQ29udGV4dCIsInVzZVBvcnRhbENvbnRleHQiLCJwb3J0YWxOb2RlIiwic2V0UG9ydGFsTm9kZSIsInBvcnRhbE5vZGVSZWYiLCJyZW1vdmUiLCJxdWV1ZU1pY3JvdGFzayIsImV4aXN0aW5nSWRSb290IiwiZ2V0RWxlbWVudEJ5SWQiLCJzdWJSb290IiwiYXBwZW5kQ2hpbGQiLCJpZFdyYXBwZXIiLCJGbG9hdGluZ1BvcnRhbCIsInByZXNlcnZlVGFiT3JkZXIiLCJmb2N1c01hbmFnZXJTdGF0ZSIsInNldEZvY3VzTWFuYWdlclN0YXRlIiwiYmVmb3JlT3V0c2lkZVJlZiIsImFmdGVyT3V0c2lkZVJlZiIsImJlZm9yZUluc2lkZVJlZiIsImFmdGVySW5zaWRlUmVmIiwibW9kYWwiLCJzaG91bGRSZW5kZXJHdWFyZHMiLCJmb2N1c2luZyIsIm1hbmFnZUZvY3VzIiwiX2JlZm9yZUluc2lkZVJlZiRjdXJyIiwicHJldlRhYmJhYmxlIiwiY3JlYXRlUG9ydGFsIiwiX2FmdGVySW5zaWRlUmVmJGN1cnJlIiwibmV4dFRhYmJhYmxlIiwiY2xvc2VPbkZvY3VzT3V0IiwiRk9DVVNBQkxFX0FUVFJJQlVURSIsImdldEZsb2F0aW5nRm9jdXNFbGVtZW50IiwiZmxvYXRpbmdFbGVtZW50IiwicXVlcnlTZWxlY3RvciIsIkxJU1RfTElNSVQiLCJwcmV2aW91c2x5Rm9jdXNlZEVsZW1lbnRzIiwiYWRkUHJldmlvdXNseUZvY3VzZWRFbGVtZW50IiwiaXNDb25uZWN0ZWQiLCJ0YWJiYWJsZUVsIiwidGFiYmFibGVDaGlsZCIsImdldFByZXZpb3VzbHlGb2N1c2VkRWxlbWVudCIsIlZpc3VhbGx5SGlkZGVuRGlzbWlzcyIsIkZsb2F0aW5nRm9jdXNNYW5hZ2VyIiwiZGlzYWJsZWQiLCJvcmRlciIsImd1YXJkcyIsIl9ndWFyZHMiLCJpbml0aWFsRm9jdXMiLCJyZXR1cm5Gb2N1cyIsInJlc3RvcmVGb2N1cyIsInZpc3VhbGx5SGlkZGVuRGlzbWlzcyIsImlnbm9yZUluaXRpYWxGb2N1cyIsImlzVW50cmFwcGVkVHlwZWFibGVDb21ib2JveCIsIm9yZGVyUmVmIiwiaW5pdGlhbEZvY3VzUmVmIiwicmV0dXJuRm9jdXNSZWYiLCJzdGFydERpc21pc3NCdXR0b25SZWYiLCJlbmREaXNtaXNzQnV0dG9uUmVmIiwicHJldmVudFJldHVybkZvY3VzUmVmIiwiaXNQb2ludGVyRG93blJlZiIsInRhYmJhYmxlSW5kZXhSZWYiLCJpc0luc2lkZVBvcnRhbCIsImZsb2F0aW5nRm9jdXNFbGVtZW50IiwiZ2V0VGFiYmFibGVDb250ZW50IiwiZ2V0VGFiYmFibGVFbGVtZW50cyIsImNvbnRlbnQiLCJCb29sZWFuIiwiZmxhdCIsImVscyIsInNoaWZ0S2V5IiwiaGFuZGxlRm9jdXNJbiIsInRhYmJhYmxlQ29udGVudCIsInRhYmJhYmxlSW5kZXgiLCJoYW5kbGVQb2ludGVyRG93biIsImhhbmRsZUZvY3VzT3V0c2lkZSIsIm1vdmVkVG9VbnJlbGF0ZWROb2RlIiwiX25vZGUkY29udGV4dDMiLCJfbm9kZSRjb250ZXh0NCIsInByZXZUYWJiYWJsZUluZGV4Iiwibm9kZVRvRm9jdXMiLCJfcG9ydGFsQ29udGV4dCRwb3J0YWwiLCJwb3J0YWxOb2RlcyIsImluc2lkZUVsZW1lbnRzIiwiY2xlYW51cCIsInByZXZpb3VzbHlGb2N1c2VkRWxlbWVudCIsImZvY3VzYWJsZUVsZW1lbnRzIiwiaW5pdGlhbEZvY3VzVmFsdWUiLCJlbFRvRm9jdXMiLCJmb2N1c0FscmVhZHlJbnNpZGVGbG9hdGluZ0VsIiwicHJldmVudFJldHVybkZvY3VzU2Nyb2xsIiwiY29udGV4dERhdGEiLCJuZXN0ZWQiLCJmYWxsYmFja0VsIiwiaW5zZXJ0QWRqYWNlbnRFbGVtZW50IiwiZ2V0UmV0dXJuRWxlbWVudCIsImFjdGl2ZUVsIiwiaXNGb2N1c0luc2lkZUZsb2F0aW5nVHJlZSIsIl9ub2RlJGNvbnRleHQ1Iiwic2hvdWxkRm9jdXNSZWZlcmVuY2UiLCJyZXR1cm5FbGVtZW50IiwiTXV0YXRpb25PYnNlcnZlciIsImhhbmRsZU11dGF0aW9uIiwib2JzZXJ2ZXIiLCJvYnNlcnZlIiwiY2hpbGRMaXN0Iiwic3VidHJlZSIsImF0dHJpYnV0ZXMiLCJkaXNjb25uZWN0IiwicmVuZGVyRGlzbWlzc0J1dHRvbiIsImxvY2F0aW9uIiwib25DbGljayIsIkZyYWdtZW50IiwiX3BvcnRhbENvbnRleHQkYmVmb3JlIiwiX3BvcnRhbENvbnRleHQkYWZ0ZXJPIiwibG9ja0NvdW50IiwiZW5hYmxlU2Nyb2xsTG9jayIsImlzSU9TIiwidGVzdCIsImJvZHlTdHlsZSIsInNjcm9sbGJhclgiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJzY3JvbGxMZWZ0IiwicGFkZGluZ1Byb3AiLCJzY3JvbGxiYXJXaWR0aCIsImlubmVyV2lkdGgiLCJjbGllbnRXaWR0aCIsInNjcm9sbFgiLCJwYXJzZUZsb2F0Iiwic2Nyb2xsWSIsIl93aW5kb3ckdmlzdWFsVmlld3BvciIsIl93aW5kb3ckdmlzdWFsVmlld3BvcjIiLCJvZmZzZXRMZWZ0IiwidmlzdWFsVmlld3BvcnQiLCJvZmZzZXRUb3AiLCJzY3JvbGxUbyIsIkZsb2F0aW5nT3ZlcmxheSIsImxvY2tTY3JvbGwiLCJpc0J1dHRvblRhcmdldCIsInRhZ05hbWUiLCJpc1NwYWNlSWdub3JlZCIsInVzZUNsaWNrIiwiZXZlbnRPcHRpb24iLCJ0b2dnbGUiLCJpZ25vcmVNb3VzZSIsImtleWJvYXJkSGFuZGxlcnMiLCJzdGlja0lmT3BlbiIsImRpZEtleURvd25SZWYiLCJvbk1vdXNlRG93biIsImJ1dHRvbiIsImRlZmF1bHRQcmV2ZW50ZWQiLCJvbktleVVwIiwiY3JlYXRlVmlydHVhbEVsZW1lbnQiLCJkb21FbGVtZW50Iiwib2Zmc2V0WCIsIm9mZnNldFkiLCJpc0F1dG9VcGRhdGVFdmVudCIsImNvbnRleHRFbGVtZW50IiwiX2RhdGEkZGF0YVJlZiRjdXJyZW50IiwiZG9tUmVjdCIsImlzWEF4aXMiLCJheGlzIiwiaXNZQXhpcyIsImNhblRyYWNrQ3Vyc29yT25BdXRvVXBkYXRlIiwiaXNNb3VzZUJhc2VkRXZlbnQiLCJ1c2VDbGllbnRQb2ludCIsImluaXRpYWxSZWYiLCJjbGVhbnVwTGlzdGVuZXJSZWYiLCJzZXRQb2ludGVyVHlwZSIsInJlYWN0aXZlIiwic2V0UmVhY3RpdmUiLCJzZXRSZWZlcmVuY2UiLCJzZXRQb3NpdGlvblJlZmVyZW5jZSIsImhhbmRsZVJlZmVyZW5jZUVudGVyT3JNb3ZlIiwib3BlbkNoZWNrIiwiYWRkTGlzdGVuZXIiLCJ3aW4iLCJzZXRQb2ludGVyVHlwZVJlZiIsImJ1YmJsZUhhbmRsZXJLZXlzIiwicG9pbnRlcmRvd24iLCJtb3VzZWRvd24iLCJjbGljayIsImNhcHR1cmVIYW5kbGVyS2V5cyIsIm5vcm1hbGl6ZVByb3AiLCJub3JtYWxpemFibGUiLCJfbm9ybWFsaXphYmxlJGVzY2FwZUsiLCJfbm9ybWFsaXphYmxlJG91dHNpZGUiLCJlc2NhcGVLZXkiLCJvdXRzaWRlUHJlc3MiLCJ1c2VEaXNtaXNzIiwidW5zdGFibGVfb3V0c2lkZVByZXNzIiwib3V0c2lkZVByZXNzRXZlbnQiLCJyZWZlcmVuY2VQcmVzcyIsInJlZmVyZW5jZVByZXNzRXZlbnQiLCJhbmNlc3RvclNjcm9sbCIsImJ1YmJsZXMiLCJjYXB0dXJlIiwib3V0c2lkZVByZXNzRm4iLCJpbnNpZGVSZWFjdFRyZWVSZWYiLCJlbmRlZE9yU3RhcnRlZEluc2lkZVJlZiIsImVzY2FwZUtleUJ1YmJsZXMiLCJvdXRzaWRlUHJlc3NCdWJibGVzIiwiZXNjYXBlS2V5Q2FwdHVyZSIsIm91dHNpZGVQcmVzc0NhcHR1cmUiLCJpc0NvbXBvc2luZ1JlZiIsImNsb3NlT25Fc2NhcGVLZXlEb3duIiwiX2RhdGFSZWYkY3VycmVudCRmbG9hIiwic2hvdWxkRGlzbWlzcyIsIl9jaGlsZCRjb250ZXh0IiwiX19lc2NhcGVLZXlCdWJibGVzIiwiY2xvc2VPbkVzY2FwZUtleURvd25DYXB0dXJlIiwiX2dldFRhcmdldDIiLCJfZ2V0VGFyZ2V0IiwiY2xvc2VPblByZXNzT3V0c2lkZSIsIl9kYXRhUmVmJGN1cnJlbnQkZmxvYTIiLCJpbnNpZGVSZWFjdFRyZWUiLCJlbmRlZE9yU3RhcnRlZEluc2lkZSIsImluZXJ0U2VsZWN0b3IiLCJtYXJrZXJzIiwidGFyZ2V0Um9vdEFuY2VzdG9yIiwibmV4dFBhcmVudCIsIm1hcmtlciIsImNhblNjcm9sbFgiLCJzY3JvbGxXaWR0aCIsImNhblNjcm9sbFkiLCJjbGllbnRIZWlnaHQiLCJzY3JvbGxIZWlnaHQiLCJ4Q29uZCIsIm9mZnNldFdpZHRoIiwidGFyZ2V0SXNJbnNpZGVDaGlsZHJlbiIsIl9jaGlsZCRjb250ZXh0MiIsIl9fb3V0c2lkZVByZXNzQnViYmxlcyIsImNsb3NlT25QcmVzc091dHNpZGVDYXB0dXJlIiwiX2dldFRhcmdldDQiLCJfZ2V0VGFyZ2V0MyIsImNvbXBvc2l0aW9uVGltZW91dCIsIm9uU2Nyb2xsIiwiaGFuZGxlQ29tcG9zaXRpb25TdGFydCIsImhhbmRsZUNvbXBvc2l0aW9uRW5kIiwiYW5jZXN0b3JzIiwiYW5jZXN0b3IiLCJfZG9jJGRlZmF1bHRWaWV3IiwiZGVmYXVsdFZpZXciLCJwYXNzaXZlIiwib25Nb3VzZVVwIiwidXNlRmxvYXRpbmdSb290Q29udGV4dCIsIm9uT3BlbkNoYW5nZVByb3AiLCJlbGVtZW50c1Byb3AiLCJvcHRpb25Eb21SZWZlcmVuY2UiLCJwb3NpdGlvblJlZmVyZW5jZSIsImludGVybmFsUm9vdENvbnRleHQiLCJyb290Q29udGV4dCIsImNvbXB1dGVkRWxlbWVudHMiLCJfZG9tUmVmZXJlbmNlIiwic2V0RG9tUmVmZXJlbmNlIiwiX3NldFBvc2l0aW9uUmVmZXJlbmNlIiwiZG9tUmVmZXJlbmNlUmVmIiwiY29tcHV0ZWRQb3NpdGlvblJlZmVyZW5jZSIsInVzZUZvY3VzIiwidmlzaWJsZU9ubHkiLCJibG9ja0ZvY3VzUmVmIiwia2V5Ym9hcmRNb2RhbGl0eVJlZiIsIm9uQmx1ciIsIm1hdGNoZXMiLCJtb3ZlZFRvRm9jdXNHdWFyZCIsIm93bmVyRG9jdW1lbnQiLCJBQ1RJVkVfS0VZIiwiU0VMRUNURURfS0VZIiwibWVyZ2VQcm9wcyIsInVzZXJQcm9wcyIsInByb3BzTGlzdCIsImVsZW1lbnRLZXkiLCJpc0l0ZW0iLCJkb21Vc2VyUHJvcHMiLCJfXyIsInZhbGlkUHJvcHMiLCJwcm9wc09yR2V0UHJvcHMiLCJhY2MiLCJ2YWwiLCJ1c2VJbnRlcmFjdGlvbnMiLCJyZWZlcmVuY2VEZXBzIiwiZmxvYXRpbmdEZXBzIiwiaXRlbURlcHMiLCJpdGVtIiwiZ2V0UmVmZXJlbmNlUHJvcHMiLCJnZXRGbG9hdGluZ1Byb3BzIiwiZ2V0SXRlbVByb3BzIiwiaXNQcmV2ZW50U2Nyb2xsU3VwcG9ydGVkIiwiZG9Td2l0Y2giLCJpc01haW5PcmllbnRhdGlvbktleSIsImlzTWFpbk9yaWVudGF0aW9uVG9FbmRLZXkiLCJpc0Nyb3NzT3JpZW50YXRpb25PcGVuS2V5IiwiaXNDcm9zc09yaWVudGF0aW9uQ2xvc2VLZXkiLCJ1c2VMaXN0TmF2aWdhdGlvbiIsInVuc3RhYmxlX29uTmF2aWdhdGUiLCJzZWxlY3RlZEluZGV4IiwiYWxsb3dFc2NhcGUiLCJ2aXJ0dWFsIiwiZm9jdXNJdGVtT25PcGVuIiwiZm9jdXNJdGVtT25Ib3ZlciIsIm9wZW5PbkFycm93S2V5RG93biIsInNjcm9sbEl0ZW1JbnRvVmlldyIsInZpcnR1YWxJdGVtUmVmIiwiZmxvYXRpbmdGb2N1c0VsZW1lbnRSZWYiLCJ0eXBlYWJsZUNvbWJvYm94UmVmZXJlbmNlIiwiZm9jdXNJdGVtT25PcGVuUmVmIiwiaW5kZXhSZWYiLCJrZXlSZWYiLCJpc1BvaW50ZXJNb2RhbGl0eVJlZiIsInByZXZpb3VzT25OYXZpZ2F0ZVJlZiIsInByZXZpb3VzTW91bnRlZFJlZiIsInByZXZpb3VzT3BlblJlZiIsImZvcmNlU3luY0ZvY3VzIiwiZm9yY2VTY3JvbGxJbnRvVmlld1JlZiIsImRpc2FibGVkSW5kaWNlc1JlZiIsImxhdGVzdE9wZW5SZWYiLCJzY3JvbGxJdGVtSW50b1ZpZXdSZWYiLCJzZWxlY3RlZEluZGV4UmVmIiwiYWN0aXZlSWQiLCJzZXRBY3RpdmVJZCIsInZpcnR1YWxJZCIsInNldFZpcnR1YWxJZCIsImZvY3VzSXRlbSIsImZvcmNlU2Nyb2xsSW50b1ZpZXciLCJydW5Gb2N1cyIsImluaXRpYWxJdGVtIiwid2FpdGVkSXRlbSIsInNjcm9sbEludG9WaWV3T3B0aW9ucyIsInNob3VsZFNjcm9sbEludG9WaWV3Iiwic2Nyb2xsSW50b1ZpZXciLCJibG9jayIsInJ1bnMiLCJ3YWl0Rm9yTGlzdFBvcHVsYXRlZCIsInNjaGVkdWxlciIsInRyZWVDb250YWluc0FjdGl2ZUVsIiwiaGFuZGxlVmlydHVhbEZvY3VzIiwiaGFzQWN0aXZlSW5kZXgiLCJzeW5jQ3VycmVudFRhcmdldCIsIl9yZWYzIiwib25Qb2ludGVyTGVhdmUiLCJfcmVmNCIsImNvbW1vbk9uS2V5RG93biIsIndoaWNoIiwiY3VycmVudEluZGV4IiwiYXJpYUFjdGl2ZURlc2NlbmRhbnRQcm9wIiwib25Qb2ludGVyTW92ZSIsImNoZWNrVmlydHVhbE1vdXNlIiwiY2hlY2tWaXJ0dWFsUG9pbnRlciIsImlzQXJyb3dLZXkiLCJzdGFydHNXaXRoIiwiaXNIb21lT3JFbmRLZXkiLCJpc01vdmVLZXkiLCJpc0Nyb3NzT3BlbktleSIsImlzQ3Jvc3NDbG9zZUtleSIsImlzTWFpbktleSIsImlzTmF2aWdhdGlvbktleSIsInRyaW0iLCJyb290Tm9kZSIsImRlZXBlc3ROb2RlIiwiZXZlbnRPYmplY3QiLCJLZXlib2FyZEV2ZW50IiwiX2RlZXBlc3ROb2RlJGNvbnRleHQiLCJfZGVlcGVzdE5vZGUkY29udGV4dDIiLCJpc0N1cnJlbnRUYXJnZXQiLCJkaXNwYXRjaEl0ZW0iLCJkaXNwYXRjaEV2ZW50IiwiX2RlZXBlc3ROb2RlJGNvbnRleHQkIiwiY29tcG9uZW50Um9sZVRvQXJpYVJvbGVNYXAiLCJ1c2VSb2xlIiwiX2NvbXBvbmVudFJvbGVUb0FyaWFSIiwiYXJpYVJvbGUiLCJyZWZlcmVuY2VJZCIsImlzTmVzdGVkIiwiZmxvYXRpbmdQcm9wcyIsImFjdGl2ZSIsInNlbGVjdGVkIiwiY29tbW9uUHJvcHMiLCJjYW1lbENhc2VUb0tlYmFiQ2FzZSIsInN0ciIsInJlcGxhY2UiLCIkIiwib2ZzIiwidG9Mb3dlckNhc2UiLCJleGVjV2l0aEFyZ3NPclJldHVybiIsInZhbHVlT3JGbiIsInVzZURlbGF5VW5tb3VudCIsImR1cmF0aW9uTXMiLCJpc01vdW50ZWQiLCJzZXRJc01vdW50ZWQiLCJ1c2VUcmFuc2l0aW9uU3RhdHVzIiwiZHVyYXRpb24iLCJpc051bWJlckR1cmF0aW9uIiwiY2xvc2VEdXJhdGlvbiIsInN0YXR1cyIsInNldFN0YXR1cyIsImZyYW1lIiwidXNlVHJhbnNpdGlvblN0eWxlcyIsImluaXRpYWwiLCJ1bnN0YWJsZV9pbml0aWFsIiwib3BhY2l0eSIsInVuc3RhYmxlX29wZW4iLCJ1bnN0YWJsZV9jbG9zZSIsImNvbW1vbiIsInVuc3RhYmxlX2NvbW1vbiIsImZuQXJncyIsIm9wZW5EdXJhdGlvbiIsInN0eWxlcyIsInNldFN0eWxlcyIsImNsb3NlUmVmIiwiY29tbW9uUmVmIiwiaW5pdGlhbFN0eWxlcyIsImNsb3NlU3R5bGVzIiwiY29tbW9uU3R5bGVzIiwib3BlblN0eWxlcyIsInRyYW5zaXRpb25Qcm9wZXJ0eSIsInRyYW5zaXRpb25EdXJhdGlvbiIsInVzZVR5cGVhaGVhZCIsIm9uTWF0Y2giLCJ1bnN0YWJsZV9vbk1hdGNoIiwib25UeXBpbmdDaGFuZ2UiLCJ1bnN0YWJsZV9vblR5cGluZ0NoYW5nZSIsImZpbmRNYXRjaCIsInJlc2V0TXMiLCJpZ25vcmVLZXlzIiwidGltZW91dElkUmVmIiwic3RyaW5nUmVmIiwicHJldkluZGV4UmVmIiwibWF0Y2hJbmRleFJlZiIsImZpbmRNYXRjaFJlZiIsImlnbm9yZUtleXNSZWYiLCJzZXRUeXBpbmdDaGFuZ2UiLCJ0eXBpbmciLCJnZXRNYXRjaGluZ0luZGV4Iiwib3JkZXJlZExpc3QiLCJzdHJpbmciLCJ0ZXh0IiwidG9Mb2NhbGVMb3dlckNhc2UiLCJsaXN0Q29udGVudCIsImN0cmxLZXkiLCJtZXRhS2V5IiwiYWx0S2V5IiwiYWxsb3dSYXBpZFN1Y2Nlc3Npb25PZkZpcnN0TGV0dGVyIiwiX3RleHQkIiwiX3RleHQkMiIsImdldEFyZ3NXaXRoQ3VzdG9tRmxvYXRpbmdIZWlnaHQiLCJyZWN0cyIsImlubmVyIiwib3ZlcmZsb3dSZWYiLCJvbkZhbGxiYWNrQ2hhbmdlIiwiaW5uZXJPZmZzZXQiLCJtaW5JdGVtc1Zpc2libGUiLCJyZWZlcmVuY2VPdmVyZmxvd1RocmVzaG9sZCIsInNjcm9sbFJlZiIsImRldGVjdE92ZXJmbG93T3B0aW9ucyIsInNjcm9sbEVsIiwiY2xpZW50VG9wIiwiZmxvYXRpbmdJc0JvcmRlcmVkIiwic2Nyb2xsRWxJc0JvcmRlcmVkIiwiZmxvYXRpbmdJc1Njcm9sbEVsIiwibmV4dEFyZ3MiLCJvZmZzZXRIZWlnaHQiLCJyZWZPdmVyZmxvdyIsImVsZW1lbnRDb250ZXh0IiwiZGlmZlkiLCJuZXh0WSIsImlzU2Nyb2xsYWJsZSIsInJvdW5kZXIiLCJ2IiwibWF4SGVpZ2h0Iiwic2Nyb2xsVG9wIiwic2hvdWxkRmFsbGJhY2siLCJmbHVzaFN5bmMiLCJ1c2VJbm5lck9mZnNldCIsIm9uQ2hhbmdlIiwidW5zdGFibGVfb25DaGFuZ2UiLCJjb250cm9sbGVkU2Nyb2xsaW5nUmVmIiwicHJldlNjcm9sbFRvcFJlZiIsImluaXRpYWxPdmVyZmxvd1JlZiIsIm9uV2hlZWwiLCJkWSIsImRlbHRhWSIsImlzQXRUb3AiLCJpc0F0Qm90dG9tIiwicmVtYWluaW5nU2Nyb2xsIiwic2lnbiIsIm1ldGhvZCIsInNjcm9sbERpZmYiLCJpc1BvaW50SW5Qb2x5Z29uIiwicG9pbnQiLCJwb2x5Z29uIiwiaXNJbnNpZGUiLCJ4aSIsInlpIiwieGoiLCJ5aiIsImludGVyc2VjdCIsInJlY3QiLCJzYWZlUG9seWdvbiIsImJ1ZmZlciIsInJlcXVpcmVJbnRlbnQiLCJoYXNMYW5kZWQiLCJsYXN0WCIsImxhc3RZIiwibGFzdEN1cnNvclRpbWUiLCJwZXJmb3JtYW5jZSIsIm5vdyIsImdldEN1cnNvclNwZWVkIiwiY3VycmVudFRpbWUiLCJlbGFwc2VkVGltZSIsImRlbHRhWCIsImRpc3RhbmNlIiwic3FydCIsInNwZWVkIiwiY2xpZW50UG9pbnQiLCJpc0xlYXZlIiwiaXNPdmVyRmxvYXRpbmdFbCIsImlzT3ZlclJlZmVyZW5jZUVsIiwicmVmUmVjdCIsImN1cnNvckxlYXZlRnJvbVJpZ2h0IiwiY3Vyc29yTGVhdmVGcm9tQm90dG9tIiwiaXNPdmVyUmVmZXJlbmNlUmVjdCIsImlzRmxvYXRpbmdXaWRlciIsImlzRmxvYXRpbmdUYWxsZXIiLCJyZWN0UG9seSIsImdldFBvbHlnb24iLCJjdXJzb3JQb2ludE9uZSIsImN1cnNvclBvaW50VHdvIiwiY29tbW9uUG9pbnRzIiwiY3Vyc29yU3BlZWQiLCJjdXJzb3JTcGVlZFRocmVzaG9sZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../../../node_modules/@floating-ui/react/dist/floating-ui.react.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/../../../../node_modules/@floating-ui/react/dist/floating-ui.react.utils.mjs":
/*!************************************************************************************!*\
  !*** ../../../../node_modules/@floating-ui/react/dist/floating-ui.react.utils.mjs ***!
  \************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TYPEABLE_SELECTOR: function() { return /* binding */ TYPEABLE_SELECTOR; },\n/* harmony export */   activeElement: function() { return /* binding */ activeElement; },\n/* harmony export */   contains: function() { return /* binding */ contains; },\n/* harmony export */   getDocument: function() { return /* binding */ getDocument; },\n/* harmony export */   getPlatform: function() { return /* binding */ getPlatform; },\n/* harmony export */   getTarget: function() { return /* binding */ getTarget; },\n/* harmony export */   getUserAgent: function() { return /* binding */ getUserAgent; },\n/* harmony export */   isAndroid: function() { return /* binding */ isAndroid; },\n/* harmony export */   isEventTargetWithin: function() { return /* binding */ isEventTargetWithin; },\n/* harmony export */   isJSDOM: function() { return /* binding */ isJSDOM; },\n/* harmony export */   isMac: function() { return /* binding */ isMac; },\n/* harmony export */   isMouseLikePointerType: function() { return /* binding */ isMouseLikePointerType; },\n/* harmony export */   isReactEvent: function() { return /* binding */ isReactEvent; },\n/* harmony export */   isRootElement: function() { return /* binding */ isRootElement; },\n/* harmony export */   isSafari: function() { return /* binding */ isSafari; },\n/* harmony export */   isTypeableCombobox: function() { return /* binding */ isTypeableCombobox; },\n/* harmony export */   isTypeableElement: function() { return /* binding */ isTypeableElement; },\n/* harmony export */   isVirtualClick: function() { return /* binding */ isVirtualClick; },\n/* harmony export */   isVirtualPointerEvent: function() { return /* binding */ isVirtualPointerEvent; },\n/* harmony export */   stopEvent: function() { return /* binding */ stopEvent; }\n/* harmony export */ });\n/* harmony import */ var _floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @floating-ui/utils/dom */ \"(app-pages-browser)/../../../../node_modules/@floating-ui/utils/dist/floating-ui.utils.dom.mjs\");\n\nfunction activeElement(doc) {\n    let activeElement = doc.activeElement;\n    while(((_activeElement = activeElement) == null || (_activeElement = _activeElement.shadowRoot) == null ? void 0 : _activeElement.activeElement) != null){\n        var _activeElement;\n        activeElement = activeElement.shadowRoot.activeElement;\n    }\n    return activeElement;\n}\nfunction contains(parent, child) {\n    if (!parent || !child) {\n        return false;\n    }\n    const rootNode = child.getRootNode == null ? void 0 : child.getRootNode();\n    // First, attempt with faster native method\n    if (parent.contains(child)) {\n        return true;\n    }\n    // then fallback to custom implementation with Shadow DOM support\n    if (rootNode && (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isShadowRoot)(rootNode)) {\n        let next = child;\n        while(next){\n            if (parent === next) {\n                return true;\n            }\n            // @ts-ignore\n            next = next.parentNode || next.host;\n        }\n    }\n    // Give up, the result is false\n    return false;\n}\n// Avoid Chrome DevTools blue warning.\nfunction getPlatform() {\n    const uaData = navigator.userAgentData;\n    if (uaData != null && uaData.platform) {\n        return uaData.platform;\n    }\n    return navigator.platform;\n}\nfunction getUserAgent() {\n    const uaData = navigator.userAgentData;\n    if (uaData && Array.isArray(uaData.brands)) {\n        return uaData.brands.map((_ref)=>{\n            let { brand, version } = _ref;\n            return brand + \"/\" + version;\n        }).join(\" \");\n    }\n    return navigator.userAgent;\n}\n// License: https://github.com/adobe/react-spectrum/blob/b35d5c02fe900badccd0cf1a8f23bb593419f238/packages/@react-aria/utils/src/isVirtualEvent.ts\nfunction isVirtualClick(event) {\n    // FIXME: Firefox is now emitting a deprecation warning for `mozInputSource`.\n    // Try to find a workaround for this. `react-aria` source still has the check.\n    if (event.mozInputSource === 0 && event.isTrusted) {\n        return true;\n    }\n    if (isAndroid() && event.pointerType) {\n        return event.type === \"click\" && event.buttons === 1;\n    }\n    return event.detail === 0 && !event.pointerType;\n}\nfunction isVirtualPointerEvent(event) {\n    if (isJSDOM()) return false;\n    return !isAndroid() && event.width === 0 && event.height === 0 || isAndroid() && event.width === 1 && event.height === 1 && event.pressure === 0 && event.detail === 0 && event.pointerType === \"mouse\" || // iOS VoiceOver returns 0.333 for width/height.\n    event.width < 1 && event.height < 1 && event.pressure === 0 && event.detail === 0 && event.pointerType === \"touch\";\n}\nfunction isSafari() {\n    // Chrome DevTools does not complain about navigator.vendor\n    return /apple/i.test(navigator.vendor);\n}\nfunction isAndroid() {\n    const re = /android/i;\n    return re.test(getPlatform()) || re.test(getUserAgent());\n}\nfunction isMac() {\n    return getPlatform().toLowerCase().startsWith(\"mac\") && !navigator.maxTouchPoints;\n}\nfunction isJSDOM() {\n    return getUserAgent().includes(\"jsdom/\");\n}\nfunction isMouseLikePointerType(pointerType, strict) {\n    // On some Linux machines with Chromium, mouse inputs return a `pointerType`\n    // of \"pen\": https://github.com/floating-ui/floating-ui/issues/2015\n    const values = [\n        \"mouse\",\n        \"pen\"\n    ];\n    if (!strict) {\n        values.push(\"\", undefined);\n    }\n    return values.includes(pointerType);\n}\nfunction isReactEvent(event) {\n    return \"nativeEvent\" in event;\n}\nfunction isRootElement(element) {\n    return element.matches(\"html,body\");\n}\nfunction getDocument(node) {\n    return (node == null ? void 0 : node.ownerDocument) || document;\n}\nfunction isEventTargetWithin(event, node) {\n    if (node == null) {\n        return false;\n    }\n    if (\"composedPath\" in event) {\n        return event.composedPath().includes(node);\n    }\n    // TS thinks `event` is of type never as it assumes all browsers support composedPath, but browsers without shadow dom don't\n    const e = event;\n    return e.target != null && node.contains(e.target);\n}\nfunction getTarget(event) {\n    if (\"composedPath\" in event) {\n        return event.composedPath()[0];\n    }\n    // TS thinks `event` is of type never as it assumes all browsers support\n    // `composedPath()`, but browsers without shadow DOM don't.\n    return event.target;\n}\nconst TYPEABLE_SELECTOR = \"input:not([type='hidden']):not([disabled]),\" + \"[contenteditable]:not([contenteditable='false']),textarea:not([disabled])\";\nfunction isTypeableElement(element) {\n    return (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isHTMLElement)(element) && element.matches(TYPEABLE_SELECTOR);\n}\nfunction stopEvent(event) {\n    event.preventDefault();\n    event.stopPropagation();\n}\nfunction isTypeableCombobox(element) {\n    if (!element) return false;\n    return element.getAttribute(\"role\") === \"combobox\" && isTypeableElement(element);\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQGZsb2F0aW5nLXVpL3JlYWN0L2Rpc3QvZmxvYXRpbmctdWkucmVhY3QudXRpbHMubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFxRTtBQUVyRSxTQUFTRSxjQUFjQyxHQUFHO0lBQ3hCLElBQUlELGdCQUFnQkMsSUFBSUQsYUFBYTtJQUNyQyxNQUFPLENBQUMsQ0FBQ0UsaUJBQWlCRixhQUFZLEtBQU0sUUFBUSxDQUFDRSxpQkFBaUJBLGVBQWVDLFVBQVUsS0FBSyxPQUFPLEtBQUssSUFBSUQsZUFBZUYsYUFBYSxLQUFLLEtBQU07UUFDekosSUFBSUU7UUFDSkYsZ0JBQWdCQSxjQUFjRyxVQUFVLENBQUNILGFBQWE7SUFDeEQ7SUFDQSxPQUFPQTtBQUNUO0FBQ0EsU0FBU0ksU0FBU0MsTUFBTSxFQUFFQyxLQUFLO0lBQzdCLElBQUksQ0FBQ0QsVUFBVSxDQUFDQyxPQUFPO1FBQ3JCLE9BQU87SUFDVDtJQUNBLE1BQU1DLFdBQVdELE1BQU1FLFdBQVcsSUFBSSxPQUFPLEtBQUssSUFBSUYsTUFBTUUsV0FBVztJQUV2RSwyQ0FBMkM7SUFDM0MsSUFBSUgsT0FBT0QsUUFBUSxDQUFDRSxRQUFRO1FBQzFCLE9BQU87SUFDVDtJQUVBLGlFQUFpRTtJQUNqRSxJQUFJQyxZQUFZVCxvRUFBWUEsQ0FBQ1MsV0FBVztRQUN0QyxJQUFJRSxPQUFPSDtRQUNYLE1BQU9HLEtBQU07WUFDWCxJQUFJSixXQUFXSSxNQUFNO2dCQUNuQixPQUFPO1lBQ1Q7WUFDQSxhQUFhO1lBQ2JBLE9BQU9BLEtBQUtDLFVBQVUsSUFBSUQsS0FBS0UsSUFBSTtRQUNyQztJQUNGO0lBRUEsK0JBQStCO0lBQy9CLE9BQU87QUFDVDtBQUNBLHNDQUFzQztBQUN0QyxTQUFTQztJQUNQLE1BQU1DLFNBQVNDLFVBQVVDLGFBQWE7SUFDdEMsSUFBSUYsVUFBVSxRQUFRQSxPQUFPRyxRQUFRLEVB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QU0sSUFBSSxRQUFRTixLQUFLeEQsUUFBUSxDQUFDNkQsRUFBRUMsTUFBTTtBQUNuRDtBQUNBLFNBQVNDLFVBQVV2QyxLQUFLO0lBQ3RCLElBQUksa0JBQWtCQSxPQUFPO1FBQzNCLE9BQU9BLE1BQU1vQyxZQUFZLEVBQUUsQ0FBQyxFQUFFO0lBQ2hDO0lBRUEsd0VBQXdFO0lBQ3hFLDJEQUEyRDtJQUMzRCxPQUFPcEMsTUFBTXNDLE1BQU07QUFDckI7QUFDQSxNQUFNRSxvQkFBb0IsZ0RBQWdEO0FBQzFFLFNBQVNDLGtCQUFrQlosT0FBTztJQUNoQyxPQUFPMUQscUVBQWFBLENBQUMwRCxZQUFZQSxRQUFRQyxPQUFPLENBQUNVO0FBQ25EO0FBQ0EsU0FBU0UsVUFBVTFDLEtBQUs7SUFDdEJBLE1BQU0yQyxjQUFjO0lBQ3BCM0MsTUFBTTRDLGVBQWU7QUFDdkI7QUFDQSxTQUFTQyxtQkFBbUJoQixPQUFPO0lBQ2pDLElBQUksQ0FBQ0EsU0FBUyxPQUFPO0lBQ3JCLE9BQU9BLFFBQVFpQixZQUFZLENBQUMsWUFBWSxjQUFjTCxrQkFBa0JaO0FBQzFFO0FBRWlUIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQGZsb2F0aW5nLXVpL3JlYWN0L2Rpc3QvZmxvYXRpbmctdWkucmVhY3QudXRpbHMubWpzP2Q1MGMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgaXNTaGFkb3dSb290LCBpc0hUTUxFbGVtZW50IH0gZnJvbSAnQGZsb2F0aW5nLXVpL3V0aWxzL2RvbSc7XG5cbmZ1bmN0aW9uIGFjdGl2ZUVsZW1lbnQoZG9jKSB7XG4gIGxldCBhY3RpdmVFbGVtZW50ID0gZG9jLmFjdGl2ZUVsZW1lbnQ7XG4gIHdoaWxlICgoKF9hY3RpdmVFbGVtZW50ID0gYWN0aXZlRWxlbWVudCkgPT0gbnVsbCB8fCAoX2FjdGl2ZUVsZW1lbnQgPSBfYWN0aXZlRWxlbWVudC5zaGFkb3dSb290KSA9PSBudWxsID8gdm9pZCAwIDogX2FjdGl2ZUVsZW1lbnQuYWN0aXZlRWxlbWVudCkgIT0gbnVsbCkge1xuICAgIHZhciBfYWN0aXZlRWxlbWVudDtcbiAgICBhY3RpdmVFbGVtZW50ID0gYWN0aXZlRWxlbWVudC5zaGFkb3dSb290LmFjdGl2ZUVsZW1lbnQ7XG4gIH1cbiAgcmV0dXJuIGFjdGl2ZUVsZW1lbnQ7XG59XG5mdW5jdGlvbiBjb250YWlucyhwYXJlbnQsIGNoaWxkKSB7XG4gIGlmICghcGFyZW50IHx8ICFjaGlsZCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCByb290Tm9kZSA9IGNoaWxkLmdldFJvb3ROb2RlID09IG51bGwgPyB2b2lkIDAgOiBjaGlsZC5nZXRSb290Tm9kZSgpO1xuXG4gIC8vIEZpcnN0LCBhdHRlbXB0IHdpdGggZmFzdGVyIG5hdGl2ZSBtZXRob2RcbiAgaWYgKHBhcmVudC5jb250YWlucyhjaGlsZCkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8vIHRoZW4gZmFsbGJhY2sgdG8gY3VzdG9tIGltcGxlbWVudGF0aW9uIHdpdGggU2hhZG93IERPTSBzdXBwb3J0XG4gIGlmIChyb290Tm9kZSAmJiBpc1NoYWRvd1Jvb3Qocm9vdE5vZGUpKSB7XG4gICAgbGV0IG5leHQgPSBjaGlsZDtcbiAgICB3aGlsZSAobmV4dCkge1xuICAgICAgaWYgKHBhcmVudCA9PT0gbmV4dCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIG5leHQgPSBuZXh0LnBhcmVudE5vZGUgfHwgbmV4dC5ob3N0O1xuICAgIH1cbiAgfVxuXG4gIC8vIEdpdmUgdXAsIHRoZSByZXN1bHQgaXMgZmFsc2VcbiAgcmV0dXJuIGZhbHNlO1xufVxuLy8gQXZvaWQgQ2hyb21lIERldlRvb2xzIGJsdWUgd2FybmluZy5cbmZ1bmN0aW9uIGdldFBsYXRmb3JtKCkge1xuICBjb25zdCB1YURhdGEgPSBuYXZpZ2F0b3IudXNlckFnZW50RGF0YTtcbiAgaWYgKHVhRGF0YSAhPSBudWxsICYmIHVhRGF0YS5wbGF0Zm9ybSkge1xuICAgIHJldHVybiB1YURhdGEucGxhdGZvcm07XG4gIH1cbiAgcmV0dXJuIG5hdmlnYXRvci5wbGF0Zm9ybTtcbn1cbmZ1bmN0aW9uIGdldFVzZXJBZ2VudCgpIHtcbiAgY29uc3QgdWFEYXRhID0gbmF2aWdhdG9yLnVzZXJBZ2VudERhdGE7XG4gIGlmICh1YURhdGEgJiYgQXJyYXkuaXNBcnJheSh1YURhdGEuYnJhbmRzKSkge1xuICAgIHJldHVybiB1YURhdGEuYnJhbmRzLm1hcChfcmVmID0+IHtcbiAgICAgIGxldCB7XG4gICAgICAgIGJyYW5kLFxuICAgICAgICB2ZXJzaW9uXG4gICAgICB9ID0gX3JlZjtcbiAgICAgIHJldHVybiBicmFuZCArIFwiL1wiICsgdmVyc2lvbjtcbiAgICB9KS5qb2luKCcgJyk7XG4gIH1cbiAgcmV0dXJuIG5hdmlnYXRvci51c2VyQWdlbnQ7XG59XG5cbi8vIExpY2Vuc2U6IGh0dHBzOi8vZ2l0aHViLmNvbS9hZG9iZS9yZWFjdC1zcGVjdHJ1bS9ibG9iL2IzNWQ1YzAyZmU5MDBiYWRjY2QwY2YxYThmMjNiYjU5MzQxOWYyMzgvcGFja2FnZXMvQHJlYWN0LWFyaWEvdXRpbHMvc3JjL2lzVmlydHVhbEV2ZW50LnRzXG5mdW5jdGlvbiBpc1ZpcnR1YWxDbGljayhldmVudCkge1xuICAvLyBGSVhNRTogRmlyZWZveCBpcyBub3cgZW1pdHRpbmcgYSBkZXByZWNhdGlvbiB3YXJuaW5nIGZvciBgbW96SW5wdXRTb3VyY2VgLlxuICAvLyBUcnkgdG8gZmluZCBhIHdvcmthcm91bmQgZm9yIHRoaXMuIGByZWFjdC1hcmlhYCBzb3VyY2Ugc3RpbGwgaGFzIHRoZSBjaGVjay5cbiAgaWYgKGV2ZW50Lm1veklucHV0U291cmNlID09PSAwICYmIGV2ZW50LmlzVHJ1c3RlZCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChpc0FuZHJvaWQoKSAmJiBldmVudC5wb2ludGVyVHlwZSkge1xuICAgIHJldHVybiBldmVudC50eXBlID09PSAnY2xpY2snICYmIGV2ZW50LmJ1dHRvbnMgPT09IDE7XG4gIH1cbiAgcmV0dXJuIGV2ZW50LmRldGFpbCA9PT0gMCAmJiAhZXZlbnQucG9pbnRlclR5cGU7XG59XG5mdW5jdGlvbiBpc1ZpcnR1YWxQb2ludGVyRXZlbnQoZXZlbnQpIHtcbiAgaWYgKGlzSlNET00oKSkgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gIWlzQW5kcm9pZCgpICYmIGV2ZW50LndpZHRoID09PSAwICYmIGV2ZW50LmhlaWdodCA9PT0gMCB8fCBpc0FuZHJvaWQoKSAmJiBldmVudC53aWR0aCA9PT0gMSAmJiBldmVudC5oZWlnaHQgPT09IDEgJiYgZXZlbnQucHJlc3N1cmUgPT09IDAgJiYgZXZlbnQuZGV0YWlsID09PSAwICYmIGV2ZW50LnBvaW50ZXJUeXBlID09PSAnbW91c2UnIHx8XG4gIC8vIGlPUyBWb2ljZU92ZXIgcmV0dXJucyAwLjMzM+KAoiBmb3Igd2lkdGgvaGVpZ2h0LlxuICBldmVudC53aWR0aCA8IDEgJiYgZXZlbnQuaGVpZ2h0IDwgMSAmJiBldmVudC5wcmVzc3VyZSA9PT0gMCAmJiBldmVudC5kZXRhaWwgPT09IDAgJiYgZXZlbnQucG9pbnRlclR5cGUgPT09ICd0b3VjaCc7XG59XG5mdW5jdGlvbiBpc1NhZmFyaSgpIHtcbiAgLy8gQ2hyb21lIERldlRvb2xzIGRvZXMgbm90IGNvbXBsYWluIGFib3V0IG5hdmlnYXRvci52ZW5kb3JcbiAgcmV0dXJuIC9hcHBsZS9pLnRlc3QobmF2aWdhdG9yLnZlbmRvcik7XG59XG5mdW5jdGlvbiBpc0FuZHJvaWQoKSB7XG4gIGNvbnN0IHJlID0gL2FuZHJvaWQvaTtcbiAgcmV0dXJuIHJlLnRlc3QoZ2V0UGxhdGZvcm0oKSkgfHwgcmUudGVzdChnZXRVc2VyQWdlbnQoKSk7XG59XG5mdW5jdGlvbiBpc01hYygpIHtcbiAgcmV0dXJuIGdldFBsYXRmb3JtKCkudG9Mb3dlckNhc2UoKS5zdGFydHNXaXRoKCdtYWMnKSAmJiAhbmF2aWdhdG9yLm1heFRvdWNoUG9pbnRzO1xufVxuZnVuY3Rpb24gaXNKU0RPTSgpIHtcbiAgcmV0dXJuIGdldFVzZXJBZ2VudCgpLmluY2x1ZGVzKCdqc2RvbS8nKTtcbn1cbmZ1bmN0aW9uIGlzTW91c2VMaWtlUG9pbnRlclR5cGUocG9pbnRlclR5cGUsIHN0cmljdCkge1xuICAvLyBPbiBzb21lIExpbnV4IG1hY2hpbmVzIHdpdGggQ2hyb21pdW0sIG1vdXNlIGlucHV0cyByZXR1cm4gYSBgcG9pbnRlclR5cGVgXG4gIC8vIG9mIFwicGVuXCI6IGh0dHBzOi8vZ2l0aHViLmNvbS9mbG9hdGluZy11aS9mbG9hdGluZy11aS9pc3N1ZXMvMjAxNVxuICBjb25zdCB2YWx1ZXMgPSBbJ21vdXNlJywgJ3BlbiddO1xuICBpZiAoIXN0cmljdCkge1xuICAgIHZhbHVlcy5wdXNoKCcnLCB1bmRlZmluZWQpO1xuICB9XG4gIHJldHVybiB2YWx1ZXMuaW5jbHVkZXMocG9pbnRlclR5cGUpO1xufVxuZnVuY3Rpb24gaXNSZWFjdEV2ZW50KGV2ZW50KSB7XG4gIHJldHVybiAnbmF0aXZlRXZlbnQnIGluIGV2ZW50O1xufVxuZnVuY3Rpb24gaXNSb290RWxlbWVudChlbGVtZW50KSB7XG4gIHJldHVybiBlbGVtZW50Lm1hdGNoZXMoJ2h0bWwsYm9keScpO1xufVxuZnVuY3Rpb24gZ2V0RG9jdW1lbnQobm9kZSkge1xuICByZXR1cm4gKG5vZGUgPT0gbnVsbCA/IHZvaWQgMCA6IG5vZGUub3duZXJEb2N1bWVudCkgfHwgZG9jdW1lbnQ7XG59XG5mdW5jdGlvbiBpc0V2ZW50VGFyZ2V0V2l0aGluKGV2ZW50LCBub2RlKSB7XG4gIGlmIChub2RlID09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKCdjb21wb3NlZFBhdGgnIGluIGV2ZW50KSB7XG4gICAgcmV0dXJuIGV2ZW50LmNvbXBvc2VkUGF0aCgpLmluY2x1ZGVzKG5vZGUpO1xuICB9XG5cbiAgLy8gVFMgdGhpbmtzIGBldmVudGAgaXMgb2YgdHlwZSBuZXZlciBhcyBpdCBhc3N1bWVzIGFsbCBicm93c2VycyBzdXBwb3J0IGNvbXBvc2VkUGF0aCwgYnV0IGJyb3dzZXJzIHdpdGhvdXQgc2hhZG93IGRvbSBkb24ndFxuICBjb25zdCBlID0gZXZlbnQ7XG4gIHJldHVybiBlLnRhcmdldCAhPSBudWxsICYmIG5vZGUuY29udGFpbnMoZS50YXJnZXQpO1xufVxuZnVuY3Rpb24gZ2V0VGFyZ2V0KGV2ZW50KSB7XG4gIGlmICgnY29tcG9zZWRQYXRoJyBpbiBldmVudCkge1xuICAgIHJldHVybiBldmVudC5jb21wb3NlZFBhdGgoKVswXTtcbiAgfVxuXG4gIC8vIFRTIHRoaW5rcyBgZXZlbnRgIGlzIG9mIHR5cGUgbmV2ZXIgYXMgaXQgYXNzdW1lcyBhbGwgYnJvd3NlcnMgc3VwcG9ydFxuICAvLyBgY29tcG9zZWRQYXRoKClgLCBidXQgYnJvd3NlcnMgd2l0aG91dCBzaGFkb3cgRE9NIGRvbid0LlxuICByZXR1cm4gZXZlbnQudGFyZ2V0O1xufVxuY29uc3QgVFlQRUFCTEVfU0VMRUNUT1IgPSBcImlucHV0Om5vdChbdHlwZT0naGlkZGVuJ10pOm5vdChbZGlzYWJsZWRdKSxcIiArIFwiW2NvbnRlbnRlZGl0YWJsZV06bm90KFtjb250ZW50ZWRpdGFibGU9J2ZhbHNlJ10pLHRleHRhcmVhOm5vdChbZGlzYWJsZWRdKVwiO1xuZnVuY3Rpb24gaXNUeXBlYWJsZUVsZW1lbnQoZWxlbWVudCkge1xuICByZXR1cm4gaXNIVE1MRWxlbWVudChlbGVtZW50KSAmJiBlbGVtZW50Lm1hdGNoZXMoVFlQRUFCTEVfU0VMRUNUT1IpO1xufVxuZnVuY3Rpb24gc3RvcEV2ZW50KGV2ZW50KSB7XG4gIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xufVxuZnVuY3Rpb24gaXNUeXBlYWJsZUNvbWJvYm94KGVsZW1lbnQpIHtcbiAgaWYgKCFlbGVtZW50KSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBlbGVtZW50LmdldEF0dHJpYnV0ZSgncm9sZScpID09PSAnY29tYm9ib3gnICYmIGlzVHlwZWFibGVFbGVtZW50KGVsZW1lbnQpO1xufVxuXG5leHBvcnQgeyBUWVBFQUJMRV9TRUxFQ1RPUiwgYWN0aXZlRWxlbWVudCwgY29udGFpbnMsIGdldERvY3VtZW50LCBnZXRQbGF0Zm9ybSwgZ2V0VGFyZ2V0LCBnZXRVc2VyQWdlbnQsIGlzQW5kcm9pZCwgaXNFdmVudFRhcmdldFdpdGhpbiwgaXNKU0RPTSwgaXNNYWMsIGlzTW91c2VMaWtlUG9pbnRlclR5cGUsIGlzUmVhY3RFdmVudCwgaXNSb290RWxlbWVudCwgaXNTYWZhcmksIGlzVHlwZWFibGVDb21ib2JveCwgaXNUeXBlYWJsZUVsZW1lbnQsIGlzVmlydHVhbENsaWNrLCBpc1ZpcnR1YWxQb2ludGVyRXZlbnQsIHN0b3BFdmVudCB9O1xuIl0sIm5hbWVzIjpbImlzU2hhZG93Um9vdCIsImlzSFRNTEVsZW1lbnQiLCJhY3RpdmVFbGVtZW50IiwiZG9jIiwiX2FjdGl2ZUVsZW1lbnQiLCJzaGFkb3dSb290IiwiY29udGFpbnMiLCJwYXJlbnQiLCJjaGlsZCIsInJvb3ROb2RlIiwiZ2V0Um9vdE5vZGUiLCJuZXh0IiwicGFyZW50Tm9kZSIsImhvc3QiLCJnZXRQbGF0Zm9ybSIsInVhRGF0YSIsIm5hdmlnYXRvciIsInVzZXJBZ2VudERhdGEiLCJwbGF0Zm9ybSIsImdldFVzZXJBZ2VudCIsIkFycmF5IiwiaXNBcnJheSIsImJyYW5kcyIsIm1hcCIsIl9yZWYiLCJicmFuZCIsInZlcnNpb24iLCJqb2luIiwidXNlckFnZW50IiwiaXNWaXJ0dWFsQ2xpY2siLCJldmVudCIsIm1veklucHV0U291cmNlIiwiaXNUcnVzdGVkIiwiaXNBbmRyb2lkIiwicG9pbnRlclR5cGUiLCJ0eXBlIiwiYnV0dG9ucyIsImRldGFpbCIsImlzVmlydHVhbFBvaW50ZXJFdmVudCIsImlzSlNET00iLCJ3aWR0aCIsImhlaWdodCIsInByZXNzdXJlIiwiaXNTYWZhcmkiLCJ0ZXN0IiwidmVuZG9yIiwicmUiLCJpc01hYyIsInRvTG93ZXJDYXNlIiwic3RhcnRzV2l0aCIsIm1heFRvdWNoUG9pbnRzIiwiaW5jbHVkZXMiLCJpc01vdXNlTGlrZVBvaW50ZXJUeXBlIiwic3RyaWN0IiwidmFsdWVzIiwicHVzaCIsInVuZGVmaW5lZCIsImlzUmVhY3RFdmVudCIsImlzUm9vdEVsZW1lbnQiLCJlbGVtZW50IiwibWF0Y2hlcyIsImdldERvY3VtZW50Iiwibm9kZSIsIm93bmVyRG9jdW1lbnQiLCJkb2N1bWVudCIsImlzRXZlbnRUYXJnZXRXaXRoaW4iLCJjb21wb3NlZFBhdGgiLCJlIiwidGFyZ2V0IiwiZ2V0VGFyZ2V0IiwiVFlQRUFCTEVfU0VMRUNUT1IiLCJpc1R5cGVhYmxlRWxlbWVudCIsInN0b3BFdmVudCIsInByZXZlbnREZWZhdWx0Iiwic3RvcFByb3BhZ2F0aW9uIiwiaXNUeXBlYWJsZUNvbWJvYm94IiwiZ2V0QXR0cmlidXRlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../../../node_modules/@floating-ui/react/dist/floating-ui.react.utils.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/../../../../node_modules/@floating-ui/utils/dist/floating-ui.utils.dom.mjs":
/*!**********************************************************************************!*\
  !*** ../../../../node_modules/@floating-ui/utils/dist/floating-ui.utils.dom.mjs ***!
  \**********************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getComputedStyle: function() { return /* binding */ getComputedStyle; },\n/* harmony export */   getContainingBlock: function() { return /* binding */ getContainingBlock; },\n/* harmony export */   getDocumentElement: function() { return /* binding */ getDocumentElement; },\n/* harmony export */   getFrameElement: function() { return /* binding */ getFrameElement; },\n/* harmony export */   getNearestOverflowAncestor: function() { return /* binding */ getNearestOverflowAncestor; },\n/* harmony export */   getNodeName: function() { return /* binding */ getNodeName; },\n/* harmony export */   getNodeScroll: function() { return /* binding */ getNodeScroll; },\n/* harmony export */   getOverflowAncestors: function() { return /* binding */ getOverflowAncestors; },\n/* harmony export */   getParentNode: function() { return /* binding */ getParentNode; },\n/* harmony export */   getWindow: function() { return /* binding */ getWindow; },\n/* harmony export */   isContainingBlock: function() { return /* binding */ isContainingBlock; },\n/* harmony export */   isElement: function() { return /* binding */ isElement; },\n/* harmony export */   isHTMLElement: function() { return /* binding */ isHTMLElement; },\n/* harmony export */   isLastTraversableNode: function() { return /* binding */ isLastTraversableNode; },\n/* harmony export */   isNode: function() { return /* binding */ isNode; },\n/* harmony export */   isOverflowElement: function() { return /* binding */ isOverflowElement; },\n/* harmony export */   isShadowRoot: function() { return /* binding */ isShadowRoot; },\n/* harmony export */   isTableElement: function() { return /* binding */ isTableElement; },\n/* harmony export */   isTopLayer: function() { return /* binding */ isTopLayer; },\n/* harmony export */   isWebKit: function() { return /* binding */ isWebKit; }\n/* harmony export */ });\nfunction hasWindow() {\n    return \"object\" !== \"undefined\";\n}\nfunction getNodeName(node) {\n    if (isNode(node)) {\n        return (node.nodeName || \"\").toLowerCase();\n    }\n    // Mocked nodes in testing environments may not be instances of Node. By\n    // returning `#document` an infinite loop won't occur.\n    // https://github.com/floating-ui/floating-ui/issues/2317\n    return \"#document\";\n}\nfunction getWindow(node) {\n    var _node$ownerDocument;\n    return (node == null || (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;\n}\nfunction getDocumentElement(node) {\n    var _ref;\n    return (_ref = (isNode(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;\n}\nfunction isNode(value) {\n    if (!hasWindow()) {\n        return false;\n    }\n    return value instanceof Node || value instanceof getWindow(value).Node;\n}\nfunction isElement(value) {\n    if (!hasWindow()) {\n        return false;\n    }\n    return value instanceof Element || value instanceof getWindow(value).Element;\n}\nfunction isHTMLElement(value) {\n    if (!hasWindow()) {\n        return false;\n    }\n    return value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement;\n}\nfunction isShadowRoot(value) {\n    if (!hasWindow() || typeof ShadowRoot === \"undefined\") {\n        return false;\n    }\n    return value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;\n}\nfunction isOverflowElement(element) {\n    const { overflow, overflowX, overflowY, display } = getComputedStyle(element);\n    return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && ![\n        \"inline\",\n        \"contents\"\n    ].includes(display);\n}\nfunction isTableElement(element) {\n    return [\n        \"table\",\n        \"td\",\n        \"th\"\n    ].includes(getNodeName(element));\n}\nfunction isTopLayer(element) {\n    return [\n        \":popover-open\",\n        \":modal\"\n    ].some((selector)=>{\n        try {\n            return element.matches(selector);\n        } catch (e) {\n            return false;\n        }\n    });\n}\nfunction isContainingBlock(elementOrCss) {\n    const webkit = isWebKit();\n    const css = isElement(elementOrCss) ? getComputedStyle(elementOrCss) : elementOrCss;\n    // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n    // https://drafts.csswg.org/css-transforms-2/#individual-transforms\n    return [\n        \"transform\",\n        \"translate\",\n        \"scale\",\n        \"rotate\",\n        \"perspective\"\n    ].some((value)=>css[value] ? css[value] !== \"none\" : false) || (css.containerType ? css.containerType !== \"normal\" : false) || !webkit && (css.backdropFilter ? css.backdropFilter !== \"none\" : false) || !webkit && (css.filter ? css.filter !== \"none\" : false) || [\n        \"transform\",\n        \"translate\",\n        \"scale\",\n        \"rotate\",\n        \"perspective\",\n        \"filter\"\n    ].some((value)=>(css.willChange || \"\").includes(value)) || [\n        \"paint\",\n        \"layout\",\n        \"strict\",\n        \"content\"\n    ].some((value)=>(css.contain || \"\").includes(value));\n}\nfunction getContainingBlock(element) {\n    let currentNode = getParentNode(element);\n    while(isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)){\n        if (isContainingBlock(currentNode)) {\n            return currentNode;\n        } else if (isTopLayer(currentNode)) {\n            return null;\n        }\n        currentNode = getParentNode(currentNode);\n    }\n    return null;\n}\nfunction isWebKit() {\n    if (typeof CSS === \"undefined\" || !CSS.supports) return false;\n    return CSS.supports(\"-webkit-backdrop-filter\", \"none\");\n}\nfunction isLastTraversableNode(node) {\n    return [\n        \"html\",\n        \"body\",\n        \"#document\"\n    ].includes(getNodeName(node));\n}\nfunction getComputedStyle(element) {\n    return getWindow(element).getComputedStyle(element);\n}\nfunction getNodeScroll(element) {\n    if (isElement(element)) {\n        return {\n            scrollLeft: element.scrollLeft,\n            scrollTop: element.scrollTop\n        };\n    }\n    return {\n        scrollLeft: element.scrollX,\n        scrollTop: element.scrollY\n    };\n}\nfunction getParentNode(node) {\n    if (getNodeName(node) === \"html\") {\n        return node;\n    }\n    const result = // Step into the shadow DOM of the parent of a slotted node.\n    node.assignedSlot || // DOM Element detected.\n    node.parentNode || // ShadowRoot detected.\n    isShadowRoot(node) && node.host || // Fallback.\n    getDocumentElement(node);\n    return isShadowRoot(result) ? result.host : result;\n}\nfunction getNearestOverflowAncestor(node) {\n    const parentNode = getParentNode(node);\n    if (isLastTraversableNode(parentNode)) {\n        return node.ownerDocument ? node.ownerDocument.body : node.body;\n    }\n    if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {\n        return parentNode;\n    }\n    return getNearestOverflowAncestor(parentNode);\n}\nfunction getOverflowAncestors(node, list, traverseIframes) {\n    var _node$ownerDocument2;\n    if (list === void 0) {\n        list = [];\n    }\n    if (traverseIframes === void 0) {\n        traverseIframes = true;\n    }\n    const scrollableAncestor = getNearestOverflowAncestor(node);\n    const isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);\n    const win = getWindow(scrollableAncestor);\n    if (isBody) {\n        const frameElement = getFrameElement(win);\n        return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], frameElement && traverseIframes ? getOverflowAncestors(frameElement) : []);\n    }\n    return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));\n}\nfunction getFrameElement(win) {\n    return win.parent && Object.getPrototypeOf(win.parent) ? win.frameElement : null;\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQGZsb2F0aW5nLXVpL3V0aWxzL2Rpc3QvZmxvYXRpbmctdWkudXRpbHMuZG9tLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLFNBQVNBO0lBQ1AsT0FBTyxhQUFrQjtBQUMzQjtBQUNBLFNBQVNDLFlBQVlDLElBQUk7SUFDdkIsSUFBSUMsT0FBT0QsT0FBTztRQUNoQixPQUFPLENBQUNBLEtBQUtFLFFBQVEsSUFBSSxFQUFDLEVBQUdDLFdBQVc7SUFDMUM7SUFDQSx3RUFBd0U7SUFDeEUsc0RBQXNEO0lBQ3RELHlEQUF5RDtJQUN6RCxPQUFPO0FBQ1Q7QUFDQSxTQUFTQyxVQUFVSixJQUFJO0lBQ3JCLElBQUlLO0lBQ0osT0FBTyxDQUFDTCxRQUFRLFFBQVEsQ0FBQ0ssc0JBQXNCTCxLQUFLTSxhQUFhLEtBQUssT0FBTyxLQUFLLElBQUlELG9CQUFvQkUsV0FBVyxLQUFLQztBQUM1SDtBQUNBLFNBQVNDLG1CQUFtQlQsSUFBSTtJQUM5QixJQUFJVTtJQUNKLE9BQU8sQ0FBQ0EsT0FBTyxDQUFDVCxPQUFPRCxRQUFRQSxLQUFLTSxhQUFhLEdBQUdOLEtBQUtXLFFBQVEsS0FBS0gsT0FBT0csUUFBUSxLQUFLLE9BQU8sS0FBSyxJQUFJRCxLQUFLRSxlQUFlO0FBQ2hJO0FBQ0EsU0FBU1gsT0FBT1ksS0FBSztJQUNuQixJQUFJLENBQUNmLGFBQWE7UUFDaEIsT0FBTztJQUNUO0lBQ0EsT0FBT2UsaUJBQWlCQyxRQUFRRCxpQkFBaUJULFVBQVVTLE9BQU9DLElBQUk7QUFDeEU7QUFDQSxTQUFTQyxVQUFVRixLQUFLO0lBQ3RCLElBQUksQ0FBQ2YsYUFBYTtRQUNoQixPQUFPO0lBQ1Q7SUFDQSxPQUFPZSxpQkFBaUJHLFdBQVdILGlCQUFpQlQsVUFBVVMsT0FBT0csT0FBTztBQUM5RTtBQUNBLFNBQVNDLGNBQWNKLEtBQUs7SUFDMUIsSUFBSSxDQUFDZixh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TSxhQUFhLEtBQUssT0FBTyxLQUFLLElBQUk0RCxxQkFBcUJKLElBQUk7SUFDL0gsTUFBTU8sTUFBTWpFLFVBQVUrRDtJQUN0QixJQUFJQyxRQUFRO1FBQ1YsTUFBTUUsZUFBZUMsZ0JBQWdCRjtRQUNyQyxPQUFPTCxLQUFLUSxNQUFNLENBQUNILEtBQUtBLElBQUlJLGNBQWMsSUFBSSxFQUFFLEVBQUVwRCxrQkFBa0I4QyxzQkFBc0JBLHFCQUFxQixFQUFFLEVBQUVHLGdCQUFnQkwsa0JBQWtCRixxQkFBcUJPLGdCQUFnQixFQUFFO0lBQzlMO0lBQ0EsT0FBT04sS0FBS1EsTUFBTSxDQUFDTCxvQkFBb0JKLHFCQUFxQkksb0JBQW9CLEVBQUUsRUFBRUY7QUFDdEY7QUFDQSxTQUFTTSxnQkFBZ0JGLEdBQUc7SUFDMUIsT0FBT0EsSUFBSUssTUFBTSxJQUFJQyxPQUFPQyxjQUFjLENBQUNQLElBQUlLLE1BQU0sSUFBSUwsSUFBSUMsWUFBWSxHQUFHO0FBQzlFO0FBRWdWIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQGZsb2F0aW5nLXVpL3V0aWxzL2Rpc3QvZmxvYXRpbmctdWkudXRpbHMuZG9tLm1qcz82YjZiIl0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIGhhc1dpbmRvdygpIHtcbiAgcmV0dXJuIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnO1xufVxuZnVuY3Rpb24gZ2V0Tm9kZU5hbWUobm9kZSkge1xuICBpZiAoaXNOb2RlKG5vZGUpKSB7XG4gICAgcmV0dXJuIChub2RlLm5vZGVOYW1lIHx8ICcnKS50b0xvd2VyQ2FzZSgpO1xuICB9XG4gIC8vIE1vY2tlZCBub2RlcyBpbiB0ZXN0aW5nIGVudmlyb25tZW50cyBtYXkgbm90IGJlIGluc3RhbmNlcyBvZiBOb2RlLiBCeVxuICAvLyByZXR1cm5pbmcgYCNkb2N1bWVudGAgYW4gaW5maW5pdGUgbG9vcCB3b24ndCBvY2N1ci5cbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2Zsb2F0aW5nLXVpL2Zsb2F0aW5nLXVpL2lzc3Vlcy8yMzE3XG4gIHJldHVybiAnI2RvY3VtZW50Jztcbn1cbmZ1bmN0aW9uIGdldFdpbmRvdyhub2RlKSB7XG4gIHZhciBfbm9kZSRvd25lckRvY3VtZW50O1xuICByZXR1cm4gKG5vZGUgPT0gbnVsbCB8fCAoX25vZGUkb3duZXJEb2N1bWVudCA9IG5vZGUub3duZXJEb2N1bWVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9ub2RlJG93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcpIHx8IHdpbmRvdztcbn1cbmZ1bmN0aW9uIGdldERvY3VtZW50RWxlbWVudChub2RlKSB7XG4gIHZhciBfcmVmO1xuICByZXR1cm4gKF9yZWYgPSAoaXNOb2RlKG5vZGUpID8gbm9kZS5vd25lckRvY3VtZW50IDogbm9kZS5kb2N1bWVudCkgfHwgd2luZG93LmRvY3VtZW50KSA9PSBudWxsID8gdm9pZCAwIDogX3JlZi5kb2N1bWVudEVsZW1lbnQ7XG59XG5mdW5jdGlvbiBpc05vZGUodmFsdWUpIHtcbiAgaWYgKCFoYXNXaW5kb3coKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBOb2RlIHx8IHZhbHVlIGluc3RhbmNlb2YgZ2V0V2luZG93KHZhbHVlKS5Ob2RlO1xufVxuZnVuY3Rpb24gaXNFbGVtZW50KHZhbHVlKSB7XG4gIGlmICghaGFzV2luZG93KCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgRWxlbWVudCB8fCB2YWx1ZSBpbnN0YW5jZW9mIGdldFdpbmRvdyh2YWx1ZSkuRWxlbWVudDtcbn1cbmZ1bmN0aW9uIGlzSFRNTEVsZW1lbnQodmFsdWUpIHtcbiAgaWYgKCFoYXNXaW5kb3coKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCB8fCB2YWx1ZSBpbnN0YW5jZW9mIGdldFdpbmRvdyh2YWx1ZSkuSFRNTEVsZW1lbnQ7XG59XG5mdW5jdGlvbiBpc1NoYWRvd1Jvb3QodmFsdWUpIHtcbiAgaWYgKCFoYXNXaW5kb3coKSB8fCB0eXBlb2YgU2hhZG93Um9vdCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgU2hhZG93Um9vdCB8fCB2YWx1ZSBpbnN0YW5jZW9mIGdldFdpbmRvdyh2YWx1ZSkuU2hhZG93Um9vdDtcbn1cbmZ1bmN0aW9uIGlzT3ZlcmZsb3dFbGVtZW50KGVsZW1lbnQpIHtcbiAgY29uc3Qge1xuICAgIG92ZXJmbG93LFxuICAgIG92ZXJmbG93WCxcbiAgICBvdmVyZmxvd1ksXG4gICAgZGlzcGxheVxuICB9ID0gZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KTtcbiAgcmV0dXJuIC9hdXRvfHNjcm9sbHxvdmVybGF5fGhpZGRlbnxjbGlwLy50ZXN0KG92ZXJmbG93ICsgb3ZlcmZsb3dZICsgb3ZlcmZsb3dYKSAmJiAhWydpbmxpbmUnLCAnY29udGVudHMnXS5pbmNsdWRlcyhkaXNwbGF5KTtcbn1cbmZ1bmN0aW9uIGlzVGFibGVFbGVtZW50KGVsZW1lbnQpIHtcbiAgcmV0dXJuIFsndGFibGUnLCAndGQnLCAndGgnXS5pbmNsdWRlcyhnZXROb2RlTmFtZShlbGVtZW50KSk7XG59XG5mdW5jdGlvbiBpc1RvcExheWVyKGVsZW1lbnQpIHtcbiAgcmV0dXJuIFsnOnBvcG92ZXItb3BlbicsICc6bW9kYWwnXS5zb21lKHNlbGVjdG9yID0+IHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGVsZW1lbnQubWF0Y2hlcyhzZWxlY3Rvcik7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBpc0NvbnRhaW5pbmdCbG9jayhlbGVtZW50T3JDc3MpIHtcbiAgY29uc3Qgd2Via2l0ID0gaXNXZWJLaXQoKTtcbiAgY29uc3QgY3NzID0gaXNFbGVtZW50KGVsZW1lbnRPckNzcykgPyBnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnRPckNzcykgOiBlbGVtZW50T3JDc3M7XG5cbiAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQ1NTL0NvbnRhaW5pbmdfYmxvY2sjaWRlbnRpZnlpbmdfdGhlX2NvbnRhaW5pbmdfYmxvY2tcbiAgLy8gaHR0cHM6Ly9kcmFmdHMuY3Nzd2cub3JnL2Nzcy10cmFuc2Zvcm1zLTIvI2luZGl2aWR1YWwtdHJhbnNmb3Jtc1xuICByZXR1cm4gWyd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlJywgJ3NjYWxlJywgJ3JvdGF0ZScsICdwZXJzcGVjdGl2ZSddLnNvbWUodmFsdWUgPT4gY3NzW3ZhbHVlXSA/IGNzc1t2YWx1ZV0gIT09ICdub25lJyA6IGZhbHNlKSB8fCAoY3NzLmNvbnRhaW5lclR5cGUgPyBjc3MuY29udGFpbmVyVHlwZSAhPT0gJ25vcm1hbCcgOiBmYWxzZSkgfHwgIXdlYmtpdCAmJiAoY3NzLmJhY2tkcm9wRmlsdGVyID8gY3NzLmJhY2tkcm9wRmlsdGVyICE9PSAnbm9uZScgOiBmYWxzZSkgfHwgIXdlYmtpdCAmJiAoY3NzLmZpbHRlciA/IGNzcy5maWx0ZXIgIT09ICdub25lJyA6IGZhbHNlKSB8fCBbJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUnLCAnc2NhbGUnLCAncm90YXRlJywgJ3BlcnNwZWN0aXZlJywgJ2ZpbHRlciddLnNvbWUodmFsdWUgPT4gKGNzcy53aWxsQ2hhbmdlIHx8ICcnKS5pbmNsdWRlcyh2YWx1ZSkpIHx8IFsncGFpbnQnLCAnbGF5b3V0JywgJ3N0cmljdCcsICdjb250ZW50J10uc29tZSh2YWx1ZSA9PiAoY3NzLmNvbnRhaW4gfHwgJycpLmluY2x1ZGVzKHZhbHVlKSk7XG59XG5mdW5jdGlvbiBnZXRDb250YWluaW5nQmxvY2soZWxlbWVudCkge1xuICBsZXQgY3VycmVudE5vZGUgPSBnZXRQYXJlbnROb2RlKGVsZW1lbnQpO1xuICB3aGlsZSAoaXNIVE1MRWxlbWVudChjdXJyZW50Tm9kZSkgJiYgIWlzTGFzdFRyYXZlcnNhYmxlTm9kZShjdXJyZW50Tm9kZSkpIHtcbiAgICBpZiAoaXNDb250YWluaW5nQmxvY2soY3VycmVudE5vZGUpKSB7XG4gICAgICByZXR1cm4gY3VycmVudE5vZGU7XG4gICAgfSBlbHNlIGlmIChpc1RvcExheWVyKGN1cnJlbnROb2RlKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGN1cnJlbnROb2RlID0gZ2V0UGFyZW50Tm9kZShjdXJyZW50Tm9kZSk7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBpc1dlYktpdCgpIHtcbiAgaWYgKHR5cGVvZiBDU1MgPT09ICd1bmRlZmluZWQnIHx8ICFDU1Muc3VwcG9ydHMpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIENTUy5zdXBwb3J0cygnLXdlYmtpdC1iYWNrZHJvcC1maWx0ZXInLCAnbm9uZScpO1xufVxuZnVuY3Rpb24gaXNMYXN0VHJhdmVyc2FibGVOb2RlKG5vZGUpIHtcbiAgcmV0dXJuIFsnaHRtbCcsICdib2R5JywgJyNkb2N1bWVudCddLmluY2x1ZGVzKGdldE5vZGVOYW1lKG5vZGUpKTtcbn1cbmZ1bmN0aW9uIGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCkge1xuICByZXR1cm4gZ2V0V2luZG93KGVsZW1lbnQpLmdldENvbXB1dGVkU3R5bGUoZWxlbWVudCk7XG59XG5mdW5jdGlvbiBnZXROb2RlU2Nyb2xsKGVsZW1lbnQpIHtcbiAgaWYgKGlzRWxlbWVudChlbGVtZW50KSkge1xuICAgIHJldHVybiB7XG4gICAgICBzY3JvbGxMZWZ0OiBlbGVtZW50LnNjcm9sbExlZnQsXG4gICAgICBzY3JvbGxUb3A6IGVsZW1lbnQuc2Nyb2xsVG9wXG4gICAgfTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHNjcm9sbExlZnQ6IGVsZW1lbnQuc2Nyb2xsWCxcbiAgICBzY3JvbGxUb3A6IGVsZW1lbnQuc2Nyb2xsWVxuICB9O1xufVxuZnVuY3Rpb24gZ2V0UGFyZW50Tm9kZShub2RlKSB7XG4gIGlmIChnZXROb2RlTmFtZShub2RlKSA9PT0gJ2h0bWwnKSB7XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cbiAgY29uc3QgcmVzdWx0ID1cbiAgLy8gU3RlcCBpbnRvIHRoZSBzaGFkb3cgRE9NIG9mIHRoZSBwYXJlbnQgb2YgYSBzbG90dGVkIG5vZGUuXG4gIG5vZGUuYXNzaWduZWRTbG90IHx8XG4gIC8vIERPTSBFbGVtZW50IGRldGVjdGVkLlxuICBub2RlLnBhcmVudE5vZGUgfHxcbiAgLy8gU2hhZG93Um9vdCBkZXRlY3RlZC5cbiAgaXNTaGFkb3dSb290KG5vZGUpICYmIG5vZGUuaG9zdCB8fFxuICAvLyBGYWxsYmFjay5cbiAgZ2V0RG9jdW1lbnRFbGVtZW50KG5vZGUpO1xuICByZXR1cm4gaXNTaGFkb3dSb290KHJlc3VsdCkgPyByZXN1bHQuaG9zdCA6IHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGdldE5lYXJlc3RPdmVyZmxvd0FuY2VzdG9yKG5vZGUpIHtcbiAgY29uc3QgcGFyZW50Tm9kZSA9IGdldFBhcmVudE5vZGUobm9kZSk7XG4gIGlmIChpc0xhc3RUcmF2ZXJzYWJsZU5vZGUocGFyZW50Tm9kZSkpIHtcbiAgICByZXR1cm4gbm9kZS5vd25lckRvY3VtZW50ID8gbm9kZS5vd25lckRvY3VtZW50LmJvZHkgOiBub2RlLmJvZHk7XG4gIH1cbiAgaWYgKGlzSFRNTEVsZW1lbnQocGFyZW50Tm9kZSkgJiYgaXNPdmVyZmxvd0VsZW1lbnQocGFyZW50Tm9kZSkpIHtcbiAgICByZXR1cm4gcGFyZW50Tm9kZTtcbiAgfVxuICByZXR1cm4gZ2V0TmVhcmVzdE92ZXJmbG93QW5jZXN0b3IocGFyZW50Tm9kZSk7XG59XG5mdW5jdGlvbiBnZXRPdmVyZmxvd0FuY2VzdG9ycyhub2RlLCBsaXN0LCB0cmF2ZXJzZUlmcmFtZXMpIHtcbiAgdmFyIF9ub2RlJG93bmVyRG9jdW1lbnQyO1xuICBpZiAobGlzdCA9PT0gdm9pZCAwKSB7XG4gICAgbGlzdCA9IFtdO1xuICB9XG4gIGlmICh0cmF2ZXJzZUlmcmFtZXMgPT09IHZvaWQgMCkge1xuICAgIHRyYXZlcnNlSWZyYW1lcyA9IHRydWU7XG4gIH1cbiAgY29uc3Qgc2Nyb2xsYWJsZUFuY2VzdG9yID0gZ2V0TmVhcmVzdE92ZXJmbG93QW5jZXN0b3Iobm9kZSk7XG4gIGNvbnN0IGlzQm9keSA9IHNjcm9sbGFibGVBbmNlc3RvciA9PT0gKChfbm9kZSRvd25lckRvY3VtZW50MiA9IG5vZGUub3duZXJEb2N1bWVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9ub2RlJG93bmVyRG9jdW1lbnQyLmJvZHkpO1xuICBjb25zdCB3aW4gPSBnZXRXaW5kb3coc2Nyb2xsYWJsZUFuY2VzdG9yKTtcbiAgaWYgKGlzQm9keSkge1xuICAgIGNvbnN0IGZyYW1lRWxlbWVudCA9IGdldEZyYW1lRWxlbWVudCh3aW4pO1xuICAgIHJldHVybiBsaXN0LmNvbmNhdCh3aW4sIHdpbi52aXN1YWxWaWV3cG9ydCB8fCBbXSwgaXNPdmVyZmxvd0VsZW1lbnQoc2Nyb2xsYWJsZUFuY2VzdG9yKSA/IHNjcm9sbGFibGVBbmNlc3RvciA6IFtdLCBmcmFtZUVsZW1lbnQgJiYgdHJhdmVyc2VJZnJhbWVzID8gZ2V0T3ZlcmZsb3dBbmNlc3RvcnMoZnJhbWVFbGVtZW50KSA6IFtdKTtcbiAgfVxuICByZXR1cm4gbGlzdC5jb25jYXQoc2Nyb2xsYWJsZUFuY2VzdG9yLCBnZXRPdmVyZmxvd0FuY2VzdG9ycyhzY3JvbGxhYmxlQW5jZXN0b3IsIFtdLCB0cmF2ZXJzZUlmcmFtZXMpKTtcbn1cbmZ1bmN0aW9uIGdldEZyYW1lRWxlbWVudCh3aW4pIHtcbiAgcmV0dXJuIHdpbi5wYXJlbnQgJiYgT2JqZWN0LmdldFByb3RvdHlwZU9mKHdpbi5wYXJlbnQpID8gd2luLmZyYW1lRWxlbWVudCA6IG51bGw7XG59XG5cbmV4cG9ydCB7IGdldENvbXB1dGVkU3R5bGUsIGdldENvbnRhaW5pbmdCbG9jaywgZ2V0RG9jdW1lbnRFbGVtZW50LCBnZXRGcmFtZUVsZW1lbnQsIGdldE5lYXJlc3RPdmVyZmxvd0FuY2VzdG9yLCBnZXROb2RlTmFtZSwgZ2V0Tm9kZVNjcm9sbCwgZ2V0T3ZlcmZsb3dBbmNlc3RvcnMsIGdldFBhcmVudE5vZGUsIGdldFdpbmRvdywgaXNDb250YWluaW5nQmxvY2ssIGlzRWxlbWVudCwgaXNIVE1MRWxlbWVudCwgaXNMYXN0VHJhdmVyc2FibGVOb2RlLCBpc05vZGUsIGlzT3ZlcmZsb3dFbGVtZW50LCBpc1NoYWRvd1Jvb3QsIGlzVGFibGVFbGVtZW50LCBpc1RvcExheWVyLCBpc1dlYktpdCB9O1xuIl0sIm5hbWVzIjpbImhhc1dpbmRvdyIsImdldE5vZGVOYW1lIiwibm9kZSIsImlzTm9kZSIsIm5vZGVOYW1lIiwidG9Mb3dlckNhc2UiLCJnZXRXaW5kb3ciLCJfbm9kZSRvd25lckRvY3VtZW50Iiwib3duZXJEb2N1bWVudCIsImRlZmF1bHRWaWV3Iiwid2luZG93IiwiZ2V0RG9jdW1lbnRFbGVtZW50IiwiX3JlZiIsImRvY3VtZW50IiwiZG9jdW1lbnRFbGVtZW50IiwidmFsdWUiLCJOb2RlIiwiaXNFbGVtZW50IiwiRWxlbWVudCIsImlzSFRNTEVsZW1lbnQiLCJIVE1MRWxlbWVudCIsImlzU2hhZG93Um9vdCIsIlNoYWRvd1Jvb3QiLCJpc092ZXJmbG93RWxlbWVudCIsImVsZW1lbnQiLCJvdmVyZmxvdyIsIm92ZXJmbG93WCIsIm92ZXJmbG93WSIsImRpc3BsYXkiLCJnZXRDb21wdXRlZFN0eWxlIiwidGVzdCIsImluY2x1ZGVzIiwiaXNUYWJsZUVsZW1lbnQiLCJpc1RvcExheWVyIiwic29tZSIsInNlbGVjdG9yIiwibWF0Y2hlcyIsImUiLCJpc0NvbnRhaW5pbmdCbG9jayIsImVsZW1lbnRPckNzcyIsIndlYmtpdCIsImlzV2ViS2l0IiwiY3NzIiwiY29udGFpbmVyVHlwZSIsImJhY2tkcm9wRmlsdGVyIiwiZmlsdGVyIiwid2lsbENoYW5nZSIsImNvbnRhaW4iLCJnZXRDb250YWluaW5nQmxvY2siLCJjdXJyZW50Tm9kZSIsImdldFBhcmVudE5vZGUiLCJpc0xhc3RUcmF2ZXJzYWJsZU5vZGUiLCJDU1MiLCJzdXBwb3J0cyIsImdldE5vZGVTY3JvbGwiLCJzY3JvbGxMZWZ0Iiwic2Nyb2xsVG9wIiwic2Nyb2xsWCIsInNjcm9sbFkiLCJyZXN1bHQiLCJhc3NpZ25lZFNsb3QiLCJwYXJlbnROb2RlIiwiaG9zdCIsImdldE5lYXJlc3RPdmVyZmxvd0FuY2VzdG9yIiwiYm9keSIsImdldE92ZXJmbG93QW5jZXN0b3JzIiwibGlzdCIsInRyYXZlcnNlSWZyYW1lcyIsIl9ub2RlJG93bmVyRG9jdW1lbnQyIiwic2Nyb2xsYWJsZUFuY2VzdG9yIiwiaXNCb2R5Iiwid2luIiwiZnJhbWVFbGVtZW50IiwiZ2V0RnJhbWVFbGVtZW50IiwiY29uY2F0IiwidmlzdWFsVmlld3BvcnQiLCJwYXJlbnQiLCJPYmplY3QiLCJnZXRQcm90b3R5cGVPZiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../../../node_modules/@floating-ui/utils/dist/floating-ui.utils.dom.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/../../../../node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs":
/*!******************************************************************************!*\
  !*** ../../../../node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs ***!
  \******************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   alignments: function() { return /* binding */ alignments; },\n/* harmony export */   clamp: function() { return /* binding */ clamp; },\n/* harmony export */   createCoords: function() { return /* binding */ createCoords; },\n/* harmony export */   evaluate: function() { return /* binding */ evaluate; },\n/* harmony export */   expandPaddingObject: function() { return /* binding */ expandPaddingObject; },\n/* harmony export */   floor: function() { return /* binding */ floor; },\n/* harmony export */   getAlignment: function() { return /* binding */ getAlignment; },\n/* harmony export */   getAlignmentAxis: function() { return /* binding */ getAlignmentAxis; },\n/* harmony export */   getAlignmentSides: function() { return /* binding */ getAlignmentSides; },\n/* harmony export */   getAxisLength: function() { return /* binding */ getAxisLength; },\n/* harmony export */   getExpandedPlacements: function() { return /* binding */ getExpandedPlacements; },\n/* harmony export */   getOppositeAlignmentPlacement: function() { return /* binding */ getOppositeAlignmentPlacement; },\n/* harmony export */   getOppositeAxis: function() { return /* binding */ getOppositeAxis; },\n/* harmony export */   getOppositeAxisPlacements: function() { return /* binding */ getOppositeAxisPlacements; },\n/* harmony export */   getOppositePlacement: function() { return /* binding */ getOppositePlacement; },\n/* harmony export */   getPaddingObject: function() { return /* binding */ getPaddingObject; },\n/* harmony export */   getSide: function() { return /* binding */ getSide; },\n/* harmony export */   getSideAxis: function() { return /* binding */ getSideAxis; },\n/* harmony export */   max: function() { return /* binding */ max; },\n/* harmony export */   min: function() { return /* binding */ min; },\n/* harmony export */   placements: function() { return /* binding */ placements; },\n/* harmony export */   rectToClientRect: function() { return /* binding */ rectToClientRect; },\n/* harmony export */   round: function() { return /* binding */ round; },\n/* harmony export */   sides: function() { return /* binding */ sides; }\n/* harmony export */ });\n/**\n * Custom positioning reference element.\n * @see https://floating-ui.com/docs/virtual-elements\n */ const sides = [\n    \"top\",\n    \"right\",\n    \"bottom\",\n    \"left\"\n];\nconst alignments = [\n    \"start\",\n    \"end\"\n];\nconst placements = /*#__PURE__*/ sides.reduce((acc, side)=>acc.concat(side, side + \"-\" + alignments[0], side + \"-\" + alignments[1]), []);\nconst min = Math.min;\nconst max = Math.max;\nconst round = Math.round;\nconst floor = Math.floor;\nconst createCoords = (v)=>({\n        x: v,\n        y: v\n    });\nconst oppositeSideMap = {\n    left: \"right\",\n    right: \"left\",\n    bottom: \"top\",\n    top: \"bottom\"\n};\nconst oppositeAlignmentMap = {\n    start: \"end\",\n    end: \"start\"\n};\nfunction clamp(start, value, end) {\n    return max(start, min(value, end));\n}\nfunction evaluate(value, param) {\n    return typeof value === \"function\" ? value(param) : value;\n}\nfunction getSide(placement) {\n    return placement.split(\"-\")[0];\n}\nfunction getAlignment(placement) {\n    return placement.split(\"-\")[1];\n}\nfunction getOppositeAxis(axis) {\n    return axis === \"x\" ? \"y\" : \"x\";\n}\nfunction getAxisLength(axis) {\n    return axis === \"y\" ? \"height\" : \"width\";\n}\nfunction getSideAxis(placement) {\n    return [\n        \"top\",\n        \"bottom\"\n    ].includes(getSide(placement)) ? \"y\" : \"x\";\n}\nfunction getAlignmentAxis(placement) {\n    return getOppositeAxis(getSideAxis(placement));\n}\nfunction getAlignmentSides(placement, rects, rtl) {\n    if (rtl === void 0) {\n        rtl = false;\n    }\n    const alignment = getAlignment(placement);\n    const alignmentAxis = getAlignmentAxis(placement);\n    const length = getAxisLength(alignmentAxis);\n    let mainAlignmentSide = alignmentAxis === \"x\" ? alignment === (rtl ? \"end\" : \"start\") ? \"right\" : \"left\" : alignment === \"start\" ? \"bottom\" : \"top\";\n    if (rects.reference[length] > rects.floating[length]) {\n        mainAlignmentSide = getOppositePlacement(mainAlignmentSide);\n    }\n    return [\n        mainAlignmentSide,\n        getOppositePlacement(mainAlignmentSide)\n    ];\n}\nfunction getExpandedPlacements(placement) {\n    const oppositePlacement = getOppositePlacement(placement);\n    return [\n        getOppositeAlignmentPlacement(placement),\n        oppositePlacement,\n        getOppositeAlignmentPlacement(oppositePlacement)\n    ];\n}\nfunction getOppositeAlignmentPlacement(placement) {\n    return placement.replace(/start|end/g, (alignment)=>oppositeAlignmentMap[alignment]);\n}\nfunction getSideList(side, isStart, rtl) {\n    const lr = [\n        \"left\",\n        \"right\"\n    ];\n    const rl = [\n        \"right\",\n        \"left\"\n    ];\n    const tb = [\n        \"top\",\n        \"bottom\"\n    ];\n    const bt = [\n        \"bottom\",\n        \"top\"\n    ];\n    switch(side){\n        case \"top\":\n        case \"bottom\":\n            if (rtl) return isStart ? rl : lr;\n            return isStart ? lr : rl;\n        case \"left\":\n        case \"right\":\n            return isStart ? tb : bt;\n        default:\n            return [];\n    }\n}\nfunction getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {\n    const alignment = getAlignment(placement);\n    let list = getSideList(getSide(placement), direction === \"start\", rtl);\n    if (alignment) {\n        list = list.map((side)=>side + \"-\" + alignment);\n        if (flipAlignment) {\n            list = list.concat(list.map(getOppositeAlignmentPlacement));\n        }\n    }\n    return list;\n}\nfunction getOppositePlacement(placement) {\n    return placement.replace(/left|right|bottom|top/g, (side)=>oppositeSideMap[side]);\n}\nfunction expandPaddingObject(padding) {\n    return {\n        top: 0,\n        right: 0,\n        bottom: 0,\n        left: 0,\n        ...padding\n    };\n}\nfunction getPaddingObject(padding) {\n    return typeof padding !== \"number\" ? expandPaddingObject(padding) : {\n        top: padding,\n        right: padding,\n        bottom: padding,\n        left: padding\n    };\n}\nfunction rectToClientRect(rect) {\n    const { x, y, width, height } = rect;\n    return {\n        width,\n        height,\n        top: y,\n        left: x,\n        right: x + width,\n        bottom: y + height,\n        x,\n        y\n    };\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQGZsb2F0aW5nLXVpL3V0aWxzL2Rpc3QvZmxvYXRpbmctdWkudXRpbHMubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBOzs7Q0FHQyxHQUVELE1BQU1BLFFBQVE7SUFBQztJQUFPO0lBQVM7SUFBVTtDQUFPO0FBQ2hELE1BQU1DLGFBQWE7SUFBQztJQUFTO0NBQU07QUFDbkMsTUFBTUMsYUFBYSxXQUFXLEdBQUVGLE1BQU1HLE1BQU0sQ0FBQyxDQUFDQyxLQUFLQyxPQUFTRCxJQUFJRSxNQUFNLENBQUNELE1BQU1BLE9BQU8sTUFBTUosVUFBVSxDQUFDLEVBQUUsRUFBRUksT0FBTyxNQUFNSixVQUFVLENBQUMsRUFBRSxHQUFHLEVBQUU7QUFDeEksTUFBTU0sTUFBTUMsS0FBS0QsR0FBRztBQUNwQixNQUFNRSxNQUFNRCxLQUFLQyxHQUFHO0FBQ3BCLE1BQU1DLFFBQVFGLEtBQUtFLEtBQUs7QUFDeEIsTUFBTUMsUUFBUUgsS0FBS0csS0FBSztBQUN4QixNQUFNQyxlQUFlQyxDQUFBQSxJQUFNO1FBQ3pCQyxHQUFHRDtRQUNIRSxHQUFHRjtJQUNMO0FBQ0EsTUFBTUcsa0JBQWtCO0lBQ3RCQyxNQUFNO0lBQ05DLE9BQU87SUFDUEMsUUFBUTtJQUNSQyxLQUFLO0FBQ1A7QUFDQSxNQUFNQyx1QkFBdUI7SUFDM0JDLE9BQU87SUFDUEMsS0FBSztBQUNQO0FBQ0EsU0FBU0MsTUFBTUYsS0FBSyxFQUFFRyxLQUFLLEVBQUVGLEdBQUc7SUFDOUIsT0FBT2QsSUFBSWEsT0FBT2YsSUFBSWtCLE9BQU9GO0FBQy9CO0FBQ0EsU0FBU0csU0FBU0QsS0FBSyxFQUFFRSxLQUFLO0lBQzVCLE9BQU8sT0FBT0YsVUFBVSxhQUFhQSxNQUFNRSxTQUFTRjtBQUN0RDtBQUNBLFNBQVNHLFFBQVFDLFNBQVM7SUFDeEIsT0FBT0EsVUFBVUMsS0FBSyxDQUFDLElBQUks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Q0EsU0FBU0MsaUJBQWlCRCxPQUFPO0lBQy9CLE9BQU8sT0FBT0EsWUFBWSxXQUFXRCxvQkFBb0JDLFdBQVc7UUFDbEU1QyxLQUFLNEM7UUFDTDlDLE9BQU84QztRQUNQN0MsUUFBUTZDO1FBQ1IvQyxNQUFNK0M7SUFDUjtBQUNGO0FBQ0EsU0FBU0UsaUJBQWlCQyxJQUFJO0lBQzVCLE1BQU0sRUFDSnJELENBQUMsRUFDREMsQ0FBQyxFQUNEcUQsS0FBSyxFQUNMQyxNQUFNLEVBQ1AsR0FBR0Y7SUFDSixPQUFPO1FBQ0xDO1FBQ0FDO1FBQ0FqRCxLQUFLTDtRQUNMRSxNQUFNSDtRQUNOSSxPQUFPSixJQUFJc0Q7UUFDWGpELFFBQVFKLElBQUlzRDtRQUNadkQ7UUFDQUM7SUFDRjtBQUNGO0FBRXlXIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQGZsb2F0aW5nLXVpL3V0aWxzL2Rpc3QvZmxvYXRpbmctdWkudXRpbHMubWpzPzU0N2MiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDdXN0b20gcG9zaXRpb25pbmcgcmVmZXJlbmNlIGVsZW1lbnQuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvdmlydHVhbC1lbGVtZW50c1xuICovXG5cbmNvbnN0IHNpZGVzID0gWyd0b3AnLCAncmlnaHQnLCAnYm90dG9tJywgJ2xlZnQnXTtcbmNvbnN0IGFsaWdubWVudHMgPSBbJ3N0YXJ0JywgJ2VuZCddO1xuY29uc3QgcGxhY2VtZW50cyA9IC8qI19fUFVSRV9fKi9zaWRlcy5yZWR1Y2UoKGFjYywgc2lkZSkgPT4gYWNjLmNvbmNhdChzaWRlLCBzaWRlICsgXCItXCIgKyBhbGlnbm1lbnRzWzBdLCBzaWRlICsgXCItXCIgKyBhbGlnbm1lbnRzWzFdKSwgW10pO1xuY29uc3QgbWluID0gTWF0aC5taW47XG5jb25zdCBtYXggPSBNYXRoLm1heDtcbmNvbnN0IHJvdW5kID0gTWF0aC5yb3VuZDtcbmNvbnN0IGZsb29yID0gTWF0aC5mbG9vcjtcbmNvbnN0IGNyZWF0ZUNvb3JkcyA9IHYgPT4gKHtcbiAgeDogdixcbiAgeTogdlxufSk7XG5jb25zdCBvcHBvc2l0ZVNpZGVNYXAgPSB7XG4gIGxlZnQ6ICdyaWdodCcsXG4gIHJpZ2h0OiAnbGVmdCcsXG4gIGJvdHRvbTogJ3RvcCcsXG4gIHRvcDogJ2JvdHRvbSdcbn07XG5jb25zdCBvcHBvc2l0ZUFsaWdubWVudE1hcCA9IHtcbiAgc3RhcnQ6ICdlbmQnLFxuICBlbmQ6ICdzdGFydCdcbn07XG5mdW5jdGlvbiBjbGFtcChzdGFydCwgdmFsdWUsIGVuZCkge1xuICByZXR1cm4gbWF4KHN0YXJ0LCBtaW4odmFsdWUsIGVuZCkpO1xufVxuZnVuY3Rpb24gZXZhbHVhdGUodmFsdWUsIHBhcmFtKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicgPyB2YWx1ZShwYXJhbSkgOiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIGdldFNpZGUocGxhY2VtZW50KSB7XG4gIHJldHVybiBwbGFjZW1lbnQuc3BsaXQoJy0nKVswXTtcbn1cbmZ1bmN0aW9uIGdldEFsaWdubWVudChwbGFjZW1lbnQpIHtcbiAgcmV0dXJuIHBsYWNlbWVudC5zcGxpdCgnLScpWzFdO1xufVxuZnVuY3Rpb24gZ2V0T3Bwb3NpdGVBeGlzKGF4aXMpIHtcbiAgcmV0dXJuIGF4aXMgPT09ICd4JyA/ICd5JyA6ICd4Jztcbn1cbmZ1bmN0aW9uIGdldEF4aXNMZW5ndGgoYXhpcykge1xuICByZXR1cm4gYXhpcyA9PT0gJ3knID8gJ2hlaWdodCcgOiAnd2lkdGgnO1xufVxuZnVuY3Rpb24gZ2V0U2lkZUF4aXMocGxhY2VtZW50KSB7XG4gIHJldHVybiBbJ3RvcCcsICdib3R0b20nXS5pbmNsdWRlcyhnZXRTaWRlKHBsYWNlbWVudCkpID8gJ3knIDogJ3gnO1xufVxuZnVuY3Rpb24gZ2V0QWxpZ25tZW50QXhpcyhwbGFjZW1lbnQpIHtcbiAgcmV0dXJuIGdldE9wcG9zaXRlQXhpcyhnZXRTaWRlQXhpcyhwbGFjZW1lbnQpKTtcbn1cbmZ1bmN0aW9uIGdldEFsaWdubWVudFNpZGVzKHBsYWNlbWVudCwgcmVjdHMsIHJ0bCkge1xuICBpZiAocnRsID09PSB2b2lkIDApIHtcbiAgICBydGwgPSBmYWxzZTtcbiAgfVxuICBjb25zdCBhbGlnbm1lbnQgPSBnZXRBbGlnbm1lbnQocGxhY2VtZW50KTtcbiAgY29uc3QgYWxpZ25tZW50QXhpcyA9IGdldEFsaWdubWVudEF4aXMocGxhY2VtZW50KTtcbiAgY29uc3QgbGVuZ3RoID0gZ2V0QXhpc0xlbmd0aChhbGlnbm1lbnRBeGlzKTtcbiAgbGV0IG1haW5BbGlnbm1lbnRTaWRlID0gYWxpZ25tZW50QXhpcyA9PT0gJ3gnID8gYWxpZ25tZW50ID09PSAocnRsID8gJ2VuZCcgOiAnc3RhcnQnKSA/ICdyaWdodCcgOiAnbGVmdCcgOiBhbGlnbm1lbnQgPT09ICdzdGFydCcgPyAnYm90dG9tJyA6ICd0b3AnO1xuICBpZiAocmVjdHMucmVmZXJlbmNlW2xlbmd0aF0gPiByZWN0cy5mbG9hdGluZ1tsZW5ndGhdKSB7XG4gICAgbWFpbkFsaWdubWVudFNpZGUgPSBnZXRPcHBvc2l0ZVBsYWNlbWVudChtYWluQWxpZ25tZW50U2lkZSk7XG4gIH1cbiAgcmV0dXJuIFttYWluQWxpZ25tZW50U2lkZSwgZ2V0T3Bwb3NpdGVQbGFjZW1lbnQobWFpbkFsaWdubWVudFNpZGUpXTtcbn1cbmZ1bmN0aW9uIGdldEV4cGFuZGVkUGxhY2VtZW50cyhwbGFjZW1lbnQpIHtcbiAgY29uc3Qgb3Bwb3NpdGVQbGFjZW1lbnQgPSBnZXRPcHBvc2l0ZVBsYWNlbWVudChwbGFjZW1lbnQpO1xuICByZXR1cm4gW2dldE9wcG9zaXRlQWxpZ25tZW50UGxhY2VtZW50KHBsYWNlbWVudCksIG9wcG9zaXRlUGxhY2VtZW50LCBnZXRPcHBvc2l0ZUFsaWdubWVudFBsYWNlbWVudChvcHBvc2l0ZVBsYWNlbWVudCldO1xufVxuZnVuY3Rpb24gZ2V0T3Bwb3NpdGVBbGlnbm1lbnRQbGFjZW1lbnQocGxhY2VtZW50KSB7XG4gIHJldHVybiBwbGFjZW1lbnQucmVwbGFjZSgvc3RhcnR8ZW5kL2csIGFsaWdubWVudCA9PiBvcHBvc2l0ZUFsaWdubWVudE1hcFthbGlnbm1lbnRdKTtcbn1cbmZ1bmN0aW9uIGdldFNpZGVMaXN0KHNpZGUsIGlzU3RhcnQsIHJ0bCkge1xuICBjb25zdCBsciA9IFsnbGVmdCcsICdyaWdodCddO1xuICBjb25zdCBybCA9IFsncmlnaHQnLCAnbGVmdCddO1xuICBjb25zdCB0YiA9IFsndG9wJywgJ2JvdHRvbSddO1xuICBjb25zdCBidCA9IFsnYm90dG9tJywgJ3RvcCddO1xuICBzd2l0Y2ggKHNpZGUpIHtcbiAgICBjYXNlICd0b3AnOlxuICAgIGNhc2UgJ2JvdHRvbSc6XG4gICAgICBpZiAocnRsKSByZXR1cm4gaXNTdGFydCA/IHJsIDogbHI7XG4gICAgICByZXR1cm4gaXNTdGFydCA/IGxyIDogcmw7XG4gICAgY2FzZSAnbGVmdCc6XG4gICAgY2FzZSAncmlnaHQnOlxuICAgICAgcmV0dXJuIGlzU3RhcnQgPyB0YiA6IGJ0O1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gW107XG4gIH1cbn1cbmZ1bmN0aW9uIGdldE9wcG9zaXRlQXhpc1BsYWNlbWVudHMocGxhY2VtZW50LCBmbGlwQWxpZ25tZW50LCBkaXJlY3Rpb24sIHJ0bCkge1xuICBjb25zdCBhbGlnbm1lbnQgPSBnZXRBbGlnbm1lbnQocGxhY2VtZW50KTtcbiAgbGV0IGxpc3QgPSBnZXRTaWRlTGlzdChnZXRTaWRlKHBsYWNlbWVudCksIGRpcmVjdGlvbiA9PT0gJ3N0YXJ0JywgcnRsKTtcbiAgaWYgKGFsaWdubWVudCkge1xuICAgIGxpc3QgPSBsaXN0Lm1hcChzaWRlID0+IHNpZGUgKyBcIi1cIiArIGFsaWdubWVudCk7XG4gICAgaWYgKGZsaXBBbGlnbm1lbnQpIHtcbiAgICAgIGxpc3QgPSBsaXN0LmNvbmNhdChsaXN0Lm1hcChnZXRPcHBvc2l0ZUFsaWdubWVudFBsYWNlbWVudCkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbGlzdDtcbn1cbmZ1bmN0aW9uIGdldE9wcG9zaXRlUGxhY2VtZW50KHBsYWNlbWVudCkge1xuICByZXR1cm4gcGxhY2VtZW50LnJlcGxhY2UoL2xlZnR8cmlnaHR8Ym90dG9tfHRvcC9nLCBzaWRlID0+IG9wcG9zaXRlU2lkZU1hcFtzaWRlXSk7XG59XG5mdW5jdGlvbiBleHBhbmRQYWRkaW5nT2JqZWN0KHBhZGRpbmcpIHtcbiAgcmV0dXJuIHtcbiAgICB0b3A6IDAsXG4gICAgcmlnaHQ6IDAsXG4gICAgYm90dG9tOiAwLFxuICAgIGxlZnQ6IDAsXG4gICAgLi4ucGFkZGluZ1xuICB9O1xufVxuZnVuY3Rpb24gZ2V0UGFkZGluZ09iamVjdChwYWRkaW5nKSB7XG4gIHJldHVybiB0eXBlb2YgcGFkZGluZyAhPT0gJ251bWJlcicgPyBleHBhbmRQYWRkaW5nT2JqZWN0KHBhZGRpbmcpIDoge1xuICAgIHRvcDogcGFkZGluZyxcbiAgICByaWdodDogcGFkZGluZyxcbiAgICBib3R0b206IHBhZGRpbmcsXG4gICAgbGVmdDogcGFkZGluZ1xuICB9O1xufVxuZnVuY3Rpb24gcmVjdFRvQ2xpZW50UmVjdChyZWN0KSB7XG4gIGNvbnN0IHtcbiAgICB4LFxuICAgIHksXG4gICAgd2lkdGgsXG4gICAgaGVpZ2h0XG4gIH0gPSByZWN0O1xuICByZXR1cm4ge1xuICAgIHdpZHRoLFxuICAgIGhlaWdodCxcbiAgICB0b3A6IHksXG4gICAgbGVmdDogeCxcbiAgICByaWdodDogeCArIHdpZHRoLFxuICAgIGJvdHRvbTogeSArIGhlaWdodCxcbiAgICB4LFxuICAgIHlcbiAgfTtcbn1cblxuZXhwb3J0IHsgYWxpZ25tZW50cywgY2xhbXAsIGNyZWF0ZUNvb3JkcywgZXZhbHVhdGUsIGV4cGFuZFBhZGRpbmdPYmplY3QsIGZsb29yLCBnZXRBbGlnbm1lbnQsIGdldEFsaWdubWVudEF4aXMsIGdldEFsaWdubWVudFNpZGVzLCBnZXRBeGlzTGVuZ3RoLCBnZXRFeHBhbmRlZFBsYWNlbWVudHMsIGdldE9wcG9zaXRlQWxpZ25tZW50UGxhY2VtZW50LCBnZXRPcHBvc2l0ZUF4aXMsIGdldE9wcG9zaXRlQXhpc1BsYWNlbWVudHMsIGdldE9wcG9zaXRlUGxhY2VtZW50LCBnZXRQYWRkaW5nT2JqZWN0LCBnZXRTaWRlLCBnZXRTaWRlQXhpcywgbWF4LCBtaW4sIHBsYWNlbWVudHMsIHJlY3RUb0NsaWVudFJlY3QsIHJvdW5kLCBzaWRlcyB9O1xuIl0sIm5hbWVzIjpbInNpZGVzIiwiYWxpZ25tZW50cyIsInBsYWNlbWVudHMiLCJyZWR1Y2UiLCJhY2MiLCJzaWRlIiwiY29uY2F0IiwibWluIiwiTWF0aCIsIm1heCIsInJvdW5kIiwiZmxvb3IiLCJjcmVhdGVDb29yZHMiLCJ2IiwieCIsInkiLCJvcHBvc2l0ZVNpZGVNYXAiLCJsZWZ0IiwicmlnaHQiLCJib3R0b20iLCJ0b3AiLCJvcHBvc2l0ZUFsaWdubWVudE1hcCIsInN0YXJ0IiwiZW5kIiwiY2xhbXAiLCJ2YWx1ZSIsImV2YWx1YXRlIiwicGFyYW0iLCJnZXRTaWRlIiwicGxhY2VtZW50Iiwic3BsaXQiLCJnZXRBbGlnbm1lbnQiLCJnZXRPcHBvc2l0ZUF4aXMiLCJheGlzIiwiZ2V0QXhpc0xlbmd0aCIsImdldFNpZGVBeGlzIiwiaW5jbHVkZXMiLCJnZXRBbGlnbm1lbnRBeGlzIiwiZ2V0QWxpZ25tZW50U2lkZXMiLCJyZWN0cyIsInJ0bCIsImFsaWdubWVudCIsImFsaWdubWVudEF4aXMiLCJsZW5ndGgiLCJtYWluQWxpZ25tZW50U2lkZSIsInJlZmVyZW5jZSIsImZsb2F0aW5nIiwiZ2V0T3Bwb3NpdGVQbGFjZW1lbnQiLCJnZXRFeHBhbmRlZFBsYWNlbWVudHMiLCJvcHBvc2l0ZVBsYWNlbWVudCIsImdldE9wcG9zaXRlQWxpZ25tZW50UGxhY2VtZW50IiwicmVwbGFjZSIsImdldFNpZGVMaXN0IiwiaXNTdGFydCIsImxyIiwicmwiLCJ0YiIsImJ0IiwiZ2V0T3Bwb3NpdGVBeGlzUGxhY2VtZW50cyIsImZsaXBBbGlnbm1lbnQiLCJkaXJlY3Rpb24iLCJsaXN0IiwibWFwIiwiZXhwYW5kUGFkZGluZ09iamVjdCIsInBhZGRpbmciLCJnZXRQYWRkaW5nT2JqZWN0IiwicmVjdFRvQ2xpZW50UmVjdCIsInJlY3QiLCJ3aWR0aCIsImhlaWdodCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../../../node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/../../../../node_modules/@headlessui/react/dist/components/label/label.js":
/*!*********************************************************************************!*\
  !*** ../../../../node_modules/@headlessui/react/dist/components/label/label.js ***!
  \*********************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Label: function() { return /* binding */ Q; },\n/* harmony export */   useLabelContext: function() { return /* binding */ P; },\n/* harmony export */   useLabelledBy: function() { return /* binding */ I; },\n/* harmony export */   useLabels: function() { return /* binding */ K; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../hooks/use-id.js */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var _hooks_use_event_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../hooks/use-event.js */ \"(app-pages-browser)/../../../../node_modules/@headlessui/react/dist/hooks/use-event.js\");\n/* harmony import */ var _hooks_use_iso_morphic_effect_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../hooks/use-iso-morphic-effect.js */ \"(app-pages-browser)/../../../../node_modules/@headlessui/react/dist/hooks/use-iso-morphic-effect.js\");\n/* harmony import */ var _hooks_use_sync_refs_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../hooks/use-sync-refs.js */ \"(app-pages-browser)/../../../../node_modules/@headlessui/react/dist/hooks/use-sync-refs.js\");\n/* harmony import */ var _internal_disabled_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../internal/disabled.js */ \"(app-pages-browser)/../../../../node_modules/@headlessui/react/dist/internal/disabled.js\");\n/* harmony import */ var _internal_id_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../internal/id.js */ \"(app-pages-browser)/../../../../node_modules/@headlessui/react/dist/internal/id.js\");\n/* harmony import */ var _utils_render_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../utils/render.js */ \"(app-pages-browser)/../../../../node_modules/@headlessui/react/dist/utils/render.js\");\n/* __next_internal_client_entry_do_not_use__ Label,useLabelContext,useLabelledBy,useLabels auto */ \n\n\n\n\n\n\n\nlet c = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(null);\nc.displayName = \"LabelContext\";\nfunction P() {\n    let r = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(c);\n    if (r === null) {\n        let l = new Error(\"You used a <Label /> component, but it is not inside a relevant parent.\");\n        throw Error.captureStackTrace && Error.captureStackTrace(l, P), l;\n    }\n    return r;\n}\n_c = P;\nfunction I(r) {\n    var a, e, o;\n    let l = (e = (a = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(c)) == null ? void 0 : a.value) != null ? e : void 0;\n    return ((o = r == null ? void 0 : r.length) != null ? o : 0) > 0 ? [\n        l,\n        ...r\n    ].filter(Boolean).join(\" \") : l;\n}\n_c1 = I;\nfunction K() {\n    let { inherit: r = !1 } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n    let l = I(), [a, e] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]), o = r ? [\n        l,\n        ...a\n    ].filter(Boolean) : a;\n    return [\n        o.length > 0 ? o.join(\" \") : void 0,\n        (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>function(t) {\n                let s = (0,_hooks_use_event_js__WEBPACK_IMPORTED_MODULE_1__.useEvent)((i)=>(e((p)=>[\n                            ...p,\n                            i\n                        ]), ()=>e((p)=>{\n                            let u = p.slice(), d = u.indexOf(i);\n                            return d !== -1 && u.splice(d, 1), u;\n                        }))), m = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>({\n                        register: s,\n                        slot: t.slot,\n                        name: t.name,\n                        props: t.props,\n                        value: t.value\n                    }), [\n                    s,\n                    t.slot,\n                    t.name,\n                    t.props,\n                    t.value\n                ]);\n                return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(c.Provider, {\n                    value: m\n                }, t.children);\n            }, [\n            e\n        ])\n    ];\n}\n_c2 = K;\nlet N = \"label\";\nfunction G(r, l) {\n    var y;\n    let a = (0,react__WEBPACK_IMPORTED_MODULE_0__.useId)(), e = P(), o = (0,_internal_id_js__WEBPACK_IMPORTED_MODULE_2__.useProvidedId)(), g = (0,_internal_disabled_js__WEBPACK_IMPORTED_MODULE_3__.useDisabled)(), { id: t = \"headlessui-label-\".concat(a), htmlFor: s = o != null ? o : (y = e.props) == null ? void 0 : y.htmlFor, passive: m = !1, ...i } = r, p = (0,_hooks_use_sync_refs_js__WEBPACK_IMPORTED_MODULE_4__.useSyncRefs)(l);\n    (0,_hooks_use_iso_morphic_effect_js__WEBPACK_IMPORTED_MODULE_5__.useIsoMorphicEffect)(()=>e.register(t), [\n        t,\n        e.register\n    ]);\n    let u = (0,_hooks_use_event_js__WEBPACK_IMPORTED_MODULE_1__.useEvent)((L)=>{\n        let b = L.currentTarget;\n        if (b instanceof HTMLLabelElement && L.preventDefault(), e.props && \"onClick\" in e.props && typeof e.props.onClick == \"function\" && e.props.onClick(L), b instanceof HTMLLabelElement) {\n            let n = document.getElementById(b.htmlFor);\n            if (n) {\n                let E = n.getAttribute(\"disabled\");\n                if (E === \"true\" || E === \"\") return;\n                let x = n.getAttribute(\"aria-disabled\");\n                if (x === \"true\" || x === \"\") return;\n                (n instanceof HTMLInputElement && (n.type === \"radio\" || n.type === \"checkbox\") || n.role === \"radio\" || n.role === \"checkbox\" || n.role === \"switch\") && n.click(), n.focus({\n                    preventScroll: !0\n                });\n            }\n        }\n    }), d = g || !1, C = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>({\n            ...e.slot,\n            disabled: d\n        }), [\n        e.slot,\n        d\n    ]), f = {\n        ref: p,\n        ...e.props,\n        id: t,\n        htmlFor: s,\n        onClick: u\n    };\n    return m && (\"onClick\" in f && (delete f.htmlFor, delete f.onClick), \"onClick\" in i && delete i.onClick), (0,_utils_render_js__WEBPACK_IMPORTED_MODULE_6__.useRender)()({\n        ourProps: f,\n        theirProps: i,\n        slot: C,\n        defaultTag: s ? N : \"div\",\n        name: e.name || \"Label\"\n    });\n}\n_c3 = G;\nlet U = (0,_utils_render_js__WEBPACK_IMPORTED_MODULE_6__.forwardRefWithAs)(G), Q = Object.assign(U, {});\n\nvar _c, _c1, _c2, _c3;\n$RefreshReg$(_c, \"P\");\n$RefreshReg$(_c1, \"I\");\n$RefreshReg$(_c2, \"K\");\n$RefreshReg$(_c3, \"G\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQGhlYWRsZXNzdWkvcmVhY3QvZGlzdC9jb21wb25lbnRzL2xhYmVsL2xhYmVsLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O21HQUFpRztBQUFvRDtBQUE4QztBQUE0RTtBQUEyRDtBQUF5RDtBQUFxRDtBQUF3RTtBQUFBLElBQUl5QixrQkFBRXZCLG9EQUFDQSxDQUFDO0FBQU11QixFQUFFQyxXQUFXLEdBQUM7QUFBZSxTQUFTQztJQUFJLElBQUlDLElBQUV4QixpREFBQ0EsQ0FBQ3FCO0lBQUcsSUFBR0csTUFBSSxNQUFLO1FBQUMsSUFBSUMsSUFBRSxJQUFJQyxNQUFNO1FBQTJFLE1BQU1BLE1BQU1DLGlCQUFpQixJQUFFRCxNQUFNQyxpQkFBaUIsQ0FBQ0YsR0FBRUYsSUFBR0U7SUFBQztJQUFDLE9BQU9EO0FBQUM7S0FBN0xEO0FBQThMLFNBQVNLLEVBQUVKLENBQUM7SUFBRSxJQUFJSyxHQUFFQyxHQUFFQztJQUFFLElBQUlOLElBQUUsQ0FBQ0ssSUFBRSxDQUFDRCxJQUFFN0IsaURBQUNBLENBQUNxQixFQUFDLEtBQUksT0FBSyxLQUFLLElBQUVRLEVBQUVHLEtBQUssS0FBRyxPQUFLRixJQUFFLEtBQUs7SUFBRSxPQUFNLENBQUMsQ0FBQ0MsSUFBRVAsS0FBRyxPQUFLLEtBQUssSUFBRUEsRUFBRVMsTUFBTSxLQUFHLE9BQUtGLElBQUUsS0FBRyxJQUFFO1FBQUNOO1dBQUtEO0tBQUUsQ0FBQ1UsTUFBTSxDQUFDQyxTQUFTQyxJQUFJLENBQUMsT0FBS1g7QUFBQztNQUExSkc7QUFBMkosU0FBU1M7UUFBRSxFQUFDQyxTQUFRZCxJQUFFLENBQUMsQ0FBQyxFQUFDLEdBQWQsaUVBQWUsQ0FBQztJQUFHLElBQUlDLElBQUVHLEtBQUksQ0FBQ0MsR0FBRUMsRUFBRSxHQUFDMUIsK0NBQUNBLENBQUMsRUFBRSxHQUFFMkIsSUFBRVAsSUFBRTtRQUFDQztXQUFLSTtLQUFF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QUFFO1FBQUM7SUFBQyxJQUFHbkMsSUFBRWMsS0FBRyxDQUFDLEdBQUVzQixJQUFFL0UsOENBQUNBLENBQUMsSUFBSztZQUFDLEdBQUc0QixFQUFFb0IsSUFBSTtZQUFDZ0MsVUFBU3JDO1FBQUMsSUFBRztRQUFDZixFQUFFb0IsSUFBSTtRQUFDTDtLQUFFLEdBQUVzQyxJQUFFO1FBQUNDLEtBQUkxQztRQUFFLEdBQUdaLEVBQUVzQixLQUFLO1FBQUNRLElBQUdyQjtRQUFFc0IsU0FBUXJCO1FBQUU0QixTQUFRekI7SUFBQztJQUFFLE9BQU9LLEtBQUksY0FBWW1DLEtBQUksUUFBT0EsRUFBRXRCLE9BQU8sRUFBQyxPQUFPc0IsRUFBRWYsT0FBTyxHQUFFLGFBQVkzQixLQUFHLE9BQU9BLEVBQUUyQixPQUFPLEdBQUVoRCwyREFBQ0EsR0FBRztRQUFDaUUsVUFBU0Y7UUFBRUcsWUFBVzdDO1FBQUVTLE1BQUsrQjtRQUFFTSxZQUFXL0MsSUFBRWdCLElBQUU7UUFBTUwsTUFBS3JCLEVBQUVxQixJQUFJLElBQUU7SUFBTztBQUFFO01BQXgvQk07QUFBeS9CLElBQUkrQixJQUFFdEUsa0VBQUNBLENBQUN1QyxJQUFHZ0MsSUFBRUMsT0FBT0MsTUFBTSxDQUFDSCxHQUFFLENBQUM7QUFBNkUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AaGVhZGxlc3N1aS9yZWFjdC9kaXN0L2NvbXBvbmVudHMvbGFiZWwvbGFiZWwuanM/ZTBmNSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBjbGllbnRcIjtpbXBvcnQgUix7Y3JlYXRlQ29udGV4dCBhcyBrLHVzZUNvbnRleHQgYXMgaCx1c2VNZW1vIGFzIFQsdXNlU3RhdGUgYXMgRH1mcm9tXCJyZWFjdFwiO2ltcG9ydHt1c2VFdmVudCBhcyB2fWZyb20nLi4vLi4vaG9va3MvdXNlLWV2ZW50LmpzJztpbXBvcnR7dXNlSWQgYXMgX31mcm9tJy4uLy4uL2hvb2tzL3VzZS1pZC5qcyc7aW1wb3J0e3VzZUlzb01vcnBoaWNFZmZlY3QgYXMgQX1mcm9tJy4uLy4uL2hvb2tzL3VzZS1pc28tbW9ycGhpYy1lZmZlY3QuanMnO2ltcG9ydHt1c2VTeW5jUmVmcyBhcyBCfWZyb20nLi4vLi4vaG9va3MvdXNlLXN5bmMtcmVmcy5qcyc7aW1wb3J0e3VzZURpc2FibGVkIGFzIEZ9ZnJvbScuLi8uLi9pbnRlcm5hbC9kaXNhYmxlZC5qcyc7aW1wb3J0e3VzZVByb3ZpZGVkSWQgYXMgU31mcm9tJy4uLy4uL2ludGVybmFsL2lkLmpzJztpbXBvcnR7Zm9yd2FyZFJlZldpdGhBcyBhcyBNLHVzZVJlbmRlciBhcyBIfWZyb20nLi4vLi4vdXRpbHMvcmVuZGVyLmpzJztsZXQgYz1rKG51bGwpO2MuZGlzcGxheU5hbWU9XCJMYWJlbENvbnRleHRcIjtmdW5jdGlvbiBQKCl7bGV0IHI9aChjKTtpZihyPT09bnVsbCl7bGV0IGw9bmV3IEVycm9yKFwiWW91IHVzZWQgYSA8TGFiZWwgLz4gY29tcG9uZW50LCBidXQgaXQgaXMgbm90IGluc2lkZSBhIHJlbGV2YW50IHBhcmVudC5cIik7dGhyb3cgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UmJkVycm9yLmNhcHR1cmVTdGFja1RyYWNlKGwsUCksbH1yZXR1cm4gcn1mdW5jdGlvbiBJKHIpe3ZhciBhLGUsbztsZXQgbD0oZT0oYT1oKGMpKT09bnVsbD92b2lkIDA6YS52YWx1ZSkhPW51bGw/ZTp2b2lkIDA7cmV0dXJuKChvPXI9PW51bGw/dm9pZCAwOnIubGVuZ3RoKSE9bnVsbD9vOjApPjA/W2wsLi4ucl0uZmlsdGVyKEJvb2xlYW4pLmpvaW4oXCIgXCIpOmx9ZnVuY3Rpb24gSyh7aW5oZXJpdDpyPSExfT17fSl7bGV0IGw9SSgpLFthLGVdPUQoW10pLG89cj9bbCwuLi5hXS5maWx0ZXIoQm9vbGVhbik6YTtyZXR1cm5bby5sZW5ndGg+MD9vLmpvaW4oXCIgXCIpOnZvaWQgMCxUKCgpPT5mdW5jdGlvbih0KXtsZXQgcz12KGk9PihlKHA9PlsuLi5wLGldKSwoKT0+ZShwPT57bGV0IHU9cC5zbGljZSgpLGQ9dS5pbmRleE9mKGkpO3JldHVybiBkIT09LTEmJnUuc3BsaWNlKGQsMSksdX0pKSksbT1UKCgpPT4oe3JlZ2lzdGVyOnMsc2xvdDp0LnNsb3QsbmFtZTp0Lm5hbWUscHJvcHM6dC5wcm9wcyx2YWx1ZTp0LnZhbHVlfSksW3MsdC5zbG90LHQubmFtZSx0LnByb3BzLHQudmFsdWVdKTtyZXR1cm4gUi5jcmVhdGVFbGVtZW50KGMuUHJvdmlkZXIse3ZhbHVlOm19LHQuY2hpbGRyZW4pfSxbZV0pXX1sZXQgTj1cImxhYmVsXCI7ZnVuY3Rpb24gRyhyLGwpe3ZhciB5O2xldCBhPV8oKSxlPVAoKSxvPVMoKSxnPUYoKSx7aWQ6dD1gaGVhZGxlc3N1aS1sYWJlbC0ke2F9YCxodG1sRm9yOnM9byE9bnVsbD9vOih5PWUucHJvcHMpPT1udWxsP3ZvaWQgMDp5Lmh0bWxGb3IscGFzc2l2ZTptPSExLC4uLml9PXIscD1CKGwpO0EoKCk9PmUucmVnaXN0ZXIodCksW3QsZS5yZWdpc3Rlcl0pO2xldCB1PXYoTD0+e2xldCBiPUwuY3VycmVudFRhcmdldDtpZihiIGluc3RhbmNlb2YgSFRNTExhYmVsRWxlbWVudCYmTC5wcmV2ZW50RGVmYXVsdCgpLGUucHJvcHMmJlwib25DbGlja1wiaW4gZS5wcm9wcyYmdHlwZW9mIGUucHJvcHMub25DbGljaz09XCJmdW5jdGlvblwiJiZlLnByb3BzLm9uQ2xpY2soTCksYiBpbnN0YW5jZW9mIEhUTUxMYWJlbEVsZW1lbnQpe2xldCBuPWRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGIuaHRtbEZvcik7aWYobil7bGV0IEU9bi5nZXRBdHRyaWJ1dGUoXCJkaXNhYmxlZFwiKTtpZihFPT09XCJ0cnVlXCJ8fEU9PT1cIlwiKXJldHVybjtsZXQgeD1uLmdldEF0dHJpYnV0ZShcImFyaWEtZGlzYWJsZWRcIik7aWYoeD09PVwidHJ1ZVwifHx4PT09XCJcIilyZXR1cm47KG4gaW5zdGFuY2VvZiBIVE1MSW5wdXRFbGVtZW50JiYobi50eXBlPT09XCJyYWRpb1wifHxuLnR5cGU9PT1cImNoZWNrYm94XCIpfHxuLnJvbGU9PT1cInJhZGlvXCJ8fG4ucm9sZT09PVwiY2hlY2tib3hcInx8bi5yb2xlPT09XCJzd2l0Y2hcIikmJm4uY2xpY2soKSxuLmZvY3VzKHtwcmV2ZW50U2Nyb2xsOiEwfSl9fX0pLGQ9Z3x8ITEsQz1UKCgpPT4oey4uLmUuc2xvdCxkaXNhYmxlZDpkfSksW2Uuc2xvdCxkXSksZj17cmVmOnAsLi4uZS5wcm9wcyxpZDp0LGh0bWxGb3I6cyxvbkNsaWNrOnV9O3JldHVybiBtJiYoXCJvbkNsaWNrXCJpbiBmJiYoZGVsZXRlIGYuaHRtbEZvcixkZWxldGUgZi5vbkNsaWNrKSxcIm9uQ2xpY2tcImluIGkmJmRlbGV0ZSBpLm9uQ2xpY2spLEgoKSh7b3VyUHJvcHM6Zix0aGVpclByb3BzOmksc2xvdDpDLGRlZmF1bHRUYWc6cz9OOlwiZGl2XCIsbmFtZTplLm5hbWV8fFwiTGFiZWxcIn0pfWxldCBVPU0oRyksUT1PYmplY3QuYXNzaWduKFUse30pO2V4cG9ydHtRIGFzIExhYmVsLFAgYXMgdXNlTGFiZWxDb250ZXh0LEkgYXMgdXNlTGFiZWxsZWRCeSxLIGFzIHVzZUxhYmVsc307XG4iXSwibmFtZXMiOlsiUiIsImNyZWF0ZUNvbnRleHQiLCJrIiwidXNlQ29udGV4dCIsImgiLCJ1c2VNZW1vIiwiVCIsInVzZVN0YXRlIiwiRCIsInVzZUV2ZW50IiwidiIsInVzZUlkIiwiXyIsInVzZUlzb01vcnBoaWNFZmZlY3QiLCJBIiwidXNlU3luY1JlZnMiLCJCIiwidXNlRGlzYWJsZWQiLCJGIiwidXNlUHJvdmlkZWRJZCIsIlMiLCJmb3J3YXJkUmVmV2l0aEFzIiwiTSIsInVzZVJlbmRlciIsIkgiLCJjIiwiZGlzcGxheU5hbWUiLCJQIiwiciIsImwiLCJFcnJvciIsImNhcHR1cmVTdGFja1RyYWNlIiwiSSIsImEiLCJlIiwibyIsInZhbHVlIiwibGVuZ3RoIiwiZmlsdGVyIiwiQm9vbGVhbiIsImpvaW4iLCJLIiwiaW5oZXJpdCIsInQiLCJzIiwiaSIsInAiLCJ1Iiwic2xpY2UiLCJkIiwiaW5kZXhPZiIsInNwbGljZSIsIm0iLCJyZWdpc3RlciIsInNsb3QiLCJuYW1lIiwicHJvcHMiLCJjcmVhdGVFbGVtZW50IiwiUHJvdmlkZXIiLCJjaGlsZHJlbiIsIk4iLCJHIiwieSIsImciLCJpZCIsImh0bWxGb3IiLCJwYXNzaXZlIiwiTCIsImIiLCJjdXJyZW50VGFyZ2V0IiwiSFRNTExhYmVsRWxlbWVudCIsInByZXZlbnREZWZhdWx0Iiwib25DbGljayIsIm4iLCJkb2N1bWVudCIsImdldEVsZW1lbnRCeUlkIiwiRSIsImdldEF0dHJpYnV0ZSIsIngiLCJIVE1MSW5wdXRFbGVtZW50IiwidHlwZSIsInJvbGUiLCJjbGljayIsImZvY3VzIiwicHJldmVudFNjcm9sbCIsIkMiLCJkaXNhYmxlZCIsImYiLCJyZWYiLCJvdXJQcm9wcyIsInRoZWlyUHJvcHMiLCJkZWZhdWx0VGFnIiwiVSIsIlEiLCJPYmplY3QiLCJhc3NpZ24iLCJMYWJlbCIsInVzZUxhYmVsQ29udGV4dCIsInVzZUxhYmVsbGVkQnkiLCJ1c2VMYWJlbHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../../../node_modules/@headlessui/react/dist/components/label/label.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../../../node_modules/@headlessui/react/dist/components/menu/menu-machine-glue.js":
/*!********************************************************************************************!*\
  !*** ../../../../node_modules/@headlessui/react/dist/components/menu/menu-machine-glue.js ***!
  \********************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MenuContext: function() { return /* binding */ a; },\n/* harmony export */   useMenuMachine: function() { return /* binding */ i; },\n/* harmony export */   useMenuMachineContext: function() { return /* binding */ l; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var _menu_machine_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./menu-machine.js */ \"(app-pages-browser)/../../../../node_modules/@headlessui/react/dist/components/menu/menu-machine.js\");\n\n\nconst a = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(null);\nfunction l(e) {\n    let n = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(a);\n    if (n === null) {\n        let t = new Error(\"<\".concat(e, \" /> is missing a parent <Menu /> component.\"));\n        throw Error.captureStackTrace && Error.captureStackTrace(t, i), t;\n    }\n    return n;\n}\nfunction i() {\n    let { __demoMode: e = !1 } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>_menu_machine_js__WEBPACK_IMPORTED_MODULE_1__.MenuMachine.new({\n            __demoMode: e\n        }), []);\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQGhlYWRsZXNzdWkvcmVhY3QvZGlzdC9jb21wb25lbnRzL21lbnUvbWVudS1tYWNoaW5lLWdsdWUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBbUU7QUFBZ0Q7QUFBQSxNQUFNUSxrQkFBRVAsb0RBQUNBLENBQUM7QUFBTSxTQUFTUSxFQUFFQyxDQUFDO0lBQUUsSUFBSUMsSUFBRVIsaURBQUNBLENBQUNLO0lBQUcsSUFBR0csTUFBSSxNQUFLO1FBQUMsSUFBSUMsSUFBRSxJQUFJQyxNQUFNLElBQU0sT0FBRkgsR0FBRTtRQUE4QyxNQUFNRyxNQUFNQyxpQkFBaUIsSUFBRUQsTUFBTUMsaUJBQWlCLENBQUNGLEdBQUVHLElBQUdIO0lBQUM7SUFBQyxPQUFPRDtBQUFDO0FBQUMsU0FBU0k7UUFBRSxFQUFDQyxZQUFXTixJQUFFLENBQUMsQ0FBQyxFQUFDLEdBQWpCLGlFQUFrQixDQUFDO0lBQUcsT0FBT0wsOENBQUNBLENBQUMsSUFBSUUseURBQUNBLENBQUNVLEdBQUcsQ0FBQztZQUFDRCxZQUFXTjtRQUFDLElBQUcsRUFBRTtBQUFDO0FBQXlFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQGhlYWRsZXNzdWkvcmVhY3QvZGlzdC9jb21wb25lbnRzL21lbnUvbWVudS1tYWNoaW5lLWdsdWUuanM/OTNjZSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnR7Y3JlYXRlQ29udGV4dCBhcyByLHVzZUNvbnRleHQgYXMgbyx1c2VNZW1vIGFzIHV9ZnJvbVwicmVhY3RcIjtpbXBvcnR7TWVudU1hY2hpbmUgYXMgY31mcm9tJy4vbWVudS1tYWNoaW5lLmpzJztjb25zdCBhPXIobnVsbCk7ZnVuY3Rpb24gbChlKXtsZXQgbj1vKGEpO2lmKG49PT1udWxsKXtsZXQgdD1uZXcgRXJyb3IoYDwke2V9IC8+IGlzIG1pc3NpbmcgYSBwYXJlbnQgPE1lbnUgLz4gY29tcG9uZW50LmApO3Rocm93IEVycm9yLmNhcHR1cmVTdGFja1RyYWNlJiZFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0LGkpLHR9cmV0dXJuIG59ZnVuY3Rpb24gaSh7X19kZW1vTW9kZTplPSExfT17fSl7cmV0dXJuIHUoKCk9PmMubmV3KHtfX2RlbW9Nb2RlOmV9KSxbXSl9ZXhwb3J0e2EgYXMgTWVudUNvbnRleHQsaSBhcyB1c2VNZW51TWFjaGluZSxsIGFzIHVzZU1lbnVNYWNoaW5lQ29udGV4dH07XG4iXSwibmFtZXMiOlsiY3JlYXRlQ29udGV4dCIsInIiLCJ1c2VDb250ZXh0IiwibyIsInVzZU1lbW8iLCJ1IiwiTWVudU1hY2hpbmUiLCJjIiwiYSIsImwiLCJlIiwibiIsInQiLCJFcnJvciIsImNhcHR1cmVTdGFja1RyYWNlIiwiaSIsIl9fZGVtb01vZGUiLCJuZXciLCJNZW51Q29udGV4dCIsInVzZU1lbnVNYWNoaW5lIiwidXNlTWVudU1hY2hpbmVDb250ZXh0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../../../node_modules/@headlessui/react/dist/components/menu/menu-machine-glue.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../../../node_modules/@headlessui/react/dist/components/menu/menu-machine.js":
/*!***************************************************************************************!*\
  !*** ../../../../node_modules/@headlessui/react/dist/components/menu/menu-machine.js ***!
  \***************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ActionTypes: function() { return /* binding */ b; },\n/* harmony export */   ActivationTrigger: function() { return /* binding */ T; },\n/* harmony export */   MenuMachine: function() { return /* binding */ x; },\n/* harmony export */   MenuState: function() { return /* binding */ M; }\n/* harmony export */ });\n/* harmony import */ var _machine_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../machine.js */ \"(app-pages-browser)/../../../../node_modules/@headlessui/react/dist/machine.js\");\n/* harmony import */ var _utils_calculate_active_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/calculate-active-index.js */ \"(app-pages-browser)/../../../../node_modules/@headlessui/react/dist/utils/calculate-active-index.js\");\n/* harmony import */ var _utils_focus_management_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils/focus-management.js */ \"(app-pages-browser)/../../../../node_modules/@headlessui/react/dist/utils/focus-management.js\");\n/* harmony import */ var _utils_match_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../utils/match.js */ \"(app-pages-browser)/../../../../node_modules/@headlessui/react/dist/utils/match.js\");\nvar h = Object.defineProperty;\nvar y = (e, n, t)=>n in e ? h(e, n, {\n        enumerable: !0,\n        configurable: !0,\n        writable: !0,\n        value: t\n    }) : e[n] = t;\nvar v = (e, n, t)=>(y(e, typeof n != \"symbol\" ? n + \"\" : n, t), t);\n\n\n\n\nvar M = ((t)=>(t[t.Open = 0] = \"Open\", t[t.Closed = 1] = \"Closed\", t))(M || {}), T = ((t)=>(t[t.Pointer = 0] = \"Pointer\", t[t.Other = 1] = \"Other\", t))(T || {}), b = ((i)=>(i[i.OpenMenu = 0] = \"OpenMenu\", i[i.CloseMenu = 1] = \"CloseMenu\", i[i.GoToItem = 2] = \"GoToItem\", i[i.Search = 3] = \"Search\", i[i.ClearSearch = 4] = \"ClearSearch\", i[i.RegisterItems = 5] = \"RegisterItems\", i[i.UnregisterItems = 6] = \"UnregisterItems\", i[i.SetButtonElement = 7] = \"SetButtonElement\", i[i.SetItemsElement = 8] = \"SetItemsElement\", i[i.SortItems = 9] = \"SortItems\", i))(b || {});\nfunction S(e) {\n    let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : (t)=>t;\n    let t = e.activeItemIndex !== null ? e.items[e.activeItemIndex] : null, r = (0,_utils_focus_management_js__WEBPACK_IMPORTED_MODULE_0__.sortByDomNode)(n(e.items.slice()), (u)=>u.dataRef.current.domRef.current), l = t ? r.indexOf(t) : null;\n    return l === -1 && (l = null), {\n        items: r,\n        activeItemIndex: l\n    };\n}\n_c = S;\nlet F = {\n    [1] (e) {\n        return e.menuState === 1 ? e : {\n            ...e,\n            activeItemIndex: null,\n            pendingFocus: {\n                focus: _utils_calculate_active_index_js__WEBPACK_IMPORTED_MODULE_1__.Focus.Nothing\n            },\n            menuState: 1\n        };\n    },\n    [0] (e, n) {\n        return e.menuState === 0 ? e : {\n            ...e,\n            __demoMode: !1,\n            pendingFocus: n.focus,\n            menuState: 0\n        };\n    },\n    [2]: (e, n)=>{\n        var u, m, d, a, I;\n        if (e.menuState === 1) return e;\n        let t = {\n            ...e,\n            searchQuery: \"\",\n            activationTrigger: (u = n.trigger) != null ? u : 1,\n            __demoMode: !1\n        };\n        if (n.focus === _utils_calculate_active_index_js__WEBPACK_IMPORTED_MODULE_1__.Focus.Nothing) return {\n            ...t,\n            activeItemIndex: null\n        };\n        if (n.focus === _utils_calculate_active_index_js__WEBPACK_IMPORTED_MODULE_1__.Focus.Specific) return {\n            ...t,\n            activeItemIndex: e.items.findIndex((i)=>i.id === n.id)\n        };\n        if (n.focus === _utils_calculate_active_index_js__WEBPACK_IMPORTED_MODULE_1__.Focus.Previous) {\n            let i = e.activeItemIndex;\n            if (i !== null) {\n                let g = e.items[i].dataRef.current.domRef, o = (0,_utils_calculate_active_index_js__WEBPACK_IMPORTED_MODULE_1__.calculateActiveIndex)(n, {\n                    resolveItems: ()=>e.items,\n                    resolveActiveIndex: ()=>e.activeItemIndex,\n                    resolveId: (s)=>s.id,\n                    resolveDisabled: (s)=>s.dataRef.current.disabled\n                });\n                if (o !== null) {\n                    let s = e.items[o].dataRef.current.domRef;\n                    if (((m = g.current) == null ? void 0 : m.previousElementSibling) === s.current || ((d = s.current) == null ? void 0 : d.previousElementSibling) === null) return {\n                        ...t,\n                        activeItemIndex: o\n                    };\n                }\n            }\n        } else if (n.focus === _utils_calculate_active_index_js__WEBPACK_IMPORTED_MODULE_1__.Focus.Next) {\n            let i = e.activeItemIndex;\n            if (i !== null) {\n                let g = e.items[i].dataRef.current.domRef, o = (0,_utils_calculate_active_index_js__WEBPACK_IMPORTED_MODULE_1__.calculateActiveIndex)(n, {\n                    resolveItems: ()=>e.items,\n                    resolveActiveIndex: ()=>e.activeItemIndex,\n                    resolveId: (s)=>s.id,\n                    resolveDisabled: (s)=>s.dataRef.current.disabled\n                });\n                if (o !== null) {\n                    let s = e.items[o].dataRef.current.domRef;\n                    if (((a = g.current) == null ? void 0 : a.nextElementSibling) === s.current || ((I = s.current) == null ? void 0 : I.nextElementSibling) === null) return {\n                        ...t,\n                        activeItemIndex: o\n                    };\n                }\n            }\n        }\n        let r = S(e), l = (0,_utils_calculate_active_index_js__WEBPACK_IMPORTED_MODULE_1__.calculateActiveIndex)(n, {\n            resolveItems: ()=>r.items,\n            resolveActiveIndex: ()=>r.activeItemIndex,\n            resolveId: (i)=>i.id,\n            resolveDisabled: (i)=>i.dataRef.current.disabled\n        });\n        return {\n            ...t,\n            ...r,\n            activeItemIndex: l\n        };\n    },\n    [3]: (e, n)=>{\n        let r = e.searchQuery !== \"\" ? 0 : 1, l = e.searchQuery + n.value.toLowerCase(), m = (e.activeItemIndex !== null ? e.items.slice(e.activeItemIndex + r).concat(e.items.slice(0, e.activeItemIndex + r)) : e.items).find((a)=>{\n            var I;\n            return ((I = a.dataRef.current.textValue) == null ? void 0 : I.startsWith(l)) && !a.dataRef.current.disabled;\n        }), d = m ? e.items.indexOf(m) : -1;\n        return d === -1 || d === e.activeItemIndex ? {\n            ...e,\n            searchQuery: l\n        } : {\n            ...e,\n            searchQuery: l,\n            activeItemIndex: d,\n            activationTrigger: 1\n        };\n    },\n    [4] (e) {\n        return e.searchQuery === \"\" ? e : {\n            ...e,\n            searchQuery: \"\",\n            searchActiveItemIndex: null\n        };\n    },\n    [5]: (e, n)=>{\n        let t = e.items.concat(n.items.map((l)=>l)), r = e.activeItemIndex;\n        return e.pendingFocus.focus !== _utils_calculate_active_index_js__WEBPACK_IMPORTED_MODULE_1__.Focus.Nothing && (r = (0,_utils_calculate_active_index_js__WEBPACK_IMPORTED_MODULE_1__.calculateActiveIndex)(e.pendingFocus, {\n            resolveItems: ()=>t,\n            resolveActiveIndex: ()=>e.activeItemIndex,\n            resolveId: (l)=>l.id,\n            resolveDisabled: (l)=>l.dataRef.current.disabled\n        })), {\n            ...e,\n            items: t,\n            activeItemIndex: r,\n            pendingFocus: {\n                focus: _utils_calculate_active_index_js__WEBPACK_IMPORTED_MODULE_1__.Focus.Nothing\n            },\n            pendingShouldSort: !0\n        };\n    },\n    [6]: (e, n)=>{\n        let t = e.items, r = [], l = new Set(n.items);\n        for (let [u, m] of t.entries())if (l.has(m.id) && (r.push(u), l.delete(m.id), l.size === 0)) break;\n        if (r.length > 0) {\n            t = t.slice();\n            for (let u of r.reverse())t.splice(u, 1);\n        }\n        return {\n            ...e,\n            items: t,\n            activationTrigger: 1\n        };\n    },\n    [7]: (e, n)=>e.buttonElement === n.element ? e : {\n            ...e,\n            buttonElement: n.element\n        },\n    [8]: (e, n)=>e.itemsElement === n.element ? e : {\n            ...e,\n            itemsElement: n.element\n        },\n    [9]: (e)=>e.pendingShouldSort ? {\n            ...e,\n            ...S(e),\n            pendingShouldSort: !1\n        } : e\n};\nclass x extends _machine_js__WEBPACK_IMPORTED_MODULE_2__.Machine {\n    static new() {\n        let { __demoMode: t = !1 } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n        return new x({\n            __demoMode: t,\n            menuState: t ? 0 : 1,\n            buttonElement: null,\n            itemsElement: null,\n            items: [],\n            searchQuery: \"\",\n            activeItemIndex: null,\n            activationTrigger: 1,\n            pendingShouldSort: !1,\n            pendingFocus: {\n                focus: _utils_calculate_active_index_js__WEBPACK_IMPORTED_MODULE_1__.Focus.Nothing\n            }\n        });\n    }\n    reduce(t, r) {\n        return (0,_utils_match_js__WEBPACK_IMPORTED_MODULE_3__.match)(r.type, F, t, r);\n    }\n    constructor(t){\n        super(t);\n        v(this, \"actions\", {\n            registerItem: (0,_machine_js__WEBPACK_IMPORTED_MODULE_2__.batch)(()=>{\n                let t = [], r = new Set;\n                return [\n                    (l, u)=>{\n                        r.has(u) || (r.add(u), t.push({\n                            id: l,\n                            dataRef: u\n                        }));\n                    },\n                    ()=>(r.clear(), this.send({\n                            type: 5,\n                            items: t.splice(0)\n                        }))\n                ];\n            }),\n            unregisterItem: (0,_machine_js__WEBPACK_IMPORTED_MODULE_2__.batch)(()=>{\n                let t = [];\n                return [\n                    (r)=>t.push(r),\n                    ()=>this.send({\n                            type: 6,\n                            items: t.splice(0)\n                        })\n                ];\n            })\n        });\n        v(this, \"selectors\", {\n            activeDescendantId (t) {\n                var u;\n                let r = t.activeItemIndex, l = t.items;\n                return r === null || (u = l[r]) == null ? void 0 : u.id;\n            },\n            isActive (t, r) {\n                var m;\n                let l = t.activeItemIndex, u = t.items;\n                return l !== null ? ((m = u[l]) == null ? void 0 : m.id) === r : !1;\n            },\n            shouldScrollIntoView (t, r) {\n                return t.__demoMode || t.menuState !== 0 || t.activationTrigger === 0 ? !1 : this.isActive(t, r);\n            }\n        });\n        this.on(5, ()=>{\n            requestAnimationFrame(()=>{\n                this.send({\n                    type: 9\n                });\n            });\n        });\n    }\n}\n\nvar _c;\n$RefreshReg$(_c, \"S\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQGhlYWRsZXNzdWkvcmVhY3QvZGlzdC9jb21wb25lbnRzL21lbnUvbWVudS1tYWNoaW5lLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQUEsSUFBSUEsSUFBRUMsT0FBT0MsY0FBYztBQUFDLElBQUlDLElBQUUsQ0FBQ0MsR0FBRUMsR0FBRUMsSUFBSUQsS0FBS0QsSUFBRUosRUFBRUksR0FBRUMsR0FBRTtRQUFDRSxZQUFXLENBQUM7UUFBRUMsY0FBYSxDQUFDO1FBQUVDLFVBQVMsQ0FBQztRQUFFQyxPQUFNSjtJQUFDLEtBQUdGLENBQUMsQ0FBQ0MsRUFBRSxHQUFDQztBQUFFLElBQUlLLElBQUUsQ0FBQ1AsR0FBRUMsR0FBRUMsSUFBS0gsQ0FBQUEsRUFBRUMsR0FBRSxPQUFPQyxLQUFHLFdBQVNBLElBQUUsS0FBR0EsR0FBRUMsSUFBR0EsQ0FBQUE7QUFBeUQ7QUFBd0Y7QUFBZ0U7QUFBNkM7QUFBQSxJQUFJa0IsSUFBRSxDQUFDbEIsQ0FBQUEsSUFBSUEsQ0FBQUEsQ0FBQyxDQUFDQSxFQUFFbUIsSUFBSSxHQUFDLEVBQUUsR0FBQyxRQUFPbkIsQ0FBQyxDQUFDQSxFQUFFb0IsTUFBTSxHQUFDLEVBQUUsR0FBQyxVQUFTcEIsQ0FBQUEsQ0FBQyxFQUFHa0IsS0FBRyxDQUFDLElBQUdHLElBQUUsQ0FBQ3JCLENBQUFBLElBQUlBLENBQUFBLENBQUMsQ0FBQ0EsRUFBRXNCLE9BQU8sR0FBQyxFQUFFLEdBQUMsV0FBVXRCLENBQUMsQ0FBQ0EsRUFBRXVCLEtBQUssR0FBQyxFQUFFLEdBQUMsU0FBUXZCLENBQUFBLENBQUMsRUFBR3FCLEtBQUcsQ0FBQyxJQUFHRyxJQUFFLENBQUNDLENBQUFBLElBQUlBLENBQUFBLENBQUMsQ0FBQ0EsRUFBRUMsUUFBUSxHQUFDLEVBQUUsR0FBQyxZQUFXRCxDQUFDLENBQUNBLEVBQUVFLFNBQVMsR0FBQyxFQUFFLEdBQUMsYUFBWUYsQ0FB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Z0QsUUFBUSxDQUFDMUcsR0FBRXVDO1lBQUU7UUFBQztRQUFHLElBQUksQ0FBQ3FFLEVBQUUsQ0FBQyxHQUFFO1lBQUtDLHNCQUFzQjtnQkFBSyxJQUFJLENBQUNOLElBQUksQ0FBQztvQkFBQ0wsTUFBSztnQkFBQztZQUFFO1FBQUU7SUFBRTtBQUE0UTtBQUFpRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BoZWFkbGVzc3VpL3JlYWN0L2Rpc3QvY29tcG9uZW50cy9tZW51L21lbnUtbWFjaGluZS5qcz85ZTU1Il0sInNvdXJjZXNDb250ZW50IjpbInZhciBoPU9iamVjdC5kZWZpbmVQcm9wZXJ0eTt2YXIgeT0oZSxuLHQpPT5uIGluIGU/aChlLG4se2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnR9KTplW25dPXQ7dmFyIHY9KGUsbix0KT0+KHkoZSx0eXBlb2YgbiE9XCJzeW1ib2xcIj9uK1wiXCI6bix0KSx0KTtpbXBvcnR7TWFjaGluZSBhcyBSLGJhdGNoIGFzIHB9ZnJvbScuLi8uLi9tYWNoaW5lLmpzJztpbXBvcnR7Rm9jdXMgYXMgYyxjYWxjdWxhdGVBY3RpdmVJbmRleCBhcyBmfWZyb20nLi4vLi4vdXRpbHMvY2FsY3VsYXRlLWFjdGl2ZS1pbmRleC5qcyc7aW1wb3J0e3NvcnRCeURvbU5vZGUgYXMgQX1mcm9tJy4uLy4uL3V0aWxzL2ZvY3VzLW1hbmFnZW1lbnQuanMnO2ltcG9ydHttYXRjaCBhcyBFfWZyb20nLi4vLi4vdXRpbHMvbWF0Y2guanMnO3ZhciBNPSh0PT4odFt0Lk9wZW49MF09XCJPcGVuXCIsdFt0LkNsb3NlZD0xXT1cIkNsb3NlZFwiLHQpKShNfHx7fSksVD0odD0+KHRbdC5Qb2ludGVyPTBdPVwiUG9pbnRlclwiLHRbdC5PdGhlcj0xXT1cIk90aGVyXCIsdCkpKFR8fHt9KSxiPShpPT4oaVtpLk9wZW5NZW51PTBdPVwiT3Blbk1lbnVcIixpW2kuQ2xvc2VNZW51PTFdPVwiQ2xvc2VNZW51XCIsaVtpLkdvVG9JdGVtPTJdPVwiR29Ub0l0ZW1cIixpW2kuU2VhcmNoPTNdPVwiU2VhcmNoXCIsaVtpLkNsZWFyU2VhcmNoPTRdPVwiQ2xlYXJTZWFyY2hcIixpW2kuUmVnaXN0ZXJJdGVtcz01XT1cIlJlZ2lzdGVySXRlbXNcIixpW2kuVW5yZWdpc3Rlckl0ZW1zPTZdPVwiVW5yZWdpc3Rlckl0ZW1zXCIsaVtpLlNldEJ1dHRvbkVsZW1lbnQ9N109XCJTZXRCdXR0b25FbGVtZW50XCIsaVtpLlNldEl0ZW1zRWxlbWVudD04XT1cIlNldEl0ZW1zRWxlbWVudFwiLGlbaS5Tb3J0SXRlbXM9OV09XCJTb3J0SXRlbXNcIixpKSkoYnx8e30pO2Z1bmN0aW9uIFMoZSxuPXQ9PnQpe2xldCB0PWUuYWN0aXZlSXRlbUluZGV4IT09bnVsbD9lLml0ZW1zW2UuYWN0aXZlSXRlbUluZGV4XTpudWxsLHI9QShuKGUuaXRlbXMuc2xpY2UoKSksdT0+dS5kYXRhUmVmLmN1cnJlbnQuZG9tUmVmLmN1cnJlbnQpLGw9dD9yLmluZGV4T2YodCk6bnVsbDtyZXR1cm4gbD09PS0xJiYobD1udWxsKSx7aXRlbXM6cixhY3RpdmVJdGVtSW5kZXg6bH19bGV0IEY9e1sxXShlKXtyZXR1cm4gZS5tZW51U3RhdGU9PT0xP2U6ey4uLmUsYWN0aXZlSXRlbUluZGV4Om51bGwscGVuZGluZ0ZvY3VzOntmb2N1czpjLk5vdGhpbmd9LG1lbnVTdGF0ZToxfX0sWzBdKGUsbil7cmV0dXJuIGUubWVudVN0YXRlPT09MD9lOnsuLi5lLF9fZGVtb01vZGU6ITEscGVuZGluZ0ZvY3VzOm4uZm9jdXMsbWVudVN0YXRlOjB9fSxbMl06KGUsbik9Pnt2YXIgdSxtLGQsYSxJO2lmKGUubWVudVN0YXRlPT09MSlyZXR1cm4gZTtsZXQgdD17Li4uZSxzZWFyY2hRdWVyeTpcIlwiLGFjdGl2YXRpb25UcmlnZ2VyOih1PW4udHJpZ2dlcikhPW51bGw/dToxLF9fZGVtb01vZGU6ITF9O2lmKG4uZm9jdXM9PT1jLk5vdGhpbmcpcmV0dXJuey4uLnQsYWN0aXZlSXRlbUluZGV4Om51bGx9O2lmKG4uZm9jdXM9PT1jLlNwZWNpZmljKXJldHVybnsuLi50LGFjdGl2ZUl0ZW1JbmRleDplLml0ZW1zLmZpbmRJbmRleChpPT5pLmlkPT09bi5pZCl9O2lmKG4uZm9jdXM9PT1jLlByZXZpb3VzKXtsZXQgaT1lLmFjdGl2ZUl0ZW1JbmRleDtpZihpIT09bnVsbCl7bGV0IGc9ZS5pdGVtc1tpXS5kYXRhUmVmLmN1cnJlbnQuZG9tUmVmLG89ZihuLHtyZXNvbHZlSXRlbXM6KCk9PmUuaXRlbXMscmVzb2x2ZUFjdGl2ZUluZGV4OigpPT5lLmFjdGl2ZUl0ZW1JbmRleCxyZXNvbHZlSWQ6cz0+cy5pZCxyZXNvbHZlRGlzYWJsZWQ6cz0+cy5kYXRhUmVmLmN1cnJlbnQuZGlzYWJsZWR9KTtpZihvIT09bnVsbCl7bGV0IHM9ZS5pdGVtc1tvXS5kYXRhUmVmLmN1cnJlbnQuZG9tUmVmO2lmKCgobT1nLmN1cnJlbnQpPT1udWxsP3ZvaWQgMDptLnByZXZpb3VzRWxlbWVudFNpYmxpbmcpPT09cy5jdXJyZW50fHwoKGQ9cy5jdXJyZW50KT09bnVsbD92b2lkIDA6ZC5wcmV2aW91c0VsZW1lbnRTaWJsaW5nKT09PW51bGwpcmV0dXJuey4uLnQsYWN0aXZlSXRlbUluZGV4Om99fX19ZWxzZSBpZihuLmZvY3VzPT09Yy5OZXh0KXtsZXQgaT1lLmFjdGl2ZUl0ZW1JbmRleDtpZihpIT09bnVsbCl7bGV0IGc9ZS5pdGVtc1tpXS5kYXRhUmVmLmN1cnJlbnQuZG9tUmVmLG89ZihuLHtyZXNvbHZlSXRlbXM6KCk9PmUuaXRlbXMscmVzb2x2ZUFjdGl2ZUluZGV4OigpPT5lLmFjdGl2ZUl0ZW1JbmRleCxyZXNvbHZlSWQ6cz0+cy5pZCxyZXNvbHZlRGlzYWJsZWQ6cz0+cy5kYXRhUmVmLmN1cnJlbnQuZGlzYWJsZWR9KTtpZihvIT09bnVsbCl7bGV0IHM9ZS5pdGVtc1tvXS5kYXRhUmVmLmN1cnJlbnQuZG9tUmVmO2lmKCgoYT1nLmN1cnJlbnQpPT1udWxsP3ZvaWQgMDphLm5leHRFbGVtZW50U2libGluZyk9PT1zLmN1cnJlbnR8fCgoST1zLmN1cnJlbnQpPT1udWxsP3ZvaWQgMDpJLm5leHRFbGVtZW50U2libGluZyk9PT1udWxsKXJldHVybnsuLi50LGFjdGl2ZUl0ZW1JbmRleDpvfX19fWxldCByPVMoZSksbD1mKG4se3Jlc29sdmVJdGVtczooKT0+ci5pdGVtcyxyZXNvbHZlQWN0aXZlSW5kZXg6KCk9PnIuYWN0aXZlSXRlbUluZGV4LHJlc29sdmVJZDppPT5pLmlkLHJlc29sdmVEaXNhYmxlZDppPT5pLmRhdGFSZWYuY3VycmVudC5kaXNhYmxlZH0pO3JldHVybnsuLi50LC4uLnIsYWN0aXZlSXRlbUluZGV4Omx9fSxbM106KGUsbik9PntsZXQgcj1lLnNlYXJjaFF1ZXJ5IT09XCJcIj8wOjEsbD1lLnNlYXJjaFF1ZXJ5K24udmFsdWUudG9Mb3dlckNhc2UoKSxtPShlLmFjdGl2ZUl0ZW1JbmRleCE9PW51bGw/ZS5pdGVtcy5zbGljZShlLmFjdGl2ZUl0ZW1JbmRleCtyKS5jb25jYXQoZS5pdGVtcy5zbGljZSgwLGUuYWN0aXZlSXRlbUluZGV4K3IpKTplLml0ZW1zKS5maW5kKGE9Pnt2YXIgSTtyZXR1cm4oKEk9YS5kYXRhUmVmLmN1cnJlbnQudGV4dFZhbHVlKT09bnVsbD92b2lkIDA6SS5zdGFydHNXaXRoKGwpKSYmIWEuZGF0YVJlZi5jdXJyZW50LmRpc2FibGVkfSksZD1tP2UuaXRlbXMuaW5kZXhPZihtKTotMTtyZXR1cm4gZD09PS0xfHxkPT09ZS5hY3RpdmVJdGVtSW5kZXg/ey4uLmUsc2VhcmNoUXVlcnk6bH06ey4uLmUsc2VhcmNoUXVlcnk6bCxhY3RpdmVJdGVtSW5kZXg6ZCxhY3RpdmF0aW9uVHJpZ2dlcjoxfX0sWzRdKGUpe3JldHVybiBlLnNlYXJjaFF1ZXJ5PT09XCJcIj9lOnsuLi5lLHNlYXJjaFF1ZXJ5OlwiXCIsc2VhcmNoQWN0aXZlSXRlbUluZGV4Om51bGx9fSxbNV06KGUsbik9PntsZXQgdD1lLml0ZW1zLmNvbmNhdChuLml0ZW1zLm1hcChsPT5sKSkscj1lLmFjdGl2ZUl0ZW1JbmRleDtyZXR1cm4gZS5wZW5kaW5nRm9jdXMuZm9jdXMhPT1jLk5vdGhpbmcmJihyPWYoZS5wZW5kaW5nRm9jdXMse3Jlc29sdmVJdGVtczooKT0+dCxyZXNvbHZlQWN0aXZlSW5kZXg6KCk9PmUuYWN0aXZlSXRlbUluZGV4LHJlc29sdmVJZDpsPT5sLmlkLHJlc29sdmVEaXNhYmxlZDpsPT5sLmRhdGFSZWYuY3VycmVudC5kaXNhYmxlZH0pKSx7Li4uZSxpdGVtczp0LGFjdGl2ZUl0ZW1JbmRleDpyLHBlbmRpbmdGb2N1czp7Zm9jdXM6Yy5Ob3RoaW5nfSxwZW5kaW5nU2hvdWxkU29ydDohMH19LFs2XTooZSxuKT0+e2xldCB0PWUuaXRlbXMscj1bXSxsPW5ldyBTZXQobi5pdGVtcyk7Zm9yKGxldFt1LG1db2YgdC5lbnRyaWVzKCkpaWYobC5oYXMobS5pZCkmJihyLnB1c2godSksbC5kZWxldGUobS5pZCksbC5zaXplPT09MCkpYnJlYWs7aWYoci5sZW5ndGg+MCl7dD10LnNsaWNlKCk7Zm9yKGxldCB1IG9mIHIucmV2ZXJzZSgpKXQuc3BsaWNlKHUsMSl9cmV0dXJuey4uLmUsaXRlbXM6dCxhY3RpdmF0aW9uVHJpZ2dlcjoxfX0sWzddOihlLG4pPT5lLmJ1dHRvbkVsZW1lbnQ9PT1uLmVsZW1lbnQ/ZTp7Li4uZSxidXR0b25FbGVtZW50Om4uZWxlbWVudH0sWzhdOihlLG4pPT5lLml0ZW1zRWxlbWVudD09PW4uZWxlbWVudD9lOnsuLi5lLGl0ZW1zRWxlbWVudDpuLmVsZW1lbnR9LFs5XTplPT5lLnBlbmRpbmdTaG91bGRTb3J0P3suLi5lLC4uLlMoZSkscGVuZGluZ1Nob3VsZFNvcnQ6ITF9OmV9O2NsYXNzIHggZXh0ZW5kcyBSe2NvbnN0cnVjdG9yKHQpe3N1cGVyKHQpO3YodGhpcyxcImFjdGlvbnNcIix7cmVnaXN0ZXJJdGVtOnAoKCk9PntsZXQgdD1bXSxyPW5ldyBTZXQ7cmV0dXJuWyhsLHUpPT57ci5oYXModSl8fChyLmFkZCh1KSx0LnB1c2goe2lkOmwsZGF0YVJlZjp1fSkpfSwoKT0+KHIuY2xlYXIoKSx0aGlzLnNlbmQoe3R5cGU6NSxpdGVtczp0LnNwbGljZSgwKX0pKV19KSx1bnJlZ2lzdGVySXRlbTpwKCgpPT57bGV0IHQ9W107cmV0dXJuW3I9PnQucHVzaChyKSwoKT0+dGhpcy5zZW5kKHt0eXBlOjYsaXRlbXM6dC5zcGxpY2UoMCl9KV19KX0pO3YodGhpcyxcInNlbGVjdG9yc1wiLHthY3RpdmVEZXNjZW5kYW50SWQodCl7dmFyIHU7bGV0IHI9dC5hY3RpdmVJdGVtSW5kZXgsbD10Lml0ZW1zO3JldHVybiByPT09bnVsbHx8KHU9bFtyXSk9PW51bGw/dm9pZCAwOnUuaWR9LGlzQWN0aXZlKHQscil7dmFyIG07bGV0IGw9dC5hY3RpdmVJdGVtSW5kZXgsdT10Lml0ZW1zO3JldHVybiBsIT09bnVsbD8oKG09dVtsXSk9PW51bGw/dm9pZCAwOm0uaWQpPT09cjohMX0sc2hvdWxkU2Nyb2xsSW50b1ZpZXcodCxyKXtyZXR1cm4gdC5fX2RlbW9Nb2RlfHx0Lm1lbnVTdGF0ZSE9PTB8fHQuYWN0aXZhdGlvblRyaWdnZXI9PT0wPyExOnRoaXMuaXNBY3RpdmUodCxyKX19KTt0aGlzLm9uKDUsKCk9PntyZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCk9Pnt0aGlzLnNlbmQoe3R5cGU6OX0pfSl9KX1zdGF0aWMgbmV3KHtfX2RlbW9Nb2RlOnQ9ITF9PXt9KXtyZXR1cm4gbmV3IHgoe19fZGVtb01vZGU6dCxtZW51U3RhdGU6dD8wOjEsYnV0dG9uRWxlbWVudDpudWxsLGl0ZW1zRWxlbWVudDpudWxsLGl0ZW1zOltdLHNlYXJjaFF1ZXJ5OlwiXCIsYWN0aXZlSXRlbUluZGV4Om51bGwsYWN0aXZhdGlvblRyaWdnZXI6MSxwZW5kaW5nU2hvdWxkU29ydDohMSxwZW5kaW5nRm9jdXM6e2ZvY3VzOmMuTm90aGluZ319KX1yZWR1Y2UodCxyKXtyZXR1cm4gRShyLnR5cGUsRix0LHIpfX1leHBvcnR7YiBhcyBBY3Rpb25UeXBlcyxUIGFzIEFjdGl2YXRpb25UcmlnZ2VyLHggYXMgTWVudU1hY2hpbmUsTSBhcyBNZW51U3RhdGV9O1xuIl0sIm5hbWVzIjpbImgiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsInkiLCJlIiwibiIsInQiLCJlbnVtZXJhYmxlIiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJ2YWx1ZSIsInYiLCJNYWNoaW5lIiwiUiIsImJhdGNoIiwicCIsIkZvY3VzIiwiYyIsImNhbGN1bGF0ZUFjdGl2ZUluZGV4IiwiZiIsInNvcnRCeURvbU5vZGUiLCJBIiwibWF0Y2giLCJFIiwiTSIsIk9wZW4iLCJDbG9zZWQiLCJUIiwiUG9pbnRlciIsIk90aGVyIiwiYiIsImkiLCJPcGVuTWVudSIsIkNsb3NlTWVudSIsIkdvVG9JdGVtIiwiU2VhcmNoIiwiQ2xlYXJTZWFyY2giLCJSZWdpc3Rlckl0ZW1zIiwiVW5yZWdpc3Rlckl0ZW1zIiwiU2V0QnV0dG9uRWxlbWVudCIsIlNldEl0ZW1zRWxlbWVudCIsIlNvcnRJdGVtcyIsIlMiLCJhY3RpdmVJdGVtSW5kZXgiLCJpdGVtcyIsInIiLCJzbGljZSIsInUiLCJkYXRhUmVmIiwiY3VycmVudCIsImRvbVJlZiIsImwiLCJpbmRleE9mIiwiRiIsIm1lbnVTdGF0ZSIsInBlbmRpbmdGb2N1cyIsImZvY3VzIiwiTm90aGluZyIsIl9fZGVtb01vZGUiLCJtIiwiZCIsImEiLCJJIiwic2VhcmNoUXVlcnkiLCJhY3RpdmF0aW9uVHJpZ2dlciIsInRyaWdnZXIiLCJTcGVjaWZpYyIsImZpbmRJbmRleCIsImlkIiwiUHJldmlvdXMiLCJnIiwibyIsInJlc29sdmVJdGVtcyIsInJlc29sdmVBY3RpdmVJbmRleCIsInJlc29sdmVJZCIsInMiLCJyZXNvbHZlRGlzYWJsZWQiLCJkaXNhYmxlZCIsInByZXZpb3VzRWxlbWVudFNpYmxpbmciLCJOZXh0IiwibmV4dEVsZW1lbnRTaWJsaW5nIiwidG9Mb3dlckNhc2UiLCJjb25jYXQiLCJmaW5kIiwidGV4dFZhbHVlIiwic3RhcnRzV2l0aCIsInNlYXJjaEFjdGl2ZUl0ZW1JbmRleCIsIm1hcCIsInBlbmRpbmdTaG91bGRTb3J0IiwiU2V0IiwiZW50cmllcyIsImhhcyIsInB1c2giLCJkZWxldGUiLCJzaXplIiwibGVuZ3RoIiwicmV2ZXJzZSIsInNwbGljZSIsImJ1dHRvbkVsZW1lbnQiLCJlbGVtZW50IiwiaXRlbXNFbGVtZW50IiwieCIsIm5ldyIsInJlZHVjZSIsInR5cGUiLCJjb25zdHJ1Y3RvciIsInJlZ2lzdGVySXRlbSIsImFkZCIsImNsZWFyIiwic2VuZCIsInVucmVnaXN0ZXJJdGVtIiwiYWN0aXZlRGVzY2VuZGFudElkIiwiaXNBY3RpdmUiLCJzaG91bGRTY3JvbGxJbnRvVmlldyIsIm9uIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwiQWN0aW9uVHlwZXMiLCJBY3RpdmF0aW9uVHJpZ2dlciIsIk1lbnVNYWNoaW5lIiwiTWVudVN0YXRlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../../../node_modules/@headlessui/react/dist/components/menu/menu-machine.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../../../node_modules/@headlessui/react/dist/components/menu/menu.js":
/*!*******************************************************************************!*\
  !*** ../../../../node_modules/@headlessui/react/dist/components/menu/menu.js ***!
  \*******************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Menu: function() { return /* binding */ to; },\n/* harmony export */   MenuButton: function() { return /* binding */ mt; },\n/* harmony export */   MenuHeading: function() { return /* binding */ yt; },\n/* harmony export */   MenuItem: function() { return /* binding */ ft; },\n/* harmony export */   MenuItems: function() { return /* binding */ Tt; },\n/* harmony export */   MenuSection: function() { return /* binding */ ct; },\n/* harmony export */   MenuSeparator: function() { return /* binding */ Et; }\n/* harmony export */ });\n/* harmony import */ var _react_aria_focus__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! @react-aria/focus */ \"(app-pages-browser)/../../../../node_modules/@react-aria/focus/dist/useFocusRing.mjs\");\n/* harmony import */ var _react_aria_interactions__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! @react-aria/interactions */ \"(app-pages-browser)/../../../../node_modules/@react-aria/interactions/dist/useHover.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../hooks/use-id.js */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-dom */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react-dom/index.js\");\n/* harmony import */ var _hooks_use_active_press_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ../../hooks/use-active-press.js */ \"(app-pages-browser)/../../../../node_modules/@headlessui/react/dist/hooks/use-active-press.js\");\n/* harmony import */ var _hooks_use_did_element_move_js__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ../../hooks/use-did-element-move.js */ \"(app-pages-browser)/../../../../node_modules/@headlessui/react/dist/hooks/use-did-element-move.js\");\n/* harmony import */ var _hooks_use_disposables_js__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ../../hooks/use-disposables.js */ \"(app-pages-browser)/../../../../node_modules/@headlessui/react/dist/hooks/use-disposables.js\");\n/* harmony import */ var _hooks_use_element_size_js__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ../../hooks/use-element-size.js */ \"(app-pages-browser)/../../../../node_modules/@headlessui/react/dist/hooks/use-element-size.js\");\n/* harmony import */ var _hooks_use_event_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../hooks/use-event.js */ \"(app-pages-browser)/../../../../node_modules/@headlessui/react/dist/hooks/use-event.js\");\n/* harmony import */ var _hooks_use_inert_others_js__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ../../hooks/use-inert-others.js */ \"(app-pages-browser)/../../../../node_modules/@headlessui/react/dist/hooks/use-inert-others.js\");\n/* harmony import */ var _hooks_use_iso_morphic_effect_js__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! ../../hooks/use-iso-morphic-effect.js */ \"(app-pages-browser)/../../../../node_modules/@headlessui/react/dist/hooks/use-iso-morphic-effect.js\");\n/* harmony import */ var _hooks_use_on_disappear_js__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ../../hooks/use-on-disappear.js */ \"(app-pages-browser)/../../../../node_modules/@headlessui/react/dist/hooks/use-on-disappear.js\");\n/* harmony import */ var _hooks_use_outside_click_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../hooks/use-outside-click.js */ \"(app-pages-browser)/../../../../node_modules/@headlessui/react/dist/hooks/use-outside-click.js\");\n/* harmony import */ var _hooks_use_owner_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ../../hooks/use-owner.js */ \"(app-pages-browser)/../../../../node_modules/@headlessui/react/dist/hooks/use-owner.js\");\n/* harmony import */ var _hooks_use_resolve_button_type_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ../../hooks/use-resolve-button-type.js */ \"(app-pages-browser)/../../../../node_modules/@headlessui/react/dist/hooks/use-resolve-button-type.js\");\n/* harmony import */ var _hooks_use_scroll_lock_js__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ../../hooks/use-scroll-lock.js */ \"(app-pages-browser)/../../../../node_modules/@headlessui/react/dist/hooks/use-scroll-lock.js\");\n/* harmony import */ var _hooks_use_sync_refs_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../hooks/use-sync-refs.js */ \"(app-pages-browser)/../../../../node_modules/@headlessui/react/dist/hooks/use-sync-refs.js\");\n/* harmony import */ var _hooks_use_text_value_js__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(/*! ../../hooks/use-text-value.js */ \"(app-pages-browser)/../../../../node_modules/@headlessui/react/dist/hooks/use-text-value.js\");\n/* harmony import */ var _hooks_use_tracked_pointer_js__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(/*! ../../hooks/use-tracked-pointer.js */ \"(app-pages-browser)/../../../../node_modules/@headlessui/react/dist/hooks/use-tracked-pointer.js\");\n/* harmony import */ var _hooks_use_transition_js__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ../../hooks/use-transition.js */ \"(app-pages-browser)/../../../../node_modules/@headlessui/react/dist/hooks/use-transition.js\");\n/* harmony import */ var _hooks_use_tree_walker_js__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ../../hooks/use-tree-walker.js */ \"(app-pages-browser)/../../../../node_modules/@headlessui/react/dist/hooks/use-tree-walker.js\");\n/* harmony import */ var _internal_floating_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../internal/floating.js */ \"(app-pages-browser)/../../../../node_modules/@headlessui/react/dist/internal/floating.js\");\n/* harmony import */ var _internal_open_closed_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../../internal/open-closed.js */ \"(app-pages-browser)/../../../../node_modules/@headlessui/react/dist/internal/open-closed.js\");\n/* harmony import */ var _react_glue_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../react-glue.js */ \"(app-pages-browser)/../../../../node_modules/@headlessui/react/dist/react-glue.js\");\n/* harmony import */ var _utils_bugs_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../../utils/bugs.js */ \"(app-pages-browser)/../../../../node_modules/@headlessui/react/dist/utils/bugs.js\");\n/* harmony import */ var _utils_calculate_active_index_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../../utils/calculate-active-index.js */ \"(app-pages-browser)/../../../../node_modules/@headlessui/react/dist/utils/calculate-active-index.js\");\n/* harmony import */ var _utils_disposables_js__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! ../../utils/disposables.js */ \"(app-pages-browser)/../../../../node_modules/@headlessui/react/dist/utils/disposables.js\");\n/* harmony import */ var _utils_focus_management_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../utils/focus-management.js */ \"(app-pages-browser)/../../../../node_modules/@headlessui/react/dist/utils/focus-management.js\");\n/* harmony import */ var _utils_match_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../../utils/match.js */ \"(app-pages-browser)/../../../../node_modules/@headlessui/react/dist/utils/match.js\");\n/* harmony import */ var _utils_render_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../utils/render.js */ \"(app-pages-browser)/../../../../node_modules/@headlessui/react/dist/utils/render.js\");\n/* harmony import */ var _description_description_js__WEBPACK_IMPORTED_MODULE_35__ = __webpack_require__(/*! ../description/description.js */ \"(app-pages-browser)/../../../../node_modules/@headlessui/react/dist/components/description/description.js\");\n/* harmony import */ var _keyboard_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../keyboard.js */ \"(app-pages-browser)/../../../../node_modules/@headlessui/react/dist/components/keyboard.js\");\n/* harmony import */ var _label_label_js__WEBPACK_IMPORTED_MODULE_34__ = __webpack_require__(/*! ../label/label.js */ \"(app-pages-browser)/../../../../node_modules/@headlessui/react/dist/components/label/label.js\");\n/* harmony import */ var _portal_portal_js__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! ../portal/portal.js */ \"(app-pages-browser)/../../../../node_modules/@headlessui/react/dist/components/portal/portal.js\");\n/* harmony import */ var _menu_machine_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./menu-machine.js */ \"(app-pages-browser)/../../../../node_modules/@headlessui/react/dist/components/menu/menu-machine.js\");\n/* harmony import */ var _menu_machine_glue_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./menu-machine-glue.js */ \"(app-pages-browser)/../../../../node_modules/@headlessui/react/dist/components/menu/menu-machine-glue.js\");\n/* __next_internal_client_entry_do_not_use__ Menu,MenuButton,MenuHeading,MenuItem,MenuItems,MenuSection,MenuSeparator auto */ \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlet ze = react__WEBPACK_IMPORTED_MODULE_0__.Fragment;\nfunction Qe(T, E) {\n    let { __demoMode: i = !1, ...a } = T, n = (0,_menu_machine_glue_js__WEBPACK_IMPORTED_MODULE_2__.useMenuMachine)({\n        __demoMode: i\n    }), [s, o, P] = (0,_react_glue_js__WEBPACK_IMPORTED_MODULE_3__.useSlice)(n, (p)=>[\n            p.menuState,\n            p.itemsElement,\n            p.buttonElement\n        ]), c = (0,_hooks_use_sync_refs_js__WEBPACK_IMPORTED_MODULE_4__.useSyncRefs)(E), _ = s === _menu_machine_js__WEBPACK_IMPORTED_MODULE_5__.MenuState.Open;\n    (0,_hooks_use_outside_click_js__WEBPACK_IMPORTED_MODULE_6__.useOutsideClick)(_, [\n        P,\n        o\n    ], (p, F)=>{\n        var A;\n        n.send({\n            type: _menu_machine_js__WEBPACK_IMPORTED_MODULE_5__.ActionTypes.CloseMenu\n        }), (0,_utils_focus_management_js__WEBPACK_IMPORTED_MODULE_7__.isFocusableElement)(F, _utils_focus_management_js__WEBPACK_IMPORTED_MODULE_7__.FocusableMode.Loose) || (p.preventDefault(), (A = n.state.buttonElement) == null || A.focus());\n    });\n    let t = (0,_hooks_use_event_js__WEBPACK_IMPORTED_MODULE_8__.useEvent)(()=>{\n        n.send({\n            type: _menu_machine_js__WEBPACK_IMPORTED_MODULE_5__.ActionTypes.CloseMenu\n        });\n    }), R = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>({\n            open: s === _menu_machine_js__WEBPACK_IMPORTED_MODULE_5__.MenuState.Open,\n            close: t\n        }), [\n        s,\n        t\n    ]), I = {\n        ref: c\n    }, g = (0,_utils_render_js__WEBPACK_IMPORTED_MODULE_9__.useRender)();\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_internal_floating_js__WEBPACK_IMPORTED_MODULE_10__.FloatingProvider, null, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_menu_machine_glue_js__WEBPACK_IMPORTED_MODULE_2__.MenuContext.Provider, {\n        value: n\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_internal_open_closed_js__WEBPACK_IMPORTED_MODULE_11__.OpenClosedProvider, {\n        value: (0,_utils_match_js__WEBPACK_IMPORTED_MODULE_12__.match)(s, {\n            [_menu_machine_js__WEBPACK_IMPORTED_MODULE_5__.MenuState.Open]: _internal_open_closed_js__WEBPACK_IMPORTED_MODULE_11__.State.Open,\n            [_menu_machine_js__WEBPACK_IMPORTED_MODULE_5__.MenuState.Closed]: _internal_open_closed_js__WEBPACK_IMPORTED_MODULE_11__.State.Closed\n        })\n    }, g({\n        ourProps: I,\n        theirProps: a,\n        slot: R,\n        defaultTag: ze,\n        name: \"Menu\"\n    }))));\n}\n_c = Qe;\nlet Ye = \"button\";\nfunction Ze(T, E) {\n    let i = (0,_menu_machine_glue_js__WEBPACK_IMPORTED_MODULE_2__.useMenuMachineContext)(\"Menu.Button\"), a = (0,react__WEBPACK_IMPORTED_MODULE_0__.useId)(), { id: n = \"headlessui-menu-button-\".concat(a), disabled: s = !1, autoFocus: o = !1, ...P } = T, c = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null), _ = (0,_internal_floating_js__WEBPACK_IMPORTED_MODULE_10__.useFloatingReferenceProps)(), t = (0,_hooks_use_sync_refs_js__WEBPACK_IMPORTED_MODULE_4__.useSyncRefs)(E, c, (0,_internal_floating_js__WEBPACK_IMPORTED_MODULE_10__.useFloatingReference)(), (0,_hooks_use_event_js__WEBPACK_IMPORTED_MODULE_8__.useEvent)((l)=>i.send({\n            type: _menu_machine_js__WEBPACK_IMPORTED_MODULE_5__.ActionTypes.SetButtonElement,\n            element: l\n        }))), R = (0,_hooks_use_event_js__WEBPACK_IMPORTED_MODULE_8__.useEvent)((l)=>{\n        switch(l.key){\n            case _keyboard_js__WEBPACK_IMPORTED_MODULE_13__.Keys.Space:\n            case _keyboard_js__WEBPACK_IMPORTED_MODULE_13__.Keys.Enter:\n            case _keyboard_js__WEBPACK_IMPORTED_MODULE_13__.Keys.ArrowDown:\n                l.preventDefault(), l.stopPropagation(), i.send({\n                    type: _menu_machine_js__WEBPACK_IMPORTED_MODULE_5__.ActionTypes.OpenMenu,\n                    focus: {\n                        focus: _utils_calculate_active_index_js__WEBPACK_IMPORTED_MODULE_14__.Focus.First\n                    }\n                });\n                break;\n            case _keyboard_js__WEBPACK_IMPORTED_MODULE_13__.Keys.ArrowUp:\n                l.preventDefault(), l.stopPropagation(), i.send({\n                    type: _menu_machine_js__WEBPACK_IMPORTED_MODULE_5__.ActionTypes.OpenMenu,\n                    focus: {\n                        focus: _utils_calculate_active_index_js__WEBPACK_IMPORTED_MODULE_14__.Focus.Last\n                    }\n                });\n                break;\n        }\n    }), I = (0,_hooks_use_event_js__WEBPACK_IMPORTED_MODULE_8__.useEvent)((l)=>{\n        switch(l.key){\n            case _keyboard_js__WEBPACK_IMPORTED_MODULE_13__.Keys.Space:\n                l.preventDefault();\n                break;\n        }\n    }), [g, p] = (0,_react_glue_js__WEBPACK_IMPORTED_MODULE_3__.useSlice)(i, (l)=>[\n            l.menuState,\n            l.itemsElement\n        ]), F = (0,_hooks_use_event_js__WEBPACK_IMPORTED_MODULE_8__.useEvent)((l)=>{\n        var H;\n        if (l.button === 0) {\n            if ((0,_utils_bugs_js__WEBPACK_IMPORTED_MODULE_15__.isDisabledReactIssue7711)(l.currentTarget)) return l.preventDefault();\n            s || (g === _menu_machine_js__WEBPACK_IMPORTED_MODULE_5__.MenuState.Open ? ((0,react_dom__WEBPACK_IMPORTED_MODULE_1__.flushSync)(()=>i.send({\n                    type: _menu_machine_js__WEBPACK_IMPORTED_MODULE_5__.ActionTypes.CloseMenu\n                })), (H = c.current) == null || H.focus({\n                preventScroll: !0\n            })) : (l.preventDefault(), i.send({\n                type: _menu_machine_js__WEBPACK_IMPORTED_MODULE_5__.ActionTypes.OpenMenu,\n                focus: {\n                    focus: _utils_calculate_active_index_js__WEBPACK_IMPORTED_MODULE_14__.Focus.Nothing\n                },\n                trigger: _menu_machine_js__WEBPACK_IMPORTED_MODULE_5__.ActivationTrigger.Pointer\n            })));\n        }\n    }), { isFocusVisible: A, focusProps: f } = (0,_react_aria_focus__WEBPACK_IMPORTED_MODULE_16__.useFocusRing)({\n        autoFocus: o\n    }), { isHovered: M, hoverProps: L } = (0,_react_aria_interactions__WEBPACK_IMPORTED_MODULE_17__.useHover)({\n        isDisabled: s\n    }), { pressed: S, pressProps: O } = (0,_hooks_use_active_press_js__WEBPACK_IMPORTED_MODULE_18__.useActivePress)({\n        disabled: s\n    }), x = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>({\n            open: g === _menu_machine_js__WEBPACK_IMPORTED_MODULE_5__.MenuState.Open,\n            active: S || g === _menu_machine_js__WEBPACK_IMPORTED_MODULE_5__.MenuState.Open,\n            disabled: s,\n            hover: M,\n            focus: A,\n            autofocus: o\n        }), [\n        g,\n        M,\n        A,\n        S,\n        s,\n        o\n    ]), U = (0,_utils_render_js__WEBPACK_IMPORTED_MODULE_9__.mergeProps)(_(), {\n        ref: t,\n        id: n,\n        type: (0,_hooks_use_resolve_button_type_js__WEBPACK_IMPORTED_MODULE_19__.useResolveButtonType)(T, c.current),\n        \"aria-haspopup\": \"menu\",\n        \"aria-controls\": p == null ? void 0 : p.id,\n        \"aria-expanded\": g === _menu_machine_js__WEBPACK_IMPORTED_MODULE_5__.MenuState.Open,\n        disabled: s || void 0,\n        autoFocus: o,\n        onKeyDown: R,\n        onKeyUp: I,\n        onMouseDown: F\n    }, f, L, O);\n    return (0,_utils_render_js__WEBPACK_IMPORTED_MODULE_9__.useRender)()({\n        ourProps: U,\n        theirProps: P,\n        slot: x,\n        defaultTag: Ye,\n        name: \"Menu.Button\"\n    });\n}\n_c1 = Ze;\nlet et = \"div\", tt = _utils_render_js__WEBPACK_IMPORTED_MODULE_9__.RenderFeatures.RenderStrategy | _utils_render_js__WEBPACK_IMPORTED_MODULE_9__.RenderFeatures.Static;\nfunction ot(T, E) {\n    let i = (0,react__WEBPACK_IMPORTED_MODULE_0__.useId)(), { id: a = \"headlessui-menu-items-\".concat(i), anchor: n, portal: s = !1, modal: o = !0, transition: P = !1, ...c } = T, _ = (0,_internal_floating_js__WEBPACK_IMPORTED_MODULE_10__.useResolvedAnchor)(n), t = (0,_menu_machine_glue_js__WEBPACK_IMPORTED_MODULE_2__.useMenuMachineContext)(\"Menu.Items\"), [R, I] = (0,_internal_floating_js__WEBPACK_IMPORTED_MODULE_10__.useFloatingPanel)(_), g = (0,_internal_floating_js__WEBPACK_IMPORTED_MODULE_10__.useFloatingPanelProps)(), [p, F] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null), A = (0,_hooks_use_sync_refs_js__WEBPACK_IMPORTED_MODULE_4__.useSyncRefs)(E, _ ? R : null, (0,_hooks_use_event_js__WEBPACK_IMPORTED_MODULE_8__.useEvent)((e)=>t.send({\n            type: _menu_machine_js__WEBPACK_IMPORTED_MODULE_5__.ActionTypes.SetItemsElement,\n            element: e\n        })), F), [f, M] = (0,_react_glue_js__WEBPACK_IMPORTED_MODULE_3__.useSlice)(t, (e)=>[\n            e.menuState,\n            e.buttonElement\n        ]), L = (0,_hooks_use_owner_js__WEBPACK_IMPORTED_MODULE_20__.useOwnerDocument)(M), S = (0,_hooks_use_owner_js__WEBPACK_IMPORTED_MODULE_20__.useOwnerDocument)(p);\n    _ && (s = !0);\n    let O = (0,_internal_open_closed_js__WEBPACK_IMPORTED_MODULE_11__.useOpenClosed)(), [x, U] = (0,_hooks_use_transition_js__WEBPACK_IMPORTED_MODULE_21__.useTransition)(P, p, O !== null ? (O & _internal_open_closed_js__WEBPACK_IMPORTED_MODULE_11__.State.Open) === _internal_open_closed_js__WEBPACK_IMPORTED_MODULE_11__.State.Open : f === _menu_machine_js__WEBPACK_IMPORTED_MODULE_5__.MenuState.Open);\n    (0,_hooks_use_on_disappear_js__WEBPACK_IMPORTED_MODULE_22__.useOnDisappear)(x, M, ()=>{\n        t.send({\n            type: _menu_machine_js__WEBPACK_IMPORTED_MODULE_5__.ActionTypes.CloseMenu\n        });\n    });\n    let G = (0,_react_glue_js__WEBPACK_IMPORTED_MODULE_3__.useSlice)(t, (e)=>e.__demoMode), l = G ? !1 : o && f === _menu_machine_js__WEBPACK_IMPORTED_MODULE_5__.MenuState.Open;\n    (0,_hooks_use_scroll_lock_js__WEBPACK_IMPORTED_MODULE_23__.useScrollLock)(l, S);\n    let H = G ? !1 : o && f === _menu_machine_js__WEBPACK_IMPORTED_MODULE_5__.MenuState.Open;\n    (0,_hooks_use_inert_others_js__WEBPACK_IMPORTED_MODULE_24__.useInertOthers)(H, {\n        allowed: (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>[\n                M,\n                p\n            ], [\n            M,\n            p\n        ])\n    });\n    let u = f !== _menu_machine_js__WEBPACK_IMPORTED_MODULE_5__.MenuState.Open, ae = (0,_hooks_use_did_element_move_js__WEBPACK_IMPORTED_MODULE_25__.useDidElementMove)(u, M) ? !1 : x;\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        let e = p;\n        e && f === _menu_machine_js__WEBPACK_IMPORTED_MODULE_5__.MenuState.Open && e !== (S == null ? void 0 : S.activeElement) && e.focus({\n            preventScroll: !0\n        });\n    }, [\n        f,\n        p,\n        S\n    ]), (0,_hooks_use_tree_walker_js__WEBPACK_IMPORTED_MODULE_26__.useTreeWalker)(f === _menu_machine_js__WEBPACK_IMPORTED_MODULE_5__.MenuState.Open, {\n        container: p,\n        accept (e) {\n            return e.getAttribute(\"role\") === \"menuitem\" ? NodeFilter.FILTER_REJECT : e.hasAttribute(\"role\") ? NodeFilter.FILTER_SKIP : NodeFilter.FILTER_ACCEPT;\n        },\n        walk (e) {\n            e.setAttribute(\"role\", \"none\");\n        }\n    });\n    let q = (0,_hooks_use_disposables_js__WEBPACK_IMPORTED_MODULE_27__.useDisposables)(), se = (0,_hooks_use_event_js__WEBPACK_IMPORTED_MODULE_8__.useEvent)((e)=>{\n        var N, z, Q;\n        switch(q.dispose(), e.key){\n            case _keyboard_js__WEBPACK_IMPORTED_MODULE_13__.Keys.Space:\n                if (t.state.searchQuery !== \"\") return e.preventDefault(), e.stopPropagation(), t.send({\n                    type: _menu_machine_js__WEBPACK_IMPORTED_MODULE_5__.ActionTypes.Search,\n                    value: e.key\n                });\n            case _keyboard_js__WEBPACK_IMPORTED_MODULE_13__.Keys.Enter:\n                if (e.preventDefault(), e.stopPropagation(), t.state.activeItemIndex !== null) {\n                    let { dataRef: de } = t.state.items[t.state.activeItemIndex];\n                    (z = (N = de.current) == null ? void 0 : N.domRef.current) == null || z.click();\n                }\n                t.send({\n                    type: _menu_machine_js__WEBPACK_IMPORTED_MODULE_5__.ActionTypes.CloseMenu\n                }), (0,_utils_focus_management_js__WEBPACK_IMPORTED_MODULE_7__.restoreFocusIfNecessary)(t.state.buttonElement);\n                break;\n            case _keyboard_js__WEBPACK_IMPORTED_MODULE_13__.Keys.ArrowDown:\n                return e.preventDefault(), e.stopPropagation(), t.send({\n                    type: _menu_machine_js__WEBPACK_IMPORTED_MODULE_5__.ActionTypes.GoToItem,\n                    focus: _utils_calculate_active_index_js__WEBPACK_IMPORTED_MODULE_14__.Focus.Next\n                });\n            case _keyboard_js__WEBPACK_IMPORTED_MODULE_13__.Keys.ArrowUp:\n                return e.preventDefault(), e.stopPropagation(), t.send({\n                    type: _menu_machine_js__WEBPACK_IMPORTED_MODULE_5__.ActionTypes.GoToItem,\n                    focus: _utils_calculate_active_index_js__WEBPACK_IMPORTED_MODULE_14__.Focus.Previous\n                });\n            case _keyboard_js__WEBPACK_IMPORTED_MODULE_13__.Keys.Home:\n            case _keyboard_js__WEBPACK_IMPORTED_MODULE_13__.Keys.PageUp:\n                return e.preventDefault(), e.stopPropagation(), t.send({\n                    type: _menu_machine_js__WEBPACK_IMPORTED_MODULE_5__.ActionTypes.GoToItem,\n                    focus: _utils_calculate_active_index_js__WEBPACK_IMPORTED_MODULE_14__.Focus.First\n                });\n            case _keyboard_js__WEBPACK_IMPORTED_MODULE_13__.Keys.End:\n            case _keyboard_js__WEBPACK_IMPORTED_MODULE_13__.Keys.PageDown:\n                return e.preventDefault(), e.stopPropagation(), t.send({\n                    type: _menu_machine_js__WEBPACK_IMPORTED_MODULE_5__.ActionTypes.GoToItem,\n                    focus: _utils_calculate_active_index_js__WEBPACK_IMPORTED_MODULE_14__.Focus.Last\n                });\n            case _keyboard_js__WEBPACK_IMPORTED_MODULE_13__.Keys.Escape:\n                e.preventDefault(), e.stopPropagation(), (0,react_dom__WEBPACK_IMPORTED_MODULE_1__.flushSync)(()=>t.send({\n                        type: _menu_machine_js__WEBPACK_IMPORTED_MODULE_5__.ActionTypes.CloseMenu\n                    })), (Q = t.state.buttonElement) == null || Q.focus({\n                    preventScroll: !0\n                });\n                break;\n            case _keyboard_js__WEBPACK_IMPORTED_MODULE_13__.Keys.Tab:\n                e.preventDefault(), e.stopPropagation(), (0,react_dom__WEBPACK_IMPORTED_MODULE_1__.flushSync)(()=>t.send({\n                        type: _menu_machine_js__WEBPACK_IMPORTED_MODULE_5__.ActionTypes.CloseMenu\n                    })), (0,_utils_focus_management_js__WEBPACK_IMPORTED_MODULE_7__.focusFrom)(t.state.buttonElement, e.shiftKey ? _utils_focus_management_js__WEBPACK_IMPORTED_MODULE_7__.Focus.Previous : _utils_focus_management_js__WEBPACK_IMPORTED_MODULE_7__.Focus.Next);\n                break;\n            default:\n                e.key.length === 1 && (t.send({\n                    type: _menu_machine_js__WEBPACK_IMPORTED_MODULE_5__.ActionTypes.Search,\n                    value: e.key\n                }), q.setTimeout(()=>t.send({\n                        type: _menu_machine_js__WEBPACK_IMPORTED_MODULE_5__.ActionTypes.ClearSearch\n                    }), 350));\n                break;\n        }\n    }), le = (0,_hooks_use_event_js__WEBPACK_IMPORTED_MODULE_8__.useEvent)((e)=>{\n        switch(e.key){\n            case _keyboard_js__WEBPACK_IMPORTED_MODULE_13__.Keys.Space:\n                e.preventDefault();\n                break;\n        }\n    }), pe = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>({\n            open: f === _menu_machine_js__WEBPACK_IMPORTED_MODULE_5__.MenuState.Open\n        }), [\n        f\n    ]), ie = (0,_utils_render_js__WEBPACK_IMPORTED_MODULE_9__.mergeProps)(_ ? g() : {}, {\n        \"aria-activedescendant\": (0,_react_glue_js__WEBPACK_IMPORTED_MODULE_3__.useSlice)(t, t.selectors.activeDescendantId),\n        \"aria-labelledby\": (0,_react_glue_js__WEBPACK_IMPORTED_MODULE_3__.useSlice)(t, (e)=>{\n            var N;\n            return (N = e.buttonElement) == null ? void 0 : N.id;\n        }),\n        id: a,\n        onKeyDown: se,\n        onKeyUp: le,\n        role: \"menu\",\n        tabIndex: f === _menu_machine_js__WEBPACK_IMPORTED_MODULE_5__.MenuState.Open ? 0 : void 0,\n        ref: A,\n        style: {\n            ...c.style,\n            ...I,\n            \"--button-width\": (0,_hooks_use_element_size_js__WEBPACK_IMPORTED_MODULE_28__.useElementSize)(M, !0).width\n        },\n        ...(0,_hooks_use_transition_js__WEBPACK_IMPORTED_MODULE_21__.transitionDataAttributes)(U)\n    }), ue = (0,_utils_render_js__WEBPACK_IMPORTED_MODULE_9__.useRender)();\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_portal_portal_js__WEBPACK_IMPORTED_MODULE_29__.Portal, {\n        enabled: s ? T.static || x : !1,\n        ownerDocument: L\n    }, ue({\n        ourProps: ie,\n        theirProps: c,\n        slot: pe,\n        defaultTag: et,\n        features: tt,\n        visible: ae,\n        name: \"Menu.Items\"\n    }));\n}\nlet nt = react__WEBPACK_IMPORTED_MODULE_0__.Fragment;\nfunction rt(T, E) {\n    let i = (0,react__WEBPACK_IMPORTED_MODULE_0__.useId)(), { id: a = \"headlessui-menu-item-\".concat(i), disabled: n = !1, ...s } = T, o = (0,_menu_machine_glue_js__WEBPACK_IMPORTED_MODULE_2__.useMenuMachineContext)(\"Menu.Item\"), P = (0,_react_glue_js__WEBPACK_IMPORTED_MODULE_3__.useSlice)(o, (u)=>o.selectors.isActive(u, a)), c = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null), _ = (0,_hooks_use_sync_refs_js__WEBPACK_IMPORTED_MODULE_4__.useSyncRefs)(E, c), t = (0,_react_glue_js__WEBPACK_IMPORTED_MODULE_3__.useSlice)(o, (u)=>o.selectors.shouldScrollIntoView(u, a));\n    (0,_hooks_use_iso_morphic_effect_js__WEBPACK_IMPORTED_MODULE_30__.useIsoMorphicEffect)(()=>{\n        if (t) return (0,_utils_disposables_js__WEBPACK_IMPORTED_MODULE_31__.disposables)().requestAnimationFrame(()=>{\n            var u, J;\n            (J = (u = c.current) == null ? void 0 : u.scrollIntoView) == null || J.call(u, {\n                block: \"nearest\"\n            });\n        });\n    }, [\n        t,\n        c\n    ]);\n    let R = (0,_hooks_use_text_value_js__WEBPACK_IMPORTED_MODULE_32__.useTextValue)(c), I = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({\n        disabled: n,\n        domRef: c,\n        get textValue () {\n            return R();\n        }\n    });\n    (0,_hooks_use_iso_morphic_effect_js__WEBPACK_IMPORTED_MODULE_30__.useIsoMorphicEffect)(()=>{\n        I.current.disabled = n;\n    }, [\n        I,\n        n\n    ]), (0,_hooks_use_iso_morphic_effect_js__WEBPACK_IMPORTED_MODULE_30__.useIsoMorphicEffect)(()=>(o.actions.registerItem(a, I), ()=>o.actions.unregisterItem(a)), [\n        I,\n        a\n    ]);\n    let g = (0,_hooks_use_event_js__WEBPACK_IMPORTED_MODULE_8__.useEvent)(()=>{\n        o.send({\n            type: _menu_machine_js__WEBPACK_IMPORTED_MODULE_5__.ActionTypes.CloseMenu\n        });\n    }), p = (0,_hooks_use_event_js__WEBPACK_IMPORTED_MODULE_8__.useEvent)((u)=>{\n        if (n) return u.preventDefault();\n        o.send({\n            type: _menu_machine_js__WEBPACK_IMPORTED_MODULE_5__.ActionTypes.CloseMenu\n        }), (0,_utils_focus_management_js__WEBPACK_IMPORTED_MODULE_7__.restoreFocusIfNecessary)(o.state.buttonElement);\n    }), F = (0,_hooks_use_event_js__WEBPACK_IMPORTED_MODULE_8__.useEvent)(()=>{\n        if (n) return o.send({\n            type: _menu_machine_js__WEBPACK_IMPORTED_MODULE_5__.ActionTypes.GoToItem,\n            focus: _utils_calculate_active_index_js__WEBPACK_IMPORTED_MODULE_14__.Focus.Nothing\n        });\n        o.send({\n            type: _menu_machine_js__WEBPACK_IMPORTED_MODULE_5__.ActionTypes.GoToItem,\n            focus: _utils_calculate_active_index_js__WEBPACK_IMPORTED_MODULE_14__.Focus.Specific,\n            id: a\n        });\n    }), A = (0,_hooks_use_tracked_pointer_js__WEBPACK_IMPORTED_MODULE_33__.useTrackedPointer)(), f = (0,_hooks_use_event_js__WEBPACK_IMPORTED_MODULE_8__.useEvent)((u)=>{\n        A.update(u), !n && (P || o.send({\n            type: _menu_machine_js__WEBPACK_IMPORTED_MODULE_5__.ActionTypes.GoToItem,\n            focus: _utils_calculate_active_index_js__WEBPACK_IMPORTED_MODULE_14__.Focus.Specific,\n            id: a,\n            trigger: _menu_machine_js__WEBPACK_IMPORTED_MODULE_5__.ActivationTrigger.Pointer\n        }));\n    }), M = (0,_hooks_use_event_js__WEBPACK_IMPORTED_MODULE_8__.useEvent)((u)=>{\n        A.wasMoved(u) && (n || P || o.send({\n            type: _menu_machine_js__WEBPACK_IMPORTED_MODULE_5__.ActionTypes.GoToItem,\n            focus: _utils_calculate_active_index_js__WEBPACK_IMPORTED_MODULE_14__.Focus.Specific,\n            id: a,\n            trigger: _menu_machine_js__WEBPACK_IMPORTED_MODULE_5__.ActivationTrigger.Pointer\n        }));\n    }), L = (0,_hooks_use_event_js__WEBPACK_IMPORTED_MODULE_8__.useEvent)((u)=>{\n        A.wasMoved(u) && (n || P && o.send({\n            type: _menu_machine_js__WEBPACK_IMPORTED_MODULE_5__.ActionTypes.GoToItem,\n            focus: _utils_calculate_active_index_js__WEBPACK_IMPORTED_MODULE_14__.Focus.Nothing\n        }));\n    }), [S, O] = (0,_label_label_js__WEBPACK_IMPORTED_MODULE_34__.useLabels)(), [x, U] = (0,_description_description_js__WEBPACK_IMPORTED_MODULE_35__.useDescriptions)(), G = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>({\n            active: P,\n            focus: P,\n            disabled: n,\n            close: g\n        }), [\n        P,\n        n,\n        g\n    ]), l = {\n        id: a,\n        ref: _,\n        role: \"menuitem\",\n        tabIndex: n === !0 ? void 0 : -1,\n        \"aria-disabled\": n === !0 ? !0 : void 0,\n        \"aria-labelledby\": S,\n        \"aria-describedby\": x,\n        disabled: void 0,\n        onClick: p,\n        onFocus: F,\n        onPointerEnter: f,\n        onMouseEnter: f,\n        onPointerMove: M,\n        onMouseMove: M,\n        onPointerLeave: L,\n        onMouseLeave: L\n    }, H = (0,_utils_render_js__WEBPACK_IMPORTED_MODULE_9__.useRender)();\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(O, null, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(U, null, H({\n        ourProps: l,\n        theirProps: s,\n        slot: G,\n        defaultTag: nt,\n        name: \"Menu.Item\"\n    })));\n}\nlet at = \"div\";\nfunction st(T, E) {\n    let [i, a] = (0,_label_label_js__WEBPACK_IMPORTED_MODULE_34__.useLabels)(), n = T, s = {\n        ref: E,\n        \"aria-labelledby\": i,\n        role: \"group\"\n    }, o = (0,_utils_render_js__WEBPACK_IMPORTED_MODULE_9__.useRender)();\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(a, null, o({\n        ourProps: s,\n        theirProps: n,\n        slot: {},\n        defaultTag: at,\n        name: \"Menu.Section\"\n    }));\n}\nlet lt = \"header\";\nfunction pt(T, E) {\n    let i = (0,react__WEBPACK_IMPORTED_MODULE_0__.useId)(), { id: a = \"headlessui-menu-heading-\".concat(i), ...n } = T, s = (0,_label_label_js__WEBPACK_IMPORTED_MODULE_34__.useLabelContext)();\n    (0,_hooks_use_iso_morphic_effect_js__WEBPACK_IMPORTED_MODULE_30__.useIsoMorphicEffect)(()=>s.register(a), [\n        a,\n        s.register\n    ]);\n    let o = {\n        id: a,\n        ref: E,\n        role: \"presentation\",\n        ...s.props\n    };\n    return (0,_utils_render_js__WEBPACK_IMPORTED_MODULE_9__.useRender)()({\n        ourProps: o,\n        theirProps: n,\n        slot: {},\n        defaultTag: lt,\n        name: \"Menu.Heading\"\n    });\n}\nlet it = \"div\";\nfunction ut(T, E) {\n    let i = T, a = {\n        ref: E,\n        role: \"separator\"\n    };\n    return (0,_utils_render_js__WEBPACK_IMPORTED_MODULE_9__.useRender)()({\n        ourProps: a,\n        theirProps: i,\n        slot: {},\n        defaultTag: it,\n        name: \"Menu.Separator\"\n    });\n}\nlet dt = (0,_utils_render_js__WEBPACK_IMPORTED_MODULE_9__.forwardRefWithAs)(Qe), mt = (0,_utils_render_js__WEBPACK_IMPORTED_MODULE_9__.forwardRefWithAs)(Ze), Tt = (0,_utils_render_js__WEBPACK_IMPORTED_MODULE_9__.forwardRefWithAs)(ot), ft = (0,_utils_render_js__WEBPACK_IMPORTED_MODULE_9__.forwardRefWithAs)(rt), ct = (0,_utils_render_js__WEBPACK_IMPORTED_MODULE_9__.forwardRefWithAs)(st), yt = (0,_utils_render_js__WEBPACK_IMPORTED_MODULE_9__.forwardRefWithAs)(pt), Et = (0,_utils_render_js__WEBPACK_IMPORTED_MODULE_9__.forwardRefWithAs)(ut), to = Object.assign(dt, {\n    Button: mt,\n    Items: Tt,\n    Item: ft,\n    Section: ct,\n    Heading: yt,\n    Separator: Et\n});\n\nvar _c, _c1;\n$RefreshReg$(_c, \"Qe\");\n$RefreshReg$(_c1, \"Ze\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQGhlYWRsZXNzdWkvcmVhY3QvZGlzdC9jb21wb25lbnRzL21lbnUvbWVudS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzhIQUErRDtBQUFxRDtBQUE4RztBQUFzQztBQUFrRTtBQUF5RTtBQUFpRTtBQUFrRTtBQUFvRDtBQUE4QztBQUFrRTtBQUE0RTtBQUFrRTtBQUFvRTtBQUE0RDtBQUErRTtBQUFnRTtBQUEyRDtBQUE4RDtBQUF3RTtBQUE4RjtBQUFnRTtBQUFxTTtBQUFtRztBQUErQztBQUFnRTtBQUE4RDtBQUEwRDtBQUFvSjtBQUE4QztBQUE4RztBQUFpRTtBQUFzQztBQUFxRTtBQUE4QztBQUFzRjtBQUFzRztBQUFBLElBQUk0SCxLQUFHdEgsMkNBQUNBO0FBQUMsU0FBU3VILEdBQUdDLENBQUMsRUFBQ0MsQ0FBQztJQUFFLElBQUcsRUFBQ0MsWUFBV0MsSUFBRSxDQUFDLENBQUMsRUFBQyxHQUFHQyxHQUFFLEdBQUNKLEdBQUVLLElBQUVWLHFFQUFFQSxDQUFDO1FBQUNPLFlBQVdDO0lBQUMsSUFBRyxDQUFDRyxHQUFFQyxHQUFFQyxFQUFFLEdBQUMxRCx3REFBQ0EsQ0FBQ3VELEdBQUVJLENBQUFBLElBQUc7WUFBQ0EsRUFBRUMsU0FBUztZQUFDRCxFQUFFRSxZQUFZO1lBQUNGLEVBQUVHLGFBQWE7U0FBQyxHQUFFQyxJQUFFN0Ysb0VBQUNBLENBQUNpRixJQUFHYSxJQUFFUixNQUFJZix1REFBQ0EsQ0FBQ3dCLElBQUk7SUFBQ3ZHLDRFQUFFQSxDQUFDc0csR0FBRTtRQUFDTjtRQUFFRDtLQUFFLEVBQUMsQ0FBQ0UsR0FBRU87UUFBSyxJQUFJQztRQUFFWixFQUFFYSxJQUFJLENBQUM7WUFBQ0MsTUFBS2hDLHlEQUFDQSxDQUFDaUMsU0FBUztRQUFBLElBQUd6RCw4RUFBRUEsQ0FBQ3FELEdBQUV6RCxx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QU9DLE1BQU0sQ0FBQ1QsSUFBRztJQUFDVSxRQUFPVDtJQUFHVSxPQUFNVDtJQUFHVSxNQUFLVDtJQUFHVSxTQUFRVDtJQUFHVSxTQUFRVDtJQUFHVSxXQUFVVDtBQUFFO0FBQThIIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQGhlYWRsZXNzdWkvcmVhY3QvZGlzdC9jb21wb25lbnRzL21lbnUvbWVudS5qcz8wZWE4Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIGNsaWVudFwiO2ltcG9ydHt1c2VGb2N1c1JpbmcgYXMgbWV9ZnJvbVwiQHJlYWN0LWFyaWEvZm9jdXNcIjtpbXBvcnR7dXNlSG92ZXIgYXMgVGV9ZnJvbVwiQHJlYWN0LWFyaWEvaW50ZXJhY3Rpb25zXCI7aW1wb3J0IGgse0ZyYWdtZW50IGFzIFksdXNlQ2FsbGJhY2sgYXMgZmUsdXNlRWZmZWN0IGFzIGNlLHVzZU1lbW8gYXMgQix1c2VSZWYgYXMgVix1c2VTdGF0ZSBhcyB5ZX1mcm9tXCJyZWFjdFwiO2ltcG9ydHtmbHVzaFN5bmMgYXMgWH1mcm9tXCJyZWFjdC1kb21cIjtpbXBvcnR7dXNlQWN0aXZlUHJlc3MgYXMgRWV9ZnJvbScuLi8uLi9ob29rcy91c2UtYWN0aXZlLXByZXNzLmpzJztpbXBvcnR7dXNlRGlkRWxlbWVudE1vdmUgYXMgUGV9ZnJvbScuLi8uLi9ob29rcy91c2UtZGlkLWVsZW1lbnQtbW92ZS5qcyc7aW1wb3J0e3VzZURpc3Bvc2FibGVzIGFzIGdlfWZyb20nLi4vLi4vaG9va3MvdXNlLWRpc3Bvc2FibGVzLmpzJztpbXBvcnR7dXNlRWxlbWVudFNpemUgYXMgTWV9ZnJvbScuLi8uLi9ob29rcy91c2UtZWxlbWVudC1zaXplLmpzJztpbXBvcnR7dXNlRXZlbnQgYXMgeX1mcm9tJy4uLy4uL2hvb2tzL3VzZS1ldmVudC5qcyc7aW1wb3J0e3VzZUlkIGFzIHd9ZnJvbScuLi8uLi9ob29rcy91c2UtaWQuanMnO2ltcG9ydHt1c2VJbmVydE90aGVycyBhcyBiZX1mcm9tJy4uLy4uL2hvb2tzL3VzZS1pbmVydC1vdGhlcnMuanMnO2ltcG9ydHt1c2VJc29Nb3JwaGljRWZmZWN0IGFzIGt9ZnJvbScuLi8uLi9ob29rcy91c2UtaXNvLW1vcnBoaWMtZWZmZWN0LmpzJztpbXBvcnR7dXNlT25EaXNhcHBlYXIgYXMgQWV9ZnJvbScuLi8uLi9ob29rcy91c2Utb24tZGlzYXBwZWFyLmpzJztpbXBvcnR7dXNlT3V0c2lkZUNsaWNrIGFzIF9lfWZyb20nLi4vLi4vaG9va3MvdXNlLW91dHNpZGUtY2xpY2suanMnO2ltcG9ydHt1c2VPd25lckRvY3VtZW50IGFzIFp9ZnJvbScuLi8uLi9ob29rcy91c2Utb3duZXIuanMnO2ltcG9ydHt1c2VSZXNvbHZlQnV0dG9uVHlwZSBhcyBJZX1mcm9tJy4uLy4uL2hvb2tzL3VzZS1yZXNvbHZlLWJ1dHRvbi10eXBlLmpzJztpbXBvcnR7dXNlU2Nyb2xsTG9jayBhcyBTZX1mcm9tJy4uLy4uL2hvb2tzL3VzZS1zY3JvbGwtbG9jay5qcyc7aW1wb3J0e3VzZVN5bmNSZWZzIGFzIEt9ZnJvbScuLi8uLi9ob29rcy91c2Utc3luYy1yZWZzLmpzJztpbXBvcnR7dXNlVGV4dFZhbHVlIGFzIERlfWZyb20nLi4vLi4vaG9va3MvdXNlLXRleHQtdmFsdWUuanMnO2ltcG9ydHt1c2VUcmFja2VkUG9pbnRlciBhcyBSZX1mcm9tJy4uLy4uL2hvb2tzL3VzZS10cmFja2VkLXBvaW50ZXIuanMnO2ltcG9ydHt0cmFuc2l0aW9uRGF0YUF0dHJpYnV0ZXMgYXMgRmUsdXNlVHJhbnNpdGlvbiBhcyB4ZX1mcm9tJy4uLy4uL2hvb2tzL3VzZS10cmFuc2l0aW9uLmpzJztpbXBvcnR7dXNlVHJlZVdhbGtlciBhcyBoZX1mcm9tJy4uLy4uL2hvb2tzL3VzZS10cmVlLXdhbGtlci5qcyc7aW1wb3J0e0Zsb2F0aW5nUHJvdmlkZXIgYXMgQ2UsdXNlRmxvYXRpbmdQYW5lbCBhcyB2ZSx1c2VGbG9hdGluZ1BhbmVsUHJvcHMgYXMgTGUsdXNlRmxvYXRpbmdSZWZlcmVuY2UgYXMgT2UsdXNlRmxvYXRpbmdSZWZlcmVuY2VQcm9wcyBhcyBIZSx1c2VSZXNvbHZlZEFuY2hvciBhcyBVZX1mcm9tJy4uLy4uL2ludGVybmFsL2Zsb2F0aW5nLmpzJztpbXBvcnR7T3BlbkNsb3NlZFByb3ZpZGVyIGFzIEdlLFN0YXRlIGFzIFcsdXNlT3BlbkNsb3NlZCBhcyBOZX1mcm9tJy4uLy4uL2ludGVybmFsL29wZW4tY2xvc2VkLmpzJztpbXBvcnR7dXNlU2xpY2UgYXMgRH1mcm9tJy4uLy4uL3JlYWN0LWdsdWUuanMnO2ltcG9ydHtpc0Rpc2FibGVkUmVhY3RJc3N1ZTc3MTEgYXMgQmV9ZnJvbScuLi8uLi91dGlscy9idWdzLmpzJztpbXBvcnR7Rm9jdXMgYXMgYn1mcm9tJy4uLy4uL3V0aWxzL2NhbGN1bGF0ZS1hY3RpdmUtaW5kZXguanMnO2ltcG9ydHtkaXNwb3NhYmxlcyBhcyB3ZX1mcm9tJy4uLy4uL3V0aWxzL2Rpc3Bvc2FibGVzLmpzJztpbXBvcnR7Rm9jdXMgYXMgZWUsRm9jdXNhYmxlTW9kZSBhcyBrZSxmb2N1c0Zyb20gYXMgS2UsaXNGb2N1c2FibGVFbGVtZW50IGFzIFdlLHJlc3RvcmVGb2N1c0lmTmVjZXNzYXJ5IGFzIHRlfWZyb20nLi4vLi4vdXRpbHMvZm9jdXMtbWFuYWdlbWVudC5qcyc7aW1wb3J0e21hdGNoIGFzIEplfWZyb20nLi4vLi4vdXRpbHMvbWF0Y2guanMnO2ltcG9ydHtSZW5kZXJGZWF0dXJlcyBhcyBvZSxmb3J3YXJkUmVmV2l0aEFzIGFzIEMsbWVyZ2VQcm9wcyBhcyBuZSx1c2VSZW5kZXIgYXMgdn1mcm9tJy4uLy4uL3V0aWxzL3JlbmRlci5qcyc7aW1wb3J0e3VzZURlc2NyaXB0aW9ucyBhcyBWZX1mcm9tJy4uL2Rlc2NyaXB0aW9uL2Rlc2NyaXB0aW9uLmpzJztpbXBvcnR7S2V5cyBhcyBkfWZyb20nLi4va2V5Ym9hcmQuanMnO2ltcG9ydHt1c2VMYWJlbENvbnRleHQgYXMgWGUsdXNlTGFiZWxzIGFzIHJlfWZyb20nLi4vbGFiZWwvbGFiZWwuanMnO2ltcG9ydHtQb3J0YWwgYXMgJGV9ZnJvbScuLi9wb3J0YWwvcG9ydGFsLmpzJztpbXBvcnR7QWN0aW9uVHlwZXMgYXMgcixBY3RpdmF0aW9uVHJpZ2dlciBhcyAkLE1lbnVTdGF0ZSBhcyBtfWZyb20nLi9tZW51LW1hY2hpbmUuanMnO2ltcG9ydHtNZW51Q29udGV4dCBhcyBqZSx1c2VNZW51TWFjaGluZSBhcyBxZSx1c2VNZW51TWFjaGluZUNvbnRleHQgYXMgan1mcm9tJy4vbWVudS1tYWNoaW5lLWdsdWUuanMnO2xldCB6ZT1ZO2Z1bmN0aW9uIFFlKFQsRSl7bGV0e19fZGVtb01vZGU6aT0hMSwuLi5hfT1ULG49cWUoe19fZGVtb01vZGU6aX0pLFtzLG8sUF09RChuLHA9PltwLm1lbnVTdGF0ZSxwLml0ZW1zRWxlbWVudCxwLmJ1dHRvbkVsZW1lbnRdKSxjPUsoRSksXz1zPT09bS5PcGVuO19lKF8sW1Asb10sKHAsRik9Pnt2YXIgQTtuLnNlbmQoe3R5cGU6ci5DbG9zZU1lbnV9KSxXZShGLGtlLkxvb3NlKXx8KHAucHJldmVudERlZmF1bHQoKSwoQT1uLnN0YXRlLmJ1dHRvbkVsZW1lbnQpPT1udWxsfHxBLmZvY3VzKCkpfSk7bGV0IHQ9eSgoKT0+e24uc2VuZCh7dHlwZTpyLkNsb3NlTWVudX0pfSksUj1CKCgpPT4oe29wZW46cz09PW0uT3BlbixjbG9zZTp0fSksW3MsdF0pLEk9e3JlZjpjfSxnPXYoKTtyZXR1cm4gaC5jcmVhdGVFbGVtZW50KENlLG51bGwsaC5jcmVhdGVFbGVtZW50KGplLlByb3ZpZGVyLHt2YWx1ZTpufSxoLmNyZWF0ZUVsZW1lbnQoR2Use3ZhbHVlOkplKHMse1ttLk9wZW5dOlcuT3BlbixbbS5DbG9zZWRdOlcuQ2xvc2VkfSl9LGcoe291clByb3BzOkksdGhlaXJQcm9wczphLHNsb3Q6UixkZWZhdWx0VGFnOnplLG5hbWU6XCJNZW51XCJ9KSkpKX1sZXQgWWU9XCJidXR0b25cIjtmdW5jdGlvbiBaZShULEUpe2xldCBpPWooXCJNZW51LkJ1dHRvblwiKSxhPXcoKSx7aWQ6bj1gaGVhZGxlc3N1aS1tZW51LWJ1dHRvbi0ke2F9YCxkaXNhYmxlZDpzPSExLGF1dG9Gb2N1czpvPSExLC4uLlB9PVQsYz1WKG51bGwpLF89SGUoKSx0PUsoRSxjLE9lKCkseShsPT5pLnNlbmQoe3R5cGU6ci5TZXRCdXR0b25FbGVtZW50LGVsZW1lbnQ6bH0pKSksUj15KGw9Pntzd2l0Y2gobC5rZXkpe2Nhc2UgZC5TcGFjZTpjYXNlIGQuRW50ZXI6Y2FzZSBkLkFycm93RG93bjpsLnByZXZlbnREZWZhdWx0KCksbC5zdG9wUHJvcGFnYXRpb24oKSxpLnNlbmQoe3R5cGU6ci5PcGVuTWVudSxmb2N1czp7Zm9jdXM6Yi5GaXJzdH19KTticmVhaztjYXNlIGQuQXJyb3dVcDpsLnByZXZlbnREZWZhdWx0KCksbC5zdG9wUHJvcGFnYXRpb24oKSxpLnNlbmQoe3R5cGU6ci5PcGVuTWVudSxmb2N1czp7Zm9jdXM6Yi5MYXN0fX0pO2JyZWFrfX0pLEk9eShsPT57c3dpdGNoKGwua2V5KXtjYXNlIGQuU3BhY2U6bC5wcmV2ZW50RGVmYXVsdCgpO2JyZWFrfX0pLFtnLHBdPUQoaSxsPT5bbC5tZW51U3RhdGUsbC5pdGVtc0VsZW1lbnRdKSxGPXkobD0+e3ZhciBIO2lmKGwuYnV0dG9uPT09MCl7aWYoQmUobC5jdXJyZW50VGFyZ2V0KSlyZXR1cm4gbC5wcmV2ZW50RGVmYXVsdCgpO3N8fChnPT09bS5PcGVuPyhYKCgpPT5pLnNlbmQoe3R5cGU6ci5DbG9zZU1lbnV9KSksKEg9Yy5jdXJyZW50KT09bnVsbHx8SC5mb2N1cyh7cHJldmVudFNjcm9sbDohMH0pKToobC5wcmV2ZW50RGVmYXVsdCgpLGkuc2VuZCh7dHlwZTpyLk9wZW5NZW51LGZvY3VzOntmb2N1czpiLk5vdGhpbmd9LHRyaWdnZXI6JC5Qb2ludGVyfSkpKX19KSx7aXNGb2N1c1Zpc2libGU6QSxmb2N1c1Byb3BzOmZ9PW1lKHthdXRvRm9jdXM6b30pLHtpc0hvdmVyZWQ6TSxob3ZlclByb3BzOkx9PVRlKHtpc0Rpc2FibGVkOnN9KSx7cHJlc3NlZDpTLHByZXNzUHJvcHM6T309RWUoe2Rpc2FibGVkOnN9KSx4PUIoKCk9Pih7b3BlbjpnPT09bS5PcGVuLGFjdGl2ZTpTfHxnPT09bS5PcGVuLGRpc2FibGVkOnMsaG92ZXI6TSxmb2N1czpBLGF1dG9mb2N1czpvfSksW2csTSxBLFMscyxvXSksVT1uZShfKCkse3JlZjp0LGlkOm4sdHlwZTpJZShULGMuY3VycmVudCksXCJhcmlhLWhhc3BvcHVwXCI6XCJtZW51XCIsXCJhcmlhLWNvbnRyb2xzXCI6cD09bnVsbD92b2lkIDA6cC5pZCxcImFyaWEtZXhwYW5kZWRcIjpnPT09bS5PcGVuLGRpc2FibGVkOnN8fHZvaWQgMCxhdXRvRm9jdXM6byxvbktleURvd246UixvbktleVVwOkksb25Nb3VzZURvd246Rn0sZixMLE8pO3JldHVybiB2KCkoe291clByb3BzOlUsdGhlaXJQcm9wczpQLHNsb3Q6eCxkZWZhdWx0VGFnOlllLG5hbWU6XCJNZW51LkJ1dHRvblwifSl9bGV0IGV0PVwiZGl2XCIsdHQ9b2UuUmVuZGVyU3RyYXRlZ3l8b2UuU3RhdGljO2Z1bmN0aW9uIG90KFQsRSl7bGV0IGk9dygpLHtpZDphPWBoZWFkbGVzc3VpLW1lbnUtaXRlbXMtJHtpfWAsYW5jaG9yOm4scG9ydGFsOnM9ITEsbW9kYWw6bz0hMCx0cmFuc2l0aW9uOlA9ITEsLi4uY309VCxfPVVlKG4pLHQ9aihcIk1lbnUuSXRlbXNcIiksW1IsSV09dmUoXyksZz1MZSgpLFtwLEZdPXllKG51bGwpLEE9SyhFLF8/UjpudWxsLHkoZT0+dC5zZW5kKHt0eXBlOnIuU2V0SXRlbXNFbGVtZW50LGVsZW1lbnQ6ZX0pKSxGKSxbZixNXT1EKHQsZT0+W2UubWVudVN0YXRlLGUuYnV0dG9uRWxlbWVudF0pLEw9WihNKSxTPVoocCk7XyYmKHM9ITApO2xldCBPPU5lKCksW3gsVV09eGUoUCxwLE8hPT1udWxsPyhPJlcuT3Blbik9PT1XLk9wZW46Zj09PW0uT3Blbik7QWUoeCxNLCgpPT57dC5zZW5kKHt0eXBlOnIuQ2xvc2VNZW51fSl9KTtsZXQgRz1EKHQsZT0+ZS5fX2RlbW9Nb2RlKSxsPUc/ITE6byYmZj09PW0uT3BlbjtTZShsLFMpO2xldCBIPUc/ITE6byYmZj09PW0uT3BlbjtiZShILHthbGxvd2VkOmZlKCgpPT5bTSxwXSxbTSxwXSl9KTtsZXQgdT1mIT09bS5PcGVuLGFlPVBlKHUsTSk/ITE6eDtjZSgoKT0+e2xldCBlPXA7ZSYmZj09PW0uT3BlbiYmZSE9PShTPT1udWxsP3ZvaWQgMDpTLmFjdGl2ZUVsZW1lbnQpJiZlLmZvY3VzKHtwcmV2ZW50U2Nyb2xsOiEwfSl9LFtmLHAsU10pLGhlKGY9PT1tLk9wZW4se2NvbnRhaW5lcjpwLGFjY2VwdChlKXtyZXR1cm4gZS5nZXRBdHRyaWJ1dGUoXCJyb2xlXCIpPT09XCJtZW51aXRlbVwiP05vZGVGaWx0ZXIuRklMVEVSX1JFSkVDVDplLmhhc0F0dHJpYnV0ZShcInJvbGVcIik/Tm9kZUZpbHRlci5GSUxURVJfU0tJUDpOb2RlRmlsdGVyLkZJTFRFUl9BQ0NFUFR9LHdhbGsoZSl7ZS5zZXRBdHRyaWJ1dGUoXCJyb2xlXCIsXCJub25lXCIpfX0pO2xldCBxPWdlKCksc2U9eShlPT57dmFyIE4seixRO3N3aXRjaChxLmRpc3Bvc2UoKSxlLmtleSl7Y2FzZSBkLlNwYWNlOmlmKHQuc3RhdGUuc2VhcmNoUXVlcnkhPT1cIlwiKXJldHVybiBlLnByZXZlbnREZWZhdWx0KCksZS5zdG9wUHJvcGFnYXRpb24oKSx0LnNlbmQoe3R5cGU6ci5TZWFyY2gsdmFsdWU6ZS5rZXl9KTtjYXNlIGQuRW50ZXI6aWYoZS5wcmV2ZW50RGVmYXVsdCgpLGUuc3RvcFByb3BhZ2F0aW9uKCksdC5zdGF0ZS5hY3RpdmVJdGVtSW5kZXghPT1udWxsKXtsZXR7ZGF0YVJlZjpkZX09dC5zdGF0ZS5pdGVtc1t0LnN0YXRlLmFjdGl2ZUl0ZW1JbmRleF07KHo9KE49ZGUuY3VycmVudCk9PW51bGw/dm9pZCAwOk4uZG9tUmVmLmN1cnJlbnQpPT1udWxsfHx6LmNsaWNrKCl9dC5zZW5kKHt0eXBlOnIuQ2xvc2VNZW51fSksdGUodC5zdGF0ZS5idXR0b25FbGVtZW50KTticmVhaztjYXNlIGQuQXJyb3dEb3duOnJldHVybiBlLnByZXZlbnREZWZhdWx0KCksZS5zdG9wUHJvcGFnYXRpb24oKSx0LnNlbmQoe3R5cGU6ci5Hb1RvSXRlbSxmb2N1czpiLk5leHR9KTtjYXNlIGQuQXJyb3dVcDpyZXR1cm4gZS5wcmV2ZW50RGVmYXVsdCgpLGUuc3RvcFByb3BhZ2F0aW9uKCksdC5zZW5kKHt0eXBlOnIuR29Ub0l0ZW0sZm9jdXM6Yi5QcmV2aW91c30pO2Nhc2UgZC5Ib21lOmNhc2UgZC5QYWdlVXA6cmV0dXJuIGUucHJldmVudERlZmF1bHQoKSxlLnN0b3BQcm9wYWdhdGlvbigpLHQuc2VuZCh7dHlwZTpyLkdvVG9JdGVtLGZvY3VzOmIuRmlyc3R9KTtjYXNlIGQuRW5kOmNhc2UgZC5QYWdlRG93bjpyZXR1cm4gZS5wcmV2ZW50RGVmYXVsdCgpLGUuc3RvcFByb3BhZ2F0aW9uKCksdC5zZW5kKHt0eXBlOnIuR29Ub0l0ZW0sZm9jdXM6Yi5MYXN0fSk7Y2FzZSBkLkVzY2FwZTplLnByZXZlbnREZWZhdWx0KCksZS5zdG9wUHJvcGFnYXRpb24oKSxYKCgpPT50LnNlbmQoe3R5cGU6ci5DbG9zZU1lbnV9KSksKFE9dC5zdGF0ZS5idXR0b25FbGVtZW50KT09bnVsbHx8US5mb2N1cyh7cHJldmVudFNjcm9sbDohMH0pO2JyZWFrO2Nhc2UgZC5UYWI6ZS5wcmV2ZW50RGVmYXVsdCgpLGUuc3RvcFByb3BhZ2F0aW9uKCksWCgoKT0+dC5zZW5kKHt0eXBlOnIuQ2xvc2VNZW51fSkpLEtlKHQuc3RhdGUuYnV0dG9uRWxlbWVudCxlLnNoaWZ0S2V5P2VlLlByZXZpb3VzOmVlLk5leHQpO2JyZWFrO2RlZmF1bHQ6ZS5rZXkubGVuZ3RoPT09MSYmKHQuc2VuZCh7dHlwZTpyLlNlYXJjaCx2YWx1ZTplLmtleX0pLHEuc2V0VGltZW91dCgoKT0+dC5zZW5kKHt0eXBlOnIuQ2xlYXJTZWFyY2h9KSwzNTApKTticmVha319KSxsZT15KGU9Pntzd2l0Y2goZS5rZXkpe2Nhc2UgZC5TcGFjZTplLnByZXZlbnREZWZhdWx0KCk7YnJlYWt9fSkscGU9QigoKT0+KHtvcGVuOmY9PT1tLk9wZW59KSxbZl0pLGllPW5lKF8/ZygpOnt9LHtcImFyaWEtYWN0aXZlZGVzY2VuZGFudFwiOkQodCx0LnNlbGVjdG9ycy5hY3RpdmVEZXNjZW5kYW50SWQpLFwiYXJpYS1sYWJlbGxlZGJ5XCI6RCh0LGU9Pnt2YXIgTjtyZXR1cm4oTj1lLmJ1dHRvbkVsZW1lbnQpPT1udWxsP3ZvaWQgMDpOLmlkfSksaWQ6YSxvbktleURvd246c2Usb25LZXlVcDpsZSxyb2xlOlwibWVudVwiLHRhYkluZGV4OmY9PT1tLk9wZW4/MDp2b2lkIDAscmVmOkEsc3R5bGU6ey4uLmMuc3R5bGUsLi4uSSxcIi0tYnV0dG9uLXdpZHRoXCI6TWUoTSwhMCkud2lkdGh9LC4uLkZlKFUpfSksdWU9digpO3JldHVybiBoLmNyZWF0ZUVsZW1lbnQoJGUse2VuYWJsZWQ6cz9ULnN0YXRpY3x8eDohMSxvd25lckRvY3VtZW50Okx9LHVlKHtvdXJQcm9wczppZSx0aGVpclByb3BzOmMsc2xvdDpwZSxkZWZhdWx0VGFnOmV0LGZlYXR1cmVzOnR0LHZpc2libGU6YWUsbmFtZTpcIk1lbnUuSXRlbXNcIn0pKX1sZXQgbnQ9WTtmdW5jdGlvbiBydChULEUpe2xldCBpPXcoKSx7aWQ6YT1gaGVhZGxlc3N1aS1tZW51LWl0ZW0tJHtpfWAsZGlzYWJsZWQ6bj0hMSwuLi5zfT1ULG89aihcIk1lbnUuSXRlbVwiKSxQPUQobyx1PT5vLnNlbGVjdG9ycy5pc0FjdGl2ZSh1LGEpKSxjPVYobnVsbCksXz1LKEUsYyksdD1EKG8sdT0+by5zZWxlY3RvcnMuc2hvdWxkU2Nyb2xsSW50b1ZpZXcodSxhKSk7aygoKT0+e2lmKHQpcmV0dXJuIHdlKCkucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpPT57dmFyIHUsSjsoSj0odT1jLmN1cnJlbnQpPT1udWxsP3ZvaWQgMDp1LnNjcm9sbEludG9WaWV3KT09bnVsbHx8Si5jYWxsKHUse2Jsb2NrOlwibmVhcmVzdFwifSl9KX0sW3QsY10pO2xldCBSPURlKGMpLEk9Vih7ZGlzYWJsZWQ6bixkb21SZWY6YyxnZXQgdGV4dFZhbHVlKCl7cmV0dXJuIFIoKX19KTtrKCgpPT57SS5jdXJyZW50LmRpc2FibGVkPW59LFtJLG5dKSxrKCgpPT4oby5hY3Rpb25zLnJlZ2lzdGVySXRlbShhLEkpLCgpPT5vLmFjdGlvbnMudW5yZWdpc3Rlckl0ZW0oYSkpLFtJLGFdKTtsZXQgZz15KCgpPT57by5zZW5kKHt0eXBlOnIuQ2xvc2VNZW51fSl9KSxwPXkodT0+e2lmKG4pcmV0dXJuIHUucHJldmVudERlZmF1bHQoKTtvLnNlbmQoe3R5cGU6ci5DbG9zZU1lbnV9KSx0ZShvLnN0YXRlLmJ1dHRvbkVsZW1lbnQpfSksRj15KCgpPT57aWYobilyZXR1cm4gby5zZW5kKHt0eXBlOnIuR29Ub0l0ZW0sZm9jdXM6Yi5Ob3RoaW5nfSk7by5zZW5kKHt0eXBlOnIuR29Ub0l0ZW0sZm9jdXM6Yi5TcGVjaWZpYyxpZDphfSl9KSxBPVJlKCksZj15KHU9PntBLnVwZGF0ZSh1KSwhbiYmKFB8fG8uc2VuZCh7dHlwZTpyLkdvVG9JdGVtLGZvY3VzOmIuU3BlY2lmaWMsaWQ6YSx0cmlnZ2VyOiQuUG9pbnRlcn0pKX0pLE09eSh1PT57QS53YXNNb3ZlZCh1KSYmKG58fFB8fG8uc2VuZCh7dHlwZTpyLkdvVG9JdGVtLGZvY3VzOmIuU3BlY2lmaWMsaWQ6YSx0cmlnZ2VyOiQuUG9pbnRlcn0pKX0pLEw9eSh1PT57QS53YXNNb3ZlZCh1KSYmKG58fFAmJm8uc2VuZCh7dHlwZTpyLkdvVG9JdGVtLGZvY3VzOmIuTm90aGluZ30pKX0pLFtTLE9dPXJlKCksW3gsVV09VmUoKSxHPUIoKCk9Pih7YWN0aXZlOlAsZm9jdXM6UCxkaXNhYmxlZDpuLGNsb3NlOmd9KSxbUCxuLGddKSxsPXtpZDphLHJlZjpfLHJvbGU6XCJtZW51aXRlbVwiLHRhYkluZGV4Om49PT0hMD92b2lkIDA6LTEsXCJhcmlhLWRpc2FibGVkXCI6bj09PSEwPyEwOnZvaWQgMCxcImFyaWEtbGFiZWxsZWRieVwiOlMsXCJhcmlhLWRlc2NyaWJlZGJ5XCI6eCxkaXNhYmxlZDp2b2lkIDAsb25DbGljazpwLG9uRm9jdXM6RixvblBvaW50ZXJFbnRlcjpmLG9uTW91c2VFbnRlcjpmLG9uUG9pbnRlck1vdmU6TSxvbk1vdXNlTW92ZTpNLG9uUG9pbnRlckxlYXZlOkwsb25Nb3VzZUxlYXZlOkx9LEg9digpO3JldHVybiBoLmNyZWF0ZUVsZW1lbnQoTyxudWxsLGguY3JlYXRlRWxlbWVudChVLG51bGwsSCh7b3VyUHJvcHM6bCx0aGVpclByb3BzOnMsc2xvdDpHLGRlZmF1bHRUYWc6bnQsbmFtZTpcIk1lbnUuSXRlbVwifSkpKX1sZXQgYXQ9XCJkaXZcIjtmdW5jdGlvbiBzdChULEUpe2xldFtpLGFdPXJlKCksbj1ULHM9e3JlZjpFLFwiYXJpYS1sYWJlbGxlZGJ5XCI6aSxyb2xlOlwiZ3JvdXBcIn0sbz12KCk7cmV0dXJuIGguY3JlYXRlRWxlbWVudChhLG51bGwsbyh7b3VyUHJvcHM6cyx0aGVpclByb3BzOm4sc2xvdDp7fSxkZWZhdWx0VGFnOmF0LG5hbWU6XCJNZW51LlNlY3Rpb25cIn0pKX1sZXQgbHQ9XCJoZWFkZXJcIjtmdW5jdGlvbiBwdChULEUpe2xldCBpPXcoKSx7aWQ6YT1gaGVhZGxlc3N1aS1tZW51LWhlYWRpbmctJHtpfWAsLi4ubn09VCxzPVhlKCk7aygoKT0+cy5yZWdpc3RlcihhKSxbYSxzLnJlZ2lzdGVyXSk7bGV0IG89e2lkOmEscmVmOkUscm9sZTpcInByZXNlbnRhdGlvblwiLC4uLnMucHJvcHN9O3JldHVybiB2KCkoe291clByb3BzOm8sdGhlaXJQcm9wczpuLHNsb3Q6e30sZGVmYXVsdFRhZzpsdCxuYW1lOlwiTWVudS5IZWFkaW5nXCJ9KX1sZXQgaXQ9XCJkaXZcIjtmdW5jdGlvbiB1dChULEUpe2xldCBpPVQsYT17cmVmOkUscm9sZTpcInNlcGFyYXRvclwifTtyZXR1cm4gdigpKHtvdXJQcm9wczphLHRoZWlyUHJvcHM6aSxzbG90Ont9LGRlZmF1bHRUYWc6aXQsbmFtZTpcIk1lbnUuU2VwYXJhdG9yXCJ9KX1sZXQgZHQ9QyhRZSksbXQ9QyhaZSksVHQ9QyhvdCksZnQ9QyhydCksY3Q9QyhzdCkseXQ9QyhwdCksRXQ9Qyh1dCksdG89T2JqZWN0LmFzc2lnbihkdCx7QnV0dG9uOm10LEl0ZW1zOlR0LEl0ZW06ZnQsU2VjdGlvbjpjdCxIZWFkaW5nOnl0LFNlcGFyYXRvcjpFdH0pO2V4cG9ydHt0byBhcyBNZW51LG10IGFzIE1lbnVCdXR0b24seXQgYXMgTWVudUhlYWRpbmcsZnQgYXMgTWVudUl0ZW0sVHQgYXMgTWVudUl0ZW1zLGN0IGFzIE1lbnVTZWN0aW9uLEV0IGFzIE1lbnVTZXBhcmF0b3J9O1xuIl0sIm5hbWVzIjpbInVzZUZvY3VzUmluZyIsIm1lIiwidXNlSG92ZXIiLCJUZSIsImgiLCJGcmFnbWVudCIsIlkiLCJ1c2VDYWxsYmFjayIsImZlIiwidXNlRWZmZWN0IiwiY2UiLCJ1c2VNZW1vIiwiQiIsInVzZVJlZiIsIlYiLCJ1c2VTdGF0ZSIsInllIiwiZmx1c2hTeW5jIiwiWCIsInVzZUFjdGl2ZVByZXNzIiwiRWUiLCJ1c2VEaWRFbGVtZW50TW92ZSIsIlBlIiwidXNlRGlzcG9zYWJsZXMiLCJnZSIsInVzZUVsZW1lbnRTaXplIiwiTWUiLCJ1c2VFdmVudCIsInkiLCJ1c2VJZCIsInciLCJ1c2VJbmVydE90aGVycyIsImJlIiwidXNlSXNvTW9ycGhpY0VmZmVjdCIsImsiLCJ1c2VPbkRpc2FwcGVhciIsIkFlIiwidXNlT3V0c2lkZUNsaWNrIiwiX2UiLCJ1c2VPd25lckRvY3VtZW50IiwiWiIsInVzZVJlc29sdmVCdXR0b25UeXBlIiwiSWUiLCJ1c2VTY3JvbGxMb2NrIiwiU2UiLCJ1c2VTeW5jUmVmcyIsIksiLCJ1c2VUZXh0VmFsdWUiLCJEZSIsInVzZVRyYWNrZWRQb2ludGVyIiwiUmUiLCJ0cmFuc2l0aW9uRGF0YUF0dHJpYnV0ZXMiLCJGZSIsInVzZVRyYW5zaXRpb24iLCJ4ZSIsInVzZVRyZWVXYWxrZXIiLCJoZSIsIkZsb2F0aW5nUHJvdmlkZXIiLCJDZSIsInVzZUZsb2F0aW5nUGFuZWwiLCJ2ZSIsInVzZUZsb2F0aW5nUGFuZWxQcm9wcyIsIkxlIiwidXNlRmxvYXRpbmdSZWZlcmVuY2UiLCJPZSIsInVzZUZsb2F0aW5nUmVmZXJlbmNlUHJvcHMiLCJIZSIsInVzZVJlc29sdmVkQW5jaG9yIiwiVWUiLCJPcGVuQ2xvc2VkUHJvdmlkZXIiLCJHZSIsIlN0YXRlIiwiVyIsInVzZU9wZW5DbG9zZWQiLCJOZSIsInVzZVNsaWNlIiwiRCIsImlzRGlzYWJsZWRSZWFjdElzc3VlNzcxMSIsIkJlIiwiRm9jdXMiLCJiIiwiZGlzcG9zYWJsZXMiLCJ3ZSIsImVlIiwiRm9jdXNhYmxlTW9kZSIsImtlIiwiZm9jdXNGcm9tIiwiS2UiLCJpc0ZvY3VzYWJsZUVsZW1lbnQiLCJXZSIsInJlc3RvcmVGb2N1c0lmTmVjZXNzYXJ5IiwidGUiLCJtYXRjaCIsIkplIiwiUmVuZGVyRmVhdHVyZXMiLCJvZSIsImZvcndhcmRSZWZXaXRoQXMiLCJDIiwibWVyZ2VQcm9wcyIsIm5lIiwidXNlUmVuZGVyIiwidiIsInVzZURlc2NyaXB0aW9ucyIsIlZlIiwiS2V5cyIsImQiLCJ1c2VMYWJlbENvbnRleHQiLCJYZSIsInVzZUxhYmVscyIsInJlIiwiUG9ydGFsIiwiJGUiLCJBY3Rpb25UeXBlcyIsInIiLCJBY3RpdmF0aW9uVHJpZ2dlciIsIiQiLCJNZW51U3RhdGUiLCJtIiwiTWVudUNvbnRleHQiLCJqZSIsInVzZU1lbnVNYWNoaW5lIiwicWUiLCJ1c2VNZW51TWFjaGluZUNvbnRleHQiLCJqIiwiemUiLCJRZSIsIlQiLCJFIiwiX19kZW1vTW9kZSIsImkiLCJhIiwibiIsInMiLCJvIiwiUCIsInAiLCJtZW51U3RhdGUiLCJpdGVtc0VsZW1lbnQiLCJidXR0b25FbGVtZW50IiwiYyIsIl8iLCJPcGVuIiwiRiIsIkEiLCJzZW5kIiwidHlwZSIsIkNsb3NlTWVudSIsIkxvb3NlIiwicHJldmVudERlZmF1bHQiLCJzdGF0ZSIsImZvY3VzIiwidCIsIlIiLCJvcGVuIiwiY2xvc2UiLCJJIiwicmVmIiwiZyIsImNyZWF0ZUVsZW1lbnQiLCJQcm92aWRlciIsInZhbHVlIiwiQ2xvc2VkIiwib3VyUHJvcHMiLCJ0aGVpclByb3BzIiwic2xvdCIsImRlZmF1bHRUYWciLCJuYW1lIiwiWWUiLCJaZSIsImlkIiwiZGlzYWJsZWQiLCJhdXRvRm9jdXMiLCJsIiwiU2V0QnV0dG9uRWxlbWVudCIsImVsZW1lbnQiLCJrZXkiLCJTcGFjZSIsIkVudGVyIiwiQXJyb3dEb3duIiwic3RvcFByb3BhZ2F0aW9uIiwiT3Blbk1lbnUiLCJGaXJzdCIsIkFycm93VXAiLCJMYXN0IiwiSCIsImJ1dHRvbiIsImN1cnJlbnRUYXJnZXQiLCJjdXJyZW50IiwicHJldmVudFNjcm9sbCIsIk5vdGhpbmciLCJ0cmlnZ2VyIiwiUG9pbnRlciIsImlzRm9jdXNWaXNpYmxlIiwiZm9jdXNQcm9wcyIsImYiLCJpc0hvdmVyZWQiLCJNIiwiaG92ZXJQcm9wcyIsIkwiLCJpc0Rpc2FibGVkIiwicHJlc3NlZCIsIlMiLCJwcmVzc1Byb3BzIiwiTyIsIngiLCJhY3RpdmUiLCJob3ZlciIsImF1dG9mb2N1cyIsIlUiLCJvbktleURvd24iLCJvbktleVVwIiwib25Nb3VzZURvd24iLCJldCIsInR0IiwiUmVuZGVyU3RyYXRlZ3kiLCJTdGF0aWMiLCJvdCIsImFuY2hvciIsInBvcnRhbCIsIm1vZGFsIiwidHJhbnNpdGlvbiIsImUiLCJTZXRJdGVtc0VsZW1lbnQiLCJHIiwiYWxsb3dlZCIsInUiLCJhZSIsImFjdGl2ZUVsZW1lbnQiLCJjb250YWluZXIiLCJhY2NlcHQiLCJnZXRBdHRyaWJ1dGUiLCJOb2RlRmlsdGVyIiwiRklMVEVSX1JFSkVDVCIsImhhc0F0dHJpYnV0ZSIsIkZJTFRFUl9TS0lQIiwiRklMVEVSX0FDQ0VQVCIsIndhbGsiLCJzZXRBdHRyaWJ1dGUiLCJxIiwic2UiLCJOIiwieiIsIlEiLCJkaXNwb3NlIiwic2VhcmNoUXVlcnkiLCJTZWFyY2giLCJhY3RpdmVJdGVtSW5kZXgiLCJkYXRhUmVmIiwiZGUiLCJpdGVtcyIsImRvbVJlZiIsImNsaWNrIiwiR29Ub0l0ZW0iLCJOZXh0IiwiUHJldmlvdXMiLCJIb21lIiwiUGFnZVVwIiwiRW5kIiwiUGFnZURvd24iLCJFc2NhcGUiLCJUYWIiLCJzaGlmdEtleSIsImxlbmd0aCIsInNldFRpbWVvdXQiLCJDbGVhclNlYXJjaCIsImxlIiwicGUiLCJpZSIsInNlbGVjdG9ycyIsImFjdGl2ZURlc2NlbmRhbnRJZCIsInJvbGUiLCJ0YWJJbmRleCIsInN0eWxlIiwid2lkdGgiLCJ1ZSIsImVuYWJsZWQiLCJzdGF0aWMiLCJvd25lckRvY3VtZW50IiwiZmVhdHVyZXMiLCJ2aXNpYmxlIiwibnQiLCJydCIsImlzQWN0aXZlIiwic2hvdWxkU2Nyb2xsSW50b1ZpZXciLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJKIiwic2Nyb2xsSW50b1ZpZXciLCJjYWxsIiwiYmxvY2siLCJ0ZXh0VmFsdWUiLCJhY3Rpb25zIiwicmVnaXN0ZXJJdGVtIiwidW5yZWdpc3Rlckl0ZW0iLCJTcGVjaWZpYyIsInVwZGF0ZSIsIndhc01vdmVkIiwib25DbGljayIsIm9uRm9jdXMiLCJvblBvaW50ZXJFbnRlciIsIm9uTW91c2VFbnRlciIsIm9uUG9pbnRlck1vdmUiLCJvbk1vdXNlTW92ZSIsIm9uUG9pbnRlckxlYXZlIiwib25Nb3VzZUxlYXZlIiwiYXQiLCJzdCIsImx0IiwicHQiLCJyZWdpc3RlciIsInByb3BzIiwiaXQiLCJ1dCIsImR0IiwibXQiLCJUdCIsImZ0IiwiY3QiLCJ5dCIsIkV0IiwidG8iLCJPYmplY3QiLCJhc3NpZ24iLCJCdXR0b24iLCJJdGVtcyIsIkl0ZW0iLCJTZWN0aW9uIiwiSGVhZGluZyIsIlNlcGFyYXRvciIsIk1lbnUiLCJNZW51QnV0dG9uIiwiTWVudUhlYWRpbmciLCJNZW51SXRlbSIsIk1lbnVJdGVtcyIsIk1lbnVTZWN0aW9uIiwiTWVudVNlcGFyYXRvciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../../../node_modules/@headlessui/react/dist/components/menu/menu.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../../../node_modules/@headlessui/react/dist/hooks/use-active-press.js":
/*!*********************************************************************************!*\
  !*** ../../../../node_modules/@headlessui/react/dist/hooks/use-active-press.js ***!
  \*********************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useActivePress: function() { return /* binding */ w; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var _utils_owner_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/owner.js */ \"(app-pages-browser)/../../../../node_modules/@headlessui/react/dist/utils/owner.js\");\n/* harmony import */ var _use_disposables_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./use-disposables.js */ \"(app-pages-browser)/../../../../node_modules/@headlessui/react/dist/hooks/use-disposables.js\");\n/* harmony import */ var _use_event_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./use-event.js */ \"(app-pages-browser)/../../../../node_modules/@headlessui/react/dist/hooks/use-event.js\");\n\n\n\n\nfunction E(e) {\n    let t = e.width / 2, n = e.height / 2;\n    return {\n        top: e.clientY - n,\n        right: e.clientX + t,\n        bottom: e.clientY + n,\n        left: e.clientX - t\n    };\n}\n_c = E;\nfunction P(e, t) {\n    return !(!e || !t || e.right < t.left || e.left > t.right || e.bottom < t.top || e.top > t.bottom);\n}\n_c1 = P;\nfunction w() {\n    let { disabled: e = !1 } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n    let t = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null), [n, l] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(!1), r = (0,_use_disposables_js__WEBPACK_IMPORTED_MODULE_1__.useDisposables)(), o = (0,_use_event_js__WEBPACK_IMPORTED_MODULE_2__.useEvent)(()=>{\n        t.current = null, l(!1), r.dispose();\n    }), f = (0,_use_event_js__WEBPACK_IMPORTED_MODULE_2__.useEvent)((s)=>{\n        if (r.dispose(), t.current === null) {\n            t.current = s.currentTarget, l(!0);\n            {\n                let i = (0,_utils_owner_js__WEBPACK_IMPORTED_MODULE_3__.getOwnerDocument)(s.currentTarget);\n                r.addEventListener(i, \"pointerup\", o, !1), r.addEventListener(i, \"pointermove\", (c)=>{\n                    if (t.current) {\n                        let p = E(c);\n                        l(P(p, t.current.getBoundingClientRect()));\n                    }\n                }, !1), r.addEventListener(i, \"pointercancel\", o, !1);\n            }\n        }\n    });\n    return {\n        pressed: n,\n        pressProps: e ? {} : {\n            onPointerDown: f,\n            onPointerUp: o,\n            onClick: o\n        }\n    };\n}\n\nvar _c, _c1;\n$RefreshReg$(_c, \"E\");\n$RefreshReg$(_c1, \"P\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQGhlYWRsZXNzdWkvcmVhY3QvZGlzdC9ob29rcy91c2UtYWN0aXZlLXByZXNzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQTZDO0FBQXFEO0FBQXNEO0FBQTBDO0FBQUEsU0FBU1UsRUFBRUMsQ0FBQztJQUFFLElBQUlDLElBQUVELEVBQUVFLEtBQUssR0FBQyxHQUFFQyxJQUFFSCxFQUFFSSxNQUFNLEdBQUM7SUFBRSxPQUFNO1FBQUNDLEtBQUlMLEVBQUVNLE9BQU8sR0FBQ0g7UUFBRUksT0FBTVAsRUFBRVEsT0FBTyxHQUFDUDtRQUFFUSxRQUFPVCxFQUFFTSxPQUFPLEdBQUNIO1FBQUVPLE1BQUtWLEVBQUVRLE9BQU8sR0FBQ1A7SUFBQztBQUFDO0tBQS9HRjtBQUFnSCxTQUFTWSxFQUFFWCxDQUFDLEVBQUNDLENBQUM7SUFBRSxPQUFNLENBQUUsRUFBQ0QsS0FBRyxDQUFDQyxLQUFHRCxFQUFFTyxLQUFLLEdBQUNOLEVBQUVTLElBQUksSUFBRVYsRUFBRVUsSUFBSSxHQUFDVCxFQUFFTSxLQUFLLElBQUVQLEVBQUVTLE1BQU0sR0FBQ1IsRUFBRUksR0FBRyxJQUFFTCxFQUFFSyxHQUFHLEdBQUNKLEVBQUVRLE1BQU07QUFBQztNQUF0RkU7QUFBdUYsU0FBU0M7UUFBRSxFQUFDQyxVQUFTYixJQUFFLENBQUMsQ0FBQyxFQUFDLEdBQWYsaUVBQWdCLENBQUM7SUFBRyxJQUFJQyxJQUFFWCw2Q0FBQ0EsQ0FBQyxPQUFNLENBQUNhLEdBQUVXLEVBQUUsR0FBQ3RCLCtDQUFDQSxDQUFDLENBQUMsSUFBR3VCLElBQUVuQixtRUFBQ0EsSUFBR29CLElBQUVsQix1REFBQ0EsQ0FBQztRQUFLRyxFQUFFZ0IsT0FBTyxHQUFDLE1BQUtILEVBQUUsQ0FBQyxJQUFHQyxFQUFFRyxPQUFPO0lBQUUsSUFBR0MsSUFBRXJCLHVEQUFDQSxDQUFDc0IsQ0FBQUE7UUFBSSxJQUFHTCxFQUFFRyxPQUFPLElBQUdqQixFQUFFZ0IsT0FBTyxLQUFHLE1BQUs7WUFBQ2hCLEVBQUVnQixPQUFPLEdBQUNHLEVBQUVDLGFBQWEsRUFBQ1AsRUFBRSxDQUFDO1lBQUc7Z0JBQUMsSUFBSVEsSUFBRTVCLGlFQUFDQSxDQUFDMEIsRUFBRUMsYUFBYTtnQkFBRU4sRUFBRVEsZ0JBQWdCLENBQUNELEdBQUUsYUFBWU4sR0FBRSxDQUFDLElBQUdELEVBQUVRLGdCQUFnQixDQUFDRCxHQUFFLGVBQWNFLENBQUFBO29CQUFJLElBQUd2QixFQUFFZ0IsT0FBTyxFQUFDO3dCQUFDLElBQUlRLElBQUUxQixFQUFFeUI7d0JBQUdWLEVBQUVILEVBQUVjLEdBQUV4QixFQUFFZ0IsT0FBTyxDQUFDUyxxQkFBcUI7b0JBQUk7Z0JBQUMsR0FBRSxDQUFDLElBQUdYLEVBQUVRLGdCQUFnQixDQUFDRCxHQUFFLGlCQUFnQk4sR0FBRSxDQUFDO1lBQUU7UUFBQztJQUFDO0lBQUcsT0FBTTtRQUFDVyxTQUFReEI7UUFBRXlCLFlBQVc1QixJQUFFLENBQUMsSUFBRTtZQUFDNkIsZUFBY1Y7WUFBRVcsYUFBWWQ7WUFBRWUsU0FBUWY7UUFBQztJQUFDO0FBQUM7QUFBNkIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AaGVhZGxlc3N1aS9yZWFjdC9kaXN0L2hvb2tzL3VzZS1hY3RpdmUtcHJlc3MuanM/NTcxYSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnR7dXNlUmVmIGFzIGEsdXNlU3RhdGUgYXMgbX1mcm9tXCJyZWFjdFwiO2ltcG9ydHtnZXRPd25lckRvY3VtZW50IGFzIGR9ZnJvbScuLi91dGlscy9vd25lci5qcyc7aW1wb3J0e3VzZURpc3Bvc2FibGVzIGFzIGd9ZnJvbScuL3VzZS1kaXNwb3NhYmxlcy5qcyc7aW1wb3J0e3VzZUV2ZW50IGFzIHV9ZnJvbScuL3VzZS1ldmVudC5qcyc7ZnVuY3Rpb24gRShlKXtsZXQgdD1lLndpZHRoLzIsbj1lLmhlaWdodC8yO3JldHVybnt0b3A6ZS5jbGllbnRZLW4scmlnaHQ6ZS5jbGllbnRYK3QsYm90dG9tOmUuY2xpZW50WStuLGxlZnQ6ZS5jbGllbnRYLXR9fWZ1bmN0aW9uIFAoZSx0KXtyZXR1cm4hKCFlfHwhdHx8ZS5yaWdodDx0LmxlZnR8fGUubGVmdD50LnJpZ2h0fHxlLmJvdHRvbTx0LnRvcHx8ZS50b3A+dC5ib3R0b20pfWZ1bmN0aW9uIHcoe2Rpc2FibGVkOmU9ITF9PXt9KXtsZXQgdD1hKG51bGwpLFtuLGxdPW0oITEpLHI9ZygpLG89dSgoKT0+e3QuY3VycmVudD1udWxsLGwoITEpLHIuZGlzcG9zZSgpfSksZj11KHM9PntpZihyLmRpc3Bvc2UoKSx0LmN1cnJlbnQ9PT1udWxsKXt0LmN1cnJlbnQ9cy5jdXJyZW50VGFyZ2V0LGwoITApO3tsZXQgaT1kKHMuY3VycmVudFRhcmdldCk7ci5hZGRFdmVudExpc3RlbmVyKGksXCJwb2ludGVydXBcIixvLCExKSxyLmFkZEV2ZW50TGlzdGVuZXIoaSxcInBvaW50ZXJtb3ZlXCIsYz0+e2lmKHQuY3VycmVudCl7bGV0IHA9RShjKTtsKFAocCx0LmN1cnJlbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkpKX19LCExKSxyLmFkZEV2ZW50TGlzdGVuZXIoaSxcInBvaW50ZXJjYW5jZWxcIixvLCExKX19fSk7cmV0dXJue3ByZXNzZWQ6bixwcmVzc1Byb3BzOmU/e306e29uUG9pbnRlckRvd246ZixvblBvaW50ZXJVcDpvLG9uQ2xpY2s6b319fWV4cG9ydHt3IGFzIHVzZUFjdGl2ZVByZXNzfTtcbiJdLCJuYW1lcyI6WyJ1c2VSZWYiLCJhIiwidXNlU3RhdGUiLCJtIiwiZ2V0T3duZXJEb2N1bWVudCIsImQiLCJ1c2VEaXNwb3NhYmxlcyIsImciLCJ1c2VFdmVudCIsInUiLCJFIiwiZSIsInQiLCJ3aWR0aCIsIm4iLCJoZWlnaHQiLCJ0b3AiLCJjbGllbnRZIiwicmlnaHQiLCJjbGllbnRYIiwiYm90dG9tIiwibGVmdCIsIlAiLCJ3IiwiZGlzYWJsZWQiLCJsIiwiciIsIm8iLCJjdXJyZW50IiwiZGlzcG9zZSIsImYiLCJzIiwiY3VycmVudFRhcmdldCIsImkiLCJhZGRFdmVudExpc3RlbmVyIiwiYyIsInAiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJwcmVzc2VkIiwicHJlc3NQcm9wcyIsIm9uUG9pbnRlckRvd24iLCJvblBvaW50ZXJVcCIsIm9uQ2xpY2siLCJ1c2VBY3RpdmVQcmVzcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../../../node_modules/@headlessui/react/dist/hooks/use-active-press.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../../../node_modules/@headlessui/react/dist/hooks/use-did-element-move.js":
/*!*************************************************************************************!*\
  !*** ../../../../node_modules/@headlessui/react/dist/hooks/use-did-element-move.js ***!
  \*************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useDidElementMove: function() { return /* binding */ s; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var _use_iso_morphic_effect_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./use-iso-morphic-effect.js */ \"(app-pages-browser)/../../../../node_modules/@headlessui/react/dist/hooks/use-iso-morphic-effect.js\");\n\n\nfunction s(n, t) {\n    let e = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({\n        left: 0,\n        top: 0\n    });\n    if ((0,_use_iso_morphic_effect_js__WEBPACK_IMPORTED_MODULE_1__.useIsoMorphicEffect)(()=>{\n        if (!t) return;\n        let r = t.getBoundingClientRect();\n        r && (e.current = r);\n    }, [\n        n,\n        t\n    ]), t == null || !n || t === document.activeElement) return !1;\n    let o = t.getBoundingClientRect();\n    return o.top !== e.current.top || o.left !== e.current.left;\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQGhlYWRsZXNzdWkvcmVhY3QvZGlzdC9ob29rcy91c2UtZGlkLWVsZW1lbnQtbW92ZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBK0I7QUFBa0U7QUFBQSxTQUFTSSxFQUFFQyxDQUFDLEVBQUNDLENBQUM7SUFBRSxJQUFJQyxJQUFFTiw2Q0FBQ0EsQ0FBQztRQUFDTyxNQUFLO1FBQUVDLEtBQUk7SUFBQztJQUFHLElBQUdOLCtFQUFDQSxDQUFDO1FBQUssSUFBRyxDQUFDRyxHQUFFO1FBQU8sSUFBSUksSUFBRUosRUFBRUsscUJBQXFCO1FBQUdELEtBQUlILENBQUFBLEVBQUVLLE9BQU8sR0FBQ0YsQ0FBQUE7SUFBRSxHQUFFO1FBQUNMO1FBQUVDO0tBQUUsR0FBRUEsS0FBRyxRQUFNLENBQUNELEtBQUdDLE1BQUlPLFNBQVNDLGFBQWEsRUFBQyxPQUFNLENBQUM7SUFBRSxJQUFJQyxJQUFFVCxFQUFFSyxxQkFBcUI7SUFBRyxPQUFPSSxFQUFFTixHQUFHLEtBQUdGLEVBQUVLLE9BQU8sQ0FBQ0gsR0FBRyxJQUFFTSxFQUFFUCxJQUFJLEtBQUdELEVBQUVLLE9BQU8sQ0FBQ0osSUFBSTtBQUFBO0FBQWdDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQGhlYWRsZXNzdWkvcmVhY3QvZGlzdC9ob29rcy91c2UtZGlkLWVsZW1lbnQtbW92ZS5qcz9hYzk5Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydHt1c2VSZWYgYXMgaX1mcm9tXCJyZWFjdFwiO2ltcG9ydHt1c2VJc29Nb3JwaGljRWZmZWN0IGFzIHV9ZnJvbScuL3VzZS1pc28tbW9ycGhpYy1lZmZlY3QuanMnO2Z1bmN0aW9uIHMobix0KXtsZXQgZT1pKHtsZWZ0OjAsdG9wOjB9KTtpZih1KCgpPT57aWYoIXQpcmV0dXJuO2xldCByPXQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7ciYmKGUuY3VycmVudD1yKX0sW24sdF0pLHQ9PW51bGx8fCFufHx0PT09ZG9jdW1lbnQuYWN0aXZlRWxlbWVudClyZXR1cm4hMTtsZXQgbz10LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO3JldHVybiBvLnRvcCE9PWUuY3VycmVudC50b3B8fG8ubGVmdCE9PWUuY3VycmVudC5sZWZ0fWV4cG9ydHtzIGFzIHVzZURpZEVsZW1lbnRNb3ZlfTtcbiJdLCJuYW1lcyI6WyJ1c2VSZWYiLCJpIiwidXNlSXNvTW9ycGhpY0VmZmVjdCIsInUiLCJzIiwibiIsInQiLCJlIiwibGVmdCIsInRvcCIsInIiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJjdXJyZW50IiwiZG9jdW1lbnQiLCJhY3RpdmVFbGVtZW50IiwibyIsInVzZURpZEVsZW1lbnRNb3ZlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../../../node_modules/@headlessui/react/dist/hooks/use-did-element-move.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../../../node_modules/@headlessui/react/dist/hooks/use-element-size.js":
/*!*********************************************************************************!*\
  !*** ../../../../node_modules/@headlessui/react/dist/hooks/use-element-size.js ***!
  \*********************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useElementSize: function() { return /* binding */ d; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var _use_iso_morphic_effect_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./use-iso-morphic-effect.js */ \"(app-pages-browser)/../../../../node_modules/@headlessui/react/dist/hooks/use-iso-morphic-effect.js\");\n\n\nfunction f(e) {\n    if (e === null) return {\n        width: 0,\n        height: 0\n    };\n    let { width: t, height: r } = e.getBoundingClientRect();\n    return {\n        width: t,\n        height: r\n    };\n}\nfunction d(e) {\n    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;\n    let [r, u] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useReducer)(()=>({}), {}), i = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>f(e), [\n        e,\n        r\n    ]);\n    return (0,_use_iso_morphic_effect_js__WEBPACK_IMPORTED_MODULE_1__.useIsoMorphicEffect)(()=>{\n        if (!e) return;\n        let n = new ResizeObserver(u);\n        return n.observe(e), ()=>{\n            n.disconnect();\n        };\n    }, [\n        e\n    ]), t ? {\n        width: \"\".concat(i.width, \"px\"),\n        height: \"\".concat(i.height, \"px\")\n    } : i;\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQGhlYWRsZXNzdWkvcmVhY3QvZGlzdC9ob29rcy91c2UtZWxlbWVudC1zaXplLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFnRDtBQUFrRTtBQUFBLFNBQVNNLEVBQUVDLENBQUM7SUFBRSxJQUFHQSxNQUFJLE1BQUssT0FBTTtRQUFDQyxPQUFNO1FBQUVDLFFBQU87SUFBQztJQUFFLElBQUcsRUFBQ0QsT0FBTUUsQ0FBQyxFQUFDRCxRQUFPRSxDQUFDLEVBQUMsR0FBQ0osRUFBRUsscUJBQXFCO0lBQUcsT0FBTTtRQUFDSixPQUFNRTtRQUFFRCxRQUFPRTtJQUFDO0FBQUM7QUFBQyxTQUFTRSxFQUFFTixDQUFDO1FBQUNHLElBQUFBLGlFQUFFLENBQUM7SUFBRyxJQUFHLENBQUNDLEdBQUVHLEVBQUUsR0FBQ1gsaURBQUNBLENBQUMsSUFBSyxFQUFDLElBQUcsQ0FBQyxJQUFHWSxJQUFFZCw4Q0FBQ0EsQ0FBQyxJQUFJSyxFQUFFQyxJQUFHO1FBQUNBO1FBQUVJO0tBQUU7SUFBRSxPQUFPTiwrRUFBQ0EsQ0FBQztRQUFLLElBQUcsQ0FBQ0UsR0FBRTtRQUFPLElBQUlTLElBQUUsSUFBSUMsZUFBZUg7UUFBRyxPQUFPRSxFQUFFRSxPQUFPLENBQUNYLElBQUc7WUFBS1MsRUFBRUcsVUFBVTtRQUFFO0lBQUMsR0FBRTtRQUFDWjtLQUFFLEdBQUVHLElBQUU7UUFBQ0YsT0FBTSxHQUFXLE9BQVJPLEVBQUVQLEtBQUssRUFBQztRQUFJQyxRQUFPLEdBQVksT0FBVE0sRUFBRU4sTUFBTSxFQUFDO0lBQUcsSUFBRU07QUFBQztBQUE2QiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BoZWFkbGVzc3VpL3JlYWN0L2Rpc3QvaG9va3MvdXNlLWVsZW1lbnQtc2l6ZS5qcz9lYzJkIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydHt1c2VNZW1vIGFzIG8sdXNlUmVkdWNlciBhcyBofWZyb21cInJlYWN0XCI7aW1wb3J0e3VzZUlzb01vcnBoaWNFZmZlY3QgYXMgc31mcm9tJy4vdXNlLWlzby1tb3JwaGljLWVmZmVjdC5qcyc7ZnVuY3Rpb24gZihlKXtpZihlPT09bnVsbClyZXR1cm57d2lkdGg6MCxoZWlnaHQ6MH07bGV0e3dpZHRoOnQsaGVpZ2h0OnJ9PWUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7cmV0dXJue3dpZHRoOnQsaGVpZ2h0OnJ9fWZ1bmN0aW9uIGQoZSx0PSExKXtsZXRbcix1XT1oKCgpPT4oe30pLHt9KSxpPW8oKCk9PmYoZSksW2Uscl0pO3JldHVybiBzKCgpPT57aWYoIWUpcmV0dXJuO2xldCBuPW5ldyBSZXNpemVPYnNlcnZlcih1KTtyZXR1cm4gbi5vYnNlcnZlKGUpLCgpPT57bi5kaXNjb25uZWN0KCl9fSxbZV0pLHQ/e3dpZHRoOmAke2kud2lkdGh9cHhgLGhlaWdodDpgJHtpLmhlaWdodH1weGB9Oml9ZXhwb3J0e2QgYXMgdXNlRWxlbWVudFNpemV9O1xuIl0sIm5hbWVzIjpbInVzZU1lbW8iLCJvIiwidXNlUmVkdWNlciIsImgiLCJ1c2VJc29Nb3JwaGljRWZmZWN0IiwicyIsImYiLCJlIiwid2lkdGgiLCJoZWlnaHQiLCJ0IiwiciIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsImQiLCJ1IiwiaSIsIm4iLCJSZXNpemVPYnNlcnZlciIsIm9ic2VydmUiLCJkaXNjb25uZWN0IiwidXNlRWxlbWVudFNpemUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../../../node_modules/@headlessui/react/dist/hooks/use-element-size.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../../../node_modules/@headlessui/react/dist/hooks/use-resolve-button-type.js":
/*!****************************************************************************************!*\
  !*** ../../../../node_modules/@headlessui/react/dist/hooks/use-resolve-button-type.js ***!
  \****************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useResolveButtonType: function() { return /* binding */ e; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n\nfunction e(t, u) {\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        var n;\n        if (t.type) return t.type;\n        let r = (n = t.as) != null ? n : \"button\";\n        if (typeof r == \"string\" && r.toLowerCase() === \"button\" || (u == null ? void 0 : u.tagName) === \"BUTTON\" && !u.hasAttribute(\"type\")) return \"button\";\n    }, [\n        t.type,\n        t.as,\n        u\n    ]);\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQGhlYWRsZXNzdWkvcmVhY3QvZGlzdC9ob29rcy91c2UtcmVzb2x2ZS1idXR0b24tdHlwZS5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFnQztBQUFBLFNBQVNFLEVBQUVDLENBQUMsRUFBQ0MsQ0FBQztJQUFFLE9BQU9ILDhDQUFDQSxDQUFDO1FBQUssSUFBSUk7UUFBRSxJQUFHRixFQUFFRyxJQUFJLEVBQUMsT0FBT0gsRUFBRUcsSUFBSTtRQUFDLElBQUlDLElBQUUsQ0FBQ0YsSUFBRUYsRUFBRUssRUFBRSxLQUFHLE9BQUtILElBQUU7UUFBUyxJQUFHLE9BQU9FLEtBQUcsWUFBVUEsRUFBRUUsV0FBVyxPQUFLLFlBQVUsQ0FBQ0wsS0FBRyxPQUFLLEtBQUssSUFBRUEsRUFBRU0sT0FBTyxNQUFJLFlBQVUsQ0FBQ04sRUFBRU8sWUFBWSxDQUFDLFNBQVEsT0FBTTtJQUFRLEdBQUU7UUFBQ1IsRUFBRUcsSUFBSTtRQUFDSCxFQUFFSyxFQUFFO1FBQUNKO0tBQUU7QUFBQztBQUFtQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BoZWFkbGVzc3VpL3JlYWN0L2Rpc3QvaG9va3MvdXNlLXJlc29sdmUtYnV0dG9uLXR5cGUuanM/ZjcxMyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnR7dXNlTWVtbyBhcyBhfWZyb21cInJlYWN0XCI7ZnVuY3Rpb24gZSh0LHUpe3JldHVybiBhKCgpPT57dmFyIG47aWYodC50eXBlKXJldHVybiB0LnR5cGU7bGV0IHI9KG49dC5hcykhPW51bGw/bjpcImJ1dHRvblwiO2lmKHR5cGVvZiByPT1cInN0cmluZ1wiJiZyLnRvTG93ZXJDYXNlKCk9PT1cImJ1dHRvblwifHwodT09bnVsbD92b2lkIDA6dS50YWdOYW1lKT09PVwiQlVUVE9OXCImJiF1Lmhhc0F0dHJpYnV0ZShcInR5cGVcIikpcmV0dXJuXCJidXR0b25cIn0sW3QudHlwZSx0LmFzLHVdKX1leHBvcnR7ZSBhcyB1c2VSZXNvbHZlQnV0dG9uVHlwZX07XG4iXSwibmFtZXMiOlsidXNlTWVtbyIsImEiLCJlIiwidCIsInUiLCJuIiwidHlwZSIsInIiLCJhcyIsInRvTG93ZXJDYXNlIiwidGFnTmFtZSIsImhhc0F0dHJpYnV0ZSIsInVzZVJlc29sdmVCdXR0b25UeXBlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../../../node_modules/@headlessui/react/dist/hooks/use-resolve-button-type.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../../../node_modules/@headlessui/react/dist/hooks/use-text-value.js":
/*!*******************************************************************************!*\
  !*** ../../../../node_modules/@headlessui/react/dist/hooks/use-text-value.js ***!
  \*******************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useTextValue: function() { return /* binding */ s; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var _utils_get_text_value_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/get-text-value.js */ \"(app-pages-browser)/../../../../node_modules/@headlessui/react/dist/utils/get-text-value.js\");\n/* harmony import */ var _use_event_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./use-event.js */ \"(app-pages-browser)/../../../../node_modules/@headlessui/react/dist/hooks/use-event.js\");\n\n\n\nfunction s(c) {\n    let t = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(\"\"), r = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(\"\");\n    return (0,_use_event_js__WEBPACK_IMPORTED_MODULE_1__.useEvent)(()=>{\n        let e = c.current;\n        if (!e) return \"\";\n        let u = e.innerText;\n        if (t.current === u) return r.current;\n        let n = (0,_utils_get_text_value_js__WEBPACK_IMPORTED_MODULE_2__.getTextValue)(e).trim().toLowerCase();\n        return t.current = u, r.current = n, n;\n    });\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQGhlYWRsZXNzdWkvcmVhY3QvZGlzdC9ob29rcy91c2UtdGV4dC12YWx1ZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQStCO0FBQTBEO0FBQTBDO0FBQUEsU0FBU00sRUFBRUMsQ0FBQztJQUFFLElBQUlDLElBQUVQLDZDQUFDQSxDQUFDLEtBQUlRLElBQUVSLDZDQUFDQSxDQUFDO0lBQUksT0FBT0ksdURBQUNBLENBQUM7UUFBSyxJQUFJSyxJQUFFSCxFQUFFSSxPQUFPO1FBQUMsSUFBRyxDQUFDRCxHQUFFLE9BQU07UUFBRyxJQUFJRSxJQUFFRixFQUFFRyxTQUFTO1FBQUMsSUFBR0wsRUFBRUcsT0FBTyxLQUFHQyxHQUFFLE9BQU9ILEVBQUVFLE9BQU87UUFBQyxJQUFJRyxJQUFFWCxzRUFBQ0EsQ0FBQ08sR0FBR0ssSUFBSSxHQUFHQyxXQUFXO1FBQUcsT0FBT1IsRUFBRUcsT0FBTyxHQUFDQyxHQUFFSCxFQUFFRSxPQUFPLEdBQUNHLEdBQUVBO0lBQUM7QUFBRTtBQUEyQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BoZWFkbGVzc3VpL3JlYWN0L2Rpc3QvaG9va3MvdXNlLXRleHQtdmFsdWUuanM/NzU5NCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnR7dXNlUmVmIGFzIGx9ZnJvbVwicmVhY3RcIjtpbXBvcnR7Z2V0VGV4dFZhbHVlIGFzIGl9ZnJvbScuLi91dGlscy9nZXQtdGV4dC12YWx1ZS5qcyc7aW1wb3J0e3VzZUV2ZW50IGFzIG99ZnJvbScuL3VzZS1ldmVudC5qcyc7ZnVuY3Rpb24gcyhjKXtsZXQgdD1sKFwiXCIpLHI9bChcIlwiKTtyZXR1cm4gbygoKT0+e2xldCBlPWMuY3VycmVudDtpZighZSlyZXR1cm5cIlwiO2xldCB1PWUuaW5uZXJUZXh0O2lmKHQuY3VycmVudD09PXUpcmV0dXJuIHIuY3VycmVudDtsZXQgbj1pKGUpLnRyaW0oKS50b0xvd2VyQ2FzZSgpO3JldHVybiB0LmN1cnJlbnQ9dSxyLmN1cnJlbnQ9bixufSl9ZXhwb3J0e3MgYXMgdXNlVGV4dFZhbHVlfTtcbiJdLCJuYW1lcyI6WyJ1c2VSZWYiLCJsIiwiZ2V0VGV4dFZhbHVlIiwiaSIsInVzZUV2ZW50IiwibyIsInMiLCJjIiwidCIsInIiLCJlIiwiY3VycmVudCIsInUiLCJpbm5lclRleHQiLCJuIiwidHJpbSIsInRvTG93ZXJDYXNlIiwidXNlVGV4dFZhbHVlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../../../node_modules/@headlessui/react/dist/hooks/use-text-value.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../../../node_modules/@headlessui/react/dist/hooks/use-tracked-pointer.js":
/*!************************************************************************************!*\
  !*** ../../../../node_modules/@headlessui/react/dist/hooks/use-tracked-pointer.js ***!
  \************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useTrackedPointer: function() { return /* binding */ u; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n\nfunction t(e) {\n    return [\n        e.screenX,\n        e.screenY\n    ];\n}\nfunction u() {\n    let e = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)([\n        -1,\n        -1\n    ]);\n    return {\n        wasMoved (r) {\n            let n = t(r);\n            return e.current[0] === n[0] && e.current[1] === n[1] ? !1 : (e.current = n, !0);\n        },\n        update (r) {\n            e.current = t(r);\n        }\n    };\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQGhlYWRsZXNzdWkvcmVhY3QvZGlzdC9ob29rcy91c2UtdHJhY2tlZC1wb2ludGVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQStCO0FBQUEsU0FBU0UsRUFBRUMsQ0FBQztJQUFFLE9BQU07UUFBQ0EsRUFBRUMsT0FBTztRQUFDRCxFQUFFRSxPQUFPO0tBQUM7QUFBQTtBQUFDLFNBQVNDO0lBQUksSUFBSUgsSUFBRUYsNkNBQUNBLENBQUM7UUFBQyxDQUFDO1FBQUUsQ0FBQztLQUFFO0lBQUUsT0FBTTtRQUFDTSxVQUFTQyxDQUFDO1lBQUUsSUFBSUMsSUFBRVAsRUFBRU07WUFBRyxPQUFPTCxFQUFFTyxPQUFPLENBQUMsRUFBRSxLQUFHRCxDQUFDLENBQUMsRUFBRSxJQUFFTixFQUFFTyxPQUFPLENBQUMsRUFBRSxLQUFHRCxDQUFDLENBQUMsRUFBRSxHQUFDLENBQUMsSUFBR04sQ0FBQUEsRUFBRU8sT0FBTyxHQUFDRCxHQUFFLENBQUM7UUFBRTtRQUFFRSxRQUFPSCxDQUFDO1lBQUVMLEVBQUVPLE9BQU8sR0FBQ1IsRUFBRU07UUFBRTtJQUFDO0FBQUM7QUFBZ0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AaGVhZGxlc3N1aS9yZWFjdC9kaXN0L2hvb2tzL3VzZS10cmFja2VkLXBvaW50ZXIuanM/N2NkMyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnR7dXNlUmVmIGFzIG99ZnJvbVwicmVhY3RcIjtmdW5jdGlvbiB0KGUpe3JldHVybltlLnNjcmVlblgsZS5zY3JlZW5ZXX1mdW5jdGlvbiB1KCl7bGV0IGU9byhbLTEsLTFdKTtyZXR1cm57d2FzTW92ZWQocil7bGV0IG49dChyKTtyZXR1cm4gZS5jdXJyZW50WzBdPT09blswXSYmZS5jdXJyZW50WzFdPT09blsxXT8hMTooZS5jdXJyZW50PW4sITApfSx1cGRhdGUocil7ZS5jdXJyZW50PXQocil9fX1leHBvcnR7dSBhcyB1c2VUcmFja2VkUG9pbnRlcn07XG4iXSwibmFtZXMiOlsidXNlUmVmIiwibyIsInQiLCJlIiwic2NyZWVuWCIsInNjcmVlblkiLCJ1Iiwid2FzTW92ZWQiLCJyIiwibiIsImN1cnJlbnQiLCJ1cGRhdGUiLCJ1c2VUcmFja2VkUG9pbnRlciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../../../node_modules/@headlessui/react/dist/hooks/use-tracked-pointer.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../../../node_modules/@headlessui/react/dist/hooks/use-tree-walker.js":
/*!********************************************************************************!*\
  !*** ../../../../node_modules/@headlessui/react/dist/hooks/use-tree-walker.js ***!
  \********************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useTreeWalker: function() { return /* binding */ F; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var _utils_owner_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/owner.js */ \"(app-pages-browser)/../../../../node_modules/@headlessui/react/dist/utils/owner.js\");\n/* harmony import */ var _use_iso_morphic_effect_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./use-iso-morphic-effect.js */ \"(app-pages-browser)/../../../../node_modules/@headlessui/react/dist/hooks/use-iso-morphic-effect.js\");\n\n\n\nfunction F(c, param) {\n    let { container: e, accept: t, walk: r } = param;\n    let o = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(t), l = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(r);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        o.current = t, l.current = r;\n    }, [\n        t,\n        r\n    ]), (0,_use_iso_morphic_effect_js__WEBPACK_IMPORTED_MODULE_1__.useIsoMorphicEffect)(()=>{\n        if (!e || !c) return;\n        let n = (0,_utils_owner_js__WEBPACK_IMPORTED_MODULE_2__.getOwnerDocument)(e);\n        if (!n) return;\n        let f = o.current, p = l.current, i = Object.assign((m)=>f(m), {\n            acceptNode: f\n        }), u = n.createTreeWalker(e, NodeFilter.SHOW_ELEMENT, i, !1);\n        for(; u.nextNode();)p(u.currentNode);\n    }, [\n        e,\n        c,\n        o,\n        l\n    ]);\n}\n_c = F;\n\nvar _c;\n$RefreshReg$(_c, \"F\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQGhlYWRsZXNzdWkvcmVhY3QvZGlzdC9ob29rcy91c2UtdHJlZS13YWxrZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUE4QztBQUFxRDtBQUFrRTtBQUFBLFNBQVNRLEVBQUVDLENBQUMsRUFBQyxLQUE2QjtRQUE3QixFQUFDQyxXQUFVQyxDQUFDLEVBQUNDLFFBQU9DLENBQUMsRUFBQ0MsTUFBS0MsQ0FBQyxFQUFDLEdBQTdCO0lBQStCLElBQUlDLElBQUViLDZDQUFDQSxDQUFDVSxJQUFHSSxJQUFFZCw2Q0FBQ0EsQ0FBQ1k7SUFBR2QsZ0RBQUNBLENBQUM7UUFBS2UsRUFBRUUsT0FBTyxHQUFDTCxHQUFFSSxFQUFFQyxPQUFPLEdBQUNIO0lBQUMsR0FBRTtRQUFDRjtRQUFFRTtLQUFFLEdBQUVSLCtFQUFDQSxDQUFDO1FBQUssSUFBRyxDQUFDSSxLQUFHLENBQUNGLEdBQUU7UUFBTyxJQUFJVSxJQUFFZCxpRUFBQ0EsQ0FBQ007UUFBRyxJQUFHLENBQUNRLEdBQUU7UUFBTyxJQUFJQyxJQUFFSixFQUFFRSxPQUFPLEVBQUNHLElBQUVKLEVBQUVDLE9BQU8sRUFBQ0ksSUFBRUMsT0FBT0MsTUFBTSxDQUFDQyxDQUFBQSxJQUFHTCxFQUFFSyxJQUFHO1lBQUNDLFlBQVdOO1FBQUMsSUFBR08sSUFBRVIsRUFBRVMsZ0JBQWdCLENBQUNqQixHQUFFa0IsV0FBV0MsWUFBWSxFQUFDUixHQUFFLENBQUM7UUFBRyxNQUFLSyxFQUFFSSxRQUFRLElBQUlWLEVBQUVNLEVBQUVLLFdBQVc7SUFBQyxHQUFFO1FBQUNyQjtRQUFFRjtRQUFFTztRQUFFQztLQUFFO0FBQUM7S0FBcFRUO0FBQWdWIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQGhlYWRsZXNzdWkvcmVhY3QvZGlzdC9ob29rcy91c2UtdHJlZS13YWxrZXIuanM/MTczNiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnR7dXNlRWZmZWN0IGFzIFQsdXNlUmVmIGFzIEV9ZnJvbVwicmVhY3RcIjtpbXBvcnR7Z2V0T3duZXJEb2N1bWVudCBhcyBkfWZyb20nLi4vdXRpbHMvb3duZXIuanMnO2ltcG9ydHt1c2VJc29Nb3JwaGljRWZmZWN0IGFzIE59ZnJvbScuL3VzZS1pc28tbW9ycGhpYy1lZmZlY3QuanMnO2Z1bmN0aW9uIEYoYyx7Y29udGFpbmVyOmUsYWNjZXB0OnQsd2FsazpyfSl7bGV0IG89RSh0KSxsPUUocik7VCgoKT0+e28uY3VycmVudD10LGwuY3VycmVudD1yfSxbdCxyXSksTigoKT0+e2lmKCFlfHwhYylyZXR1cm47bGV0IG49ZChlKTtpZighbilyZXR1cm47bGV0IGY9by5jdXJyZW50LHA9bC5jdXJyZW50LGk9T2JqZWN0LmFzc2lnbihtPT5mKG0pLHthY2NlcHROb2RlOmZ9KSx1PW4uY3JlYXRlVHJlZVdhbGtlcihlLE5vZGVGaWx0ZXIuU0hPV19FTEVNRU5ULGksITEpO2Zvcig7dS5uZXh0Tm9kZSgpOylwKHUuY3VycmVudE5vZGUpfSxbZSxjLG8sbF0pfWV4cG9ydHtGIGFzIHVzZVRyZWVXYWxrZXJ9O1xuIl0sIm5hbWVzIjpbInVzZUVmZmVjdCIsIlQiLCJ1c2VSZWYiLCJFIiwiZ2V0T3duZXJEb2N1bWVudCIsImQiLCJ1c2VJc29Nb3JwaGljRWZmZWN0IiwiTiIsIkYiLCJjIiwiY29udGFpbmVyIiwiZSIsImFjY2VwdCIsInQiLCJ3YWxrIiwiciIsIm8iLCJsIiwiY3VycmVudCIsIm4iLCJmIiwicCIsImkiLCJPYmplY3QiLCJhc3NpZ24iLCJtIiwiYWNjZXB0Tm9kZSIsInUiLCJjcmVhdGVUcmVlV2Fsa2VyIiwiTm9kZUZpbHRlciIsIlNIT1dfRUxFTUVOVCIsIm5leHROb2RlIiwiY3VycmVudE5vZGUiLCJ1c2VUcmVlV2Fsa2VyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../../../node_modules/@headlessui/react/dist/hooks/use-tree-walker.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../../../node_modules/@headlessui/react/dist/internal/floating.js":
/*!****************************************************************************!*\
  !*** ../../../../node_modules/@headlessui/react/dist/internal/floating.js ***!
  \****************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FloatingProvider: function() { return /* binding */ Me; },\n/* harmony export */   useFloatingPanel: function() { return /* binding */ Re; },\n/* harmony export */   useFloatingPanelProps: function() { return /* binding */ be; },\n/* harmony export */   useFloatingReference: function() { return /* binding */ ye; },\n/* harmony export */   useFloatingReferenceProps: function() { return /* binding */ Fe; },\n/* harmony export */   useResolvedAnchor: function() { return /* binding */ xe; }\n/* harmony export */ });\n/* harmony import */ var _floating_ui_react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @floating-ui/react */ \"(app-pages-browser)/../../../../node_modules/@floating-ui/react/dist/floating-ui.react.mjs\");\n/* harmony import */ var _floating_ui_react__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @floating-ui/react */ \"(app-pages-browser)/../../../../node_modules/@floating-ui/react-dom/dist/floating-ui.react-dom.mjs\");\n/* harmony import */ var _floating_ui_react__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @floating-ui/react */ \"(app-pages-browser)/../../../../node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var _hooks_use_disposables_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../hooks/use-disposables.js */ \"(app-pages-browser)/../../../../node_modules/@headlessui/react/dist/hooks/use-disposables.js\");\n/* harmony import */ var _hooks_use_event_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../hooks/use-event.js */ \"(app-pages-browser)/../../../../node_modules/@headlessui/react/dist/hooks/use-event.js\");\n/* harmony import */ var _hooks_use_iso_morphic_effect_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../hooks/use-iso-morphic-effect.js */ \"(app-pages-browser)/../../../../node_modules/@headlessui/react/dist/hooks/use-iso-morphic-effect.js\");\n\n\n\n\n\n\nlet y = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({\n    styles: void 0,\n    setReference: ()=>{},\n    setFloating: ()=>{},\n    getReferenceProps: ()=>({}),\n    getFloatingProps: ()=>({}),\n    slot: {}\n});\ny.displayName = \"FloatingContext\";\nlet H = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(null);\nH.displayName = \"PlacementContext\";\nfunction xe(e) {\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>e ? typeof e == \"string\" ? {\n            to: e\n        } : e : null, [\n        e\n    ]);\n}\nfunction ye() {\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(y).setReference;\n}\nfunction Fe() {\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(y).getReferenceProps;\n}\n_c = Fe;\nfunction be() {\n    let { getFloatingProps: e, slot: t } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(y);\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(function() {\n        for(var _len = arguments.length, n = new Array(_len), _key = 0; _key < _len; _key++){\n            n[_key] = arguments[_key];\n        }\n        return Object.assign({}, e(...n), {\n            \"data-anchor\": t.anchor\n        });\n    }, [\n        e,\n        t\n    ]);\n}\nfunction Re() {\n    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;\n    e === !1 && (e = null), typeof e == \"string\" && (e = {\n        to: e\n    });\n    let t = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(H), n = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>e, [\n        JSON.stringify(e, (r, o)=>{\n            var u;\n            return (u = o == null ? void 0 : o.outerHTML) != null ? u : o;\n        })\n    ]);\n    (0,_hooks_use_iso_morphic_effect_js__WEBPACK_IMPORTED_MODULE_1__.useIsoMorphicEffect)(()=>{\n        t == null || t(n != null ? n : null);\n    }, [\n        t,\n        n\n    ]);\n    let l = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(y);\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>[\n            l.setFloating,\n            e ? l.styles : {}\n        ], [\n        l.setFloating,\n        e,\n        l.styles\n    ]);\n}\n_c1 = Re;\nlet q = 4;\nfunction Me(param) {\n    let { children: e, enabled: t = !0 } = param;\n    let [n, l] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null), [r, o] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0), u = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null), [f, s] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    pe(f);\n    let i = t && n !== null && f !== null, { to: F = \"bottom\", gap: E = 0, offset: v = 0, padding: c = 0, inner: P } = ce(n, f), [a, p = \"center\"] = F.split(\" \");\n    (0,_hooks_use_iso_morphic_effect_js__WEBPACK_IMPORTED_MODULE_1__.useIsoMorphicEffect)(()=>{\n        i && o(0);\n    }, [\n        i\n    ]);\n    let { refs: b, floatingStyles: w, context: g } = (0,_floating_ui_react__WEBPACK_IMPORTED_MODULE_2__.useFloating)({\n        open: i,\n        placement: a === \"selection\" ? p === \"center\" ? \"bottom\" : \"bottom-\".concat(p) : p === \"center\" ? \"\".concat(a) : \"\".concat(a, \"-\").concat(p),\n        strategy: \"absolute\",\n        transform: !1,\n        middleware: [\n            (0,_floating_ui_react__WEBPACK_IMPORTED_MODULE_3__.offset)({\n                mainAxis: a === \"selection\" ? 0 : E,\n                crossAxis: v\n            }),\n            (0,_floating_ui_react__WEBPACK_IMPORTED_MODULE_3__.shift)({\n                padding: c\n            }),\n            a !== \"selection\" && (0,_floating_ui_react__WEBPACK_IMPORTED_MODULE_3__.flip)({\n                padding: c\n            }),\n            a === \"selection\" && P ? (0,_floating_ui_react__WEBPACK_IMPORTED_MODULE_2__.inner)({\n                ...P,\n                padding: c,\n                overflowRef: u,\n                offset: r,\n                minItemsVisible: q,\n                referenceOverflowThreshold: c,\n                onFallbackChange (h) {\n                    var O, W;\n                    if (!h) return;\n                    let d = g.elements.floating;\n                    if (!d) return;\n                    let T = parseFloat(getComputedStyle(d).scrollPaddingBottom) || 0, $ = Math.min(q, d.childElementCount), L = 0, N = 0;\n                    for (let m of (W = (O = g.elements.floating) == null ? void 0 : O.childNodes) != null ? W : [])if (m instanceof HTMLElement) {\n                        let x = m.offsetTop, k = x + m.clientHeight + T, S = d.scrollTop, U = S + d.clientHeight;\n                        if (x >= S && k <= U) $--;\n                        else {\n                            N = Math.max(0, Math.min(k, U) - Math.max(x, S)), L = m.clientHeight;\n                            break;\n                        }\n                    }\n                    $ >= 1 && o((m)=>{\n                        let x = L * $ - N + T;\n                        return m >= x ? m : x;\n                    });\n                }\n            }) : null,\n            (0,_floating_ui_react__WEBPACK_IMPORTED_MODULE_3__.size)({\n                padding: c,\n                apply (param) {\n                    let { availableWidth: h, availableHeight: d, elements: T } = param;\n                    Object.assign(T.floating.style, {\n                        overflow: \"auto\",\n                        maxWidth: \"\".concat(h, \"px\"),\n                        maxHeight: \"min(var(--anchor-max-height, 100vh), \".concat(d, \"px)\")\n                    });\n                }\n            })\n        ].filter(Boolean),\n        whileElementsMounted: _floating_ui_react__WEBPACK_IMPORTED_MODULE_4__.autoUpdate\n    }), [I = a, B = p] = g.placement.split(\"-\");\n    a === \"selection\" && (I = \"selection\");\n    let G = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>({\n            anchor: [\n                I,\n                B\n            ].filter(Boolean).join(\" \")\n        }), [\n        I,\n        B\n    ]), K = (0,_floating_ui_react__WEBPACK_IMPORTED_MODULE_2__.useInnerOffset)(g, {\n        overflowRef: u,\n        onChange: o\n    }), { getReferenceProps: Q, getFloatingProps: X } = (0,_floating_ui_react__WEBPACK_IMPORTED_MODULE_2__.useInteractions)([\n        K\n    ]), Y = (0,_hooks_use_event_js__WEBPACK_IMPORTED_MODULE_5__.useEvent)((h)=>{\n        s(h), b.setFloating(h);\n    });\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(H.Provider, {\n        value: l\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(y.Provider, {\n        value: {\n            setFloating: Y,\n            setReference: b.setReference,\n            styles: w,\n            getReferenceProps: Q,\n            getFloatingProps: X,\n            slot: G\n        }\n    }, e));\n}\n_c2 = Me;\nfunction pe(e) {\n    (0,_hooks_use_iso_morphic_effect_js__WEBPACK_IMPORTED_MODULE_1__.useIsoMorphicEffect)(()=>{\n        if (!e) return;\n        let t = new MutationObserver(()=>{\n            let n = window.getComputedStyle(e).maxHeight, l = parseFloat(n);\n            if (isNaN(l)) return;\n            let r = parseInt(n);\n            isNaN(r) || l !== r && (e.style.maxHeight = \"\".concat(Math.ceil(l), \"px\"));\n        });\n        return t.observe(e, {\n            attributes: !0,\n            attributeFilter: [\n                \"style\"\n            ]\n        }), ()=>{\n            t.disconnect();\n        };\n    }, [\n        e\n    ]);\n}\nfunction ce(e, t) {\n    var o, u, f;\n    let n = V((o = e == null ? void 0 : e.gap) != null ? o : \"var(--anchor-gap, 0)\", t), l = V((u = e == null ? void 0 : e.offset) != null ? u : \"var(--anchor-offset, 0)\", t), r = V((f = e == null ? void 0 : e.padding) != null ? f : \"var(--anchor-padding, 0)\", t);\n    return {\n        ...e,\n        gap: n,\n        offset: l,\n        padding: r\n    };\n}\nfunction V(e, t) {\n    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : void 0;\n    let l = (0,_hooks_use_disposables_js__WEBPACK_IMPORTED_MODULE_6__.useDisposables)(), r = (0,_hooks_use_event_js__WEBPACK_IMPORTED_MODULE_5__.useEvent)((s, i)=>{\n        if (s == null) return [\n            n,\n            null\n        ];\n        if (typeof s == \"number\") return [\n            s,\n            null\n        ];\n        if (typeof s == \"string\") {\n            if (!i) return [\n                n,\n                null\n            ];\n            let F = J(s, i);\n            return [\n                F,\n                (E)=>{\n                    let v = D(s);\n                    {\n                        let c = v.map((P)=>window.getComputedStyle(i).getPropertyValue(P));\n                        l.requestAnimationFrame(function P() {\n                            l.nextFrame(P);\n                            let a = !1;\n                            for (let [b, w] of v.entries()){\n                                let g = window.getComputedStyle(i).getPropertyValue(w);\n                                if (c[b] !== g) {\n                                    c[b] = g, a = !0;\n                                    break;\n                                }\n                            }\n                            if (!a) return;\n                            let p = J(s, i);\n                            F !== p && (E(p), F = p);\n                        });\n                    }\n                    return l.dispose;\n                }\n            ];\n        }\n        return [\n            n,\n            null\n        ];\n    }), o = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>r(e, t)[0], [\n        e,\n        t\n    ]), [u = o, f] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)();\n    return (0,_hooks_use_iso_morphic_effect_js__WEBPACK_IMPORTED_MODULE_1__.useIsoMorphicEffect)(()=>{\n        let [s, i] = r(e, t);\n        if (f(s), !!i) return i(f);\n    }, [\n        e,\n        t\n    ]), u;\n}\n_c3 = V;\nfunction D(e) {\n    let t = /var\\((.*)\\)/.exec(e);\n    if (t) {\n        let n = t[1].indexOf(\",\");\n        if (n === -1) return [\n            t[1]\n        ];\n        let l = t[1].slice(0, n).trim(), r = t[1].slice(n + 1).trim();\n        return r ? [\n            l,\n            ...D(r)\n        ] : [\n            l\n        ];\n    }\n    return [];\n}\n_c4 = D;\nfunction J(e, t) {\n    let n = document.createElement(\"div\");\n    t.appendChild(n), n.style.setProperty(\"margin-top\", \"0px\", \"important\"), n.style.setProperty(\"margin-top\", e, \"important\");\n    let l = parseFloat(window.getComputedStyle(n).marginTop) || 0;\n    return t.removeChild(n), l;\n}\n_c5 = J;\n\nvar _c, _c1, _c2, _c3, _c4, _c5;\n$RefreshReg$(_c, \"Fe\");\n$RefreshReg$(_c1, \"Re\");\n$RefreshReg$(_c2, \"Me\");\n$RefreshReg$(_c3, \"V\");\n$RefreshReg$(_c4, \"D\");\n$RefreshReg$(_c5, \"J\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQGhlYWRsZXNzdWkvcmVhY3QvZGlzdC9pbnRlcm5hbC9mbG9hdGluZy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7O0FBQXdLO0FBQXdCO0FBQWdIO0FBQThEO0FBQWlEO0FBQXlFO0FBQUEsSUFBSXFDLGtCQUFFakIsb0RBQUNBLENBQUM7SUFBQ2tCLFFBQU8sS0FBSztJQUFFQyxjQUFhLEtBQUs7SUFBRUMsYUFBWSxLQUFLO0lBQUVDLG1CQUFrQixJQUFLLEVBQUM7SUFBR0Msa0JBQWlCLElBQUssRUFBQztJQUFHQyxNQUFLLENBQUM7QUFBQztBQUFHTixFQUFFTyxXQUFXLEdBQUM7QUFBa0IsSUFBSUMsa0JBQUV6QixvREFBQ0EsQ0FBQztBQUFNeUIsRUFBRUQsV0FBVyxHQUFDO0FBQW1CLFNBQVNFLEdBQUdDLENBQUM7SUFBRSxPQUFPckIsOENBQUNBLENBQUMsSUFBSXFCLElBQUUsT0FBT0EsS0FBRyxXQUFTO1lBQUNDLElBQUdEO1FBQUMsSUFBRUEsSUFBRSxNQUFLO1FBQUNBO0tBQUU7QUFBQztBQUFDLFNBQVNFO0lBQUssT0FBT3pCLGlEQUFDQSxDQUFDYSxHQUFHRSxZQUFZO0FBQUE7QUFBQyxTQUFTVztJQUFLLE9BQU8xQixpREFBQ0EsQ0FBQ2EsR0FBR0ksaUJBQWlCO0FBQUE7S0FBbENTO0FBQW1DLFNBQVNDO0lBQUssSUFBRyxFQUFDVCxrQkFBaUJLLENBQUMsRUFBQ0osTUFBS1MsQ0FBQyxFQUFDLEdBQUM1QixpREFBQ0EsQ0FBQ2E7SUFBRyxPQUFPZixrREFBRUEsQ0FBQzt5Q0FBSStCO1lBQUFBOztlQUFJQyxPQUFPQyxNQUFNLENBQUMsQ0FBQyxHQUFFUixLQUFLTSxJQUFHO1lBQUMsZUFBY0QsRUFBRUksTUFBTTtRQUFBO09BQUc7UUFBQ1Q7UUFBRUs7S0FBRTtBQUFDO0FBQUMsU0FBU0s7UUFBR1YsSUFBQUEsaUVBQUU7SUFBTUEsTUFBSSxDQUFD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R1c7QUFBQztNQUFuUGdHO0FBQXlaIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQGhlYWRsZXNzdWkvcmVhY3QvZGlzdC9pbnRlcm5hbC9mbG9hdGluZy5qcz85YmM2Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydHthdXRvVXBkYXRlIGFzIFosZmxpcCBhcyBlZSxpbm5lciBhcyB0ZSxvZmZzZXQgYXMgbmUsc2hpZnQgYXMgbGUsc2l6ZSBhcyByZSx1c2VGbG9hdGluZyBhcyBvZSx1c2VJbm5lck9mZnNldCBhcyBpZSx1c2VJbnRlcmFjdGlvbnMgYXMgc2V9ZnJvbVwiQGZsb2F0aW5nLXVpL3JlYWN0XCI7aW1wb3J0KmFzIGogZnJvbVwicmVhY3RcIjtpbXBvcnR7Y3JlYXRlQ29udGV4dCBhcyBfLHVzZUNhbGxiYWNrIGFzIGFlLHVzZUNvbnRleHQgYXMgUix1c2VNZW1vIGFzIE0sdXNlUmVmIGFzIHVlLHVzZVN0YXRlIGFzIEF9ZnJvbVwicmVhY3RcIjtpbXBvcnR7dXNlRGlzcG9zYWJsZXMgYXMgZmV9ZnJvbScuLi9ob29rcy91c2UtZGlzcG9zYWJsZXMuanMnO2ltcG9ydHt1c2VFdmVudCBhcyB6fWZyb20nLi4vaG9va3MvdXNlLWV2ZW50LmpzJztpbXBvcnR7dXNlSXNvTW9ycGhpY0VmZmVjdCBhcyBDfWZyb20nLi4vaG9va3MvdXNlLWlzby1tb3JwaGljLWVmZmVjdC5qcyc7bGV0IHk9Xyh7c3R5bGVzOnZvaWQgMCxzZXRSZWZlcmVuY2U6KCk9Pnt9LHNldEZsb2F0aW5nOigpPT57fSxnZXRSZWZlcmVuY2VQcm9wczooKT0+KHt9KSxnZXRGbG9hdGluZ1Byb3BzOigpPT4oe30pLHNsb3Q6e319KTt5LmRpc3BsYXlOYW1lPVwiRmxvYXRpbmdDb250ZXh0XCI7bGV0IEg9XyhudWxsKTtILmRpc3BsYXlOYW1lPVwiUGxhY2VtZW50Q29udGV4dFwiO2Z1bmN0aW9uIHhlKGUpe3JldHVybiBNKCgpPT5lP3R5cGVvZiBlPT1cInN0cmluZ1wiP3t0bzplfTplOm51bGwsW2VdKX1mdW5jdGlvbiB5ZSgpe3JldHVybiBSKHkpLnNldFJlZmVyZW5jZX1mdW5jdGlvbiBGZSgpe3JldHVybiBSKHkpLmdldFJlZmVyZW5jZVByb3BzfWZ1bmN0aW9uIGJlKCl7bGV0e2dldEZsb2F0aW5nUHJvcHM6ZSxzbG90OnR9PVIoeSk7cmV0dXJuIGFlKCguLi5uKT0+T2JqZWN0LmFzc2lnbih7fSxlKC4uLm4pLHtcImRhdGEtYW5jaG9yXCI6dC5hbmNob3J9KSxbZSx0XSl9ZnVuY3Rpb24gUmUoZT1udWxsKXtlPT09ITEmJihlPW51bGwpLHR5cGVvZiBlPT1cInN0cmluZ1wiJiYoZT17dG86ZX0pO2xldCB0PVIoSCksbj1NKCgpPT5lLFtKU09OLnN0cmluZ2lmeShlLChyLG8pPT57dmFyIHU7cmV0dXJuKHU9bz09bnVsbD92b2lkIDA6by5vdXRlckhUTUwpIT1udWxsP3U6b30pXSk7QygoKT0+e3Q9PW51bGx8fHQobiE9bnVsbD9uOm51bGwpfSxbdCxuXSk7bGV0IGw9Uih5KTtyZXR1cm4gTSgoKT0+W2wuc2V0RmxvYXRpbmcsZT9sLnN0eWxlczp7fV0sW2wuc2V0RmxvYXRpbmcsZSxsLnN0eWxlc10pfWxldCBxPTQ7ZnVuY3Rpb24gTWUoe2NoaWxkcmVuOmUsZW5hYmxlZDp0PSEwfSl7bGV0W24sbF09QShudWxsKSxbcixvXT1BKDApLHU9dWUobnVsbCksW2Ysc109QShudWxsKTtwZShmKTtsZXQgaT10JiZuIT09bnVsbCYmZiE9PW51bGwse3RvOkY9XCJib3R0b21cIixnYXA6RT0wLG9mZnNldDp2PTAscGFkZGluZzpjPTAsaW5uZXI6UH09Y2UobixmKSxbYSxwPVwiY2VudGVyXCJdPUYuc3BsaXQoXCIgXCIpO0MoKCk9PntpJiZvKDApfSxbaV0pO2xldHtyZWZzOmIsZmxvYXRpbmdTdHlsZXM6dyxjb250ZXh0Omd9PW9lKHtvcGVuOmkscGxhY2VtZW50OmE9PT1cInNlbGVjdGlvblwiP3A9PT1cImNlbnRlclwiP1wiYm90dG9tXCI6YGJvdHRvbS0ke3B9YDpwPT09XCJjZW50ZXJcIj9gJHthfWA6YCR7YX0tJHtwfWAsc3RyYXRlZ3k6XCJhYnNvbHV0ZVwiLHRyYW5zZm9ybTohMSxtaWRkbGV3YXJlOltuZSh7bWFpbkF4aXM6YT09PVwic2VsZWN0aW9uXCI/MDpFLGNyb3NzQXhpczp2fSksbGUoe3BhZGRpbmc6Y30pLGEhPT1cInNlbGVjdGlvblwiJiZlZSh7cGFkZGluZzpjfSksYT09PVwic2VsZWN0aW9uXCImJlA/dGUoey4uLlAscGFkZGluZzpjLG92ZXJmbG93UmVmOnUsb2Zmc2V0OnIsbWluSXRlbXNWaXNpYmxlOnEscmVmZXJlbmNlT3ZlcmZsb3dUaHJlc2hvbGQ6YyxvbkZhbGxiYWNrQ2hhbmdlKGgpe3ZhciBPLFc7aWYoIWgpcmV0dXJuO2xldCBkPWcuZWxlbWVudHMuZmxvYXRpbmc7aWYoIWQpcmV0dXJuO2xldCBUPXBhcnNlRmxvYXQoZ2V0Q29tcHV0ZWRTdHlsZShkKS5zY3JvbGxQYWRkaW5nQm90dG9tKXx8MCwkPU1hdGgubWluKHEsZC5jaGlsZEVsZW1lbnRDb3VudCksTD0wLE49MDtmb3IobGV0IG0gb2YoVz0oTz1nLmVsZW1lbnRzLmZsb2F0aW5nKT09bnVsbD92b2lkIDA6Ty5jaGlsZE5vZGVzKSE9bnVsbD9XOltdKWlmKG0gaW5zdGFuY2VvZiBIVE1MRWxlbWVudCl7bGV0IHg9bS5vZmZzZXRUb3Asaz14K20uY2xpZW50SGVpZ2h0K1QsUz1kLnNjcm9sbFRvcCxVPVMrZC5jbGllbnRIZWlnaHQ7aWYoeD49UyYmazw9VSkkLS07ZWxzZXtOPU1hdGgubWF4KDAsTWF0aC5taW4oayxVKS1NYXRoLm1heCh4LFMpKSxMPW0uY2xpZW50SGVpZ2h0O2JyZWFrfX0kPj0xJiZvKG09PntsZXQgeD1MKiQtTitUO3JldHVybiBtPj14P206eH0pfX0pOm51bGwscmUoe3BhZGRpbmc6YyxhcHBseSh7YXZhaWxhYmxlV2lkdGg6aCxhdmFpbGFibGVIZWlnaHQ6ZCxlbGVtZW50czpUfSl7T2JqZWN0LmFzc2lnbihULmZsb2F0aW5nLnN0eWxlLHtvdmVyZmxvdzpcImF1dG9cIixtYXhXaWR0aDpgJHtofXB4YCxtYXhIZWlnaHQ6YG1pbih2YXIoLS1hbmNob3ItbWF4LWhlaWdodCwgMTAwdmgpLCAke2R9cHgpYH0pfX0pXS5maWx0ZXIoQm9vbGVhbiksd2hpbGVFbGVtZW50c01vdW50ZWQ6Wn0pLFtJPWEsQj1wXT1nLnBsYWNlbWVudC5zcGxpdChcIi1cIik7YT09PVwic2VsZWN0aW9uXCImJihJPVwic2VsZWN0aW9uXCIpO2xldCBHPU0oKCk9Pih7YW5jaG9yOltJLEJdLmZpbHRlcihCb29sZWFuKS5qb2luKFwiIFwiKX0pLFtJLEJdKSxLPWllKGcse292ZXJmbG93UmVmOnUsb25DaGFuZ2U6b30pLHtnZXRSZWZlcmVuY2VQcm9wczpRLGdldEZsb2F0aW5nUHJvcHM6WH09c2UoW0tdKSxZPXooaD0+e3MoaCksYi5zZXRGbG9hdGluZyhoKX0pO3JldHVybiBqLmNyZWF0ZUVsZW1lbnQoSC5Qcm92aWRlcix7dmFsdWU6bH0sai5jcmVhdGVFbGVtZW50KHkuUHJvdmlkZXIse3ZhbHVlOntzZXRGbG9hdGluZzpZLHNldFJlZmVyZW5jZTpiLnNldFJlZmVyZW5jZSxzdHlsZXM6dyxnZXRSZWZlcmVuY2VQcm9wczpRLGdldEZsb2F0aW5nUHJvcHM6WCxzbG90Okd9fSxlKSl9ZnVuY3Rpb24gcGUoZSl7QygoKT0+e2lmKCFlKXJldHVybjtsZXQgdD1uZXcgTXV0YXRpb25PYnNlcnZlcigoKT0+e2xldCBuPXdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGUpLm1heEhlaWdodCxsPXBhcnNlRmxvYXQobik7aWYoaXNOYU4obCkpcmV0dXJuO2xldCByPXBhcnNlSW50KG4pO2lzTmFOKHIpfHxsIT09ciYmKGUuc3R5bGUubWF4SGVpZ2h0PWAke01hdGguY2VpbChsKX1weGApfSk7cmV0dXJuIHQub2JzZXJ2ZShlLHthdHRyaWJ1dGVzOiEwLGF0dHJpYnV0ZUZpbHRlcjpbXCJzdHlsZVwiXX0pLCgpPT57dC5kaXNjb25uZWN0KCl9fSxbZV0pfWZ1bmN0aW9uIGNlKGUsdCl7dmFyIG8sdSxmO2xldCBuPVYoKG89ZT09bnVsbD92b2lkIDA6ZS5nYXApIT1udWxsP286XCJ2YXIoLS1hbmNob3ItZ2FwLCAwKVwiLHQpLGw9VigodT1lPT1udWxsP3ZvaWQgMDplLm9mZnNldCkhPW51bGw/dTpcInZhcigtLWFuY2hvci1vZmZzZXQsIDApXCIsdCkscj1WKChmPWU9PW51bGw/dm9pZCAwOmUucGFkZGluZykhPW51bGw/ZjpcInZhcigtLWFuY2hvci1wYWRkaW5nLCAwKVwiLHQpO3JldHVybnsuLi5lLGdhcDpuLG9mZnNldDpsLHBhZGRpbmc6cn19ZnVuY3Rpb24gVihlLHQsbj12b2lkIDApe2xldCBsPWZlKCkscj16KChzLGkpPT57aWYocz09bnVsbClyZXR1cm5bbixudWxsXTtpZih0eXBlb2Ygcz09XCJudW1iZXJcIilyZXR1cm5bcyxudWxsXTtpZih0eXBlb2Ygcz09XCJzdHJpbmdcIil7aWYoIWkpcmV0dXJuW24sbnVsbF07bGV0IEY9SihzLGkpO3JldHVybltGLEU9PntsZXQgdj1EKHMpO3tsZXQgYz12Lm1hcChQPT53aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShpKS5nZXRQcm9wZXJ0eVZhbHVlKFApKTtsLnJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbiBQKCl7bC5uZXh0RnJhbWUoUCk7bGV0IGE9ITE7Zm9yKGxldFtiLHddb2Ygdi5lbnRyaWVzKCkpe2xldCBnPXdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGkpLmdldFByb3BlcnR5VmFsdWUodyk7aWYoY1tiXSE9PWcpe2NbYl09ZyxhPSEwO2JyZWFrfX1pZighYSlyZXR1cm47bGV0IHA9SihzLGkpO0YhPT1wJiYoRShwKSxGPXApfSl9cmV0dXJuIGwuZGlzcG9zZX1dfXJldHVybltuLG51bGxdfSksbz1NKCgpPT5yKGUsdClbMF0sW2UsdF0pLFt1PW8sZl09QSgpO3JldHVybiBDKCgpPT57bGV0W3MsaV09cihlLHQpO2lmKGYocyksISFpKXJldHVybiBpKGYpfSxbZSx0XSksdX1mdW5jdGlvbiBEKGUpe2xldCB0PS92YXJcXCgoLiopXFwpLy5leGVjKGUpO2lmKHQpe2xldCBuPXRbMV0uaW5kZXhPZihcIixcIik7aWYobj09PS0xKXJldHVyblt0WzFdXTtsZXQgbD10WzFdLnNsaWNlKDAsbikudHJpbSgpLHI9dFsxXS5zbGljZShuKzEpLnRyaW0oKTtyZXR1cm4gcj9bbCwuLi5EKHIpXTpbbF19cmV0dXJuW119ZnVuY3Rpb24gSihlLHQpe2xldCBuPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7dC5hcHBlbmRDaGlsZChuKSxuLnN0eWxlLnNldFByb3BlcnR5KFwibWFyZ2luLXRvcFwiLFwiMHB4XCIsXCJpbXBvcnRhbnRcIiksbi5zdHlsZS5zZXRQcm9wZXJ0eShcIm1hcmdpbi10b3BcIixlLFwiaW1wb3J0YW50XCIpO2xldCBsPXBhcnNlRmxvYXQod2luZG93LmdldENvbXB1dGVkU3R5bGUobikubWFyZ2luVG9wKXx8MDtyZXR1cm4gdC5yZW1vdmVDaGlsZChuKSxsfWV4cG9ydHtNZSBhcyBGbG9hdGluZ1Byb3ZpZGVyLFJlIGFzIHVzZUZsb2F0aW5nUGFuZWwsYmUgYXMgdXNlRmxvYXRpbmdQYW5lbFByb3BzLHllIGFzIHVzZUZsb2F0aW5nUmVmZXJlbmNlLEZlIGFzIHVzZUZsb2F0aW5nUmVmZXJlbmNlUHJvcHMseGUgYXMgdXNlUmVzb2x2ZWRBbmNob3J9O1xuIl0sIm5hbWVzIjpbImF1dG9VcGRhdGUiLCJaIiwiZmxpcCIsImVlIiwiaW5uZXIiLCJ0ZSIsIm9mZnNldCIsIm5lIiwic2hpZnQiLCJsZSIsInNpemUiLCJyZSIsInVzZUZsb2F0aW5nIiwib2UiLCJ1c2VJbm5lck9mZnNldCIsImllIiwidXNlSW50ZXJhY3Rpb25zIiwic2UiLCJqIiwiY3JlYXRlQ29udGV4dCIsIl8iLCJ1c2VDYWxsYmFjayIsImFlIiwidXNlQ29udGV4dCIsIlIiLCJ1c2VNZW1vIiwiTSIsInVzZVJlZiIsInVlIiwidXNlU3RhdGUiLCJBIiwidXNlRGlzcG9zYWJsZXMiLCJmZSIsInVzZUV2ZW50IiwieiIsInVzZUlzb01vcnBoaWNFZmZlY3QiLCJDIiwieSIsInN0eWxlcyIsInNldFJlZmVyZW5jZSIsInNldEZsb2F0aW5nIiwiZ2V0UmVmZXJlbmNlUHJvcHMiLCJnZXRGbG9hdGluZ1Byb3BzIiwic2xvdCIsImRpc3BsYXlOYW1lIiwiSCIsInhlIiwiZSIsInRvIiwieWUiLCJGZSIsImJlIiwidCIsIm4iLCJPYmplY3QiLCJhc3NpZ24iLCJhbmNob3IiLCJSZSIsIkpTT04iLCJzdHJpbmdpZnkiLCJyIiwibyIsInUiLCJvdXRlckhUTUwiLCJsIiwicSIsIk1lIiwiY2hpbGRyZW4iLCJlbmFibGVkIiwiZiIsInMiLCJwZSIsImkiLCJGIiwiZ2FwIiwiRSIsInYiLCJwYWRkaW5nIiwiYyIsIlAiLCJjZSIsImEiLCJwIiwic3BsaXQiLCJyZWZzIiwiYiIsImZsb2F0aW5nU3R5bGVzIiwidyIsImNvbnRleHQiLCJnIiwib3BlbiIsInBsYWNlbWVudCIsInN0cmF0ZWd5IiwidHJhbnNmb3JtIiwibWlkZGxld2FyZSIsIm1haW5BeGlzIiwiY3Jvc3NBeGlzIiwib3ZlcmZsb3dSZWYiLCJtaW5JdGVtc1Zpc2libGUiLCJyZWZlcmVuY2VPdmVyZmxvd1RocmVzaG9sZCIsIm9uRmFsbGJhY2tDaGFuZ2UiLCJoIiwiTyIsIlciLCJkIiwiZWxlbWVudHMiLCJmbG9hdGluZyIsIlQiLCJwYXJzZUZsb2F0IiwiZ2V0Q29tcHV0ZWRTdHlsZSIsInNjcm9sbFBhZGRpbmdCb3R0b20iLCIkIiwiTWF0aCIsIm1pbiIsImNoaWxkRWxlbWVudENvdW50IiwiTCIsIk4iLCJtIiwiY2hpbGROb2RlcyIsIkhUTUxFbGVtZW50IiwieCIsIm9mZnNldFRvcCIsImsiLCJjbGllbnRIZWlnaHQiLCJTIiwic2Nyb2xsVG9wIiwiVSIsIm1heCIsImFwcGx5IiwiYXZhaWxhYmxlV2lkdGgiLCJhdmFpbGFibGVIZWlnaHQiLCJzdHlsZSIsIm92ZXJmbG93IiwibWF4V2lkdGgiLCJtYXhIZWlnaHQiLCJmaWx0ZXIiLCJCb29sZWFuIiwid2hpbGVFbGVtZW50c01vdW50ZWQiLCJJIiwiQiIsIkciLCJqb2luIiwiSyIsIm9uQ2hhbmdlIiwiUSIsIlgiLCJZIiwiY3JlYXRlRWxlbWVudCIsIlByb3ZpZGVyIiwidmFsdWUiLCJNdXRhdGlvbk9ic2VydmVyIiwid2luZG93IiwiaXNOYU4iLCJwYXJzZUludCIsImNlaWwiLCJvYnNlcnZlIiwiYXR0cmlidXRlcyIsImF0dHJpYnV0ZUZpbHRlciIsImRpc2Nvbm5lY3QiLCJWIiwiSiIsIkQiLCJtYXAiLCJnZXRQcm9wZXJ0eVZhbHVlIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwibmV4dEZyYW1lIiwiZW50cmllcyIsImRpc3Bvc2UiLCJleGVjIiwiaW5kZXhPZiIsInNsaWNlIiwidHJpbSIsImRvY3VtZW50IiwiYXBwZW5kQ2hpbGQiLCJzZXRQcm9wZXJ0eSIsIm1hcmdpblRvcCIsInJlbW92ZUNoaWxkIiwiRmxvYXRpbmdQcm92aWRlciIsInVzZUZsb2F0aW5nUGFuZWwiLCJ1c2VGbG9hdGluZ1BhbmVsUHJvcHMiLCJ1c2VGbG9hdGluZ1JlZmVyZW5jZSIsInVzZUZsb2F0aW5nUmVmZXJlbmNlUHJvcHMiLCJ1c2VSZXNvbHZlZEFuY2hvciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../../../node_modules/@headlessui/react/dist/internal/floating.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../../../node_modules/@headlessui/react/dist/internal/id.js":
/*!**********************************************************************!*\
  !*** ../../../../node_modules/@headlessui/react/dist/internal/id.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   IdProvider: function() { return /* binding */ f; },\n/* harmony export */   useProvidedId: function() { return /* binding */ u; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n\nlet e = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(void 0);\nfunction u() {\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(e);\n}\nfunction f(param) {\n    let { id: t, children: r } = param;\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(e.Provider, {\n        value: t\n    }, r);\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQGhlYWRsZXNzdWkvcmVhY3QvZGlzdC9pbnRlcm5hbC9pZC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBeUQ7QUFBQSxJQUFJSyxrQkFBRUgsb0RBQUNBLENBQUMsS0FBSztBQUFHLFNBQVNJO0lBQUksT0FBT0YsaURBQUNBLENBQUNDO0FBQUU7QUFBQyxTQUFTRSxFQUFFLEtBQWlCO1FBQWpCLEVBQUNDLElBQUdDLENBQUMsRUFBQ0MsVUFBU0MsQ0FBQyxFQUFDLEdBQWpCO0lBQW1CLHFCQUFPWCxnREFBZSxDQUFDSyxFQUFFUSxRQUFRLEVBQUM7UUFBQ0MsT0FBTUw7SUFBQyxHQUFFRTtBQUFFO0FBQTRDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQGhlYWRsZXNzdWkvcmVhY3QvZGlzdC9pbnRlcm5hbC9pZC5qcz84NTYwIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBuLHtjcmVhdGVDb250ZXh0IGFzIGQsdXNlQ29udGV4dCBhcyBpfWZyb21cInJlYWN0XCI7bGV0IGU9ZCh2b2lkIDApO2Z1bmN0aW9uIHUoKXtyZXR1cm4gaShlKX1mdW5jdGlvbiBmKHtpZDp0LGNoaWxkcmVuOnJ9KXtyZXR1cm4gbi5jcmVhdGVFbGVtZW50KGUuUHJvdmlkZXIse3ZhbHVlOnR9LHIpfWV4cG9ydHtmIGFzIElkUHJvdmlkZXIsdSBhcyB1c2VQcm92aWRlZElkfTtcbiJdLCJuYW1lcyI6WyJuIiwiY3JlYXRlQ29udGV4dCIsImQiLCJ1c2VDb250ZXh0IiwiaSIsImUiLCJ1IiwiZiIsImlkIiwidCIsImNoaWxkcmVuIiwiciIsImNyZWF0ZUVsZW1lbnQiLCJQcm92aWRlciIsInZhbHVlIiwiSWRQcm92aWRlciIsInVzZVByb3ZpZGVkSWQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../../../node_modules/@headlessui/react/dist/internal/id.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../../../node_modules/@headlessui/react/dist/machine.js":
/*!******************************************************************!*\
  !*** ../../../../node_modules/@headlessui/react/dist/machine.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Machine: function() { return /* binding */ m; },\n/* harmony export */   batch: function() { return /* binding */ g; },\n/* harmony export */   shallowEqual: function() { return /* binding */ h; }\n/* harmony export */ });\n/* harmony import */ var _utils_default_map_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/default-map.js */ \"(app-pages-browser)/../../../../node_modules/@headlessui/react/dist/utils/default-map.js\");\n/* harmony import */ var _utils_disposables_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils/disposables.js */ \"(app-pages-browser)/../../../../node_modules/@headlessui/react/dist/utils/disposables.js\");\nvar f = (t, e, r)=>{\n    if (!e.has(t)) throw TypeError(\"Cannot \" + r);\n};\nvar a = (t, e, r)=>(f(t, e, \"read from private field\"), r ? r.call(t) : e.get(t)), l = (t, e, r)=>{\n    if (e.has(t)) throw TypeError(\"Cannot add the same private member more than once\");\n    e instanceof WeakSet ? e.add(t) : e.set(t, r);\n}, c = (t, e, r, n)=>(f(t, e, \"write to private field\"), n ? n.call(t, r) : e.set(t, r), r);\nvar i, s, o;\n\n\nclass m {\n    get state() {\n        return a(this, i);\n    }\n    subscribe(e, r) {\n        let n = {\n            selector: e,\n            callback: r,\n            current: e(a(this, i))\n        };\n        return a(this, o).add(n), ()=>{\n            a(this, o).delete(n);\n        };\n    }\n    on(e, r) {\n        return a(this, s).get(e).add(r), ()=>{\n            a(this, s).get(e).delete(r);\n        };\n    }\n    send(e) {\n        c(this, i, this.reduce(a(this, i), e));\n        for (let r of a(this, o)){\n            let n = r.selector(a(this, i));\n            h(r.current, n) || (r.current = n, r.callback(n));\n        }\n        for (let r of a(this, s).get(e.type))r(a(this, i), e);\n    }\n    constructor(e){\n        l(this, i, {});\n        l(this, s, new _utils_default_map_js__WEBPACK_IMPORTED_MODULE_0__.DefaultMap(()=>new Set));\n        l(this, o, new Set);\n        c(this, i, e);\n    }\n}\ni = new WeakMap, s = new WeakMap, o = new WeakMap;\nfunction h(t, e) {\n    return Object.is(t, e) ? !0 : typeof t != \"object\" || t === null || typeof e != \"object\" || e === null ? !1 : Array.isArray(t) && Array.isArray(e) ? t.length !== e.length ? !1 : u(t[Symbol.iterator](), e[Symbol.iterator]()) : t instanceof Map && e instanceof Map || t instanceof Set && e instanceof Set ? t.size !== e.size ? !1 : u(t.entries(), e.entries()) : S(t) && S(e) ? u(Object.entries(t)[Symbol.iterator](), Object.entries(e)[Symbol.iterator]()) : !1;\n}\nfunction u(t, e) {\n    do {\n        let r = t.next(), n = e.next();\n        if (r.done && n.done) return !0;\n        if (r.done || n.done || !Object.is(r.value, n.value)) return !1;\n    }while (!0);\n}\nfunction S(t) {\n    if (Object.prototype.toString.call(t) !== \"[object Object]\") return !1;\n    let e = Object.getPrototypeOf(t);\n    return e === null || Object.getPrototypeOf(e) === null;\n}\n_c = S;\nfunction g(t) {\n    let [e, r] = t(), n = (0,_utils_disposables_js__WEBPACK_IMPORTED_MODULE_1__.disposables)();\n    return function() {\n        for(var _len = arguments.length, b = new Array(_len), _key = 0; _key < _len; _key++){\n            b[_key] = arguments[_key];\n        }\n        e(...b), n.dispose(), n.microTask(r);\n    };\n}\n\nvar _c;\n$RefreshReg$(_c, \"S\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQGhlYWRsZXNzdWkvcmVhY3QvZGlzdC9tYWNoaW5lLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUEsSUFBSUEsSUFBRSxDQUFDQyxHQUFFQyxHQUFFQztJQUFLLElBQUcsQ0FBQ0QsRUFBRUUsR0FBRyxDQUFDSCxJQUFHLE1BQU1JLFVBQVUsWUFBVUY7QUFBRTtBQUFFLElBQUlHLElBQUUsQ0FBQ0wsR0FBRUMsR0FBRUMsSUFBS0gsQ0FBQUEsRUFBRUMsR0FBRUMsR0FBRSw0QkFBMkJDLElBQUVBLEVBQUVJLElBQUksQ0FBQ04sS0FBR0MsRUFBRU0sR0FBRyxDQUFDUCxFQUFDLEdBQUdRLElBQUUsQ0FBQ1IsR0FBRUMsR0FBRUM7SUFBSyxJQUFHRCxFQUFFRSxHQUFHLENBQUNILElBQUcsTUFBTUksVUFBVTtJQUFxREgsYUFBYVEsVUFBUVIsRUFBRVMsR0FBRyxDQUFDVixLQUFHQyxFQUFFVSxHQUFHLENBQUNYLEdBQUVFO0FBQUUsR0FBRVUsSUFBRSxDQUFDWixHQUFFQyxHQUFFQyxHQUFFVyxJQUFLZCxDQUFBQSxFQUFFQyxHQUFFQyxHQUFFLDJCQUEwQlksSUFBRUEsRUFBRVAsSUFBSSxDQUFDTixHQUFFRSxLQUFHRCxFQUFFVSxHQUFHLENBQUNYLEdBQUVFLElBQUdBLENBQUFBO0FBQUcsSUFBSVksR0FBRUMsR0FBRUM7QUFBc0Q7QUFBcUQ7QUFBQSxNQUFNSztJQUF5RixJQUFJQyxRQUFPO1FBQUMsT0FBT2pCLEVBQUUsSUFBSSxFQUFDUztJQUFFO0lBQUNTLFVBQVV0QixDQUFDLEVBQUNDLENBQUMsRUFBQztRQUFDLElBQUlXLElBQUU7WUFBQ1csVUFBU3ZCO1lBQUV3QixVQUFTdkI7WUFBRXdCLFNBQVF6QixFQUFFSSxFQUFFLElBQUksRUFBQ1M7UUFBRztRQUFFLE9BQU9ULEVBQUUsSUFBSSxFQUFDVyxHQUFHTixHQUFHLENBQUNHLElBQUc7WUFBS1IsRUFBRSxJQUFJ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U0FBUyxDQUFDQyxRQUFRLENBQUM5QyxJQUFJLENBQUNOLE9BQUssbUJBQWtCLE9BQU0sQ0FBQztJQUFFLElBQUlDLElBQUVtQyxPQUFPaUIsY0FBYyxDQUFDckQ7SUFBRyxPQUFPQyxNQUFJLFFBQU1tQyxPQUFPaUIsY0FBYyxDQUFDcEQsT0FBSztBQUFJO0tBQXRKOEM7QUFBdUosU0FBU08sRUFBRXRELENBQUM7SUFBRSxJQUFHLENBQUNDLEdBQUVDLEVBQUUsR0FBQ0YsS0FBSWEsSUFBRU8sa0VBQUNBO0lBQUcsT0FBTTt5Q0FBSW1DO1lBQUFBOztRQUFLdEQsS0FBS3NELElBQUcxQyxFQUFFMkMsT0FBTyxJQUFHM0MsRUFBRTRDLFNBQVMsQ0FBQ3ZEO0lBQUU7QUFBQztBQUFtRCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BoZWFkbGVzc3VpL3JlYWN0L2Rpc3QvbWFjaGluZS5qcz82MzhiIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBmPSh0LGUscik9PntpZighZS5oYXModCkpdGhyb3cgVHlwZUVycm9yKFwiQ2Fubm90IFwiK3IpfTt2YXIgYT0odCxlLHIpPT4oZih0LGUsXCJyZWFkIGZyb20gcHJpdmF0ZSBmaWVsZFwiKSxyP3IuY2FsbCh0KTplLmdldCh0KSksbD0odCxlLHIpPT57aWYoZS5oYXModCkpdGhyb3cgVHlwZUVycm9yKFwiQ2Fubm90IGFkZCB0aGUgc2FtZSBwcml2YXRlIG1lbWJlciBtb3JlIHRoYW4gb25jZVwiKTtlIGluc3RhbmNlb2YgV2Vha1NldD9lLmFkZCh0KTplLnNldCh0LHIpfSxjPSh0LGUscixuKT0+KGYodCxlLFwid3JpdGUgdG8gcHJpdmF0ZSBmaWVsZFwiKSxuP24uY2FsbCh0LHIpOmUuc2V0KHQscikscik7dmFyIGkscyxvO2ltcG9ydHtEZWZhdWx0TWFwIGFzIGR9ZnJvbScuL3V0aWxzL2RlZmF1bHQtbWFwLmpzJztpbXBvcnR7ZGlzcG9zYWJsZXMgYXMgeX1mcm9tJy4vdXRpbHMvZGlzcG9zYWJsZXMuanMnO2NsYXNzIG17Y29uc3RydWN0b3IoZSl7bCh0aGlzLGkse30pO2wodGhpcyxzLG5ldyBkKCgpPT5uZXcgU2V0KSk7bCh0aGlzLG8sbmV3IFNldCk7Yyh0aGlzLGksZSl9Z2V0IHN0YXRlKCl7cmV0dXJuIGEodGhpcyxpKX1zdWJzY3JpYmUoZSxyKXtsZXQgbj17c2VsZWN0b3I6ZSxjYWxsYmFjazpyLGN1cnJlbnQ6ZShhKHRoaXMsaSkpfTtyZXR1cm4gYSh0aGlzLG8pLmFkZChuKSwoKT0+e2EodGhpcyxvKS5kZWxldGUobil9fW9uKGUscil7cmV0dXJuIGEodGhpcyxzKS5nZXQoZSkuYWRkKHIpLCgpPT57YSh0aGlzLHMpLmdldChlKS5kZWxldGUocil9fXNlbmQoZSl7Yyh0aGlzLGksdGhpcy5yZWR1Y2UoYSh0aGlzLGkpLGUpKTtmb3IobGV0IHIgb2YgYSh0aGlzLG8pKXtsZXQgbj1yLnNlbGVjdG9yKGEodGhpcyxpKSk7aChyLmN1cnJlbnQsbil8fChyLmN1cnJlbnQ9bixyLmNhbGxiYWNrKG4pKX1mb3IobGV0IHIgb2YgYSh0aGlzLHMpLmdldChlLnR5cGUpKXIoYSh0aGlzLGkpLGUpfX1pPW5ldyBXZWFrTWFwLHM9bmV3IFdlYWtNYXAsbz1uZXcgV2Vha01hcDtmdW5jdGlvbiBoKHQsZSl7cmV0dXJuIE9iamVjdC5pcyh0LGUpPyEwOnR5cGVvZiB0IT1cIm9iamVjdFwifHx0PT09bnVsbHx8dHlwZW9mIGUhPVwib2JqZWN0XCJ8fGU9PT1udWxsPyExOkFycmF5LmlzQXJyYXkodCkmJkFycmF5LmlzQXJyYXkoZSk/dC5sZW5ndGghPT1lLmxlbmd0aD8hMTp1KHRbU3ltYm9sLml0ZXJhdG9yXSgpLGVbU3ltYm9sLml0ZXJhdG9yXSgpKTp0IGluc3RhbmNlb2YgTWFwJiZlIGluc3RhbmNlb2YgTWFwfHx0IGluc3RhbmNlb2YgU2V0JiZlIGluc3RhbmNlb2YgU2V0P3Quc2l6ZSE9PWUuc2l6ZT8hMTp1KHQuZW50cmllcygpLGUuZW50cmllcygpKTpTKHQpJiZTKGUpP3UoT2JqZWN0LmVudHJpZXModClbU3ltYm9sLml0ZXJhdG9yXSgpLE9iamVjdC5lbnRyaWVzKGUpW1N5bWJvbC5pdGVyYXRvcl0oKSk6ITF9ZnVuY3Rpb24gdSh0LGUpe2Rve2xldCByPXQubmV4dCgpLG49ZS5uZXh0KCk7aWYoci5kb25lJiZuLmRvbmUpcmV0dXJuITA7aWYoci5kb25lfHxuLmRvbmV8fCFPYmplY3QuaXMoci52YWx1ZSxuLnZhbHVlKSlyZXR1cm4hMX13aGlsZSghMCl9ZnVuY3Rpb24gUyh0KXtpZihPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodCkhPT1cIltvYmplY3QgT2JqZWN0XVwiKXJldHVybiExO2xldCBlPU9iamVjdC5nZXRQcm90b3R5cGVPZih0KTtyZXR1cm4gZT09PW51bGx8fE9iamVjdC5nZXRQcm90b3R5cGVPZihlKT09PW51bGx9ZnVuY3Rpb24gZyh0KXtsZXRbZSxyXT10KCksbj15KCk7cmV0dXJuKC4uLmIpPT57ZSguLi5iKSxuLmRpc3Bvc2UoKSxuLm1pY3JvVGFzayhyKX19ZXhwb3J0e20gYXMgTWFjaGluZSxnIGFzIGJhdGNoLGggYXMgc2hhbGxvd0VxdWFsfTtcbiJdLCJuYW1lcyI6WyJmIiwidCIsImUiLCJyIiwiaGFzIiwiVHlwZUVycm9yIiwiYSIsImNhbGwiLCJnZXQiLCJsIiwiV2Vha1NldCIsImFkZCIsInNldCIsImMiLCJuIiwiaSIsInMiLCJvIiwiRGVmYXVsdE1hcCIsImQiLCJkaXNwb3NhYmxlcyIsInkiLCJtIiwic3RhdGUiLCJzdWJzY3JpYmUiLCJzZWxlY3RvciIsImNhbGxiYWNrIiwiY3VycmVudCIsImRlbGV0ZSIsIm9uIiwic2VuZCIsInJlZHVjZSIsImgiLCJ0eXBlIiwiY29uc3RydWN0b3IiLCJTZXQiLCJXZWFrTWFwIiwiT2JqZWN0IiwiaXMiLCJBcnJheSIsImlzQXJyYXkiLCJsZW5ndGgiLCJ1IiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJNYXAiLCJzaXplIiwiZW50cmllcyIsIlMiLCJuZXh0IiwiZG9uZSIsInZhbHVlIiwicHJvdG90eXBlIiwidG9TdHJpbmciLCJnZXRQcm90b3R5cGVPZiIsImciLCJiIiwiZGlzcG9zZSIsIm1pY3JvVGFzayIsIk1hY2hpbmUiLCJiYXRjaCIsInNoYWxsb3dFcXVhbCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../../../node_modules/@headlessui/react/dist/machine.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../../../node_modules/@headlessui/react/dist/react-glue.js":
/*!*********************************************************************!*\
  !*** ../../../../node_modules/@headlessui/react/dist/react-glue.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useSlice: function() { return /* binding */ S; }\n/* harmony export */ });\n/* harmony import */ var use_sync_external_store_with_selector__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! use-sync-external-store/with-selector */ \"(app-pages-browser)/../../../../node_modules/use-sync-external-store/with-selector.js\");\n/* harmony import */ var _hooks_use_event_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./hooks/use-event.js */ \"(app-pages-browser)/../../../../node_modules/@headlessui/react/dist/hooks/use-event.js\");\n/* harmony import */ var _machine_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./machine.js */ \"(app-pages-browser)/../../../../node_modules/@headlessui/react/dist/machine.js\");\n\n\n\nfunction S(e, n) {\n    let r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : _machine_js__WEBPACK_IMPORTED_MODULE_1__.shallowEqual;\n    return (0,use_sync_external_store_with_selector__WEBPACK_IMPORTED_MODULE_0__.useSyncExternalStoreWithSelector)((0,_hooks_use_event_js__WEBPACK_IMPORTED_MODULE_2__.useEvent)((i)=>e.subscribe(s, i)), (0,_hooks_use_event_js__WEBPACK_IMPORTED_MODULE_2__.useEvent)(()=>e.state), (0,_hooks_use_event_js__WEBPACK_IMPORTED_MODULE_2__.useEvent)(()=>e.state), (0,_hooks_use_event_js__WEBPACK_IMPORTED_MODULE_2__.useEvent)(n), r);\n}\n_c = S;\nfunction s(e) {\n    return e;\n}\n\nvar _c;\n$RefreshReg$(_c, \"S\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQGhlYWRsZXNzdWkvcmVhY3QvZGlzdC9yZWFjdC1nbHVlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBeUY7QUFBZ0Q7QUFBNEM7QUFBQSxTQUFTTSxFQUFFQyxDQUFDLEVBQUNDLENBQUM7UUFBQ0MsSUFBQUEsaUVBQUVKLHFEQUFDQTtJQUFFLE9BQU9KLHVHQUFDQSxDQUFDRSw2REFBQ0EsQ0FBQ08sQ0FBQUEsSUFBR0gsRUFBRUksU0FBUyxDQUFDQyxHQUFFRixLQUFJUCw2REFBQ0EsQ0FBQyxJQUFJSSxFQUFFTSxLQUFLLEdBQUVWLDZEQUFDQSxDQUFDLElBQUlJLEVBQUVNLEtBQUssR0FBRVYsNkRBQUNBLENBQUNLLElBQUdDO0FBQUU7S0FBaEZIO0FBQWlGLFNBQVNNLEVBQUVMLENBQUM7SUFBRSxPQUFPQTtBQUFDO0FBQXVCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQGhlYWRsZXNzdWkvcmVhY3QvZGlzdC9yZWFjdC1nbHVlLmpzPzNjNDkiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0e3VzZVN5bmNFeHRlcm5hbFN0b3JlV2l0aFNlbGVjdG9yIGFzIGF9ZnJvbVwidXNlLXN5bmMtZXh0ZXJuYWwtc3RvcmUvd2l0aC1zZWxlY3RvclwiO2ltcG9ydHt1c2VFdmVudCBhcyB0fWZyb20nLi9ob29rcy91c2UtZXZlbnQuanMnO2ltcG9ydHtzaGFsbG93RXF1YWwgYXMgb31mcm9tJy4vbWFjaGluZS5qcyc7ZnVuY3Rpb24gUyhlLG4scj1vKXtyZXR1cm4gYSh0KGk9PmUuc3Vic2NyaWJlKHMsaSkpLHQoKCk9PmUuc3RhdGUpLHQoKCk9PmUuc3RhdGUpLHQobikscil9ZnVuY3Rpb24gcyhlKXtyZXR1cm4gZX1leHBvcnR7UyBhcyB1c2VTbGljZX07XG4iXSwibmFtZXMiOlsidXNlU3luY0V4dGVybmFsU3RvcmVXaXRoU2VsZWN0b3IiLCJhIiwidXNlRXZlbnQiLCJ0Iiwic2hhbGxvd0VxdWFsIiwibyIsIlMiLCJlIiwibiIsInIiLCJpIiwic3Vic2NyaWJlIiwicyIsInN0YXRlIiwidXNlU2xpY2UiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../../../node_modules/@headlessui/react/dist/react-glue.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../../../node_modules/@headlessui/react/dist/utils/bugs.js":
/*!*********************************************************************!*\
  !*** ../../../../node_modules/@headlessui/react/dist/utils/bugs.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   isDisabledReactIssue7711: function() { return /* binding */ r; }\n/* harmony export */ });\nfunction r(n) {\n    let e = n.parentElement, l = null;\n    for(; e && !(e instanceof HTMLFieldSetElement);)e instanceof HTMLLegendElement && (l = e), e = e.parentElement;\n    let t = (e == null ? void 0 : e.getAttribute(\"disabled\")) === \"\";\n    return t && i(l) ? !1 : t;\n}\nfunction i(n) {\n    if (!n) return !1;\n    let e = n.previousElementSibling;\n    for(; e !== null;){\n        if (e instanceof HTMLLegendElement) return !1;\n        e = e.previousElementSibling;\n    }\n    return !0;\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQGhlYWRsZXNzdWkvcmVhY3QvZGlzdC91dGlscy9idWdzLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQSxTQUFTQSxFQUFFQyxDQUFDO0lBQUUsSUFBSUMsSUFBRUQsRUFBRUUsYUFBYSxFQUFDQyxJQUFFO0lBQUssTUFBS0YsS0FBRyxDQUFFQSxDQUFBQSxhQUFhRyxtQkFBa0IsR0FBSUgsYUFBYUkscUJBQW9CRixDQUFBQSxJQUFFRixDQUFBQSxHQUFHQSxJQUFFQSxFQUFFQyxhQUFhO0lBQUMsSUFBSUksSUFBRSxDQUFDTCxLQUFHLE9BQUssS0FBSyxJQUFFQSxFQUFFTSxZQUFZLENBQUMsV0FBVSxNQUFLO0lBQUcsT0FBT0QsS0FBR0UsRUFBRUwsS0FBRyxDQUFDLElBQUVHO0FBQUM7QUFBQyxTQUFTRSxFQUFFUixDQUFDO0lBQUUsSUFBRyxDQUFDQSxHQUFFLE9BQU0sQ0FBQztJQUFFLElBQUlDLElBQUVELEVBQUVTLHNCQUFzQjtJQUFDLE1BQUtSLE1BQUksTUFBTTtRQUFDLElBQUdBLGFBQWFJLG1CQUFrQixPQUFNLENBQUM7UUFBRUosSUFBRUEsRUFBRVEsc0JBQXNCO0lBQUE7SUFBQyxPQUFNLENBQUM7QUFBQztBQUF1QyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BoZWFkbGVzc3VpL3JlYWN0L2Rpc3QvdXRpbHMvYnVncy5qcz8zZWI3Il0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIHIobil7bGV0IGU9bi5wYXJlbnRFbGVtZW50LGw9bnVsbDtmb3IoO2UmJiEoZSBpbnN0YW5jZW9mIEhUTUxGaWVsZFNldEVsZW1lbnQpOyllIGluc3RhbmNlb2YgSFRNTExlZ2VuZEVsZW1lbnQmJihsPWUpLGU9ZS5wYXJlbnRFbGVtZW50O2xldCB0PShlPT1udWxsP3ZvaWQgMDplLmdldEF0dHJpYnV0ZShcImRpc2FibGVkXCIpKT09PVwiXCI7cmV0dXJuIHQmJmkobCk/ITE6dH1mdW5jdGlvbiBpKG4pe2lmKCFuKXJldHVybiExO2xldCBlPW4ucHJldmlvdXNFbGVtZW50U2libGluZztmb3IoO2UhPT1udWxsOyl7aWYoZSBpbnN0YW5jZW9mIEhUTUxMZWdlbmRFbGVtZW50KXJldHVybiExO2U9ZS5wcmV2aW91c0VsZW1lbnRTaWJsaW5nfXJldHVybiEwfWV4cG9ydHtyIGFzIGlzRGlzYWJsZWRSZWFjdElzc3VlNzcxMX07XG4iXSwibmFtZXMiOlsiciIsIm4iLCJlIiwicGFyZW50RWxlbWVudCIsImwiLCJIVE1MRmllbGRTZXRFbGVtZW50IiwiSFRNTExlZ2VuZEVsZW1lbnQiLCJ0IiwiZ2V0QXR0cmlidXRlIiwiaSIsInByZXZpb3VzRWxlbWVudFNpYmxpbmciLCJpc0Rpc2FibGVkUmVhY3RJc3N1ZTc3MTEiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../../../node_modules/@headlessui/react/dist/utils/bugs.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../../../node_modules/@headlessui/react/dist/utils/calculate-active-index.js":
/*!***************************************************************************************!*\
  !*** ../../../../node_modules/@headlessui/react/dist/utils/calculate-active-index.js ***!
  \***************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Focus: function() { return /* binding */ c; },\n/* harmony export */   calculateActiveIndex: function() { return /* binding */ f; }\n/* harmony export */ });\nfunction u(l) {\n    throw new Error(\"Unexpected object: \" + l);\n}\nvar c = ((i)=>(i[i.First = 0] = \"First\", i[i.Previous = 1] = \"Previous\", i[i.Next = 2] = \"Next\", i[i.Last = 3] = \"Last\", i[i.Specific = 4] = \"Specific\", i[i.Nothing = 5] = \"Nothing\", i))(c || {});\nfunction f(l, n) {\n    let t = n.resolveItems();\n    if (t.length <= 0) return null;\n    let r = n.resolveActiveIndex(), s = r != null ? r : -1;\n    switch(l.focus){\n        case 0:\n            {\n                for(let e = 0; e < t.length; ++e)if (!n.resolveDisabled(t[e], e, t)) return e;\n                return r;\n            }\n        case 1:\n            {\n                s === -1 && (s = t.length);\n                for(let e = s - 1; e >= 0; --e)if (!n.resolveDisabled(t[e], e, t)) return e;\n                return r;\n            }\n        case 2:\n            {\n                for(let e = s + 1; e < t.length; ++e)if (!n.resolveDisabled(t[e], e, t)) return e;\n                return r;\n            }\n        case 3:\n            {\n                for(let e = t.length - 1; e >= 0; --e)if (!n.resolveDisabled(t[e], e, t)) return e;\n                return r;\n            }\n        case 4:\n            {\n                for(let e = 0; e < t.length; ++e)if (n.resolveId(t[e], e, t) === l.id) return e;\n                return r;\n            }\n        case 5:\n            return null;\n        default:\n            u(l);\n    }\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQGhlYWRsZXNzdWkvcmVhY3QvZGlzdC91dGlscy9jYWxjdWxhdGUtYWN0aXZlLWluZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUEsU0FBU0EsRUFBRUMsQ0FBQztJQUFFLE1BQU0sSUFBSUMsTUFBTSx3QkFBc0JEO0FBQUU7QUFBQyxJQUFJRSxJQUFFLENBQUNDLENBQUFBLElBQUlBLENBQUFBLENBQUMsQ0FBQ0EsRUFBRUMsS0FBSyxHQUFDLEVBQUUsR0FBQyxTQUFRRCxDQUFDLENBQUNBLEVBQUVFLFFBQVEsR0FBQyxFQUFFLEdBQUMsWUFBV0YsQ0FBQyxDQUFDQSxFQUFFRyxJQUFJLEdBQUMsRUFBRSxHQUFDLFFBQU9ILENBQUMsQ0FBQ0EsRUFBRUksSUFBSSxHQUFDLEVBQUUsR0FBQyxRQUFPSixDQUFDLENBQUNBLEVBQUVLLFFBQVEsR0FBQyxFQUFFLEdBQUMsWUFBV0wsQ0FBQyxDQUFDQSxFQUFFTSxPQUFPLEdBQUMsRUFBRSxHQUFDLFdBQVVOLENBQUFBLENBQUMsRUFBR0QsS0FBRyxDQUFDO0FBQUcsU0FBU1EsRUFBRVYsQ0FBQyxFQUFDVyxDQUFDO0lBQUUsSUFBSUMsSUFBRUQsRUFBRUUsWUFBWTtJQUFHLElBQUdELEVBQUVFLE1BQU0sSUFBRSxHQUFFLE9BQU87SUFBSyxJQUFJQyxJQUFFSixFQUFFSyxrQkFBa0IsSUFBR0MsSUFBRUYsS0FBRyxPQUFLQSxJQUFFLENBQUM7SUFBRSxPQUFPZixFQUFFa0IsS0FBSztRQUFFLEtBQUs7WUFBRTtnQkFBQyxJQUFJLElBQUlDLElBQUUsR0FBRUEsSUFBRVAsRUFBRUUsTUFBTSxFQUFDLEVBQUVLLEVBQUUsSUFBRyxDQUFDUixFQUFFUyxlQUFlLENBQUNSLENBQUMsQ0FBQ08sRUFBRSxFQUFDQSxHQUFFUCxJQUFHLE9BQU9PO2dCQUFFLE9BQU9KO1lBQUM7UUFBQyxLQUFLO1lBQUU7Z0JBQUNFLE1BQUksQ0FBQyxLQUFJQSxDQUFBQSxJQUFFTCxFQUFFRSxNQUFNO2dCQUFFLElBQUksSUFBSUssSUFBRUYsSUFBRSxHQUFFRSxLQUFHLEdBQUUsRUFBRUEsRUFBRSxJQUFHLENBQUNSLEVBQUVTLGVBQWUsQ0FBQ1IsQ0FBQyxDQUFDTyxFQUFFLEVBQUNBLEdBQUVQLElBQUcsT0FBT087Z0JBQUUsT0FBT0o7WUFBQztRQUFDLEtBQUs7WUFBRTtnQkFBQyxJQUFJLElBQUlJLElBQUVGLElBQUUsR0FBRUUsSUFBRVAsRUFBRUUsTUFBTSxFQUFDLEVBQUVLLEVBQUUsSUFBRyxDQUFDUixFQUFFUyxlQUFlLENBQUNSLENBQUMsQ0FBQ08sRUFBRSxFQUFDQSxHQUFFUCxJQUFHLE9BQU9PO2dCQUFFLE9BQU9KO1lBQUM7UUFBQyxLQUFLO1lBQUU7Z0JBQUMsSUFBSSxJQUFJSSxJQUFFUCxFQUFFRSxNQUFNLEdBQUMsR0FBRUssS0FBRyxHQUFFLEVBQUVBLEVBQUUsSUFBRyxDQUFDUixFQUFFUyxlQUFlLENBQUNSLENBQUMsQ0FBQ08sRUFBRSxFQUFDQSxHQUFFUCxJQUFHLE9BQU9PO2dCQUFFLE9BQU9KO1lBQUM7UUFBQyxLQUFLO1lBQUU7Z0JBQUMsSUFBSSxJQUFJSSxJQUFFLEdBQUVBLElBQUVQLEVBQUVFLE1BQU0sRUFBQyxFQUFFSyxFQUFFLElBQUdSLEVBQUVVLFNBQVMsQ0FBQ1QsQ0FBQyxDQUFDTyxFQUFFLEVBQUNBLEdBQUVQLE9BQUtaLEVBQUVzQixFQUFFLEVBQUMsT0FBT0g7Z0JBQUUsT0FBT0o7WUFBQztRQUFDLEtBQUs7WUFBRSxPQUFPO1FBQUs7WUFBUWhCLEVBQUVDO0lBQUU7QUFBQztBQUE4QyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BoZWFkbGVzc3VpL3JlYWN0L2Rpc3QvdXRpbHMvY2FsY3VsYXRlLWFjdGl2ZS1pbmRleC5qcz82ZDFkIl0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIHUobCl7dGhyb3cgbmV3IEVycm9yKFwiVW5leHBlY3RlZCBvYmplY3Q6IFwiK2wpfXZhciBjPShpPT4oaVtpLkZpcnN0PTBdPVwiRmlyc3RcIixpW2kuUHJldmlvdXM9MV09XCJQcmV2aW91c1wiLGlbaS5OZXh0PTJdPVwiTmV4dFwiLGlbaS5MYXN0PTNdPVwiTGFzdFwiLGlbaS5TcGVjaWZpYz00XT1cIlNwZWNpZmljXCIsaVtpLk5vdGhpbmc9NV09XCJOb3RoaW5nXCIsaSkpKGN8fHt9KTtmdW5jdGlvbiBmKGwsbil7bGV0IHQ9bi5yZXNvbHZlSXRlbXMoKTtpZih0Lmxlbmd0aDw9MClyZXR1cm4gbnVsbDtsZXQgcj1uLnJlc29sdmVBY3RpdmVJbmRleCgpLHM9ciE9bnVsbD9yOi0xO3N3aXRjaChsLmZvY3VzKXtjYXNlIDA6e2ZvcihsZXQgZT0wO2U8dC5sZW5ndGg7KytlKWlmKCFuLnJlc29sdmVEaXNhYmxlZCh0W2VdLGUsdCkpcmV0dXJuIGU7cmV0dXJuIHJ9Y2FzZSAxOntzPT09LTEmJihzPXQubGVuZ3RoKTtmb3IobGV0IGU9cy0xO2U+PTA7LS1lKWlmKCFuLnJlc29sdmVEaXNhYmxlZCh0W2VdLGUsdCkpcmV0dXJuIGU7cmV0dXJuIHJ9Y2FzZSAyOntmb3IobGV0IGU9cysxO2U8dC5sZW5ndGg7KytlKWlmKCFuLnJlc29sdmVEaXNhYmxlZCh0W2VdLGUsdCkpcmV0dXJuIGU7cmV0dXJuIHJ9Y2FzZSAzOntmb3IobGV0IGU9dC5sZW5ndGgtMTtlPj0wOy0tZSlpZighbi5yZXNvbHZlRGlzYWJsZWQodFtlXSxlLHQpKXJldHVybiBlO3JldHVybiByfWNhc2UgNDp7Zm9yKGxldCBlPTA7ZTx0Lmxlbmd0aDsrK2UpaWYobi5yZXNvbHZlSWQodFtlXSxlLHQpPT09bC5pZClyZXR1cm4gZTtyZXR1cm4gcn1jYXNlIDU6cmV0dXJuIG51bGw7ZGVmYXVsdDp1KGwpfX1leHBvcnR7YyBhcyBGb2N1cyxmIGFzIGNhbGN1bGF0ZUFjdGl2ZUluZGV4fTtcbiJdLCJuYW1lcyI6WyJ1IiwibCIsIkVycm9yIiwiYyIsImkiLCJGaXJzdCIsIlByZXZpb3VzIiwiTmV4dCIsIkxhc3QiLCJTcGVjaWZpYyIsIk5vdGhpbmciLCJmIiwibiIsInQiLCJyZXNvbHZlSXRlbXMiLCJsZW5ndGgiLCJyIiwicmVzb2x2ZUFjdGl2ZUluZGV4IiwicyIsImZvY3VzIiwiZSIsInJlc29sdmVEaXNhYmxlZCIsInJlc29sdmVJZCIsImlkIiwiRm9jdXMiLCJjYWxjdWxhdGVBY3RpdmVJbmRleCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../../../node_modules/@headlessui/react/dist/utils/calculate-active-index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../../../node_modules/@headlessui/react/dist/utils/get-text-value.js":
/*!*******************************************************************************!*\
  !*** ../../../../node_modules/@headlessui/react/dist/utils/get-text-value.js ***!
  \*******************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getTextValue: function() { return /* binding */ g; }\n/* harmony export */ });\nlet a = /([\\u2700-\\u27BF]|[\\uE000-\\uF8FF]|\\uD83C[\\uDC00-\\uDFFF]|\\uD83D[\\uDC00-\\uDFFF]|[\\u2011-\\u26FF]|\\uD83E[\\uDD10-\\uDDFF])/g;\nfunction o(e) {\n    var r, i;\n    let n = (r = e.innerText) != null ? r : \"\", t = e.cloneNode(!0);\n    if (!(t instanceof HTMLElement)) return n;\n    let u = !1;\n    for (let f of t.querySelectorAll('[hidden],[aria-hidden],[role=\"img\"]'))f.remove(), u = !0;\n    let l = u ? (i = t.innerText) != null ? i : \"\" : n;\n    return a.test(l) && (l = l.replace(a, \"\")), l;\n}\nfunction g(e) {\n    let n = e.getAttribute(\"aria-label\");\n    if (typeof n == \"string\") return n.trim();\n    let t = e.getAttribute(\"aria-labelledby\");\n    if (t) {\n        let u = t.split(\" \").map((l)=>{\n            let r = document.getElementById(l);\n            if (r) {\n                let i = r.getAttribute(\"aria-label\");\n                return typeof i == \"string\" ? i.trim() : o(r).trim();\n            }\n            return null;\n        }).filter(Boolean);\n        if (u.length > 0) return u.join(\", \");\n    }\n    return o(e).trim();\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQGhlYWRsZXNzdWkvcmVhY3QvZGlzdC91dGlscy9nZXQtdGV4dC12YWx1ZS5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUEsSUFBSUEsSUFBRTtBQUF1SCxTQUFTQyxFQUFFQyxDQUFDO0lBQUUsSUFBSUMsR0FBRUM7SUFBRSxJQUFJQyxJQUFFLENBQUNGLElBQUVELEVBQUVJLFNBQVMsS0FBRyxPQUFLSCxJQUFFLElBQUdJLElBQUVMLEVBQUVNLFNBQVMsQ0FBQyxDQUFDO0lBQUcsSUFBRyxDQUFFRCxDQUFBQSxhQUFhRSxXQUFVLEdBQUcsT0FBT0o7SUFBRSxJQUFJSyxJQUFFLENBQUM7SUFBRSxLQUFJLElBQUlDLEtBQUtKLEVBQUVLLGdCQUFnQixDQUFDLHVDQUF1Q0QsRUFBRUUsTUFBTSxJQUFHSCxJQUFFLENBQUM7SUFBRSxJQUFJSSxJQUFFSixJQUFFLENBQUNOLElBQUVHLEVBQUVELFNBQVMsS0FBRyxPQUFLRixJQUFFLEtBQUdDO0lBQUUsT0FBT0wsRUFBRWUsSUFBSSxDQUFDRCxNQUFLQSxDQUFBQSxJQUFFQSxFQUFFRSxPQUFPLENBQUNoQixHQUFFLEdBQUUsR0FBR2M7QUFBQztBQUFDLFNBQVNHLEVBQUVmLENBQUM7SUFBRSxJQUFJRyxJQUFFSCxFQUFFZ0IsWUFBWSxDQUFDO0lBQWMsSUFBRyxPQUFPYixLQUFHLFVBQVMsT0FBT0EsRUFBRWMsSUFBSTtJQUFHLElBQUlaLElBQUVMLEVBQUVnQixZQUFZLENBQUM7SUFBbUIsSUFBR1gsR0FBRTtRQUFDLElBQUlHLElBQUVILEVBQUVhLEtBQUssQ0FBQyxLQUFLQyxHQUFHLENBQUNQLENBQUFBO1lBQUksSUFBSVgsSUFBRW1CLFNBQVNDLGNBQWMsQ0FBQ1Q7WUFBRyxJQUFHWCxHQUFFO2dCQUFDLElBQUlDLElBQUVELEVBQUVlLFlBQVksQ0FBQztnQkFBYyxPQUFPLE9BQU9kLEtBQUcsV0FBU0EsRUFBRWUsSUFBSSxLQUFHbEIsRUFBRUUsR0FBR2dCLElBQUk7WUFBRTtZQUFDLE9BQU87UUFBSSxHQUFHSyxNQUFNLENBQUNDO1FBQVMsSUFBR2YsRUFBRWdCLE1BQU0sR0FBQyxHQUFFLE9BQU9oQixFQUFFaUIsSUFBSSxDQUFDO0lBQUs7SUFBQyxPQUFPMUIsRUFBRUMsR0FBR2lCLElBQUk7QUFBRTtBQUEyQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BoZWFkbGVzc3VpL3JlYWN0L2Rpc3QvdXRpbHMvZ2V0LXRleHQtdmFsdWUuanM/ZWVmZiJdLCJzb3VyY2VzQ29udGVudCI6WyJsZXQgYT0vKFtcXHUyNzAwLVxcdTI3QkZdfFtcXHVFMDAwLVxcdUY4RkZdfFxcdUQ4M0NbXFx1REMwMC1cXHVERkZGXXxcXHVEODNEW1xcdURDMDAtXFx1REZGRl18W1xcdTIwMTEtXFx1MjZGRl18XFx1RDgzRVtcXHVERDEwLVxcdURERkZdKS9nO2Z1bmN0aW9uIG8oZSl7dmFyIHIsaTtsZXQgbj0ocj1lLmlubmVyVGV4dCkhPW51bGw/cjpcIlwiLHQ9ZS5jbG9uZU5vZGUoITApO2lmKCEodCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSlyZXR1cm4gbjtsZXQgdT0hMTtmb3IobGV0IGYgb2YgdC5xdWVyeVNlbGVjdG9yQWxsKCdbaGlkZGVuXSxbYXJpYS1oaWRkZW5dLFtyb2xlPVwiaW1nXCJdJykpZi5yZW1vdmUoKSx1PSEwO2xldCBsPXU/KGk9dC5pbm5lclRleHQpIT1udWxsP2k6XCJcIjpuO3JldHVybiBhLnRlc3QobCkmJihsPWwucmVwbGFjZShhLFwiXCIpKSxsfWZ1bmN0aW9uIGcoZSl7bGV0IG49ZS5nZXRBdHRyaWJ1dGUoXCJhcmlhLWxhYmVsXCIpO2lmKHR5cGVvZiBuPT1cInN0cmluZ1wiKXJldHVybiBuLnRyaW0oKTtsZXQgdD1lLmdldEF0dHJpYnV0ZShcImFyaWEtbGFiZWxsZWRieVwiKTtpZih0KXtsZXQgdT10LnNwbGl0KFwiIFwiKS5tYXAobD0+e2xldCByPWRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGwpO2lmKHIpe2xldCBpPXIuZ2V0QXR0cmlidXRlKFwiYXJpYS1sYWJlbFwiKTtyZXR1cm4gdHlwZW9mIGk9PVwic3RyaW5nXCI/aS50cmltKCk6byhyKS50cmltKCl9cmV0dXJuIG51bGx9KS5maWx0ZXIoQm9vbGVhbik7aWYodS5sZW5ndGg+MClyZXR1cm4gdS5qb2luKFwiLCBcIil9cmV0dXJuIG8oZSkudHJpbSgpfWV4cG9ydHtnIGFzIGdldFRleHRWYWx1ZX07XG4iXSwibmFtZXMiOlsiYSIsIm8iLCJlIiwiciIsImkiLCJuIiwiaW5uZXJUZXh0IiwidCIsImNsb25lTm9kZSIsIkhUTUxFbGVtZW50IiwidSIsImYiLCJxdWVyeVNlbGVjdG9yQWxsIiwicmVtb3ZlIiwibCIsInRlc3QiLCJyZXBsYWNlIiwiZyIsImdldEF0dHJpYnV0ZSIsInRyaW0iLCJzcGxpdCIsIm1hcCIsImRvY3VtZW50IiwiZ2V0RWxlbWVudEJ5SWQiLCJmaWx0ZXIiLCJCb29sZWFuIiwibGVuZ3RoIiwiam9pbiIsImdldFRleHRWYWx1ZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../../../node_modules/@headlessui/react/dist/utils/get-text-value.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../../../node_modules/@react-aria/focus/dist/useFocusRing.mjs":
/*!************************************************************************!*\
  !*** ../../../../node_modules/@react-aria/focus/dist/useFocusRing.mjs ***!
  \************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useFocusRing: function() { return /* binding */ $f7dceffc5ad7768b$export$4e328f61c538687f; }\n/* harmony export */ });\n/* harmony import */ var _react_aria_interactions__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @react-aria/interactions */ \"(app-pages-browser)/../../../../node_modules/@react-aria/interactions/dist/useFocusVisible.mjs\");\n/* harmony import */ var _react_aria_interactions__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @react-aria/interactions */ \"(app-pages-browser)/../../../../node_modules/@react-aria/interactions/dist/useFocus.mjs\");\n/* harmony import */ var _react_aria_interactions__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @react-aria/interactions */ \"(app-pages-browser)/../../../../node_modules/@react-aria/interactions/dist/useFocusWithin.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n\n\nfunction $f7dceffc5ad7768b$export$4e328f61c538687f() {\n    let props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n    let { autoFocus: autoFocus = false, isTextInput: isTextInput, within: within } = props;\n    let state = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)({\n        isFocused: false,\n        isFocusVisible: autoFocus || (0, _react_aria_interactions__WEBPACK_IMPORTED_MODULE_1__.isFocusVisible)()\n    });\n    let [isFocused, setFocused] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    let [isFocusVisibleState, setFocusVisible] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(()=>state.current.isFocused && state.current.isFocusVisible);\n    let updateState = (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>setFocusVisible(state.current.isFocused && state.current.isFocusVisible), []);\n    let onFocusChange = (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((isFocused)=>{\n        state.current.isFocused = isFocused;\n        setFocused(isFocused);\n        updateState();\n    }, [\n        updateState\n    ]);\n    (0, _react_aria_interactions__WEBPACK_IMPORTED_MODULE_1__.useFocusVisibleListener)((isFocusVisible)=>{\n        state.current.isFocusVisible = isFocusVisible;\n        updateState();\n    }, [], {\n        isTextInput: isTextInput\n    });\n    let { focusProps: focusProps } = (0, _react_aria_interactions__WEBPACK_IMPORTED_MODULE_2__.useFocus)({\n        isDisabled: within,\n        onFocusChange: onFocusChange\n    });\n    let { focusWithinProps: focusWithinProps } = (0, _react_aria_interactions__WEBPACK_IMPORTED_MODULE_3__.useFocusWithin)({\n        isDisabled: !within,\n        onFocusWithinChange: onFocusChange\n    });\n    return {\n        isFocused: isFocused,\n        isFocusVisible: isFocusVisibleState,\n        focusProps: within ? focusWithinProps : focusProps\n    };\n}\n //# sourceMappingURL=useFocusRing.module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQHJlYWN0LWFyaWEvZm9jdXMvZGlzdC91c2VGb2N1c1JpbmcubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQWtOO0FBQ3BHO0FBSTlHLFNBQVNjO1FBQTBDQyxRQUFBQSxpRUFBUSxDQUFDO0lBQ3hELElBQUksRUFBRUMsV0FBV0EsWUFBWSxLQUFLLEVBQUVDLGFBQWFBLFdBQVcsRUFBRUMsUUFBUUEsTUFBTSxFQUFFLEdBQUdIO0lBQ2pGLElBQUlJLFFBQVEsQ0FBQyxHQUFHVix5Q0FBWSxFQUFHO1FBQzNCVyxXQUFXO1FBQ1hwQixnQkFBZ0JnQixhQUFhLENBQUMsR0FBR2Ysb0VBQW9CO0lBQ3pEO0lBQ0EsSUFBSSxDQUFDbUIsV0FBV0MsV0FBVyxHQUFHLENBQUMsR0FBR1YsMkNBQWMsRUFBRztJQUNuRCxJQUFJLENBQUNXLHFCQUFxQkMsZ0JBQWdCLEdBQUcsQ0FBQyxHQUFHWiwyQ0FBYyxFQUFHLElBQUlRLE1BQU1LLE9BQU8sQ0FBQ0osU0FBUyxJQUFJRCxNQUFNSyxPQUFPLENBQUN4QixjQUFjO0lBQzdILElBQUl5QixjQUFjLENBQUMsR0FBR1osOENBQWlCLEVBQUcsSUFBSVUsZ0JBQWdCSixNQUFNSyxPQUFPLENBQUNKLFNBQVMsSUFBSUQsTUFBTUssT0FBTyxDQUFDeEIsY0FBYyxHQUFHLEVBQUU7SUFDMUgsSUFBSTBCLGdCQUFnQixDQUFDLEdBQUdiLDhDQUFpQixFQUFHLENBQUNPO1FBQ3pDRCxNQUFNSyxPQUFPLENBQUNKLFNBQVMsR0FBR0E7UUFDMUJDLFdBQVdEO1FBQ1hLO0lBQ0osR0FBRztRQUNDQTtLQUNIO0lBQ0EsSUFBR3RCLDZFQUE2QixFQUFHLENBQUNIO1FBQ2pDbUIsTUFBTUssT0FBTyxDQUFDeEIsY0FBYyxHQUFHQTtRQUMvQnlCO0lBQ0osR0FBRyxFQUFFLEVBQUU7UUFDSFIsYUFBYUE7SUFDakI7SUFDQSxJQUFJLEVBQUVVLFlBQVlBLFVBQVUsRUFBRSxHQUFHLENBQUMsR0FBR3RCLDhEQUFjLEVBQUc7UUFDbER1QixZQUFZVjtRQUNaUSxlQUFlQTtJQUNuQjtJQUNBLElBQUksRUFBRUcsa0JBQWtCQSxnQkFBZ0IsRUFBRSxHQUFHLENBQUMsR0FBR3RCLG9FQUFvQixFQUFHO1FBQ3BFcUIsWUFBWSxDQUFDVjtRQUNiWSxxQkFBcUJKO0lBQ3pCO0lBQ0EsT0FBTztRQUNITixXQUFXQTtRQUNYcEIsZ0JBQWdCc0I7UUFDaEJLLFlBQVlULFNBQVNXLG1CQUFtQkY7SUFDNUM7QUFDSjtBQUdtRSxDQUNuRSwrQ0FBK0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AcmVhY3QtYXJpYS9mb2N1cy9kaXN0L3VzZUZvY3VzUmluZy5tanM/YjY1OSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge2lzRm9jdXNWaXNpYmxlIGFzICRpc1dFNSRpc0ZvY3VzVmlzaWJsZSwgdXNlRm9jdXNWaXNpYmxlTGlzdGVuZXIgYXMgJGlzV0U1JHVzZUZvY3VzVmlzaWJsZUxpc3RlbmVyLCB1c2VGb2N1cyBhcyAkaXNXRTUkdXNlRm9jdXMsIHVzZUZvY3VzV2l0aGluIGFzICRpc1dFNSR1c2VGb2N1c1dpdGhpbn0gZnJvbSBcIkByZWFjdC1hcmlhL2ludGVyYWN0aW9uc1wiO1xuaW1wb3J0IHt1c2VSZWYgYXMgJGlzV0U1JHVzZVJlZiwgdXNlU3RhdGUgYXMgJGlzV0U1JHVzZVN0YXRlLCB1c2VDYWxsYmFjayBhcyAkaXNXRTUkdXNlQ2FsbGJhY2t9IGZyb20gXCJyZWFjdFwiO1xuXG5cblxuZnVuY3Rpb24gJGY3ZGNlZmZjNWFkNzc2OGIkZXhwb3J0JDRlMzI4ZjYxYzUzODY4N2YocHJvcHMgPSB7fSkge1xuICAgIGxldCB7IGF1dG9Gb2N1czogYXV0b0ZvY3VzID0gZmFsc2UsIGlzVGV4dElucHV0OiBpc1RleHRJbnB1dCwgd2l0aGluOiB3aXRoaW4gfSA9IHByb3BzO1xuICAgIGxldCBzdGF0ZSA9ICgwLCAkaXNXRTUkdXNlUmVmKSh7XG4gICAgICAgIGlzRm9jdXNlZDogZmFsc2UsXG4gICAgICAgIGlzRm9jdXNWaXNpYmxlOiBhdXRvRm9jdXMgfHwgKDAsICRpc1dFNSRpc0ZvY3VzVmlzaWJsZSkoKVxuICAgIH0pO1xuICAgIGxldCBbaXNGb2N1c2VkLCBzZXRGb2N1c2VkXSA9ICgwLCAkaXNXRTUkdXNlU3RhdGUpKGZhbHNlKTtcbiAgICBsZXQgW2lzRm9jdXNWaXNpYmxlU3RhdGUsIHNldEZvY3VzVmlzaWJsZV0gPSAoMCwgJGlzV0U1JHVzZVN0YXRlKSgoKT0+c3RhdGUuY3VycmVudC5pc0ZvY3VzZWQgJiYgc3RhdGUuY3VycmVudC5pc0ZvY3VzVmlzaWJsZSk7XG4gICAgbGV0IHVwZGF0ZVN0YXRlID0gKDAsICRpc1dFNSR1c2VDYWxsYmFjaykoKCk9PnNldEZvY3VzVmlzaWJsZShzdGF0ZS5jdXJyZW50LmlzRm9jdXNlZCAmJiBzdGF0ZS5jdXJyZW50LmlzRm9jdXNWaXNpYmxlKSwgW10pO1xuICAgIGxldCBvbkZvY3VzQ2hhbmdlID0gKDAsICRpc1dFNSR1c2VDYWxsYmFjaykoKGlzRm9jdXNlZCk9PntcbiAgICAgICAgc3RhdGUuY3VycmVudC5pc0ZvY3VzZWQgPSBpc0ZvY3VzZWQ7XG4gICAgICAgIHNldEZvY3VzZWQoaXNGb2N1c2VkKTtcbiAgICAgICAgdXBkYXRlU3RhdGUoKTtcbiAgICB9LCBbXG4gICAgICAgIHVwZGF0ZVN0YXRlXG4gICAgXSk7XG4gICAgKDAsICRpc1dFNSR1c2VGb2N1c1Zpc2libGVMaXN0ZW5lcikoKGlzRm9jdXNWaXNpYmxlKT0+e1xuICAgICAgICBzdGF0ZS5jdXJyZW50LmlzRm9jdXNWaXNpYmxlID0gaXNGb2N1c1Zpc2libGU7XG4gICAgICAgIHVwZGF0ZVN0YXRlKCk7XG4gICAgfSwgW10sIHtcbiAgICAgICAgaXNUZXh0SW5wdXQ6IGlzVGV4dElucHV0XG4gICAgfSk7XG4gICAgbGV0IHsgZm9jdXNQcm9wczogZm9jdXNQcm9wcyB9ID0gKDAsICRpc1dFNSR1c2VGb2N1cykoe1xuICAgICAgICBpc0Rpc2FibGVkOiB3aXRoaW4sXG4gICAgICAgIG9uRm9jdXNDaGFuZ2U6IG9uRm9jdXNDaGFuZ2VcbiAgICB9KTtcbiAgICBsZXQgeyBmb2N1c1dpdGhpblByb3BzOiBmb2N1c1dpdGhpblByb3BzIH0gPSAoMCwgJGlzV0U1JHVzZUZvY3VzV2l0aGluKSh7XG4gICAgICAgIGlzRGlzYWJsZWQ6ICF3aXRoaW4sXG4gICAgICAgIG9uRm9jdXNXaXRoaW5DaGFuZ2U6IG9uRm9jdXNDaGFuZ2VcbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgICBpc0ZvY3VzZWQ6IGlzRm9jdXNlZCxcbiAgICAgICAgaXNGb2N1c1Zpc2libGU6IGlzRm9jdXNWaXNpYmxlU3RhdGUsXG4gICAgICAgIGZvY3VzUHJvcHM6IHdpdGhpbiA/IGZvY3VzV2l0aGluUHJvcHMgOiBmb2N1c1Byb3BzXG4gICAgfTtcbn1cblxuXG5leHBvcnQgeyRmN2RjZWZmYzVhZDc3NjhiJGV4cG9ydCQ0ZTMyOGY2MWM1Mzg2ODdmIGFzIHVzZUZvY3VzUmluZ307XG4vLyMgc291cmNlTWFwcGluZ1VSTD11c2VGb2N1c1JpbmcubW9kdWxlLmpzLm1hcFxuIl0sIm5hbWVzIjpbImlzRm9jdXNWaXNpYmxlIiwiJGlzV0U1JGlzRm9jdXNWaXNpYmxlIiwidXNlRm9jdXNWaXNpYmxlTGlzdGVuZXIiLCIkaXNXRTUkdXNlRm9jdXNWaXNpYmxlTGlzdGVuZXIiLCJ1c2VGb2N1cyIsIiRpc1dFNSR1c2VGb2N1cyIsInVzZUZvY3VzV2l0aGluIiwiJGlzV0U1JHVzZUZvY3VzV2l0aGluIiwidXNlUmVmIiwiJGlzV0U1JHVzZVJlZiIsInVzZVN0YXRlIiwiJGlzV0U1JHVzZVN0YXRlIiwidXNlQ2FsbGJhY2siLCIkaXNXRTUkdXNlQ2FsbGJhY2siLCIkZjdkY2VmZmM1YWQ3NzY4YiRleHBvcnQkNGUzMjhmNjFjNTM4Njg3ZiIsInByb3BzIiwiYXV0b0ZvY3VzIiwiaXNUZXh0SW5wdXQiLCJ3aXRoaW4iLCJzdGF0ZSIsImlzRm9jdXNlZCIsInNldEZvY3VzZWQiLCJpc0ZvY3VzVmlzaWJsZVN0YXRlIiwic2V0Rm9jdXNWaXNpYmxlIiwiY3VycmVudCIsInVwZGF0ZVN0YXRlIiwib25Gb2N1c0NoYW5nZSIsImZvY3VzUHJvcHMiLCJpc0Rpc2FibGVkIiwiZm9jdXNXaXRoaW5Qcm9wcyIsIm9uRm9jdXNXaXRoaW5DaGFuZ2UiLCJ1c2VGb2N1c1JpbmciXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../../../node_modules/@react-aria/focus/dist/useFocusRing.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/../../../../node_modules/@react-aria/interactions/dist/useFocus.mjs":
/*!***************************************************************************!*\
  !*** ../../../../node_modules/@react-aria/interactions/dist/useFocus.mjs ***!
  \***************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useFocus: function() { return /* binding */ $a1ea59d68270f0dd$export$f8168d8dd8fd66e6; }\n/* harmony export */ });\n/* harmony import */ var _utils_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.mjs */ \"(app-pages-browser)/../../../../node_modules/@react-aria/interactions/dist/utils.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var _react_aria_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @react-aria/utils */ \"(app-pages-browser)/../../../../node_modules/@react-aria/utils/dist/domHelpers.mjs\");\n/* harmony import */ var _react_aria_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @react-aria/utils */ \"(app-pages-browser)/../../../../node_modules/@react-aria/utils/dist/DOMFunctions.mjs\");\n\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ // Portions of the code in this file are based on code from react.\n// Original licensing for the following can be found in the\n// NOTICE file in the root directory of this source tree.\n// See https://github.com/facebook/react/tree/cc7c1aece46a6b69b41958d731e0fd27c94bfc6c/packages/react-interactions\nfunction $a1ea59d68270f0dd$export$f8168d8dd8fd66e6(props) {\n    let { isDisabled: isDisabled, onFocus: onFocusProp, onBlur: onBlurProp, onFocusChange: onFocusChange } = props;\n    const onBlur = (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((e)=>{\n        if (e.target === e.currentTarget) {\n            if (onBlurProp) onBlurProp(e);\n            if (onFocusChange) onFocusChange(false);\n            return true;\n        }\n    }, [\n        onBlurProp,\n        onFocusChange\n    ]);\n    const onSyntheticFocus = (0, _utils_mjs__WEBPACK_IMPORTED_MODULE_1__.useSyntheticBlurEvent)(onBlur);\n    const onFocus = (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((e)=>{\n        // Double check that document.activeElement actually matches e.target in case a previously chained\n        // focus handler already moved focus somewhere else.\n        const ownerDocument = (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_2__.getOwnerDocument)(e.target);\n        const activeElement = ownerDocument ? (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_3__.getActiveElement)(ownerDocument) : (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_3__.getActiveElement)();\n        if (e.target === e.currentTarget && activeElement === (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_3__.getEventTarget)(e.nativeEvent)) {\n            if (onFocusProp) onFocusProp(e);\n            if (onFocusChange) onFocusChange(true);\n            onSyntheticFocus(e);\n        }\n    }, [\n        onFocusChange,\n        onFocusProp,\n        onSyntheticFocus\n    ]);\n    return {\n        focusProps: {\n            onFocus: !isDisabled && (onFocusProp || onFocusChange || onBlurProp) ? onFocus : undefined,\n            onBlur: !isDisabled && (onBlurProp || onFocusChange) ? onBlur : undefined\n        }\n    };\n}\n //# sourceMappingURL=useFocus.module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQHJlYWN0LWFyaWEvaW50ZXJhY3Rpb25zL2Rpc3QvdXNlRm9jdXMubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQStGO0FBQ3ZDO0FBQzRHO0FBRXBLOzs7Ozs7Ozs7O0NBVUMsR0FBRyxrRUFBa0U7QUFDdEUsMkRBQTJEO0FBQzNELHlEQUF5RDtBQUN6RCxrSEFBa0g7QUFJbEgsU0FBU1UsMENBQTBDQyxLQUFLO0lBQ3BELElBQUksRUFBRUMsWUFBWUEsVUFBVSxFQUFFQyxTQUFTQyxXQUFXLEVBQUVDLFFBQVFDLFVBQVUsRUFBRUMsZUFBZUEsYUFBYSxFQUFFLEdBQUdOO0lBQ3pHLE1BQU1JLFNBQVMsQ0FBQyxHQUFHWiw4Q0FBaUIsRUFBRyxDQUFDZTtRQUNwQyxJQUFJQSxFQUFFQyxNQUFNLEtBQUtELEVBQUVFLGFBQWEsRUFBRTtZQUM5QixJQUFJSixZQUFZQSxXQUFXRTtZQUMzQixJQUFJRCxlQUFlQSxjQUFjO1lBQ2pDLE9BQU87UUFDWDtJQUNKLEdBQUc7UUFDQ0Q7UUFDQUM7S0FDSDtJQUNELE1BQU1JLG1CQUFtQixDQUFDLEdBQUdwQiw2REFBd0MsRUFBR2M7SUFDeEUsTUFBTUYsVUFBVSxDQUFDLEdBQUdWLDhDQUFpQixFQUFHLENBQUNlO1FBQ3JDLGtHQUFrRztRQUNsRyxvREFBb0Q7UUFDcEQsTUFBTUksZ0JBQWdCLENBQUMsR0FBR2pCLCtEQUFzQixFQUFHYSxFQUFFQyxNQUFNO1FBQzNELE1BQU1JLGdCQUFnQkQsZ0JBQWdCLENBQUMsR0FBR2YsK0RBQXNCLEVBQUdlLGlCQUFpQixDQUFDLEdBQUdmLCtEQUFzQjtRQUM5RyxJQUFJVyxFQUFFQyxNQUFNLEtBQUtELEVBQUVFLGFBQWEsSUFBSUcsa0JBQWtCLENBQUMsR0FBR2QsNkRBQW9CLEVBQUdTLEVBQUVNLFdBQVcsR0FBRztZQUM3RixJQUFJVixhQUFhQSxZQUFZSTtZQUM3QixJQUFJRCxlQUFlQSxjQUFjO1lBQ2pDSSxpQkFBaUJIO1FBQ3JCO0lBQ0osR0FBRztRQUNDRDtRQUNBSDtRQUNBTztLQUNIO0lBQ0QsT0FBTztRQUNISSxZQUFZO1lBQ1JaLFNBQVMsQ0FBQ0QsY0FBZUUsQ0FBQUEsZUFBZUcsaUJBQWlCRCxVQUFTLElBQUtILFVBQVVhO1lBQ2pGWCxRQUFRLENBQUNILGNBQWVJLENBQUFBLGNBQWNDLGFBQVksSUFBS0YsU0FBU1c7UUFDcEU7SUFDSjtBQUNKO0FBRytELENBQy9ELDJDQUEyQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0ByZWFjdC1hcmlhL2ludGVyYWN0aW9ucy9kaXN0L3VzZUZvY3VzLm1qcz8yM2VmIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7dXNlU3ludGhldGljQmx1ckV2ZW50IGFzICQ4YTljYjI3OWRjODdlMTMwJGV4cG9ydCQ3MTVjNjgyZDA5ZDYzOWNjfSBmcm9tIFwiLi91dGlscy5tanNcIjtcbmltcG9ydCB7dXNlQ2FsbGJhY2sgYXMgJGhmMGxqJHVzZUNhbGxiYWNrfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7Z2V0T3duZXJEb2N1bWVudCBhcyAkaGYwbGokZ2V0T3duZXJEb2N1bWVudCwgZ2V0QWN0aXZlRWxlbWVudCBhcyAkaGYwbGokZ2V0QWN0aXZlRWxlbWVudCwgZ2V0RXZlbnRUYXJnZXQgYXMgJGhmMGxqJGdldEV2ZW50VGFyZ2V0fSBmcm9tIFwiQHJlYWN0LWFyaWEvdXRpbHNcIjtcblxuLypcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIC8vIFBvcnRpb25zIG9mIHRoZSBjb2RlIGluIHRoaXMgZmlsZSBhcmUgYmFzZWQgb24gY29kZSBmcm9tIHJlYWN0LlxuLy8gT3JpZ2luYWwgbGljZW5zaW5nIGZvciB0aGUgZm9sbG93aW5nIGNhbiBiZSBmb3VuZCBpbiB0aGVcbi8vIE5PVElDRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC90cmVlL2NjN2MxYWVjZTQ2YTZiNjliNDE5NThkNzMxZTBmZDI3Yzk0YmZjNmMvcGFja2FnZXMvcmVhY3QtaW50ZXJhY3Rpb25zXG5cblxuXG5mdW5jdGlvbiAkYTFlYTU5ZDY4MjcwZjBkZCRleHBvcnQkZjgxNjhkOGRkOGZkNjZlNihwcm9wcykge1xuICAgIGxldCB7IGlzRGlzYWJsZWQ6IGlzRGlzYWJsZWQsIG9uRm9jdXM6IG9uRm9jdXNQcm9wLCBvbkJsdXI6IG9uQmx1clByb3AsIG9uRm9jdXNDaGFuZ2U6IG9uRm9jdXNDaGFuZ2UgfSA9IHByb3BzO1xuICAgIGNvbnN0IG9uQmx1ciA9ICgwLCAkaGYwbGokdXNlQ2FsbGJhY2spKChlKT0+e1xuICAgICAgICBpZiAoZS50YXJnZXQgPT09IGUuY3VycmVudFRhcmdldCkge1xuICAgICAgICAgICAgaWYgKG9uQmx1clByb3ApIG9uQmx1clByb3AoZSk7XG4gICAgICAgICAgICBpZiAob25Gb2N1c0NoYW5nZSkgb25Gb2N1c0NoYW5nZShmYWxzZSk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH0sIFtcbiAgICAgICAgb25CbHVyUHJvcCxcbiAgICAgICAgb25Gb2N1c0NoYW5nZVxuICAgIF0pO1xuICAgIGNvbnN0IG9uU3ludGhldGljRm9jdXMgPSAoMCwgJDhhOWNiMjc5ZGM4N2UxMzAkZXhwb3J0JDcxNWM2ODJkMDlkNjM5Y2MpKG9uQmx1cik7XG4gICAgY29uc3Qgb25Gb2N1cyA9ICgwLCAkaGYwbGokdXNlQ2FsbGJhY2spKChlKT0+e1xuICAgICAgICAvLyBEb3VibGUgY2hlY2sgdGhhdCBkb2N1bWVudC5hY3RpdmVFbGVtZW50IGFjdHVhbGx5IG1hdGNoZXMgZS50YXJnZXQgaW4gY2FzZSBhIHByZXZpb3VzbHkgY2hhaW5lZFxuICAgICAgICAvLyBmb2N1cyBoYW5kbGVyIGFscmVhZHkgbW92ZWQgZm9jdXMgc29tZXdoZXJlIGVsc2UuXG4gICAgICAgIGNvbnN0IG93bmVyRG9jdW1lbnQgPSAoMCwgJGhmMGxqJGdldE93bmVyRG9jdW1lbnQpKGUudGFyZ2V0KTtcbiAgICAgICAgY29uc3QgYWN0aXZlRWxlbWVudCA9IG93bmVyRG9jdW1lbnQgPyAoMCwgJGhmMGxqJGdldEFjdGl2ZUVsZW1lbnQpKG93bmVyRG9jdW1lbnQpIDogKDAsICRoZjBsaiRnZXRBY3RpdmVFbGVtZW50KSgpO1xuICAgICAgICBpZiAoZS50YXJnZXQgPT09IGUuY3VycmVudFRhcmdldCAmJiBhY3RpdmVFbGVtZW50ID09PSAoMCwgJGhmMGxqJGdldEV2ZW50VGFyZ2V0KShlLm5hdGl2ZUV2ZW50KSkge1xuICAgICAgICAgICAgaWYgKG9uRm9jdXNQcm9wKSBvbkZvY3VzUHJvcChlKTtcbiAgICAgICAgICAgIGlmIChvbkZvY3VzQ2hhbmdlKSBvbkZvY3VzQ2hhbmdlKHRydWUpO1xuICAgICAgICAgICAgb25TeW50aGV0aWNGb2N1cyhlKTtcbiAgICAgICAgfVxuICAgIH0sIFtcbiAgICAgICAgb25Gb2N1c0NoYW5nZSxcbiAgICAgICAgb25Gb2N1c1Byb3AsXG4gICAgICAgIG9uU3ludGhldGljRm9jdXNcbiAgICBdKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBmb2N1c1Byb3BzOiB7XG4gICAgICAgICAgICBvbkZvY3VzOiAhaXNEaXNhYmxlZCAmJiAob25Gb2N1c1Byb3AgfHwgb25Gb2N1c0NoYW5nZSB8fCBvbkJsdXJQcm9wKSA/IG9uRm9jdXMgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBvbkJsdXI6ICFpc0Rpc2FibGVkICYmIChvbkJsdXJQcm9wIHx8IG9uRm9jdXNDaGFuZ2UpID8gb25CbHVyIDogdW5kZWZpbmVkXG4gICAgICAgIH1cbiAgICB9O1xufVxuXG5cbmV4cG9ydCB7JGExZWE1OWQ2ODI3MGYwZGQkZXhwb3J0JGY4MTY4ZDhkZDhmZDY2ZTYgYXMgdXNlRm9jdXN9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXNlRm9jdXMubW9kdWxlLmpzLm1hcFxuIl0sIm5hbWVzIjpbInVzZVN5bnRoZXRpY0JsdXJFdmVudCIsIiQ4YTljYjI3OWRjODdlMTMwJGV4cG9ydCQ3MTVjNjgyZDA5ZDYzOWNjIiwidXNlQ2FsbGJhY2siLCIkaGYwbGokdXNlQ2FsbGJhY2siLCJnZXRPd25lckRvY3VtZW50IiwiJGhmMGxqJGdldE93bmVyRG9jdW1lbnQiLCJnZXRBY3RpdmVFbGVtZW50IiwiJGhmMGxqJGdldEFjdGl2ZUVsZW1lbnQiLCJnZXRFdmVudFRhcmdldCIsIiRoZjBsaiRnZXRFdmVudFRhcmdldCIsIiRhMWVhNTlkNjgyNzBmMGRkJGV4cG9ydCRmODE2OGQ4ZGQ4ZmQ2NmU2IiwicHJvcHMiLCJpc0Rpc2FibGVkIiwib25Gb2N1cyIsIm9uRm9jdXNQcm9wIiwib25CbHVyIiwib25CbHVyUHJvcCIsIm9uRm9jdXNDaGFuZ2UiLCJlIiwidGFyZ2V0IiwiY3VycmVudFRhcmdldCIsIm9uU3ludGhldGljRm9jdXMiLCJvd25lckRvY3VtZW50IiwiYWN0aXZlRWxlbWVudCIsIm5hdGl2ZUV2ZW50IiwiZm9jdXNQcm9wcyIsInVuZGVmaW5lZCIsInVzZUZvY3VzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../../../node_modules/@react-aria/interactions/dist/useFocus.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/../../../../node_modules/@react-aria/interactions/dist/useFocusVisible.mjs":
/*!**********************************************************************************!*\
  !*** ../../../../node_modules/@react-aria/interactions/dist/useFocusVisible.mjs ***!
  \**********************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addWindowFocusTracking: function() { return /* binding */ $507fabe10e71c6fb$export$2f1888112f558a7d; },\n/* harmony export */   getInteractionModality: function() { return /* binding */ $507fabe10e71c6fb$export$630ff653c5ada6a9; },\n/* harmony export */   hasSetupGlobalListeners: function() { return /* binding */ $507fabe10e71c6fb$export$d90243b58daecda7; },\n/* harmony export */   isFocusVisible: function() { return /* binding */ $507fabe10e71c6fb$export$b9b3dfddab17db27; },\n/* harmony export */   setInteractionModality: function() { return /* binding */ $507fabe10e71c6fb$export$8397ddfc504fdb9a; },\n/* harmony export */   useFocusVisible: function() { return /* binding */ $507fabe10e71c6fb$export$ffd9e5021c1fb2d6; },\n/* harmony export */   useFocusVisibleListener: function() { return /* binding */ $507fabe10e71c6fb$export$ec71b4b83ac08ec3; },\n/* harmony export */   useInteractionModality: function() { return /* binding */ $507fabe10e71c6fb$export$98e20ec92f614cfe; }\n/* harmony export */ });\n/* harmony import */ var _utils_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils.mjs */ \"(app-pages-browser)/../../../../node_modules/@react-aria/interactions/dist/utils.mjs\");\n/* harmony import */ var _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @react-aria/utils */ \"(app-pages-browser)/../../../../node_modules/@react-aria/utils/dist/platform.mjs\");\n/* harmony import */ var _react_aria_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @react-aria/utils */ \"(app-pages-browser)/../../../../node_modules/@react-aria/utils/dist/isVirtualEvent.mjs\");\n/* harmony import */ var _react_aria_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @react-aria/utils */ \"(app-pages-browser)/../../../../node_modules/@react-aria/utils/dist/domHelpers.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var _react_aria_ssr__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @react-aria/ssr */ \"(app-pages-browser)/../../../../node_modules/@react-aria/ssr/dist/SSRProvider.mjs\");\n\n\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ // Portions of the code in this file are based on code from react.\n// Original licensing for the following can be found in the\n// NOTICE file in the root directory of this source tree.\n// See https://github.com/facebook/react/tree/cc7c1aece46a6b69b41958d731e0fd27c94bfc6c/packages/react-interactions\nlet $507fabe10e71c6fb$var$currentModality = null;\nlet $507fabe10e71c6fb$var$changeHandlers = new Set();\nlet $507fabe10e71c6fb$export$d90243b58daecda7 = new Map(); // We use a map here to support setting event listeners across multiple document objects.\nlet $507fabe10e71c6fb$var$hasEventBeforeFocus = false;\nlet $507fabe10e71c6fb$var$hasBlurredWindowRecently = false;\n// Only Tab or Esc keys will make focus visible on text input elements\nconst $507fabe10e71c6fb$var$FOCUS_VISIBLE_INPUT_KEYS = {\n    Tab: true,\n    Escape: true\n};\nfunction $507fabe10e71c6fb$var$triggerChangeHandlers(modality, e) {\n    for (let handler of $507fabe10e71c6fb$var$changeHandlers)handler(modality, e);\n}\n/**\n * Helper function to determine if a KeyboardEvent is unmodified and could make keyboard focus styles visible.\n */ function $507fabe10e71c6fb$var$isValidKey(e) {\n    // Control and Shift keys trigger when navigating back to the tab with keyboard.\n    return !(e.metaKey || !(0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.isMac)() && e.altKey || e.ctrlKey || e.key === \"Control\" || e.key === \"Shift\" || e.key === \"Meta\");\n}\nfunction $507fabe10e71c6fb$var$handleKeyboardEvent(e) {\n    $507fabe10e71c6fb$var$hasEventBeforeFocus = true;\n    if ($507fabe10e71c6fb$var$isValidKey(e)) {\n        $507fabe10e71c6fb$var$currentModality = \"keyboard\";\n        $507fabe10e71c6fb$var$triggerChangeHandlers(\"keyboard\", e);\n    }\n}\nfunction $507fabe10e71c6fb$var$handlePointerEvent(e) {\n    $507fabe10e71c6fb$var$currentModality = \"pointer\";\n    if (e.type === \"mousedown\" || e.type === \"pointerdown\") {\n        $507fabe10e71c6fb$var$hasEventBeforeFocus = true;\n        $507fabe10e71c6fb$var$triggerChangeHandlers(\"pointer\", e);\n    }\n}\nfunction $507fabe10e71c6fb$var$handleClickEvent(e) {\n    if ((0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_2__.isVirtualClick)(e)) {\n        $507fabe10e71c6fb$var$hasEventBeforeFocus = true;\n        $507fabe10e71c6fb$var$currentModality = \"virtual\";\n    }\n}\nfunction $507fabe10e71c6fb$var$handleFocusEvent(e) {\n    // Firefox fires two extra focus events when the user first clicks into an iframe:\n    // first on the window, then on the document. We ignore these events so they don't\n    // cause keyboard focus rings to appear.\n    if (e.target === window || e.target === document || (0, _utils_mjs__WEBPACK_IMPORTED_MODULE_3__.ignoreFocusEvent) || !e.isTrusted) return;\n    // If a focus event occurs without a preceding keyboard or pointer event, switch to virtual modality.\n    // This occurs, for example, when navigating a form with the next/previous buttons on iOS.\n    if (!$507fabe10e71c6fb$var$hasEventBeforeFocus && !$507fabe10e71c6fb$var$hasBlurredWindowRecently) {\n        $507fabe10e71c6fb$var$currentModality = \"virtual\";\n        $507fabe10e71c6fb$var$triggerChangeHandlers(\"virtual\", e);\n    }\n    $507fabe10e71c6fb$var$hasEventBeforeFocus = false;\n    $507fabe10e71c6fb$var$hasBlurredWindowRecently = false;\n}\nfunction $507fabe10e71c6fb$var$handleWindowBlur() {\n    if (0, _utils_mjs__WEBPACK_IMPORTED_MODULE_3__.ignoreFocusEvent) return;\n    // When the window is blurred, reset state. This is necessary when tabbing out of the window,\n    // for example, since a subsequent focus event won't be fired.\n    $507fabe10e71c6fb$var$hasEventBeforeFocus = false;\n    $507fabe10e71c6fb$var$hasBlurredWindowRecently = true;\n}\n/**\n * Setup global event listeners to control when keyboard focus style should be visible.\n */ function $507fabe10e71c6fb$var$setupGlobalFocusEvents(element) {\n    if ( false || $507fabe10e71c6fb$export$d90243b58daecda7.get((0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_4__.getOwnerWindow)(element))) return;\n    const windowObject = (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_4__.getOwnerWindow)(element);\n    const documentObject = (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_4__.getOwnerDocument)(element);\n    // Programmatic focus() calls shouldn't affect the current input modality.\n    // However, we need to detect other cases when a focus event occurs without\n    // a preceding user event (e.g. screen reader focus). Overriding the focus\n    // method on HTMLElement.prototype is a bit hacky, but works.\n    let focus = windowObject.HTMLElement.prototype.focus;\n    windowObject.HTMLElement.prototype.focus = function() {\n        $507fabe10e71c6fb$var$hasEventBeforeFocus = true;\n        focus.apply(this, arguments);\n    };\n    documentObject.addEventListener(\"keydown\", $507fabe10e71c6fb$var$handleKeyboardEvent, true);\n    documentObject.addEventListener(\"keyup\", $507fabe10e71c6fb$var$handleKeyboardEvent, true);\n    documentObject.addEventListener(\"click\", $507fabe10e71c6fb$var$handleClickEvent, true);\n    // Register focus events on the window so they are sure to happen\n    // before React's event listeners (registered on the document).\n    windowObject.addEventListener(\"focus\", $507fabe10e71c6fb$var$handleFocusEvent, true);\n    windowObject.addEventListener(\"blur\", $507fabe10e71c6fb$var$handleWindowBlur, false);\n    if (typeof PointerEvent !== \"undefined\") {\n        documentObject.addEventListener(\"pointerdown\", $507fabe10e71c6fb$var$handlePointerEvent, true);\n        documentObject.addEventListener(\"pointermove\", $507fabe10e71c6fb$var$handlePointerEvent, true);\n        documentObject.addEventListener(\"pointerup\", $507fabe10e71c6fb$var$handlePointerEvent, true);\n    } else if (false) {}\n    // Add unmount handler\n    windowObject.addEventListener(\"beforeunload\", ()=>{\n        $507fabe10e71c6fb$var$tearDownWindowFocusTracking(element);\n    }, {\n        once: true\n    });\n    $507fabe10e71c6fb$export$d90243b58daecda7.set(windowObject, {\n        focus: focus\n    });\n}\nconst $507fabe10e71c6fb$var$tearDownWindowFocusTracking = (element, loadListener)=>{\n    const windowObject = (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_4__.getOwnerWindow)(element);\n    const documentObject = (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_4__.getOwnerDocument)(element);\n    if (loadListener) documentObject.removeEventListener(\"DOMContentLoaded\", loadListener);\n    if (!$507fabe10e71c6fb$export$d90243b58daecda7.has(windowObject)) return;\n    windowObject.HTMLElement.prototype.focus = $507fabe10e71c6fb$export$d90243b58daecda7.get(windowObject).focus;\n    documentObject.removeEventListener(\"keydown\", $507fabe10e71c6fb$var$handleKeyboardEvent, true);\n    documentObject.removeEventListener(\"keyup\", $507fabe10e71c6fb$var$handleKeyboardEvent, true);\n    documentObject.removeEventListener(\"click\", $507fabe10e71c6fb$var$handleClickEvent, true);\n    windowObject.removeEventListener(\"focus\", $507fabe10e71c6fb$var$handleFocusEvent, true);\n    windowObject.removeEventListener(\"blur\", $507fabe10e71c6fb$var$handleWindowBlur, false);\n    if (typeof PointerEvent !== \"undefined\") {\n        documentObject.removeEventListener(\"pointerdown\", $507fabe10e71c6fb$var$handlePointerEvent, true);\n        documentObject.removeEventListener(\"pointermove\", $507fabe10e71c6fb$var$handlePointerEvent, true);\n        documentObject.removeEventListener(\"pointerup\", $507fabe10e71c6fb$var$handlePointerEvent, true);\n    } else if (false) {}\n    $507fabe10e71c6fb$export$d90243b58daecda7.delete(windowObject);\n};\nfunction $507fabe10e71c6fb$export$2f1888112f558a7d(element) {\n    const documentObject = (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_4__.getOwnerDocument)(element);\n    let loadListener;\n    if (documentObject.readyState !== \"loading\") $507fabe10e71c6fb$var$setupGlobalFocusEvents(element);\n    else {\n        loadListener = ()=>{\n            $507fabe10e71c6fb$var$setupGlobalFocusEvents(element);\n        };\n        documentObject.addEventListener(\"DOMContentLoaded\", loadListener);\n    }\n    return ()=>$507fabe10e71c6fb$var$tearDownWindowFocusTracking(element, loadListener);\n}\n// Server-side rendering does not have the document object defined\n// eslint-disable-next-line no-restricted-globals\nif (typeof document !== \"undefined\") $507fabe10e71c6fb$export$2f1888112f558a7d();\nfunction $507fabe10e71c6fb$export$b9b3dfddab17db27() {\n    return $507fabe10e71c6fb$var$currentModality !== \"pointer\";\n}\nfunction $507fabe10e71c6fb$export$630ff653c5ada6a9() {\n    return $507fabe10e71c6fb$var$currentModality;\n}\nfunction $507fabe10e71c6fb$export$8397ddfc504fdb9a(modality) {\n    $507fabe10e71c6fb$var$currentModality = modality;\n    $507fabe10e71c6fb$var$triggerChangeHandlers(modality, null);\n}\nfunction $507fabe10e71c6fb$export$98e20ec92f614cfe() {\n    $507fabe10e71c6fb$var$setupGlobalFocusEvents();\n    let [modality, setModality] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)($507fabe10e71c6fb$var$currentModality);\n    (0, react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        let handler = ()=>{\n            setModality($507fabe10e71c6fb$var$currentModality);\n        };\n        $507fabe10e71c6fb$var$changeHandlers.add(handler);\n        return ()=>{\n            $507fabe10e71c6fb$var$changeHandlers.delete(handler);\n        };\n    }, []);\n    return (0, _react_aria_ssr__WEBPACK_IMPORTED_MODULE_5__.useIsSSR)() ? null : modality;\n}\nconst $507fabe10e71c6fb$var$nonTextInputTypes = new Set([\n    \"checkbox\",\n    \"radio\",\n    \"range\",\n    \"color\",\n    \"file\",\n    \"image\",\n    \"button\",\n    \"submit\",\n    \"reset\"\n]);\n/**\n * If this is attached to text input component, return if the event is a focus event (Tab/Escape keys pressed) so that\n * focus visible style can be properly set.\n */ function $507fabe10e71c6fb$var$isKeyboardFocusEvent(isTextInput, modality, e) {\n    let document1 = (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_4__.getOwnerDocument)(e === null || e === void 0 ? void 0 : e.target);\n    const IHTMLInputElement =  true ? (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_4__.getOwnerWindow)(e === null || e === void 0 ? void 0 : e.target).HTMLInputElement : 0;\n    const IHTMLTextAreaElement =  true ? (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_4__.getOwnerWindow)(e === null || e === void 0 ? void 0 : e.target).HTMLTextAreaElement : 0;\n    const IHTMLElement =  true ? (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_4__.getOwnerWindow)(e === null || e === void 0 ? void 0 : e.target).HTMLElement : 0;\n    const IKeyboardEvent =  true ? (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_4__.getOwnerWindow)(e === null || e === void 0 ? void 0 : e.target).KeyboardEvent : 0;\n    // For keyboard events that occur on a non-input element that will move focus into input element (aka ArrowLeft going from Datepicker button to the main input group)\n    // we need to rely on the user passing isTextInput into here. This way we can skip toggling focus visiblity for said input element\n    isTextInput = isTextInput || document1.activeElement instanceof IHTMLInputElement && !$507fabe10e71c6fb$var$nonTextInputTypes.has(document1.activeElement.type) || document1.activeElement instanceof IHTMLTextAreaElement || document1.activeElement instanceof IHTMLElement && document1.activeElement.isContentEditable;\n    return !(isTextInput && modality === \"keyboard\" && e instanceof IKeyboardEvent && !$507fabe10e71c6fb$var$FOCUS_VISIBLE_INPUT_KEYS[e.key]);\n}\nfunction $507fabe10e71c6fb$export$ffd9e5021c1fb2d6() {\n    let props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n    let { isTextInput: isTextInput, autoFocus: autoFocus } = props;\n    let [isFocusVisibleState, setFocusVisible] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(autoFocus || $507fabe10e71c6fb$export$b9b3dfddab17db27());\n    $507fabe10e71c6fb$export$ec71b4b83ac08ec3((isFocusVisible)=>{\n        setFocusVisible(isFocusVisible);\n    }, [\n        isTextInput\n    ], {\n        isTextInput: isTextInput\n    });\n    return {\n        isFocusVisible: isFocusVisibleState\n    };\n}\nfunction $507fabe10e71c6fb$export$ec71b4b83ac08ec3(fn, deps, opts) {\n    $507fabe10e71c6fb$var$setupGlobalFocusEvents();\n    (0, react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        let handler = (modality, e)=>{\n            // We want to early return for any keyboard events that occur inside text inputs EXCEPT for Tab and Escape\n            if (!$507fabe10e71c6fb$var$isKeyboardFocusEvent(!!(opts === null || opts === void 0 ? void 0 : opts.isTextInput), modality, e)) return;\n            fn($507fabe10e71c6fb$export$b9b3dfddab17db27());\n        };\n        $507fabe10e71c6fb$var$changeHandlers.add(handler);\n        return ()=>{\n            $507fabe10e71c6fb$var$changeHandlers.delete(handler);\n        };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, deps);\n}\n //# sourceMappingURL=useFocusVisible.module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQHJlYWN0LWFyaWEvaW50ZXJhY3Rpb25zL2Rpc3QvdXNlRm9jdXNWaXNpYmxlLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7OztBQUEwRjtBQUM2RjtBQUN0RztBQUNyQjtBQUU1RDs7Ozs7Ozs7OztDQVVDLEdBQUcsa0VBQWtFO0FBQ3RFLDJEQUEyRDtBQUMzRCx5REFBeUQ7QUFDekQsa0hBQWtIO0FBS2xILElBQUlnQix3Q0FBd0M7QUFDNUMsSUFBSUMsdUNBQXVDLElBQUlDO0FBQy9DLElBQUlDLDRDQUE0QyxJQUFJQyxPQUFPLHlGQUF5RjtBQUNwSixJQUFJQyw0Q0FBNEM7QUFDaEQsSUFBSUMsaURBQWlEO0FBQ3JELHNFQUFzRTtBQUN0RSxNQUFNQyxpREFBaUQ7SUFDbkRDLEtBQUs7SUFDTEMsUUFBUTtBQUNaO0FBQ0EsU0FBU0MsNENBQTRDQyxRQUFRLEVBQUVDLENBQUM7SUFDNUQsS0FBSyxJQUFJQyxXQUFXWixxQ0FBcUNZLFFBQVFGLFVBQVVDO0FBQy9FO0FBQ0E7O0NBRUMsR0FBRyxTQUFTRSxpQ0FBaUNGLENBQUM7SUFDM0MsZ0ZBQWdGO0lBQ2hGLE9BQU8sQ0FBRUEsQ0FBQUEsRUFBRUcsT0FBTyxJQUFJLENBQUMsQ0FBQyxHQUFHNUIsb0RBQVcsT0FBUXlCLEVBQUVJLE1BQU0sSUFBSUosRUFBRUssT0FBTyxJQUFJTCxFQUFFTSxHQUFHLEtBQUssYUFBYU4sRUFBRU0sR0FBRyxLQUFLLFdBQVdOLEVBQUVNLEdBQUcsS0FBSyxNQUFLO0FBQ3RJO0FBQ0EsU0FBU0MsMENBQTBDUCxDQUFDO0lBQ2hEUCw0Q0FBNEM7SUFDNUMsSUFBSVMsaUNBQWlDRixJQUFJO1FBQ3JDWix3Q0FBd0M7UUFDeENVLDRDQUE0QyxZQUFZRTtJQUM1RDtBQUNKO0FBQ0EsU0FBU1EseUNBQXlDUixDQUFDO0lBQy9DWix3Q0FBd0M7SUFDeEMsSUFBSVksRUFBRVMsSUFBSSxLQUFL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dUQsR0FBRyxDQUFDM0M7UUFDekMsT0FBTztZQUNIWixxQ0FBcUMrQyxNQUFNLENBQUNuQztRQUNoRDtJQUNKLHVEQUF1RDtJQUN2RCxHQUFHaUU7QUFDUDtBQUdtaUIsQ0FDbmlCLGtEQUFrRCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0ByZWFjdC1hcmlhL2ludGVyYWN0aW9ucy9kaXN0L3VzZUZvY3VzVmlzaWJsZS5tanM/OTI3NCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge2lnbm9yZUZvY3VzRXZlbnQgYXMgJDhhOWNiMjc5ZGM4N2UxMzAkZXhwb3J0JGZkYTdkYTczYWI1ZDRjNDh9IGZyb20gXCIuL3V0aWxzLm1qc1wiO1xuaW1wb3J0IHtpc01hYyBhcyAkMjhBblIkaXNNYWMsIGlzVmlydHVhbENsaWNrIGFzICQyOEFuUiRpc1ZpcnR1YWxDbGljaywgZ2V0T3duZXJXaW5kb3cgYXMgJDI4QW5SJGdldE93bmVyV2luZG93LCBnZXRPd25lckRvY3VtZW50IGFzICQyOEFuUiRnZXRPd25lckRvY3VtZW50fSBmcm9tIFwiQHJlYWN0LWFyaWEvdXRpbHNcIjtcbmltcG9ydCB7dXNlU3RhdGUgYXMgJDI4QW5SJHVzZVN0YXRlLCB1c2VFZmZlY3QgYXMgJDI4QW5SJHVzZUVmZmVjdH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQge3VzZUlzU1NSIGFzICQyOEFuUiR1c2VJc1NTUn0gZnJvbSBcIkByZWFjdC1hcmlhL3NzclwiO1xuXG4vKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gLy8gUG9ydGlvbnMgb2YgdGhlIGNvZGUgaW4gdGhpcyBmaWxlIGFyZSBiYXNlZCBvbiBjb2RlIGZyb20gcmVhY3QuXG4vLyBPcmlnaW5hbCBsaWNlbnNpbmcgZm9yIHRoZSBmb2xsb3dpbmcgY2FuIGJlIGZvdW5kIGluIHRoZVxuLy8gTk9USUNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4vLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L3RyZWUvY2M3YzFhZWNlNDZhNmI2OWI0MTk1OGQ3MzFlMGZkMjdjOTRiZmM2Yy9wYWNrYWdlcy9yZWFjdC1pbnRlcmFjdGlvbnNcblxuXG5cblxubGV0ICQ1MDdmYWJlMTBlNzFjNmZiJHZhciRjdXJyZW50TW9kYWxpdHkgPSBudWxsO1xubGV0ICQ1MDdmYWJlMTBlNzFjNmZiJHZhciRjaGFuZ2VIYW5kbGVycyA9IG5ldyBTZXQoKTtcbmxldCAkNTA3ZmFiZTEwZTcxYzZmYiRleHBvcnQkZDkwMjQzYjU4ZGFlY2RhNyA9IG5ldyBNYXAoKTsgLy8gV2UgdXNlIGEgbWFwIGhlcmUgdG8gc3VwcG9ydCBzZXR0aW5nIGV2ZW50IGxpc3RlbmVycyBhY3Jvc3MgbXVsdGlwbGUgZG9jdW1lbnQgb2JqZWN0cy5cbmxldCAkNTA3ZmFiZTEwZTcxYzZmYiR2YXIkaGFzRXZlbnRCZWZvcmVGb2N1cyA9IGZhbHNlO1xubGV0ICQ1MDdmYWJlMTBlNzFjNmZiJHZhciRoYXNCbHVycmVkV2luZG93UmVjZW50bHkgPSBmYWxzZTtcbi8vIE9ubHkgVGFiIG9yIEVzYyBrZXlzIHdpbGwgbWFrZSBmb2N1cyB2aXNpYmxlIG9uIHRleHQgaW5wdXQgZWxlbWVudHNcbmNvbnN0ICQ1MDdmYWJlMTBlNzFjNmZiJHZhciRGT0NVU19WSVNJQkxFX0lOUFVUX0tFWVMgPSB7XG4gICAgVGFiOiB0cnVlLFxuICAgIEVzY2FwZTogdHJ1ZVxufTtcbmZ1bmN0aW9uICQ1MDdmYWJlMTBlNzFjNmZiJHZhciR0cmlnZ2VyQ2hhbmdlSGFuZGxlcnMobW9kYWxpdHksIGUpIHtcbiAgICBmb3IgKGxldCBoYW5kbGVyIG9mICQ1MDdmYWJlMTBlNzFjNmZiJHZhciRjaGFuZ2VIYW5kbGVycyloYW5kbGVyKG1vZGFsaXR5LCBlKTtcbn1cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIHRvIGRldGVybWluZSBpZiBhIEtleWJvYXJkRXZlbnQgaXMgdW5tb2RpZmllZCBhbmQgY291bGQgbWFrZSBrZXlib2FyZCBmb2N1cyBzdHlsZXMgdmlzaWJsZS5cbiAqLyBmdW5jdGlvbiAkNTA3ZmFiZTEwZTcxYzZmYiR2YXIkaXNWYWxpZEtleShlKSB7XG4gICAgLy8gQ29udHJvbCBhbmQgU2hpZnQga2V5cyB0cmlnZ2VyIHdoZW4gbmF2aWdhdGluZyBiYWNrIHRvIHRoZSB0YWIgd2l0aCBrZXlib2FyZC5cbiAgICByZXR1cm4gIShlLm1ldGFLZXkgfHwgISgwLCAkMjhBblIkaXNNYWMpKCkgJiYgZS5hbHRLZXkgfHwgZS5jdHJsS2V5IHx8IGUua2V5ID09PSAnQ29udHJvbCcgfHwgZS5rZXkgPT09ICdTaGlmdCcgfHwgZS5rZXkgPT09ICdNZXRhJyk7XG59XG5mdW5jdGlvbiAkNTA3ZmFiZTEwZTcxYzZmYiR2YXIkaGFuZGxlS2V5Ym9hcmRFdmVudChlKSB7XG4gICAgJDUwN2ZhYmUxMGU3MWM2ZmIkdmFyJGhhc0V2ZW50QmVmb3JlRm9jdXMgPSB0cnVlO1xuICAgIGlmICgkNTA3ZmFiZTEwZTcxYzZmYiR2YXIkaXNWYWxpZEtleShlKSkge1xuICAgICAgICAkNTA3ZmFiZTEwZTcxYzZmYiR2YXIkY3VycmVudE1vZGFsaXR5ID0gJ2tleWJvYXJkJztcbiAgICAgICAgJDUwN2ZhYmUxMGU3MWM2ZmIkdmFyJHRyaWdnZXJDaGFuZ2VIYW5kbGVycygna2V5Ym9hcmQnLCBlKTtcbiAgICB9XG59XG5mdW5jdGlvbiAkNTA3ZmFiZTEwZTcxYzZmYiR2YXIkaGFuZGxlUG9pbnRlckV2ZW50KGUpIHtcbiAgICAkNTA3ZmFiZTEwZTcxYzZmYiR2YXIkY3VycmVudE1vZGFsaXR5ID0gJ3BvaW50ZXInO1xuICAgIGlmIChlLnR5cGUgPT09ICdtb3VzZWRvd24nIHx8IGUudHlwZSA9PT0gJ3BvaW50ZXJkb3duJykge1xuICAgICAgICAkNTA3ZmFiZTEwZTcxYzZmYiR2YXIkaGFzRXZlbnRCZWZvcmVGb2N1cyA9IHRydWU7XG4gICAgICAgICQ1MDdmYWJlMTBlNzFjNmZiJHZhciR0cmlnZ2VyQ2hhbmdlSGFuZGxlcnMoJ3BvaW50ZXInLCBlKTtcbiAgICB9XG59XG5mdW5jdGlvbiAkNTA3ZmFiZTEwZTcxYzZmYiR2YXIkaGFuZGxlQ2xpY2tFdmVudChlKSB7XG4gICAgaWYgKCgwLCAkMjhBblIkaXNWaXJ0dWFsQ2xpY2spKGUpKSB7XG4gICAgICAgICQ1MDdmYWJlMTBlNzFjNmZiJHZhciRoYXNFdmVudEJlZm9yZUZvY3VzID0gdHJ1ZTtcbiAgICAgICAgJDUwN2ZhYmUxMGU3MWM2ZmIkdmFyJGN1cnJlbnRNb2RhbGl0eSA9ICd2aXJ0dWFsJztcbiAgICB9XG59XG5mdW5jdGlvbiAkNTA3ZmFiZTEwZTcxYzZmYiR2YXIkaGFuZGxlRm9jdXNFdmVudChlKSB7XG4gICAgLy8gRmlyZWZveCBmaXJlcyB0d28gZXh0cmEgZm9jdXMgZXZlbnRzIHdoZW4gdGhlIHVzZXIgZmlyc3QgY2xpY2tzIGludG8gYW4gaWZyYW1lOlxuICAgIC8vIGZpcnN0IG9uIHRoZSB3aW5kb3csIHRoZW4gb24gdGhlIGRvY3VtZW50LiBXZSBpZ25vcmUgdGhlc2UgZXZlbnRzIHNvIHRoZXkgZG9uJ3RcbiAgICAvLyBjYXVzZSBrZXlib2FyZCBmb2N1cyByaW5ncyB0byBhcHBlYXIuXG4gICAgaWYgKGUudGFyZ2V0ID09PSB3aW5kb3cgfHwgZS50YXJnZXQgPT09IGRvY3VtZW50IHx8ICgwLCAkOGE5Y2IyNzlkYzg3ZTEzMCRleHBvcnQkZmRhN2RhNzNhYjVkNGM0OCkgfHwgIWUuaXNUcnVzdGVkKSByZXR1cm47XG4gICAgLy8gSWYgYSBmb2N1cyBldmVudCBvY2N1cnMgd2l0aG91dCBhIHByZWNlZGluZyBrZXlib2FyZCBvciBwb2ludGVyIGV2ZW50LCBzd2l0Y2ggdG8gdmlydHVhbCBtb2RhbGl0eS5cbiAgICAvLyBUaGlzIG9jY3VycywgZm9yIGV4YW1wbGUsIHdoZW4gbmF2aWdhdGluZyBhIGZvcm0gd2l0aCB0aGUgbmV4dC9wcmV2aW91cyBidXR0b25zIG9uIGlPUy5cbiAgICBpZiAoISQ1MDdmYWJlMTBlNzFjNmZiJHZhciRoYXNFdmVudEJlZm9yZUZvY3VzICYmICEkNTA3ZmFiZTEwZTcxYzZmYiR2YXIkaGFzQmx1cnJlZFdpbmRvd1JlY2VudGx5KSB7XG4gICAgICAgICQ1MDdmYWJlMTBlNzFjNmZiJHZhciRjdXJyZW50TW9kYWxpdHkgPSAndmlydHVhbCc7XG4gICAgICAgICQ1MDdmYWJlMTBlNzFjNmZiJHZhciR0cmlnZ2VyQ2hhbmdlSGFuZGxlcnMoJ3ZpcnR1YWwnLCBlKTtcbiAgICB9XG4gICAgJDUwN2ZhYmUxMGU3MWM2ZmIkdmFyJGhhc0V2ZW50QmVmb3JlRm9jdXMgPSBmYWxzZTtcbiAgICAkNTA3ZmFiZTEwZTcxYzZmYiR2YXIkaGFzQmx1cnJlZFdpbmRvd1JlY2VudGx5ID0gZmFsc2U7XG59XG5mdW5jdGlvbiAkNTA3ZmFiZTEwZTcxYzZmYiR2YXIkaGFuZGxlV2luZG93Qmx1cigpIHtcbiAgICBpZiAoMCwgJDhhOWNiMjc5ZGM4N2UxMzAkZXhwb3J0JGZkYTdkYTczYWI1ZDRjNDgpIHJldHVybjtcbiAgICAvLyBXaGVuIHRoZSB3aW5kb3cgaXMgYmx1cnJlZCwgcmVzZXQgc3RhdGUuIFRoaXMgaXMgbmVjZXNzYXJ5IHdoZW4gdGFiYmluZyBvdXQgb2YgdGhlIHdpbmRvdyxcbiAgICAvLyBmb3IgZXhhbXBsZSwgc2luY2UgYSBzdWJzZXF1ZW50IGZvY3VzIGV2ZW50IHdvbid0IGJlIGZpcmVkLlxuICAgICQ1MDdmYWJlMTBlNzFjNmZiJHZhciRoYXNFdmVudEJlZm9yZUZvY3VzID0gZmFsc2U7XG4gICAgJDUwN2ZhYmUxMGU3MWM2ZmIkdmFyJGhhc0JsdXJyZWRXaW5kb3dSZWNlbnRseSA9IHRydWU7XG59XG4vKipcbiAqIFNldHVwIGdsb2JhbCBldmVudCBsaXN0ZW5lcnMgdG8gY29udHJvbCB3aGVuIGtleWJvYXJkIGZvY3VzIHN0eWxlIHNob3VsZCBiZSB2aXNpYmxlLlxuICovIGZ1bmN0aW9uICQ1MDdmYWJlMTBlNzFjNmZiJHZhciRzZXR1cEdsb2JhbEZvY3VzRXZlbnRzKGVsZW1lbnQpIHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgfHwgJDUwN2ZhYmUxMGU3MWM2ZmIkZXhwb3J0JGQ5MDI0M2I1OGRhZWNkYTcuZ2V0KCgwLCAkMjhBblIkZ2V0T3duZXJXaW5kb3cpKGVsZW1lbnQpKSkgcmV0dXJuO1xuICAgIGNvbnN0IHdpbmRvd09iamVjdCA9ICgwLCAkMjhBblIkZ2V0T3duZXJXaW5kb3cpKGVsZW1lbnQpO1xuICAgIGNvbnN0IGRvY3VtZW50T2JqZWN0ID0gKDAsICQyOEFuUiRnZXRPd25lckRvY3VtZW50KShlbGVtZW50KTtcbiAgICAvLyBQcm9ncmFtbWF0aWMgZm9jdXMoKSBjYWxscyBzaG91bGRuJ3QgYWZmZWN0IHRoZSBjdXJyZW50IGlucHV0IG1vZGFsaXR5LlxuICAgIC8vIEhvd2V2ZXIsIHdlIG5lZWQgdG8gZGV0ZWN0IG90aGVyIGNhc2VzIHdoZW4gYSBmb2N1cyBldmVudCBvY2N1cnMgd2l0aG91dFxuICAgIC8vIGEgcHJlY2VkaW5nIHVzZXIgZXZlbnQgKGUuZy4gc2NyZWVuIHJlYWRlciBmb2N1cykuIE92ZXJyaWRpbmcgdGhlIGZvY3VzXG4gICAgLy8gbWV0aG9kIG9uIEhUTUxFbGVtZW50LnByb3RvdHlwZSBpcyBhIGJpdCBoYWNreSwgYnV0IHdvcmtzLlxuICAgIGxldCBmb2N1cyA9IHdpbmRvd09iamVjdC5IVE1MRWxlbWVudC5wcm90b3R5cGUuZm9jdXM7XG4gICAgd2luZG93T2JqZWN0LkhUTUxFbGVtZW50LnByb3RvdHlwZS5mb2N1cyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAkNTA3ZmFiZTEwZTcxYzZmYiR2YXIkaGFzRXZlbnRCZWZvcmVGb2N1cyA9IHRydWU7XG4gICAgICAgIGZvY3VzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgICBkb2N1bWVudE9iamVjdC5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgJDUwN2ZhYmUxMGU3MWM2ZmIkdmFyJGhhbmRsZUtleWJvYXJkRXZlbnQsIHRydWUpO1xuICAgIGRvY3VtZW50T2JqZWN0LmFkZEV2ZW50TGlzdGVuZXIoJ2tleXVwJywgJDUwN2ZhYmUxMGU3MWM2ZmIkdmFyJGhhbmRsZUtleWJvYXJkRXZlbnQsIHRydWUpO1xuICAgIGRvY3VtZW50T2JqZWN0LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgJDUwN2ZhYmUxMGU3MWM2ZmIkdmFyJGhhbmRsZUNsaWNrRXZlbnQsIHRydWUpO1xuICAgIC8vIFJlZ2lzdGVyIGZvY3VzIGV2ZW50cyBvbiB0aGUgd2luZG93IHNvIHRoZXkgYXJlIHN1cmUgdG8gaGFwcGVuXG4gICAgLy8gYmVmb3JlIFJlYWN0J3MgZXZlbnQgbGlzdGVuZXJzIChyZWdpc3RlcmVkIG9uIHRoZSBkb2N1bWVudCkuXG4gICAgd2luZG93T2JqZWN0LmFkZEV2ZW50TGlzdGVuZXIoJ2ZvY3VzJywgJDUwN2ZhYmUxMGU3MWM2ZmIkdmFyJGhhbmRsZUZvY3VzRXZlbnQsIHRydWUpO1xuICAgIHdpbmRvd09iamVjdC5hZGRFdmVudExpc3RlbmVyKCdibHVyJywgJDUwN2ZhYmUxMGU3MWM2ZmIkdmFyJGhhbmRsZVdpbmRvd0JsdXIsIGZhbHNlKTtcbiAgICBpZiAodHlwZW9mIFBvaW50ZXJFdmVudCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgZG9jdW1lbnRPYmplY3QuYWRkRXZlbnRMaXN0ZW5lcigncG9pbnRlcmRvd24nLCAkNTA3ZmFiZTEwZTcxYzZmYiR2YXIkaGFuZGxlUG9pbnRlckV2ZW50LCB0cnVlKTtcbiAgICAgICAgZG9jdW1lbnRPYmplY3QuYWRkRXZlbnRMaXN0ZW5lcigncG9pbnRlcm1vdmUnLCAkNTA3ZmFiZTEwZTcxYzZmYiR2YXIkaGFuZGxlUG9pbnRlckV2ZW50LCB0cnVlKTtcbiAgICAgICAgZG9jdW1lbnRPYmplY3QuYWRkRXZlbnRMaXN0ZW5lcigncG9pbnRlcnVwJywgJDUwN2ZhYmUxMGU3MWM2ZmIkdmFyJGhhbmRsZVBvaW50ZXJFdmVudCwgdHJ1ZSk7XG4gICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Rlc3QnKSB7XG4gICAgICAgIGRvY3VtZW50T2JqZWN0LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsICQ1MDdmYWJlMTBlNzFjNmZiJHZhciRoYW5kbGVQb2ludGVyRXZlbnQsIHRydWUpO1xuICAgICAgICBkb2N1bWVudE9iamVjdC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCAkNTA3ZmFiZTEwZTcxYzZmYiR2YXIkaGFuZGxlUG9pbnRlckV2ZW50LCB0cnVlKTtcbiAgICAgICAgZG9jdW1lbnRPYmplY3QuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsICQ1MDdmYWJlMTBlNzFjNmZiJHZhciRoYW5kbGVQb2ludGVyRXZlbnQsIHRydWUpO1xuICAgIH1cbiAgICAvLyBBZGQgdW5tb3VudCBoYW5kbGVyXG4gICAgd2luZG93T2JqZWN0LmFkZEV2ZW50TGlzdGVuZXIoJ2JlZm9yZXVubG9hZCcsICgpPT57XG4gICAgICAgICQ1MDdmYWJlMTBlNzFjNmZiJHZhciR0ZWFyRG93bldpbmRvd0ZvY3VzVHJhY2tpbmcoZWxlbWVudCk7XG4gICAgfSwge1xuICAgICAgICBvbmNlOiB0cnVlXG4gICAgfSk7XG4gICAgJDUwN2ZhYmUxMGU3MWM2ZmIkZXhwb3J0JGQ5MDI0M2I1OGRhZWNkYTcuc2V0KHdpbmRvd09iamVjdCwge1xuICAgICAgICBmb2N1czogZm9jdXNcbiAgICB9KTtcbn1cbmNvbnN0ICQ1MDdmYWJlMTBlNzFjNmZiJHZhciR0ZWFyRG93bldpbmRvd0ZvY3VzVHJhY2tpbmcgPSAoZWxlbWVudCwgbG9hZExpc3RlbmVyKT0+e1xuICAgIGNvbnN0IHdpbmRvd09iamVjdCA9ICgwLCAkMjhBblIkZ2V0T3duZXJXaW5kb3cpKGVsZW1lbnQpO1xuICAgIGNvbnN0IGRvY3VtZW50T2JqZWN0ID0gKDAsICQyOEFuUiRnZXRPd25lckRvY3VtZW50KShlbGVtZW50KTtcbiAgICBpZiAobG9hZExpc3RlbmVyKSBkb2N1bWVudE9iamVjdC5yZW1vdmVFdmVudExpc3RlbmVyKCdET01Db250ZW50TG9hZGVkJywgbG9hZExpc3RlbmVyKTtcbiAgICBpZiAoISQ1MDdmYWJlMTBlNzFjNmZiJGV4cG9ydCRkOTAyNDNiNThkYWVjZGE3Lmhhcyh3aW5kb3dPYmplY3QpKSByZXR1cm47XG4gICAgd2luZG93T2JqZWN0LkhUTUxFbGVtZW50LnByb3RvdHlwZS5mb2N1cyA9ICQ1MDdmYWJlMTBlNzFjNmZiJGV4cG9ydCRkOTAyNDNiNThkYWVjZGE3LmdldCh3aW5kb3dPYmplY3QpLmZvY3VzO1xuICAgIGRvY3VtZW50T2JqZWN0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCAkNTA3ZmFiZTEwZTcxYzZmYiR2YXIkaGFuZGxlS2V5Ym9hcmRFdmVudCwgdHJ1ZSk7XG4gICAgZG9jdW1lbnRPYmplY3QucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5dXAnLCAkNTA3ZmFiZTEwZTcxYzZmYiR2YXIkaGFuZGxlS2V5Ym9hcmRFdmVudCwgdHJ1ZSk7XG4gICAgZG9jdW1lbnRPYmplY3QucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCAkNTA3ZmFiZTEwZTcxYzZmYiR2YXIkaGFuZGxlQ2xpY2tFdmVudCwgdHJ1ZSk7XG4gICAgd2luZG93T2JqZWN0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2ZvY3VzJywgJDUwN2ZhYmUxMGU3MWM2ZmIkdmFyJGhhbmRsZUZvY3VzRXZlbnQsIHRydWUpO1xuICAgIHdpbmRvd09iamVjdC5yZW1vdmVFdmVudExpc3RlbmVyKCdibHVyJywgJDUwN2ZhYmUxMGU3MWM2ZmIkdmFyJGhhbmRsZVdpbmRvd0JsdXIsIGZhbHNlKTtcbiAgICBpZiAodHlwZW9mIFBvaW50ZXJFdmVudCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgZG9jdW1lbnRPYmplY3QucmVtb3ZlRXZlbnRMaXN0ZW5lcigncG9pbnRlcmRvd24nLCAkNTA3ZmFiZTEwZTcxYzZmYiR2YXIkaGFuZGxlUG9pbnRlckV2ZW50LCB0cnVlKTtcbiAgICAgICAgZG9jdW1lbnRPYmplY3QucmVtb3ZlRXZlbnRMaXN0ZW5lcigncG9pbnRlcm1vdmUnLCAkNTA3ZmFiZTEwZTcxYzZmYiR2YXIkaGFuZGxlUG9pbnRlckV2ZW50LCB0cnVlKTtcbiAgICAgICAgZG9jdW1lbnRPYmplY3QucmVtb3ZlRXZlbnRMaXN0ZW5lcigncG9pbnRlcnVwJywgJDUwN2ZhYmUxMGU3MWM2ZmIkdmFyJGhhbmRsZVBvaW50ZXJFdmVudCwgdHJ1ZSk7XG4gICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Rlc3QnKSB7XG4gICAgICAgIGRvY3VtZW50T2JqZWN0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsICQ1MDdmYWJlMTBlNzFjNmZiJHZhciRoYW5kbGVQb2ludGVyRXZlbnQsIHRydWUpO1xuICAgICAgICBkb2N1bWVudE9iamVjdC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCAkNTA3ZmFiZTEwZTcxYzZmYiR2YXIkaGFuZGxlUG9pbnRlckV2ZW50LCB0cnVlKTtcbiAgICAgICAgZG9jdW1lbnRPYmplY3QucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsICQ1MDdmYWJlMTBlNzFjNmZiJHZhciRoYW5kbGVQb2ludGVyRXZlbnQsIHRydWUpO1xuICAgIH1cbiAgICAkNTA3ZmFiZTEwZTcxYzZmYiRleHBvcnQkZDkwMjQzYjU4ZGFlY2RhNy5kZWxldGUod2luZG93T2JqZWN0KTtcbn07XG5mdW5jdGlvbiAkNTA3ZmFiZTEwZTcxYzZmYiRleHBvcnQkMmYxODg4MTEyZjU1OGE3ZChlbGVtZW50KSB7XG4gICAgY29uc3QgZG9jdW1lbnRPYmplY3QgPSAoMCwgJDI4QW5SJGdldE93bmVyRG9jdW1lbnQpKGVsZW1lbnQpO1xuICAgIGxldCBsb2FkTGlzdGVuZXI7XG4gICAgaWYgKGRvY3VtZW50T2JqZWN0LnJlYWR5U3RhdGUgIT09ICdsb2FkaW5nJykgJDUwN2ZhYmUxMGU3MWM2ZmIkdmFyJHNldHVwR2xvYmFsRm9jdXNFdmVudHMoZWxlbWVudCk7XG4gICAgZWxzZSB7XG4gICAgICAgIGxvYWRMaXN0ZW5lciA9ICgpPT57XG4gICAgICAgICAgICAkNTA3ZmFiZTEwZTcxYzZmYiR2YXIkc2V0dXBHbG9iYWxGb2N1c0V2ZW50cyhlbGVtZW50KTtcbiAgICAgICAgfTtcbiAgICAgICAgZG9jdW1lbnRPYmplY3QuYWRkRXZlbnRMaXN0ZW5lcignRE9NQ29udGVudExvYWRlZCcsIGxvYWRMaXN0ZW5lcik7XG4gICAgfVxuICAgIHJldHVybiAoKT0+JDUwN2ZhYmUxMGU3MWM2ZmIkdmFyJHRlYXJEb3duV2luZG93Rm9jdXNUcmFja2luZyhlbGVtZW50LCBsb2FkTGlzdGVuZXIpO1xufVxuLy8gU2VydmVyLXNpZGUgcmVuZGVyaW5nIGRvZXMgbm90IGhhdmUgdGhlIGRvY3VtZW50IG9iamVjdCBkZWZpbmVkXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVzdHJpY3RlZC1nbG9iYWxzXG5pZiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJykgJDUwN2ZhYmUxMGU3MWM2ZmIkZXhwb3J0JDJmMTg4ODExMmY1NThhN2QoKTtcbmZ1bmN0aW9uICQ1MDdmYWJlMTBlNzFjNmZiJGV4cG9ydCRiOWIzZGZkZGFiMTdkYjI3KCkge1xuICAgIHJldHVybiAkNTA3ZmFiZTEwZTcxYzZmYiR2YXIkY3VycmVudE1vZGFsaXR5ICE9PSAncG9pbnRlcic7XG59XG5mdW5jdGlvbiAkNTA3ZmFiZTEwZTcxYzZmYiRleHBvcnQkNjMwZmY2NTNjNWFkYTZhOSgpIHtcbiAgICByZXR1cm4gJDUwN2ZhYmUxMGU3MWM2ZmIkdmFyJGN1cnJlbnRNb2RhbGl0eTtcbn1cbmZ1bmN0aW9uICQ1MDdmYWJlMTBlNzFjNmZiJGV4cG9ydCQ4Mzk3ZGRmYzUwNGZkYjlhKG1vZGFsaXR5KSB7XG4gICAgJDUwN2ZhYmUxMGU3MWM2ZmIkdmFyJGN1cnJlbnRNb2RhbGl0eSA9IG1vZGFsaXR5O1xuICAgICQ1MDdmYWJlMTBlNzFjNmZiJHZhciR0cmlnZ2VyQ2hhbmdlSGFuZGxlcnMobW9kYWxpdHksIG51bGwpO1xufVxuZnVuY3Rpb24gJDUwN2ZhYmUxMGU3MWM2ZmIkZXhwb3J0JDk4ZTIwZWM5MmY2MTRjZmUoKSB7XG4gICAgJDUwN2ZhYmUxMGU3MWM2ZmIkdmFyJHNldHVwR2xvYmFsRm9jdXNFdmVudHMoKTtcbiAgICBsZXQgW21vZGFsaXR5LCBzZXRNb2RhbGl0eV0gPSAoMCwgJDI4QW5SJHVzZVN0YXRlKSgkNTA3ZmFiZTEwZTcxYzZmYiR2YXIkY3VycmVudE1vZGFsaXR5KTtcbiAgICAoMCwgJDI4QW5SJHVzZUVmZmVjdCkoKCk9PntcbiAgICAgICAgbGV0IGhhbmRsZXIgPSAoKT0+e1xuICAgICAgICAgICAgc2V0TW9kYWxpdHkoJDUwN2ZhYmUxMGU3MWM2ZmIkdmFyJGN1cnJlbnRNb2RhbGl0eSk7XG4gICAgICAgIH07XG4gICAgICAgICQ1MDdmYWJlMTBlNzFjNmZiJHZhciRjaGFuZ2VIYW5kbGVycy5hZGQoaGFuZGxlcik7XG4gICAgICAgIHJldHVybiAoKT0+e1xuICAgICAgICAgICAgJDUwN2ZhYmUxMGU3MWM2ZmIkdmFyJGNoYW5nZUhhbmRsZXJzLmRlbGV0ZShoYW5kbGVyKTtcbiAgICAgICAgfTtcbiAgICB9LCBbXSk7XG4gICAgcmV0dXJuICgwLCAkMjhBblIkdXNlSXNTU1IpKCkgPyBudWxsIDogbW9kYWxpdHk7XG59XG5jb25zdCAkNTA3ZmFiZTEwZTcxYzZmYiR2YXIkbm9uVGV4dElucHV0VHlwZXMgPSBuZXcgU2V0KFtcbiAgICAnY2hlY2tib3gnLFxuICAgICdyYWRpbycsXG4gICAgJ3JhbmdlJyxcbiAgICAnY29sb3InLFxuICAgICdmaWxlJyxcbiAgICAnaW1hZ2UnLFxuICAgICdidXR0b24nLFxuICAgICdzdWJtaXQnLFxuICAgICdyZXNldCdcbl0pO1xuLyoqXG4gKiBJZiB0aGlzIGlzIGF0dGFjaGVkIHRvIHRleHQgaW5wdXQgY29tcG9uZW50LCByZXR1cm4gaWYgdGhlIGV2ZW50IGlzIGEgZm9jdXMgZXZlbnQgKFRhYi9Fc2NhcGUga2V5cyBwcmVzc2VkKSBzbyB0aGF0XG4gKiBmb2N1cyB2aXNpYmxlIHN0eWxlIGNhbiBiZSBwcm9wZXJseSBzZXQuXG4gKi8gZnVuY3Rpb24gJDUwN2ZhYmUxMGU3MWM2ZmIkdmFyJGlzS2V5Ym9hcmRGb2N1c0V2ZW50KGlzVGV4dElucHV0LCBtb2RhbGl0eSwgZSkge1xuICAgIGxldCBkb2N1bWVudDEgPSAoMCwgJDI4QW5SJGdldE93bmVyRG9jdW1lbnQpKGUgPT09IG51bGwgfHwgZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZS50YXJnZXQpO1xuICAgIGNvbnN0IElIVE1MSW5wdXRFbGVtZW50ID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyAoMCwgJDI4QW5SJGdldE93bmVyV2luZG93KShlID09PSBudWxsIHx8IGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGUudGFyZ2V0KS5IVE1MSW5wdXRFbGVtZW50IDogSFRNTElucHV0RWxlbWVudDtcbiAgICBjb25zdCBJSFRNTFRleHRBcmVhRWxlbWVudCA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gKDAsICQyOEFuUiRnZXRPd25lcldpbmRvdykoZSA9PT0gbnVsbCB8fCBlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlLnRhcmdldCkuSFRNTFRleHRBcmVhRWxlbWVudCA6IEhUTUxUZXh0QXJlYUVsZW1lbnQ7XG4gICAgY29uc3QgSUhUTUxFbGVtZW50ID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyAoMCwgJDI4QW5SJGdldE93bmVyV2luZG93KShlID09PSBudWxsIHx8IGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGUudGFyZ2V0KS5IVE1MRWxlbWVudCA6IEhUTUxFbGVtZW50O1xuICAgIGNvbnN0IElLZXlib2FyZEV2ZW50ID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyAoMCwgJDI4QW5SJGdldE93bmVyV2luZG93KShlID09PSBudWxsIHx8IGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGUudGFyZ2V0KS5LZXlib2FyZEV2ZW50IDogS2V5Ym9hcmRFdmVudDtcbiAgICAvLyBGb3Iga2V5Ym9hcmQgZXZlbnRzIHRoYXQgb2NjdXIgb24gYSBub24taW5wdXQgZWxlbWVudCB0aGF0IHdpbGwgbW92ZSBmb2N1cyBpbnRvIGlucHV0IGVsZW1lbnQgKGFrYSBBcnJvd0xlZnQgZ29pbmcgZnJvbSBEYXRlcGlja2VyIGJ1dHRvbiB0byB0aGUgbWFpbiBpbnB1dCBncm91cClcbiAgICAvLyB3ZSBuZWVkIHRvIHJlbHkgb24gdGhlIHVzZXIgcGFzc2luZyBpc1RleHRJbnB1dCBpbnRvIGhlcmUuIFRoaXMgd2F5IHdlIGNhbiBza2lwIHRvZ2dsaW5nIGZvY3VzIHZpc2libGl0eSBmb3Igc2FpZCBpbnB1dCBlbGVtZW50XG4gICAgaXNUZXh0SW5wdXQgPSBpc1RleHRJbnB1dCB8fCBkb2N1bWVudDEuYWN0aXZlRWxlbWVudCBpbnN0YW5jZW9mIElIVE1MSW5wdXRFbGVtZW50ICYmICEkNTA3ZmFiZTEwZTcxYzZmYiR2YXIkbm9uVGV4dElucHV0VHlwZXMuaGFzKGRvY3VtZW50MS5hY3RpdmVFbGVtZW50LnR5cGUpIHx8IGRvY3VtZW50MS5hY3RpdmVFbGVtZW50IGluc3RhbmNlb2YgSUhUTUxUZXh0QXJlYUVsZW1lbnQgfHwgZG9jdW1lbnQxLmFjdGl2ZUVsZW1lbnQgaW5zdGFuY2VvZiBJSFRNTEVsZW1lbnQgJiYgZG9jdW1lbnQxLmFjdGl2ZUVsZW1lbnQuaXNDb250ZW50RWRpdGFibGU7XG4gICAgcmV0dXJuICEoaXNUZXh0SW5wdXQgJiYgbW9kYWxpdHkgPT09ICdrZXlib2FyZCcgJiYgZSBpbnN0YW5jZW9mIElLZXlib2FyZEV2ZW50ICYmICEkNTA3ZmFiZTEwZTcxYzZmYiR2YXIkRk9DVVNfVklTSUJMRV9JTlBVVF9LRVlTW2Uua2V5XSk7XG59XG5mdW5jdGlvbiAkNTA3ZmFiZTEwZTcxYzZmYiRleHBvcnQkZmZkOWU1MDIxYzFmYjJkNihwcm9wcyA9IHt9KSB7XG4gICAgbGV0IHsgaXNUZXh0SW5wdXQ6IGlzVGV4dElucHV0LCBhdXRvRm9jdXM6IGF1dG9Gb2N1cyB9ID0gcHJvcHM7XG4gICAgbGV0IFtpc0ZvY3VzVmlzaWJsZVN0YXRlLCBzZXRGb2N1c1Zpc2libGVdID0gKDAsICQyOEFuUiR1c2VTdGF0ZSkoYXV0b0ZvY3VzIHx8ICQ1MDdmYWJlMTBlNzFjNmZiJGV4cG9ydCRiOWIzZGZkZGFiMTdkYjI3KCkpO1xuICAgICQ1MDdmYWJlMTBlNzFjNmZiJGV4cG9ydCRlYzcxYjRiODNhYzA4ZWMzKChpc0ZvY3VzVmlzaWJsZSk9PntcbiAgICAgICAgc2V0Rm9jdXNWaXNpYmxlKGlzRm9jdXNWaXNpYmxlKTtcbiAgICB9LCBbXG4gICAgICAgIGlzVGV4dElucHV0XG4gICAgXSwge1xuICAgICAgICBpc1RleHRJbnB1dDogaXNUZXh0SW5wdXRcbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgICBpc0ZvY3VzVmlzaWJsZTogaXNGb2N1c1Zpc2libGVTdGF0ZVxuICAgIH07XG59XG5mdW5jdGlvbiAkNTA3ZmFiZTEwZTcxYzZmYiRleHBvcnQkZWM3MWI0YjgzYWMwOGVjMyhmbiwgZGVwcywgb3B0cykge1xuICAgICQ1MDdmYWJlMTBlNzFjNmZiJHZhciRzZXR1cEdsb2JhbEZvY3VzRXZlbnRzKCk7XG4gICAgKDAsICQyOEFuUiR1c2VFZmZlY3QpKCgpPT57XG4gICAgICAgIGxldCBoYW5kbGVyID0gKG1vZGFsaXR5LCBlKT0+e1xuICAgICAgICAgICAgLy8gV2Ugd2FudCB0byBlYXJseSByZXR1cm4gZm9yIGFueSBrZXlib2FyZCBldmVudHMgdGhhdCBvY2N1ciBpbnNpZGUgdGV4dCBpbnB1dHMgRVhDRVBUIGZvciBUYWIgYW5kIEVzY2FwZVxuICAgICAgICAgICAgaWYgKCEkNTA3ZmFiZTEwZTcxYzZmYiR2YXIkaXNLZXlib2FyZEZvY3VzRXZlbnQoISEob3B0cyA9PT0gbnVsbCB8fCBvcHRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRzLmlzVGV4dElucHV0KSwgbW9kYWxpdHksIGUpKSByZXR1cm47XG4gICAgICAgICAgICBmbigkNTA3ZmFiZTEwZTcxYzZmYiRleHBvcnQkYjliM2RmZGRhYjE3ZGIyNygpKTtcbiAgICAgICAgfTtcbiAgICAgICAgJDUwN2ZhYmUxMGU3MWM2ZmIkdmFyJGNoYW5nZUhhbmRsZXJzLmFkZChoYW5kbGVyKTtcbiAgICAgICAgcmV0dXJuICgpPT57XG4gICAgICAgICAgICAkNTA3ZmFiZTEwZTcxYzZmYiR2YXIkY2hhbmdlSGFuZGxlcnMuZGVsZXRlKGhhbmRsZXIpO1xuICAgICAgICB9O1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgICB9LCBkZXBzKTtcbn1cblxuXG5leHBvcnQgeyQ1MDdmYWJlMTBlNzFjNmZiJGV4cG9ydCRkOTAyNDNiNThkYWVjZGE3IGFzIGhhc1NldHVwR2xvYmFsTGlzdGVuZXJzLCAkNTA3ZmFiZTEwZTcxYzZmYiRleHBvcnQkMmYxODg4MTEyZjU1OGE3ZCBhcyBhZGRXaW5kb3dGb2N1c1RyYWNraW5nLCAkNTA3ZmFiZTEwZTcxYzZmYiRleHBvcnQkYjliM2RmZGRhYjE3ZGIyNyBhcyBpc0ZvY3VzVmlzaWJsZSwgJDUwN2ZhYmUxMGU3MWM2ZmIkZXhwb3J0JDYzMGZmNjUzYzVhZGE2YTkgYXMgZ2V0SW50ZXJhY3Rpb25Nb2RhbGl0eSwgJDUwN2ZhYmUxMGU3MWM2ZmIkZXhwb3J0JDgzOTdkZGZjNTA0ZmRiOWEgYXMgc2V0SW50ZXJhY3Rpb25Nb2RhbGl0eSwgJDUwN2ZhYmUxMGU3MWM2ZmIkZXhwb3J0JDk4ZTIwZWM5MmY2MTRjZmUgYXMgdXNlSW50ZXJhY3Rpb25Nb2RhbGl0eSwgJDUwN2ZhYmUxMGU3MWM2ZmIkZXhwb3J0JGZmZDllNTAyMWMxZmIyZDYgYXMgdXNlRm9jdXNWaXNpYmxlLCAkNTA3ZmFiZTEwZTcxYzZmYiRleHBvcnQkZWM3MWI0YjgzYWMwOGVjMyBhcyB1c2VGb2N1c1Zpc2libGVMaXN0ZW5lcn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD11c2VGb2N1c1Zpc2libGUubW9kdWxlLmpzLm1hcFxuIl0sIm5hbWVzIjpbImlnbm9yZUZvY3VzRXZlbnQiLCIkOGE5Y2IyNzlkYzg3ZTEzMCRleHBvcnQkZmRhN2RhNzNhYjVkNGM0OCIsImlzTWFjIiwiJDI4QW5SJGlzTWFjIiwiaXNWaXJ0dWFsQ2xpY2siLCIkMjhBblIkaXNWaXJ0dWFsQ2xpY2siLCJnZXRPd25lcldpbmRvdyIsIiQyOEFuUiRnZXRPd25lcldpbmRvdyIsImdldE93bmVyRG9jdW1lbnQiLCIkMjhBblIkZ2V0T3duZXJEb2N1bWVudCIsInVzZVN0YXRlIiwiJDI4QW5SJHVzZVN0YXRlIiwidXNlRWZmZWN0IiwiJDI4QW5SJHVzZUVmZmVjdCIsInVzZUlzU1NSIiwiJDI4QW5SJHVzZUlzU1NSIiwiJDUwN2ZhYmUxMGU3MWM2ZmIkdmFyJGN1cnJlbnRNb2RhbGl0eSIsIiQ1MDdmYWJlMTBlNzFjNmZiJHZhciRjaGFuZ2VIYW5kbGVycyIsIlNldCIsIiQ1MDdmYWJlMTBlNzFjNmZiJGV4cG9ydCRkOTAyNDNiNThkYWVjZGE3IiwiTWFwIiwiJDUwN2ZhYmUxMGU3MWM2ZmIkdmFyJGhhc0V2ZW50QmVmb3JlRm9jdXMiLCIkNTA3ZmFiZTEwZTcxYzZmYiR2YXIkaGFzQmx1cnJlZFdpbmRvd1JlY2VudGx5IiwiJDUwN2ZhYmUxMGU3MWM2ZmIkdmFyJEZPQ1VTX1ZJU0lCTEVfSU5QVVRfS0VZUyIsIlRhYiIsIkVzY2FwZSIsIiQ1MDdmYWJlMTBlNzFjNmZiJHZhciR0cmlnZ2VyQ2hhbmdlSGFuZGxlcnMiLCJtb2RhbGl0eSIsImUiLCJoYW5kbGVyIiwiJDUwN2ZhYmUxMGU3MWM2ZmIkdmFyJGlzVmFsaWRLZXkiLCJtZXRhS2V5IiwiYWx0S2V5IiwiY3RybEtleSIsImtleSIsIiQ1MDdmYWJlMTBlNzFjNmZiJHZhciRoYW5kbGVLZXlib2FyZEV2ZW50IiwiJDUwN2ZhYmUxMGU3MWM2ZmIkdmFyJGhhbmRsZVBvaW50ZXJFdmVudCIsInR5cGUiLCIkNTA3ZmFiZTEwZTcxYzZmYiR2YXIkaGFuZGxlQ2xpY2tFdmVudCIsIiQ1MDdmYWJlMTBlNzFjNmZiJHZhciRoYW5kbGVGb2N1c0V2ZW50IiwidGFyZ2V0Iiwid2luZG93IiwiZG9jdW1lbnQiLCJpc1RydXN0ZWQiLCIkNTA3ZmFiZTEwZTcxYzZmYiR2YXIkaGFuZGxlV2luZG93Qmx1ciIsIiQ1MDdmYWJlMTBlNzFjNmZiJHZhciRzZXR1cEdsb2JhbEZvY3VzRXZlbnRzIiwiZWxlbWVudCIsImdldCIsIndpbmRvd09iamVjdCIsImRvY3VtZW50T2JqZWN0IiwiZm9jdXMiLCJIVE1MRWxlbWVudCIsInByb3RvdHlwZSIsImFwcGx5IiwiYXJndW1lbnRzIiwiYWRkRXZlbnRMaXN0ZW5lciIsIlBvaW50ZXJFdmVudCIsInByb2Nlc3MiLCIkNTA3ZmFiZTEwZTcxYzZmYiR2YXIkdGVhckRvd25XaW5kb3dGb2N1c1RyYWNraW5nIiwib25jZSIsInNldCIsImxvYWRMaXN0ZW5lciIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJoYXMiLCJkZWxldGUiLCIkNTA3ZmFiZTEwZTcxYzZmYiRleHBvcnQkMmYxODg4MTEyZjU1OGE3ZCIsInJlYWR5U3RhdGUiLCIkNTA3ZmFiZTEwZTcxYzZmYiRleHBvcnQkYjliM2RmZGRhYjE3ZGIyNyIsIiQ1MDdmYWJlMTBlNzFjNmZiJGV4cG9ydCQ2MzBmZjY1M2M1YWRhNmE5IiwiJDUwN2ZhYmUxMGU3MWM2ZmIkZXhwb3J0JDgzOTdkZGZjNTA0ZmRiOWEiLCIkNTA3ZmFiZTEwZTcxYzZmYiRleHBvcnQkOThlMjBlYzkyZjYxNGNmZSIsInNldE1vZGFsaXR5IiwiYWRkIiwiJDUwN2ZhYmUxMGU3MWM2ZmIkdmFyJG5vblRleHRJbnB1dFR5cGVzIiwiJDUwN2ZhYmUxMGU3MWM2ZmIkdmFyJGlzS2V5Ym9hcmRGb2N1c0V2ZW50IiwiaXNUZXh0SW5wdXQiLCJkb2N1bWVudDEiLCJJSFRNTElucHV0RWxlbWVudCIsIkhUTUxJbnB1dEVsZW1lbnQiLCJJSFRNTFRleHRBcmVhRWxlbWVudCIsIkhUTUxUZXh0QXJlYUVsZW1lbnQiLCJJSFRNTEVsZW1lbnQiLCJJS2V5Ym9hcmRFdmVudCIsIktleWJvYXJkRXZlbnQiLCJhY3RpdmVFbGVtZW50IiwiaXNDb250ZW50RWRpdGFibGUiLCIkNTA3ZmFiZTEwZTcxYzZmYiRleHBvcnQkZmZkOWU1MDIxYzFmYjJkNiIsInByb3BzIiwiYXV0b0ZvY3VzIiwiaXNGb2N1c1Zpc2libGVTdGF0ZSIsInNldEZvY3VzVmlzaWJsZSIsIiQ1MDdmYWJlMTBlNzFjNmZiJGV4cG9ydCRlYzcxYjRiODNhYzA4ZWMzIiwiaXNGb2N1c1Zpc2libGUiLCJmbiIsImRlcHMiLCJvcHRzIiwiaGFzU2V0dXBHbG9iYWxMaXN0ZW5lcnMiLCJhZGRXaW5kb3dGb2N1c1RyYWNraW5nIiwiZ2V0SW50ZXJhY3Rpb25Nb2RhbGl0eSIsInNldEludGVyYWN0aW9uTW9kYWxpdHkiLCJ1c2VJbnRlcmFjdGlvbk1vZGFsaXR5IiwidXNlRm9jdXNWaXNpYmxlIiwidXNlRm9jdXNWaXNpYmxlTGlzdGVuZXIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../../../node_modules/@react-aria/interactions/dist/useFocusVisible.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/../../../../node_modules/@react-aria/interactions/dist/useFocusWithin.mjs":
/*!*********************************************************************************!*\
  !*** ../../../../node_modules/@react-aria/interactions/dist/useFocusWithin.mjs ***!
  \*********************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useFocusWithin: function() { return /* binding */ $9ab94262bd0047c7$export$420e68273165f4ec; }\n/* harmony export */ });\n/* harmony import */ var _utils_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils.mjs */ \"(app-pages-browser)/../../../../node_modules/@react-aria/interactions/dist/utils.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @react-aria/utils */ \"(app-pages-browser)/../../../../node_modules/@react-aria/utils/dist/useGlobalListeners.mjs\");\n/* harmony import */ var _react_aria_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @react-aria/utils */ \"(app-pages-browser)/../../../../node_modules/@react-aria/utils/dist/domHelpers.mjs\");\n/* harmony import */ var _react_aria_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @react-aria/utils */ \"(app-pages-browser)/../../../../node_modules/@react-aria/utils/dist/DOMFunctions.mjs\");\n\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ // Portions of the code in this file are based on code from react.\n// Original licensing for the following can be found in the\n// NOTICE file in the root directory of this source tree.\n// See https://github.com/facebook/react/tree/cc7c1aece46a6b69b41958d731e0fd27c94bfc6c/packages/react-interactions\nfunction $9ab94262bd0047c7$export$420e68273165f4ec(props) {\n    let { isDisabled: isDisabled, onBlurWithin: onBlurWithin, onFocusWithin: onFocusWithin, onFocusWithinChange: onFocusWithinChange } = props;\n    let state = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)({\n        isFocusWithin: false\n    });\n    let { addGlobalListener: addGlobalListener, removeAllGlobalListeners: removeAllGlobalListeners } = (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.useGlobalListeners)();\n    let onBlur = (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((e)=>{\n        // Ignore events bubbling through portals.\n        if (!e.currentTarget.contains(e.target)) return;\n        // We don't want to trigger onBlurWithin and then immediately onFocusWithin again\n        // when moving focus inside the element. Only trigger if the currentTarget doesn't\n        // include the relatedTarget (where focus is moving).\n        if (state.current.isFocusWithin && !e.currentTarget.contains(e.relatedTarget)) {\n            state.current.isFocusWithin = false;\n            removeAllGlobalListeners();\n            if (onBlurWithin) onBlurWithin(e);\n            if (onFocusWithinChange) onFocusWithinChange(false);\n        }\n    }, [\n        onBlurWithin,\n        onFocusWithinChange,\n        state,\n        removeAllGlobalListeners\n    ]);\n    let onSyntheticFocus = (0, _utils_mjs__WEBPACK_IMPORTED_MODULE_2__.useSyntheticBlurEvent)(onBlur);\n    let onFocus = (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((e)=>{\n        // Ignore events bubbling through portals.\n        if (!e.currentTarget.contains(e.target)) return;\n        // Double check that document.activeElement actually matches e.target in case a previously chained\n        // focus handler already moved focus somewhere else.\n        const ownerDocument = (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_3__.getOwnerDocument)(e.target);\n        const activeElement = (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_4__.getActiveElement)(ownerDocument);\n        if (!state.current.isFocusWithin && activeElement === (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_4__.getEventTarget)(e.nativeEvent)) {\n            if (onFocusWithin) onFocusWithin(e);\n            if (onFocusWithinChange) onFocusWithinChange(true);\n            state.current.isFocusWithin = true;\n            onSyntheticFocus(e);\n            // Browsers don't fire blur events when elements are removed from the DOM.\n            // However, if a focus event occurs outside the element we're tracking, we\n            // can manually fire onBlur.\n            let currentTarget = e.currentTarget;\n            addGlobalListener(ownerDocument, \"focus\", (e)=>{\n                if (state.current.isFocusWithin && !(0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_4__.nodeContains)(currentTarget, e.target)) {\n                    let nativeEvent = new ownerDocument.defaultView.FocusEvent(\"blur\", {\n                        relatedTarget: e.target\n                    });\n                    (0, _utils_mjs__WEBPACK_IMPORTED_MODULE_2__.setEventTarget)(nativeEvent, currentTarget);\n                    let event = (0, _utils_mjs__WEBPACK_IMPORTED_MODULE_2__.createSyntheticEvent)(nativeEvent);\n                    onBlur(event);\n                }\n            }, {\n                capture: true\n            });\n        }\n    }, [\n        onFocusWithin,\n        onFocusWithinChange,\n        onSyntheticFocus,\n        addGlobalListener,\n        onBlur\n    ]);\n    if (isDisabled) return {\n        focusWithinProps: {\n            // These cannot be null, that would conflict in mergeProps\n            onFocus: undefined,\n            onBlur: undefined\n        }\n    };\n    return {\n        focusWithinProps: {\n            onFocus: onFocus,\n            onBlur: onBlur\n        }\n    };\n}\n //# sourceMappingURL=useFocusWithin.module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQHJlYWN0LWFyaWEvaW50ZXJhY3Rpb25zL2Rpc3QvdXNlRm9jdXNXaXRoaW4ubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUE4TjtBQUM3STtBQUN5SztBQUUxUDs7Ozs7Ozs7OztDQVVDLEdBQUcsa0VBQWtFO0FBQ3RFLDJEQUEyRDtBQUMzRCx5REFBeUQ7QUFDekQsa0hBQWtIO0FBSWxILFNBQVNvQiwwQ0FBMENDLEtBQUs7SUFDcEQsSUFBSSxFQUFFQyxZQUFZQSxVQUFVLEVBQUVDLGNBQWNBLFlBQVksRUFBRUMsZUFBZUEsYUFBYSxFQUFFQyxxQkFBcUJBLG1CQUFtQixFQUFFLEdBQUdKO0lBQ3JJLElBQUlLLFFBQVEsQ0FBQyxHQUFHbkIseUNBQVksRUFBRztRQUMzQm9CLGVBQWU7SUFDbkI7SUFDQSxJQUFJLEVBQUVDLG1CQUFtQkEsaUJBQWlCLEVBQUVDLDBCQUEwQkEsd0JBQXdCLEVBQUUsR0FBRyxDQUFDLEdBQUdsQixpRUFBd0I7SUFDL0gsSUFBSW1CLFNBQVMsQ0FBQyxHQUFHckIsOENBQWlCLEVBQUcsQ0FBQ3NCO1FBQ2xDLDBDQUEwQztRQUMxQyxJQUFJLENBQUNBLEVBQUVDLGFBQWEsQ0FBQ0MsUUFBUSxDQUFDRixFQUFFRyxNQUFNLEdBQUc7UUFDekMsaUZBQWlGO1FBQ2pGLGtGQUFrRjtRQUNsRixxREFBcUQ7UUFDckQsSUFBSVIsTUFBTVMsT0FBTyxDQUFDUixhQUFhLElBQUksQ0FBQ0ksRUFBRUMsYUFBYSxDQUFDQyxRQUFRLENBQUNGLEVBQUVLLGFBQWEsR0FBRztZQUMzRVYsTUFBTVMsT0FBTyxDQUFDUixhQUFhLEdBQUc7WUFDOUJFO1lBQ0EsSUFBSU4sY0FBY0EsYUFBYVE7WUFDL0IsSUFBSU4scUJBQXFCQSxvQkFBb0I7UUFDakQ7SUFDSixHQUFHO1FBQ0NGO1FBQ0FFO1FBQ0FDO1FBQ0FHO0tBQ0g7SUFDRCxJQUFJUSxtQkFBbUIsQ0FBQyxHQUFHaEMsNkRBQXdDLEVBQUd5QjtJQUN0RSxJQUFJUSxVQUFVLENBQUMsR0FBRzdCLDhDQUFpQixFQUFHLENBQUNzQjtRQUNuQywwQ0FBMEM7UUFDMUMsSUFBSSxDQUFDQSxFQUFFQyxhQUFhLENBQUNDLFFBQVEsQ0FBQ0YsRUFBRUcsTUFBTSxHQUFHO1FBQ3pDLGtHQUFrRztRQUNsRyxvREFBb0Q7UUFDcEQsTUFBTUssZ0JBQWdCLENBQUMsR0FBRzFCLCtEQUFzQixFQUFHa0IsRUFBRUcsTUFBTTtRQUMzRCxNQUFNTSxnQkFBZ0IsQ0FBQyxHQUFHekIsK0RBQXNCLEVBQUd3QjtRQUNuRCxJQUFJLENBQUNiLE1BQU1TLE9BQU8sQ0FBQ1IsYUFBYSxJQUFJYSxrQkFBa0IsQ0FBQyxHQUFHdkIsNkRBQW9CLEVBQUdjLEVBQUVVLFdBQVcsR0FBRztZQUM3RixJQUFJakIsZUFBZUEsY0FBY087WUFDakMsSUFBSU4scUJBQXFCQSxvQkFBb0I7WUFDN0NDLE1BQU1TLE9BQU8sQ0FBQ1IsYUFBYSxHQUFHO1lBQzlCVSxpQkFBaUJOO1lBQ2pCLDBFQUEwRTtZQUMxRSwwRUFBMEU7WUFDMUUsNEJBQTRCO1lBQzVCLElBQUlDLGdCQUFnQkQsRUFBRUMsYUFBYTtZQUNuQ0osa0JBQWtCVyxlQUFlLFNBQVMsQ0FBQ1I7Z0JBQ3ZDLElBQUlMLE1BQU1TLE9BQU8sQ0FBQ1IsYUFBYSxJQUFJLENBQUMsQ0FBQyxHQUFHUiwyREFBa0IsRUFBR2EsZUFBZUQsRUFBRUcsTUFBTSxHQUFHO29CQUNuRixJQUFJTyxjQUFjLElBQUlGLGNBQWNHLFdBQVcsQ0FBQ0MsVUFBVSxDQUFDLFFBQVE7d0JBQy9EUCxlQUFlTCxFQUFFRyxNQUFNO29CQUMzQjtvQkFDQyxJQUFHL0Isc0RBQXdDLEVBQUdzQyxhQUFhVDtvQkFDNUQsSUFBSVksUUFBUSxDQUFDLEdBQUczQyw0REFBdUMsRUFBR3dDO29CQUMxRFgsT0FBT2M7Z0JBQ1g7WUFDSixHQUFHO2dCQUNDQyxTQUFTO1lBQ2I7UUFDSjtJQUNKLEdBQUc7UUFDQ3JCO1FBQ0FDO1FBQ0FZO1FBQ0FUO1FBQ0FFO0tBQ0g7SUFDRCxJQUFJUixZQUFZLE9BQU87UUFDbkJ3QixrQkFBa0I7WUFDZCwwREFBMEQ7WUFDMURSLFNBQVNTO1lBQ1RqQixRQUFRaUI7UUFDWjtJQUNKO0lBQ0EsT0FBTztRQUNIRCxrQkFBa0I7WUFDZFIsU0FBU0E7WUFDVFIsUUFBUUE7UUFDWjtJQUNKO0FBQ0o7QUFHcUUsQ0FDckUsaURBQWlEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQHJlYWN0LWFyaWEvaW50ZXJhY3Rpb25zL2Rpc3QvdXNlRm9jdXNXaXRoaW4ubWpzP2RmMmIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtjcmVhdGVTeW50aGV0aWNFdmVudCBhcyAkOGE5Y2IyNzlkYzg3ZTEzMCRleHBvcnQkNTI1YmM0OTIxZDU2ZDRhLCBzZXRFdmVudFRhcmdldCBhcyAkOGE5Y2IyNzlkYzg3ZTEzMCRleHBvcnQkYzJiN2FiZTVkNjFlYzY5NiwgdXNlU3ludGhldGljQmx1ckV2ZW50IGFzICQ4YTljYjI3OWRjODdlMTMwJGV4cG9ydCQ3MTVjNjgyZDA5ZDYzOWNjfSBmcm9tIFwiLi91dGlscy5tanNcIjtcbmltcG9ydCB7dXNlUmVmIGFzICQzYjlRMCR1c2VSZWYsIHVzZUNhbGxiYWNrIGFzICQzYjlRMCR1c2VDYWxsYmFja30gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQge3VzZUdsb2JhbExpc3RlbmVycyBhcyAkM2I5UTAkdXNlR2xvYmFsTGlzdGVuZXJzLCBnZXRPd25lckRvY3VtZW50IGFzICQzYjlRMCRnZXRPd25lckRvY3VtZW50LCBnZXRBY3RpdmVFbGVtZW50IGFzICQzYjlRMCRnZXRBY3RpdmVFbGVtZW50LCBnZXRFdmVudFRhcmdldCBhcyAkM2I5UTAkZ2V0RXZlbnRUYXJnZXQsIG5vZGVDb250YWlucyBhcyAkM2I5UTAkbm9kZUNvbnRhaW5zfSBmcm9tIFwiQHJlYWN0LWFyaWEvdXRpbHNcIjtcblxuLypcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIC8vIFBvcnRpb25zIG9mIHRoZSBjb2RlIGluIHRoaXMgZmlsZSBhcmUgYmFzZWQgb24gY29kZSBmcm9tIHJlYWN0LlxuLy8gT3JpZ2luYWwgbGljZW5zaW5nIGZvciB0aGUgZm9sbG93aW5nIGNhbiBiZSBmb3VuZCBpbiB0aGVcbi8vIE5PVElDRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC90cmVlL2NjN2MxYWVjZTQ2YTZiNjliNDE5NThkNzMxZTBmZDI3Yzk0YmZjNmMvcGFja2FnZXMvcmVhY3QtaW50ZXJhY3Rpb25zXG5cblxuXG5mdW5jdGlvbiAkOWFiOTQyNjJiZDAwNDdjNyRleHBvcnQkNDIwZTY4MjczMTY1ZjRlYyhwcm9wcykge1xuICAgIGxldCB7IGlzRGlzYWJsZWQ6IGlzRGlzYWJsZWQsIG9uQmx1cldpdGhpbjogb25CbHVyV2l0aGluLCBvbkZvY3VzV2l0aGluOiBvbkZvY3VzV2l0aGluLCBvbkZvY3VzV2l0aGluQ2hhbmdlOiBvbkZvY3VzV2l0aGluQ2hhbmdlIH0gPSBwcm9wcztcbiAgICBsZXQgc3RhdGUgPSAoMCwgJDNiOVEwJHVzZVJlZikoe1xuICAgICAgICBpc0ZvY3VzV2l0aGluOiBmYWxzZVxuICAgIH0pO1xuICAgIGxldCB7IGFkZEdsb2JhbExpc3RlbmVyOiBhZGRHbG9iYWxMaXN0ZW5lciwgcmVtb3ZlQWxsR2xvYmFsTGlzdGVuZXJzOiByZW1vdmVBbGxHbG9iYWxMaXN0ZW5lcnMgfSA9ICgwLCAkM2I5UTAkdXNlR2xvYmFsTGlzdGVuZXJzKSgpO1xuICAgIGxldCBvbkJsdXIgPSAoMCwgJDNiOVEwJHVzZUNhbGxiYWNrKSgoZSk9PntcbiAgICAgICAgLy8gSWdub3JlIGV2ZW50cyBidWJibGluZyB0aHJvdWdoIHBvcnRhbHMuXG4gICAgICAgIGlmICghZS5jdXJyZW50VGFyZ2V0LmNvbnRhaW5zKGUudGFyZ2V0KSkgcmV0dXJuO1xuICAgICAgICAvLyBXZSBkb24ndCB3YW50IHRvIHRyaWdnZXIgb25CbHVyV2l0aGluIGFuZCB0aGVuIGltbWVkaWF0ZWx5IG9uRm9jdXNXaXRoaW4gYWdhaW5cbiAgICAgICAgLy8gd2hlbiBtb3ZpbmcgZm9jdXMgaW5zaWRlIHRoZSBlbGVtZW50LiBPbmx5IHRyaWdnZXIgaWYgdGhlIGN1cnJlbnRUYXJnZXQgZG9lc24ndFxuICAgICAgICAvLyBpbmNsdWRlIHRoZSByZWxhdGVkVGFyZ2V0ICh3aGVyZSBmb2N1cyBpcyBtb3ZpbmcpLlxuICAgICAgICBpZiAoc3RhdGUuY3VycmVudC5pc0ZvY3VzV2l0aGluICYmICFlLmN1cnJlbnRUYXJnZXQuY29udGFpbnMoZS5yZWxhdGVkVGFyZ2V0KSkge1xuICAgICAgICAgICAgc3RhdGUuY3VycmVudC5pc0ZvY3VzV2l0aGluID0gZmFsc2U7XG4gICAgICAgICAgICByZW1vdmVBbGxHbG9iYWxMaXN0ZW5lcnMoKTtcbiAgICAgICAgICAgIGlmIChvbkJsdXJXaXRoaW4pIG9uQmx1cldpdGhpbihlKTtcbiAgICAgICAgICAgIGlmIChvbkZvY3VzV2l0aGluQ2hhbmdlKSBvbkZvY3VzV2l0aGluQ2hhbmdlKGZhbHNlKTtcbiAgICAgICAgfVxuICAgIH0sIFtcbiAgICAgICAgb25CbHVyV2l0aGluLFxuICAgICAgICBvbkZvY3VzV2l0aGluQ2hhbmdlLFxuICAgICAgICBzdGF0ZSxcbiAgICAgICAgcmVtb3ZlQWxsR2xvYmFsTGlzdGVuZXJzXG4gICAgXSk7XG4gICAgbGV0IG9uU3ludGhldGljRm9jdXMgPSAoMCwgJDhhOWNiMjc5ZGM4N2UxMzAkZXhwb3J0JDcxNWM2ODJkMDlkNjM5Y2MpKG9uQmx1cik7XG4gICAgbGV0IG9uRm9jdXMgPSAoMCwgJDNiOVEwJHVzZUNhbGxiYWNrKSgoZSk9PntcbiAgICAgICAgLy8gSWdub3JlIGV2ZW50cyBidWJibGluZyB0aHJvdWdoIHBvcnRhbHMuXG4gICAgICAgIGlmICghZS5jdXJyZW50VGFyZ2V0LmNvbnRhaW5zKGUudGFyZ2V0KSkgcmV0dXJuO1xuICAgICAgICAvLyBEb3VibGUgY2hlY2sgdGhhdCBkb2N1bWVudC5hY3RpdmVFbGVtZW50IGFjdHVhbGx5IG1hdGNoZXMgZS50YXJnZXQgaW4gY2FzZSBhIHByZXZpb3VzbHkgY2hhaW5lZFxuICAgICAgICAvLyBmb2N1cyBoYW5kbGVyIGFscmVhZHkgbW92ZWQgZm9jdXMgc29tZXdoZXJlIGVsc2UuXG4gICAgICAgIGNvbnN0IG93bmVyRG9jdW1lbnQgPSAoMCwgJDNiOVEwJGdldE93bmVyRG9jdW1lbnQpKGUudGFyZ2V0KTtcbiAgICAgICAgY29uc3QgYWN0aXZlRWxlbWVudCA9ICgwLCAkM2I5UTAkZ2V0QWN0aXZlRWxlbWVudCkob3duZXJEb2N1bWVudCk7XG4gICAgICAgIGlmICghc3RhdGUuY3VycmVudC5pc0ZvY3VzV2l0aGluICYmIGFjdGl2ZUVsZW1lbnQgPT09ICgwLCAkM2I5UTAkZ2V0RXZlbnRUYXJnZXQpKGUubmF0aXZlRXZlbnQpKSB7XG4gICAgICAgICAgICBpZiAob25Gb2N1c1dpdGhpbikgb25Gb2N1c1dpdGhpbihlKTtcbiAgICAgICAgICAgIGlmIChvbkZvY3VzV2l0aGluQ2hhbmdlKSBvbkZvY3VzV2l0aGluQ2hhbmdlKHRydWUpO1xuICAgICAgICAgICAgc3RhdGUuY3VycmVudC5pc0ZvY3VzV2l0aGluID0gdHJ1ZTtcbiAgICAgICAgICAgIG9uU3ludGhldGljRm9jdXMoZSk7XG4gICAgICAgICAgICAvLyBCcm93c2VycyBkb24ndCBmaXJlIGJsdXIgZXZlbnRzIHdoZW4gZWxlbWVudHMgYXJlIHJlbW92ZWQgZnJvbSB0aGUgRE9NLlxuICAgICAgICAgICAgLy8gSG93ZXZlciwgaWYgYSBmb2N1cyBldmVudCBvY2N1cnMgb3V0c2lkZSB0aGUgZWxlbWVudCB3ZSdyZSB0cmFja2luZywgd2VcbiAgICAgICAgICAgIC8vIGNhbiBtYW51YWxseSBmaXJlIG9uQmx1ci5cbiAgICAgICAgICAgIGxldCBjdXJyZW50VGFyZ2V0ID0gZS5jdXJyZW50VGFyZ2V0O1xuICAgICAgICAgICAgYWRkR2xvYmFsTGlzdGVuZXIob3duZXJEb2N1bWVudCwgJ2ZvY3VzJywgKGUpPT57XG4gICAgICAgICAgICAgICAgaWYgKHN0YXRlLmN1cnJlbnQuaXNGb2N1c1dpdGhpbiAmJiAhKDAsICQzYjlRMCRub2RlQ29udGFpbnMpKGN1cnJlbnRUYXJnZXQsIGUudGFyZ2V0KSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbmF0aXZlRXZlbnQgPSBuZXcgb3duZXJEb2N1bWVudC5kZWZhdWx0Vmlldy5Gb2N1c0V2ZW50KCdibHVyJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVsYXRlZFRhcmdldDogZS50YXJnZXRcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICgwLCAkOGE5Y2IyNzlkYzg3ZTEzMCRleHBvcnQkYzJiN2FiZTVkNjFlYzY5NikobmF0aXZlRXZlbnQsIGN1cnJlbnRUYXJnZXQpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZXZlbnQgPSAoMCwgJDhhOWNiMjc5ZGM4N2UxMzAkZXhwb3J0JDUyNWJjNDkyMWQ1NmQ0YSkobmF0aXZlRXZlbnQpO1xuICAgICAgICAgICAgICAgICAgICBvbkJsdXIoZXZlbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICBjYXB0dXJlOiB0cnVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0sIFtcbiAgICAgICAgb25Gb2N1c1dpdGhpbixcbiAgICAgICAgb25Gb2N1c1dpdGhpbkNoYW5nZSxcbiAgICAgICAgb25TeW50aGV0aWNGb2N1cyxcbiAgICAgICAgYWRkR2xvYmFsTGlzdGVuZXIsXG4gICAgICAgIG9uQmx1clxuICAgIF0pO1xuICAgIGlmIChpc0Rpc2FibGVkKSByZXR1cm4ge1xuICAgICAgICBmb2N1c1dpdGhpblByb3BzOiB7XG4gICAgICAgICAgICAvLyBUaGVzZSBjYW5ub3QgYmUgbnVsbCwgdGhhdCB3b3VsZCBjb25mbGljdCBpbiBtZXJnZVByb3BzXG4gICAgICAgICAgICBvbkZvY3VzOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBvbkJsdXI6IHVuZGVmaW5lZFxuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4ge1xuICAgICAgICBmb2N1c1dpdGhpblByb3BzOiB7XG4gICAgICAgICAgICBvbkZvY3VzOiBvbkZvY3VzLFxuICAgICAgICAgICAgb25CbHVyOiBvbkJsdXJcbiAgICAgICAgfVxuICAgIH07XG59XG5cblxuZXhwb3J0IHskOWFiOTQyNjJiZDAwNDdjNyRleHBvcnQkNDIwZTY4MjczMTY1ZjRlYyBhcyB1c2VGb2N1c1dpdGhpbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD11c2VGb2N1c1dpdGhpbi5tb2R1bGUuanMubWFwXG4iXSwibmFtZXMiOlsiY3JlYXRlU3ludGhldGljRXZlbnQiLCIkOGE5Y2IyNzlkYzg3ZTEzMCRleHBvcnQkNTI1YmM0OTIxZDU2ZDRhIiwic2V0RXZlbnRUYXJnZXQiLCIkOGE5Y2IyNzlkYzg3ZTEzMCRleHBvcnQkYzJiN2FiZTVkNjFlYzY5NiIsInVzZVN5bnRoZXRpY0JsdXJFdmVudCIsIiQ4YTljYjI3OWRjODdlMTMwJGV4cG9ydCQ3MTVjNjgyZDA5ZDYzOWNjIiwidXNlUmVmIiwiJDNiOVEwJHVzZVJlZiIsInVzZUNhbGxiYWNrIiwiJDNiOVEwJHVzZUNhbGxiYWNrIiwidXNlR2xvYmFsTGlzdGVuZXJzIiwiJDNiOVEwJHVzZUdsb2JhbExpc3RlbmVycyIsImdldE93bmVyRG9jdW1lbnQiLCIkM2I5UTAkZ2V0T3duZXJEb2N1bWVudCIsImdldEFjdGl2ZUVsZW1lbnQiLCIkM2I5UTAkZ2V0QWN0aXZlRWxlbWVudCIsImdldEV2ZW50VGFyZ2V0IiwiJDNiOVEwJGdldEV2ZW50VGFyZ2V0Iiwibm9kZUNvbnRhaW5zIiwiJDNiOVEwJG5vZGVDb250YWlucyIsIiQ5YWI5NDI2MmJkMDA0N2M3JGV4cG9ydCQ0MjBlNjgyNzMxNjVmNGVjIiwicHJvcHMiLCJpc0Rpc2FibGVkIiwib25CbHVyV2l0aGluIiwib25Gb2N1c1dpdGhpbiIsIm9uRm9jdXNXaXRoaW5DaGFuZ2UiLCJzdGF0ZSIsImlzRm9jdXNXaXRoaW4iLCJhZGRHbG9iYWxMaXN0ZW5lciIsInJlbW92ZUFsbEdsb2JhbExpc3RlbmVycyIsIm9uQmx1ciIsImUiLCJjdXJyZW50VGFyZ2V0IiwiY29udGFpbnMiLCJ0YXJnZXQiLCJjdXJyZW50IiwicmVsYXRlZFRhcmdldCIsIm9uU3ludGhldGljRm9jdXMiLCJvbkZvY3VzIiwib3duZXJEb2N1bWVudCIsImFjdGl2ZUVsZW1lbnQiLCJuYXRpdmVFdmVudCIsImRlZmF1bHRWaWV3IiwiRm9jdXNFdmVudCIsImV2ZW50IiwiY2FwdHVyZSIsImZvY3VzV2l0aGluUHJvcHMiLCJ1bmRlZmluZWQiLCJ1c2VGb2N1c1dpdGhpbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../../../node_modules/@react-aria/interactions/dist/useFocusWithin.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/../../../../node_modules/@react-aria/interactions/dist/useHover.mjs":
/*!***************************************************************************!*\
  !*** ../../../../node_modules/@react-aria/interactions/dist/useHover.mjs ***!
  \***************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useHover: function() { return /* binding */ $6179b936705e76d3$export$ae780daf29e6d456; }\n/* harmony export */ });\n/* harmony import */ var _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @react-aria/utils */ \"(app-pages-browser)/../../../../node_modules/@react-aria/utils/dist/useGlobalListeners.mjs\");\n/* harmony import */ var _react_aria_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @react-aria/utils */ \"(app-pages-browser)/../../../../node_modules/@react-aria/utils/dist/domHelpers.mjs\");\n/* harmony import */ var _react_aria_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @react-aria/utils */ \"(app-pages-browser)/../../../../node_modules/@react-aria/utils/dist/DOMFunctions.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ // Portions of the code in this file are based on code from react.\n// Original licensing for the following can be found in the\n// NOTICE file in the root directory of this source tree.\n// See https://github.com/facebook/react/tree/cc7c1aece46a6b69b41958d731e0fd27c94bfc6c/packages/react-interactions\n// iOS fires onPointerEnter twice: once with pointerType=\"touch\" and again with pointerType=\"mouse\".\n// We want to ignore these emulated events so they do not trigger hover behavior.\n// See https://bugs.webkit.org/show_bug.cgi?id=214609.\nlet $6179b936705e76d3$var$globalIgnoreEmulatedMouseEvents = false;\nlet $6179b936705e76d3$var$hoverCount = 0;\nfunction $6179b936705e76d3$var$setGlobalIgnoreEmulatedMouseEvents() {\n    $6179b936705e76d3$var$globalIgnoreEmulatedMouseEvents = true;\n    // Clear globalIgnoreEmulatedMouseEvents after a short timeout. iOS fires onPointerEnter\n    // with pointerType=\"mouse\" immediately after onPointerUp and before onFocus. On other\n    // devices that don't have this quirk, we don't want to ignore a mouse hover sometime in\n    // the distant future because a user previously touched the element.\n    setTimeout(()=>{\n        $6179b936705e76d3$var$globalIgnoreEmulatedMouseEvents = false;\n    }, 50);\n}\nfunction $6179b936705e76d3$var$handleGlobalPointerEvent(e) {\n    if (e.pointerType === \"touch\") $6179b936705e76d3$var$setGlobalIgnoreEmulatedMouseEvents();\n}\nfunction $6179b936705e76d3$var$setupGlobalTouchEvents() {\n    if (typeof document === \"undefined\") return;\n    if (typeof PointerEvent !== \"undefined\") document.addEventListener(\"pointerup\", $6179b936705e76d3$var$handleGlobalPointerEvent);\n    else if (false) {}\n    $6179b936705e76d3$var$hoverCount++;\n    return ()=>{\n        $6179b936705e76d3$var$hoverCount--;\n        if ($6179b936705e76d3$var$hoverCount > 0) return;\n        if (typeof PointerEvent !== \"undefined\") document.removeEventListener(\"pointerup\", $6179b936705e76d3$var$handleGlobalPointerEvent);\n        else if (false) {}\n    };\n}\nfunction $6179b936705e76d3$export$ae780daf29e6d456(props) {\n    let { onHoverStart: onHoverStart, onHoverChange: onHoverChange, onHoverEnd: onHoverEnd, isDisabled: isDisabled } = props;\n    let [isHovered, setHovered] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    let state = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)({\n        isHovered: false,\n        ignoreEmulatedMouseEvents: false,\n        pointerType: \"\",\n        target: null\n    }).current;\n    (0, react__WEBPACK_IMPORTED_MODULE_0__.useEffect)($6179b936705e76d3$var$setupGlobalTouchEvents, []);\n    let { addGlobalListener: addGlobalListener, removeAllGlobalListeners: removeAllGlobalListeners } = (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.useGlobalListeners)();\n    let { hoverProps: hoverProps, triggerHoverEnd: triggerHoverEnd } = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        let triggerHoverStart = (event, pointerType)=>{\n            state.pointerType = pointerType;\n            if (isDisabled || pointerType === \"touch\" || state.isHovered || !event.currentTarget.contains(event.target)) return;\n            state.isHovered = true;\n            let target = event.currentTarget;\n            state.target = target;\n            // When an element that is hovered over is removed, no pointerleave event is fired by the browser,\n            // even though the originally hovered target may have shrunk in size so it is no longer hovered.\n            // However, a pointerover event will be fired on the new target the mouse is over.\n            // In Chrome this happens immediately. In Safari and Firefox, it happens upon moving the mouse one pixel.\n            addGlobalListener((0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_2__.getOwnerDocument)(event.target), \"pointerover\", (e)=>{\n                if (state.isHovered && state.target && !(0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_3__.nodeContains)(state.target, e.target)) triggerHoverEnd(e, e.pointerType);\n            }, {\n                capture: true\n            });\n            if (onHoverStart) onHoverStart({\n                type: \"hoverstart\",\n                target: target,\n                pointerType: pointerType\n            });\n            if (onHoverChange) onHoverChange(true);\n            setHovered(true);\n        };\n        let triggerHoverEnd = (event, pointerType)=>{\n            let target = state.target;\n            state.pointerType = \"\";\n            state.target = null;\n            if (pointerType === \"touch\" || !state.isHovered || !target) return;\n            state.isHovered = false;\n            removeAllGlobalListeners();\n            if (onHoverEnd) onHoverEnd({\n                type: \"hoverend\",\n                target: target,\n                pointerType: pointerType\n            });\n            if (onHoverChange) onHoverChange(false);\n            setHovered(false);\n        };\n        let hoverProps = {};\n        if (typeof PointerEvent !== \"undefined\") {\n            hoverProps.onPointerEnter = (e)=>{\n                if ($6179b936705e76d3$var$globalIgnoreEmulatedMouseEvents && e.pointerType === \"mouse\") return;\n                triggerHoverStart(e, e.pointerType);\n            };\n            hoverProps.onPointerLeave = (e)=>{\n                if (!isDisabled && e.currentTarget.contains(e.target)) triggerHoverEnd(e, e.pointerType);\n            };\n        } else if (false) {}\n        return {\n            hoverProps: hoverProps,\n            triggerHoverEnd: triggerHoverEnd\n        };\n    }, [\n        onHoverStart,\n        onHoverChange,\n        onHoverEnd,\n        isDisabled,\n        state,\n        addGlobalListener,\n        removeAllGlobalListeners\n    ]);\n    (0, react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        // Call the triggerHoverEnd as soon as isDisabled changes to true\n        // Safe to call triggerHoverEnd, it will early return if we aren't currently hovering\n        if (isDisabled) triggerHoverEnd({\n            currentTarget: state.target\n        }, state.pointerType);\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [\n        isDisabled\n    ]);\n    return {\n        hoverProps: hoverProps,\n        isHovered: isHovered\n    };\n}\n //# sourceMappingURL=useHover.module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQHJlYWN0LWFyaWEvaW50ZXJhY3Rpb25zL2Rpc3QvdXNlSG92ZXIubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQW9LO0FBQy9CO0FBRXJJOzs7Ozs7Ozs7O0NBVUMsR0FBRyxrRUFBa0U7QUFDdEUsMkRBQTJEO0FBQzNELHlEQUF5RDtBQUN6RCxrSEFBa0g7QUFHbEgsb0dBQW9HO0FBQ3BHLGlGQUFpRjtBQUNqRixzREFBc0Q7QUFDdEQsSUFBSWMsd0RBQXdEO0FBQzVELElBQUlDLG1DQUFtQztBQUN2QyxTQUFTQztJQUNMRix3REFBd0Q7SUFDeEQsd0ZBQXdGO0lBQ3hGLHNGQUFzRjtJQUN0Rix3RkFBd0Y7SUFDeEYsb0VBQW9FO0lBQ3BFRyxXQUFXO1FBQ1BILHdEQUF3RDtJQUM1RCxHQUFHO0FBQ1A7QUFDQSxTQUFTSSwrQ0FBK0NDLENBQUM7SUFDckQsSUFBSUEsRUFBRUMsV0FBVyxLQUFLLFNBQVNKO0FBQ25DO0FBQ0EsU0FBU0s7SUFDTCxJQUFJLE9BQU9DLGFBQWEsYUFBYTtJQUNyQyxJQUFJLE9BQU9DLGlCQUFpQixhQUFhRCxTQUFTRSxnQkFBZ0IsQ0FBQyxhQUFhTjtTQUMzRSxJQUFJTyxLQUF5QixFQUFRSCxFQUFnR047SUFDMUlEO0lBQ0EsT0FBTztRQUNIQTtRQUNBLElBQUlBLG1DQUFtQyxHQUFHO1FBQzFDLElBQUksT0FBT1EsaUJBQWlCLGFBQWFELFNBQVNJLG1CQUFtQixDQUFDLGFBQWFSO2FBQzlFLElBQUlPLEtBQXlCLEVBQVFILEVBQW1HTjtJQUNqSjtBQUNKO0FBQ0EsU0FBU1csMENBQTBDQyxLQUFLO0lBQ3BELElBQUksRUFBRUMsY0FBY0EsWUFBWSxFQUFFQyxlQUFlQSxhQUFhLEVBQUVDLFlBQVlBLFVBQVUsRUFBRUMsWUFBWUEsVUFBVSxFQUFFLEdBQUdKO0lBQ25ILElBQUksQ0FBQ0ssV0FBV0MsV0FBVyxHQUFHLENBQUMsR0FBRzNCLDJDQUFj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eEIsdURBQXVEO0lBQ3ZELEdBQUc7UUFDQ1k7S0FDSDtJQUNELE9BQU87UUFDSFMsWUFBWUE7UUFDWlIsV0FBV0E7SUFDZjtBQUNKO0FBRytELENBQy9ELDJDQUEyQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0ByZWFjdC1hcmlhL2ludGVyYWN0aW9ucy9kaXN0L3VzZUhvdmVyLm1qcz8yYTM2Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7dXNlR2xvYmFsTGlzdGVuZXJzIGFzICRBV3huVCR1c2VHbG9iYWxMaXN0ZW5lcnMsIGdldE93bmVyRG9jdW1lbnQgYXMgJEFXeG5UJGdldE93bmVyRG9jdW1lbnQsIG5vZGVDb250YWlucyBhcyAkQVd4blQkbm9kZUNvbnRhaW5zfSBmcm9tIFwiQHJlYWN0LWFyaWEvdXRpbHNcIjtcbmltcG9ydCB7dXNlU3RhdGUgYXMgJEFXeG5UJHVzZVN0YXRlLCB1c2VSZWYgYXMgJEFXeG5UJHVzZVJlZiwgdXNlRWZmZWN0IGFzICRBV3huVCR1c2VFZmZlY3QsIHVzZU1lbW8gYXMgJEFXeG5UJHVzZU1lbW99IGZyb20gXCJyZWFjdFwiO1xuXG4vKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gLy8gUG9ydGlvbnMgb2YgdGhlIGNvZGUgaW4gdGhpcyBmaWxlIGFyZSBiYXNlZCBvbiBjb2RlIGZyb20gcmVhY3QuXG4vLyBPcmlnaW5hbCBsaWNlbnNpbmcgZm9yIHRoZSBmb2xsb3dpbmcgY2FuIGJlIGZvdW5kIGluIHRoZVxuLy8gTk9USUNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4vLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L3RyZWUvY2M3YzFhZWNlNDZhNmI2OWI0MTk1OGQ3MzFlMGZkMjdjOTRiZmM2Yy9wYWNrYWdlcy9yZWFjdC1pbnRlcmFjdGlvbnNcblxuXG4vLyBpT1MgZmlyZXMgb25Qb2ludGVyRW50ZXIgdHdpY2U6IG9uY2Ugd2l0aCBwb2ludGVyVHlwZT1cInRvdWNoXCIgYW5kIGFnYWluIHdpdGggcG9pbnRlclR5cGU9XCJtb3VzZVwiLlxuLy8gV2Ugd2FudCB0byBpZ25vcmUgdGhlc2UgZW11bGF0ZWQgZXZlbnRzIHNvIHRoZXkgZG8gbm90IHRyaWdnZXIgaG92ZXIgYmVoYXZpb3IuXG4vLyBTZWUgaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTIxNDYwOS5cbmxldCAkNjE3OWI5MzY3MDVlNzZkMyR2YXIkZ2xvYmFsSWdub3JlRW11bGF0ZWRNb3VzZUV2ZW50cyA9IGZhbHNlO1xubGV0ICQ2MTc5YjkzNjcwNWU3NmQzJHZhciRob3ZlckNvdW50ID0gMDtcbmZ1bmN0aW9uICQ2MTc5YjkzNjcwNWU3NmQzJHZhciRzZXRHbG9iYWxJZ25vcmVFbXVsYXRlZE1vdXNlRXZlbnRzKCkge1xuICAgICQ2MTc5YjkzNjcwNWU3NmQzJHZhciRnbG9iYWxJZ25vcmVFbXVsYXRlZE1vdXNlRXZlbnRzID0gdHJ1ZTtcbiAgICAvLyBDbGVhciBnbG9iYWxJZ25vcmVFbXVsYXRlZE1vdXNlRXZlbnRzIGFmdGVyIGEgc2hvcnQgdGltZW91dC4gaU9TIGZpcmVzIG9uUG9pbnRlckVudGVyXG4gICAgLy8gd2l0aCBwb2ludGVyVHlwZT1cIm1vdXNlXCIgaW1tZWRpYXRlbHkgYWZ0ZXIgb25Qb2ludGVyVXAgYW5kIGJlZm9yZSBvbkZvY3VzLiBPbiBvdGhlclxuICAgIC8vIGRldmljZXMgdGhhdCBkb24ndCBoYXZlIHRoaXMgcXVpcmssIHdlIGRvbid0IHdhbnQgdG8gaWdub3JlIGEgbW91c2UgaG92ZXIgc29tZXRpbWUgaW5cbiAgICAvLyB0aGUgZGlzdGFudCBmdXR1cmUgYmVjYXVzZSBhIHVzZXIgcHJldmlvdXNseSB0b3VjaGVkIHRoZSBlbGVtZW50LlxuICAgIHNldFRpbWVvdXQoKCk9PntcbiAgICAgICAgJDYxNzliOTM2NzA1ZTc2ZDMkdmFyJGdsb2JhbElnbm9yZUVtdWxhdGVkTW91c2VFdmVudHMgPSBmYWxzZTtcbiAgICB9LCA1MCk7XG59XG5mdW5jdGlvbiAkNjE3OWI5MzY3MDVlNzZkMyR2YXIkaGFuZGxlR2xvYmFsUG9pbnRlckV2ZW50KGUpIHtcbiAgICBpZiAoZS5wb2ludGVyVHlwZSA9PT0gJ3RvdWNoJykgJDYxNzliOTM2NzA1ZTc2ZDMkdmFyJHNldEdsb2JhbElnbm9yZUVtdWxhdGVkTW91c2VFdmVudHMoKTtcbn1cbmZ1bmN0aW9uICQ2MTc5YjkzNjcwNWU3NmQzJHZhciRzZXR1cEdsb2JhbFRvdWNoRXZlbnRzKCkge1xuICAgIGlmICh0eXBlb2YgZG9jdW1lbnQgPT09ICd1bmRlZmluZWQnKSByZXR1cm47XG4gICAgaWYgKHR5cGVvZiBQb2ludGVyRXZlbnQgIT09ICd1bmRlZmluZWQnKSBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdwb2ludGVydXAnLCAkNjE3OWI5MzY3MDVlNzZkMyR2YXIkaGFuZGxlR2xvYmFsUG9pbnRlckV2ZW50KTtcbiAgICBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Rlc3QnKSBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsICQ2MTc5YjkzNjcwNWU3NmQzJHZhciRzZXRHbG9iYWxJZ25vcmVFbXVsYXRlZE1vdXNlRXZlbnRzKTtcbiAgICAkNjE3OWI5MzY3MDVlNzZkMyR2YXIkaG92ZXJDb3VudCsrO1xuICAgIHJldHVybiAoKT0+e1xuICAgICAgICAkNjE3OWI5MzY3MDVlNzZkMyR2YXIkaG92ZXJDb3VudC0tO1xuICAgICAgICBpZiAoJDYxNzliOTM2NzA1ZTc2ZDMkdmFyJGhvdmVyQ291bnQgPiAwKSByZXR1cm47XG4gICAgICAgIGlmICh0eXBlb2YgUG9pbnRlckV2ZW50ICE9PSAndW5kZWZpbmVkJykgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigncG9pbnRlcnVwJywgJDYxNzliOTM2NzA1ZTc2ZDMkdmFyJGhhbmRsZUdsb2JhbFBvaW50ZXJFdmVudCk7XG4gICAgICAgIGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAndGVzdCcpIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgJDYxNzliOTM2NzA1ZTc2ZDMkdmFyJHNldEdsb2JhbElnbm9yZUVtdWxhdGVkTW91c2VFdmVudHMpO1xuICAgIH07XG59XG5mdW5jdGlvbiAkNjE3OWI5MzY3MDVlNzZkMyRleHBvcnQkYWU3ODBkYWYyOWU2ZDQ1Nihwcm9wcykge1xuICAgIGxldCB7IG9uSG92ZXJTdGFydDogb25Ib3ZlclN0YXJ0LCBvbkhvdmVyQ2hhbmdlOiBvbkhvdmVyQ2hhbmdlLCBvbkhvdmVyRW5kOiBvbkhvdmVyRW5kLCBpc0Rpc2FibGVkOiBpc0Rpc2FibGVkIH0gPSBwcm9wcztcbiAgICBsZXQgW2lzSG92ZXJlZCwgc2V0SG92ZXJlZF0gPSAoMCwgJEFXeG5UJHVzZVN0YXRlKShmYWxzZSk7XG4gICAgbGV0IHN0YXRlID0gKDAsICRBV3huVCR1c2VSZWYpKHtcbiAgICAgICAgaXNIb3ZlcmVkOiBmYWxzZSxcbiAgICAgICAgaWdub3JlRW11bGF0ZWRNb3VzZUV2ZW50czogZmFsc2UsXG4gICAgICAgIHBvaW50ZXJUeXBlOiAnJyxcbiAgICAgICAgdGFyZ2V0OiBudWxsXG4gICAgfSkuY3VycmVudDtcbiAgICAoMCwgJEFXeG5UJHVzZUVmZmVjdCkoJDYxNzliOTM2NzA1ZTc2ZDMkdmFyJHNldHVwR2xvYmFsVG91Y2hFdmVudHMsIFtdKTtcbiAgICBsZXQgeyBhZGRHbG9iYWxMaXN0ZW5lcjogYWRkR2xvYmFsTGlzdGVuZXIsIHJlbW92ZUFsbEdsb2JhbExpc3RlbmVyczogcmVtb3ZlQWxsR2xvYmFsTGlzdGVuZXJzIH0gPSAoMCwgJEFXeG5UJHVzZUdsb2JhbExpc3RlbmVycykoKTtcbiAgICBsZXQgeyBob3ZlclByb3BzOiBob3ZlclByb3BzLCB0cmlnZ2VySG92ZXJFbmQ6IHRyaWdnZXJIb3ZlckVuZCB9ID0gKDAsICRBV3huVCR1c2VNZW1vKSgoKT0+e1xuICAgICAgICBsZXQgdHJpZ2dlckhvdmVyU3RhcnQgPSAoZXZlbnQsIHBvaW50ZXJUeXBlKT0+e1xuICAgICAgICAgICAgc3RhdGUucG9pbnRlclR5cGUgPSBwb2ludGVyVHlwZTtcbiAgICAgICAgICAgIGlmIChpc0Rpc2FibGVkIHx8IHBvaW50ZXJUeXBlID09PSAndG91Y2gnIHx8IHN0YXRlLmlzSG92ZXJlZCB8fCAhZXZlbnQuY3VycmVudFRhcmdldC5jb250YWlucyhldmVudC50YXJnZXQpKSByZXR1cm47XG4gICAgICAgICAgICBzdGF0ZS5pc0hvdmVyZWQgPSB0cnVlO1xuICAgICAgICAgICAgbGV0IHRhcmdldCA9IGV2ZW50LmN1cnJlbnRUYXJnZXQ7XG4gICAgICAgICAgICBzdGF0ZS50YXJnZXQgPSB0YXJnZXQ7XG4gICAgICAgICAgICAvLyBXaGVuIGFuIGVsZW1lbnQgdGhhdCBpcyBob3ZlcmVkIG92ZXIgaXMgcmVtb3ZlZCwgbm8gcG9pbnRlcmxlYXZlIGV2ZW50IGlzIGZpcmVkIGJ5IHRoZSBicm93c2VyLFxuICAgICAgICAgICAgLy8gZXZlbiB0aG91Z2ggdGhlIG9yaWdpbmFsbHkgaG92ZXJlZCB0YXJnZXQgbWF5IGhhdmUgc2hydW5rIGluIHNpemUgc28gaXQgaXMgbm8gbG9uZ2VyIGhvdmVyZWQuXG4gICAgICAgICAgICAvLyBIb3dldmVyLCBhIHBvaW50ZXJvdmVyIGV2ZW50IHdpbGwgYmUgZmlyZWQgb24gdGhlIG5ldyB0YXJnZXQgdGhlIG1vdXNlIGlzIG92ZXIuXG4gICAgICAgICAgICAvLyBJbiBDaHJvbWUgdGhpcyBoYXBwZW5zIGltbWVkaWF0ZWx5LiBJbiBTYWZhcmkgYW5kIEZpcmVmb3gsIGl0IGhhcHBlbnMgdXBvbiBtb3ZpbmcgdGhlIG1vdXNlIG9uZSBwaXhlbC5cbiAgICAgICAgICAgIGFkZEdsb2JhbExpc3RlbmVyKCgwLCAkQVd4blQkZ2V0T3duZXJEb2N1bWVudCkoZXZlbnQudGFyZ2V0KSwgJ3BvaW50ZXJvdmVyJywgKGUpPT57XG4gICAgICAgICAgICAgICAgaWYgKHN0YXRlLmlzSG92ZXJlZCAmJiBzdGF0ZS50YXJnZXQgJiYgISgwLCAkQVd4blQkbm9kZUNvbnRhaW5zKShzdGF0ZS50YXJnZXQsIGUudGFyZ2V0KSkgdHJpZ2dlckhvdmVyRW5kKGUsIGUucG9pbnRlclR5cGUpO1xuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIGNhcHR1cmU6IHRydWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKG9uSG92ZXJTdGFydCkgb25Ib3ZlclN0YXJ0KHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnaG92ZXJzdGFydCcsXG4gICAgICAgICAgICAgICAgdGFyZ2V0OiB0YXJnZXQsXG4gICAgICAgICAgICAgICAgcG9pbnRlclR5cGU6IHBvaW50ZXJUeXBlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChvbkhvdmVyQ2hhbmdlKSBvbkhvdmVyQ2hhbmdlKHRydWUpO1xuICAgICAgICAgICAgc2V0SG92ZXJlZCh0cnVlKTtcbiAgICAgICAgfTtcbiAgICAgICAgbGV0IHRyaWdnZXJIb3ZlckVuZCA9IChldmVudCwgcG9pbnRlclR5cGUpPT57XG4gICAgICAgICAgICBsZXQgdGFyZ2V0ID0gc3RhdGUudGFyZ2V0O1xuICAgICAgICAgICAgc3RhdGUucG9pbnRlclR5cGUgPSAnJztcbiAgICAgICAgICAgIHN0YXRlLnRhcmdldCA9IG51bGw7XG4gICAgICAgICAgICBpZiAocG9pbnRlclR5cGUgPT09ICd0b3VjaCcgfHwgIXN0YXRlLmlzSG92ZXJlZCB8fCAhdGFyZ2V0KSByZXR1cm47XG4gICAgICAgICAgICBzdGF0ZS5pc0hvdmVyZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHJlbW92ZUFsbEdsb2JhbExpc3RlbmVycygpO1xuICAgICAgICAgICAgaWYgKG9uSG92ZXJFbmQpIG9uSG92ZXJFbmQoe1xuICAgICAgICAgICAgICAgIHR5cGU6ICdob3ZlcmVuZCcsXG4gICAgICAgICAgICAgICAgdGFyZ2V0OiB0YXJnZXQsXG4gICAgICAgICAgICAgICAgcG9pbnRlclR5cGU6IHBvaW50ZXJUeXBlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChvbkhvdmVyQ2hhbmdlKSBvbkhvdmVyQ2hhbmdlKGZhbHNlKTtcbiAgICAgICAgICAgIHNldEhvdmVyZWQoZmFsc2UpO1xuICAgICAgICB9O1xuICAgICAgICBsZXQgaG92ZXJQcm9wcyA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIFBvaW50ZXJFdmVudCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIGhvdmVyUHJvcHMub25Qb2ludGVyRW50ZXIgPSAoZSk9PntcbiAgICAgICAgICAgICAgICBpZiAoJDYxNzliOTM2NzA1ZTc2ZDMkdmFyJGdsb2JhbElnbm9yZUVtdWxhdGVkTW91c2VFdmVudHMgJiYgZS5wb2ludGVyVHlwZSA9PT0gJ21vdXNlJykgcmV0dXJuO1xuICAgICAgICAgICAgICAgIHRyaWdnZXJIb3ZlclN0YXJ0KGUsIGUucG9pbnRlclR5cGUpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGhvdmVyUHJvcHMub25Qb2ludGVyTGVhdmUgPSAoZSk9PntcbiAgICAgICAgICAgICAgICBpZiAoIWlzRGlzYWJsZWQgJiYgZS5jdXJyZW50VGFyZ2V0LmNvbnRhaW5zKGUudGFyZ2V0KSkgdHJpZ2dlckhvdmVyRW5kKGUsIGUucG9pbnRlclR5cGUpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Rlc3QnKSB7XG4gICAgICAgICAgICBob3ZlclByb3BzLm9uVG91Y2hTdGFydCA9ICgpPT57XG4gICAgICAgICAgICAgICAgc3RhdGUuaWdub3JlRW11bGF0ZWRNb3VzZUV2ZW50cyA9IHRydWU7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaG92ZXJQcm9wcy5vbk1vdXNlRW50ZXIgPSAoZSk9PntcbiAgICAgICAgICAgICAgICBpZiAoIXN0YXRlLmlnbm9yZUVtdWxhdGVkTW91c2VFdmVudHMgJiYgISQ2MTc5YjkzNjcwNWU3NmQzJHZhciRnbG9iYWxJZ25vcmVFbXVsYXRlZE1vdXNlRXZlbnRzKSB0cmlnZ2VySG92ZXJTdGFydChlLCAnbW91c2UnKTtcbiAgICAgICAgICAgICAgICBzdGF0ZS5pZ25vcmVFbXVsYXRlZE1vdXNlRXZlbnRzID0gZmFsc2U7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaG92ZXJQcm9wcy5vbk1vdXNlTGVhdmUgPSAoZSk9PntcbiAgICAgICAgICAgICAgICBpZiAoIWlzRGlzYWJsZWQgJiYgZS5jdXJyZW50VGFyZ2V0LmNvbnRhaW5zKGUudGFyZ2V0KSkgdHJpZ2dlckhvdmVyRW5kKGUsICdtb3VzZScpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaG92ZXJQcm9wczogaG92ZXJQcm9wcyxcbiAgICAgICAgICAgIHRyaWdnZXJIb3ZlckVuZDogdHJpZ2dlckhvdmVyRW5kXG4gICAgICAgIH07XG4gICAgfSwgW1xuICAgICAgICBvbkhvdmVyU3RhcnQsXG4gICAgICAgIG9uSG92ZXJDaGFuZ2UsXG4gICAgICAgIG9uSG92ZXJFbmQsXG4gICAgICAgIGlzRGlzYWJsZWQsXG4gICAgICAgIHN0YXRlLFxuICAgICAgICBhZGRHbG9iYWxMaXN0ZW5lcixcbiAgICAgICAgcmVtb3ZlQWxsR2xvYmFsTGlzdGVuZXJzXG4gICAgXSk7XG4gICAgKDAsICRBV3huVCR1c2VFZmZlY3QpKCgpPT57XG4gICAgICAgIC8vIENhbGwgdGhlIHRyaWdnZXJIb3ZlckVuZCBhcyBzb29uIGFzIGlzRGlzYWJsZWQgY2hhbmdlcyB0byB0cnVlXG4gICAgICAgIC8vIFNhZmUgdG8gY2FsbCB0cmlnZ2VySG92ZXJFbmQsIGl0IHdpbGwgZWFybHkgcmV0dXJuIGlmIHdlIGFyZW4ndCBjdXJyZW50bHkgaG92ZXJpbmdcbiAgICAgICAgaWYgKGlzRGlzYWJsZWQpIHRyaWdnZXJIb3ZlckVuZCh7XG4gICAgICAgICAgICBjdXJyZW50VGFyZ2V0OiBzdGF0ZS50YXJnZXRcbiAgICAgICAgfSwgc3RhdGUucG9pbnRlclR5cGUpO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgICB9LCBbXG4gICAgICAgIGlzRGlzYWJsZWRcbiAgICBdKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBob3ZlclByb3BzOiBob3ZlclByb3BzLFxuICAgICAgICBpc0hvdmVyZWQ6IGlzSG92ZXJlZFxuICAgIH07XG59XG5cblxuZXhwb3J0IHskNjE3OWI5MzY3MDVlNzZkMyRleHBvcnQkYWU3ODBkYWYyOWU2ZDQ1NiBhcyB1c2VIb3Zlcn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD11c2VIb3Zlci5tb2R1bGUuanMubWFwXG4iXSwibmFtZXMiOlsidXNlR2xvYmFsTGlzdGVuZXJzIiwiJEFXeG5UJHVzZUdsb2JhbExpc3RlbmVycyIsImdldE93bmVyRG9jdW1lbnQiLCIkQVd4blQkZ2V0T3duZXJEb2N1bWVudCIsIm5vZGVDb250YWlucyIsIiRBV3huVCRub2RlQ29udGFpbnMiLCJ1c2VTdGF0ZSIsIiRBV3huVCR1c2VTdGF0ZSIsInVzZVJlZiIsIiRBV3huVCR1c2VSZWYiLCJ1c2VFZmZlY3QiLCIkQVd4blQkdXNlRWZmZWN0IiwidXNlTWVtbyIsIiRBV3huVCR1c2VNZW1vIiwiJDYxNzliOTM2NzA1ZTc2ZDMkdmFyJGdsb2JhbElnbm9yZUVtdWxhdGVkTW91c2VFdmVudHMiLCIkNjE3OWI5MzY3MDVlNzZkMyR2YXIkaG92ZXJDb3VudCIsIiQ2MTc5YjkzNjcwNWU3NmQzJHZhciRzZXRHbG9iYWxJZ25vcmVFbXVsYXRlZE1vdXNlRXZlbnRzIiwic2V0VGltZW91dCIsIiQ2MTc5YjkzNjcwNWU3NmQzJHZhciRoYW5kbGVHbG9iYWxQb2ludGVyRXZlbnQiLCJlIiwicG9pbnRlclR5cGUiLCIkNjE3OWI5MzY3MDVlNzZkMyR2YXIkc2V0dXBHbG9iYWxUb3VjaEV2ZW50cyIsImRvY3VtZW50IiwiUG9pbnRlckV2ZW50IiwiYWRkRXZlbnRMaXN0ZW5lciIsInByb2Nlc3MiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiJDYxNzliOTM2NzA1ZTc2ZDMkZXhwb3J0JGFlNzgwZGFmMjllNmQ0NTYiLCJwcm9wcyIsIm9uSG92ZXJTdGFydCIsIm9uSG92ZXJDaGFuZ2UiLCJvbkhvdmVyRW5kIiwiaXNEaXNhYmxlZCIsImlzSG92ZXJlZCIsInNldEhvdmVyZWQiLCJzdGF0ZSIsImlnbm9yZUVtdWxhdGVkTW91c2VFdmVudHMiLCJ0YXJnZXQiLCJjdXJyZW50IiwiYWRkR2xvYmFsTGlzdGVuZXIiLCJyZW1vdmVBbGxHbG9iYWxMaXN0ZW5lcnMiLCJob3ZlclByb3BzIiwidHJpZ2dlckhvdmVyRW5kIiwidHJpZ2dlckhvdmVyU3RhcnQiLCJldmVudCIsImN1cnJlbnRUYXJnZXQiLCJjb250YWlucyIsImNhcHR1cmUiLCJ0eXBlIiwib25Qb2ludGVyRW50ZXIiLCJvblBvaW50ZXJMZWF2ZSIsIm9uVG91Y2hTdGFydCIsIm9uTW91c2VFbnRlciIsIm9uTW91c2VMZWF2ZSIsInVzZUhvdmVyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../../../node_modules/@react-aria/interactions/dist/useHover.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/../../../../node_modules/@react-aria/interactions/dist/utils.mjs":
/*!************************************************************************!*\
  !*** ../../../../node_modules/@react-aria/interactions/dist/utils.mjs ***!
  \************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createSyntheticEvent: function() { return /* binding */ $8a9cb279dc87e130$export$525bc4921d56d4a; },\n/* harmony export */   ignoreFocusEvent: function() { return /* binding */ $8a9cb279dc87e130$export$fda7da73ab5d4c48; },\n/* harmony export */   preventFocus: function() { return /* binding */ $8a9cb279dc87e130$export$cabe61c495ee3649; },\n/* harmony export */   setEventTarget: function() { return /* binding */ $8a9cb279dc87e130$export$c2b7abe5d61ec696; },\n/* harmony export */   useSyntheticBlurEvent: function() { return /* binding */ $8a9cb279dc87e130$export$715c682d09d639cc; }\n/* harmony export */ });\n/* harmony import */ var _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @react-aria/utils */ \"(app-pages-browser)/../../../../node_modules/@react-aria/utils/dist/useLayoutEffect.mjs\");\n/* harmony import */ var _react_aria_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @react-aria/utils */ \"(app-pages-browser)/../../../../node_modules/@react-aria/utils/dist/useEffectEvent.mjs\");\n/* harmony import */ var _react_aria_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @react-aria/utils */ \"(app-pages-browser)/../../../../node_modules/@react-aria/utils/dist/isFocusable.mjs\");\n/* harmony import */ var _react_aria_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @react-aria/utils */ \"(app-pages-browser)/../../../../node_modules/@react-aria/utils/dist/domHelpers.mjs\");\n/* harmony import */ var _react_aria_utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @react-aria/utils */ \"(app-pages-browser)/../../../../node_modules/@react-aria/utils/dist/focusWithoutScrolling.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ function $8a9cb279dc87e130$export$525bc4921d56d4a(nativeEvent) {\n    let event = nativeEvent;\n    event.nativeEvent = nativeEvent;\n    event.isDefaultPrevented = ()=>event.defaultPrevented;\n    // cancelBubble is technically deprecated in the spec, but still supported in all browsers.\n    event.isPropagationStopped = ()=>event.cancelBubble;\n    event.persist = ()=>{};\n    return event;\n}\nfunction $8a9cb279dc87e130$export$c2b7abe5d61ec696(event, target) {\n    Object.defineProperty(event, \"target\", {\n        value: target\n    });\n    Object.defineProperty(event, \"currentTarget\", {\n        value: target\n    });\n}\nfunction $8a9cb279dc87e130$export$715c682d09d639cc(onBlur) {\n    let stateRef = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)({\n        isFocused: false,\n        observer: null\n    });\n    // Clean up MutationObserver on unmount. See below.\n    (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_1__.useLayoutEffect)(()=>{\n        const state = stateRef.current;\n        return ()=>{\n            if (state.observer) {\n                state.observer.disconnect();\n                state.observer = null;\n            }\n        };\n    }, []);\n    let dispatchBlur = (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_2__.useEffectEvent)((e)=>{\n        onBlur === null || onBlur === void 0 ? void 0 : onBlur(e);\n    });\n    // This function is called during a React onFocus event.\n    return (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((e)=>{\n        // React does not fire onBlur when an element is disabled. https://github.com/facebook/react/issues/9142\n        // Most browsers fire a native focusout event in this case, except for Firefox. In that case, we use a\n        // MutationObserver to watch for the disabled attribute, and dispatch these events ourselves.\n        // For browsers that do, focusout fires before the MutationObserver, so onBlur should not fire twice.\n        if (e.target instanceof HTMLButtonElement || e.target instanceof HTMLInputElement || e.target instanceof HTMLTextAreaElement || e.target instanceof HTMLSelectElement) {\n            stateRef.current.isFocused = true;\n            let target = e.target;\n            let onBlurHandler = (e)=>{\n                stateRef.current.isFocused = false;\n                if (target.disabled) {\n                    // For backward compatibility, dispatch a (fake) React synthetic event.\n                    let event = $8a9cb279dc87e130$export$525bc4921d56d4a(e);\n                    dispatchBlur(event);\n                }\n                // We no longer need the MutationObserver once the target is blurred.\n                if (stateRef.current.observer) {\n                    stateRef.current.observer.disconnect();\n                    stateRef.current.observer = null;\n                }\n            };\n            target.addEventListener(\"focusout\", onBlurHandler, {\n                once: true\n            });\n            stateRef.current.observer = new MutationObserver(()=>{\n                if (stateRef.current.isFocused && target.disabled) {\n                    var _stateRef_current_observer;\n                    (_stateRef_current_observer = stateRef.current.observer) === null || _stateRef_current_observer === void 0 ? void 0 : _stateRef_current_observer.disconnect();\n                    let relatedTargetEl = target === document.activeElement ? null : document.activeElement;\n                    target.dispatchEvent(new FocusEvent(\"blur\", {\n                        relatedTarget: relatedTargetEl\n                    }));\n                    target.dispatchEvent(new FocusEvent(\"focusout\", {\n                        bubbles: true,\n                        relatedTarget: relatedTargetEl\n                    }));\n                }\n            });\n            stateRef.current.observer.observe(target, {\n                attributes: true,\n                attributeFilter: [\n                    \"disabled\"\n                ]\n            });\n        }\n    }, [\n        dispatchBlur\n    ]);\n}\nlet $8a9cb279dc87e130$export$fda7da73ab5d4c48 = false;\nfunction $8a9cb279dc87e130$export$cabe61c495ee3649(target) {\n    // The browser will focus the nearest focusable ancestor of our target.\n    while(target && !(0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_3__.isFocusable)(target))target = target.parentElement;\n    let window = (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_4__.getOwnerWindow)(target);\n    let activeElement = window.document.activeElement;\n    if (!activeElement || activeElement === target) return;\n    $8a9cb279dc87e130$export$fda7da73ab5d4c48 = true;\n    let isRefocusing = false;\n    let onBlur = (e)=>{\n        if (e.target === activeElement || isRefocusing) e.stopImmediatePropagation();\n    };\n    let onFocusOut = (e)=>{\n        if (e.target === activeElement || isRefocusing) {\n            e.stopImmediatePropagation();\n            // If there was no focusable ancestor, we don't expect a focus event.\n            // Re-focus the original active element here.\n            if (!target && !isRefocusing) {\n                isRefocusing = true;\n                (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_5__.focusWithoutScrolling)(activeElement);\n                cleanup();\n            }\n        }\n    };\n    let onFocus = (e)=>{\n        if (e.target === target || isRefocusing) e.stopImmediatePropagation();\n    };\n    let onFocusIn = (e)=>{\n        if (e.target === target || isRefocusing) {\n            e.stopImmediatePropagation();\n            if (!isRefocusing) {\n                isRefocusing = true;\n                (0, _react_aria_utils__WEBPACK_IMPORTED_MODULE_5__.focusWithoutScrolling)(activeElement);\n                cleanup();\n            }\n        }\n    };\n    window.addEventListener(\"blur\", onBlur, true);\n    window.addEventListener(\"focusout\", onFocusOut, true);\n    window.addEventListener(\"focusin\", onFocusIn, true);\n    window.addEventListener(\"focus\", onFocus, true);\n    let cleanup = ()=>{\n        cancelAnimationFrame(raf);\n        window.removeEventListener(\"blur\", onBlur, true);\n        window.removeEventListener(\"focusout\", onFocusOut, true);\n        window.removeEventListener(\"focusin\", onFocusIn, true);\n        window.removeEventListener(\"focus\", onFocus, true);\n        $8a9cb279dc87e130$export$fda7da73ab5d4c48 = false;\n        isRefocusing = false;\n    };\n    let raf = requestAnimationFrame(cleanup);\n    return cleanup;\n}\n //# sourceMappingURL=utils.module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQHJlYWN0LWFyaWEvaW50ZXJhY3Rpb25zL2Rpc3QvdXRpbHMubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQXdQO0FBQ3ZLO0FBRWpGOzs7Ozs7Ozs7O0NBVUMsR0FFRCxTQUFTYyx5Q0FBeUNDLFdBQVc7SUFDekQsSUFBSUMsUUFBUUQ7SUFDWkMsTUFBTUQsV0FBVyxHQUFHQTtJQUNwQkMsTUFBTUMsa0JBQWtCLEdBQUcsSUFBSUQsTUFBTUUsZ0JBQWdCO0lBQ3JELDJGQUEyRjtJQUMzRkYsTUFBTUcsb0JBQW9CLEdBQUcsSUFBSUgsTUFBTUksWUFBWTtJQUNuREosTUFBTUssT0FBTyxHQUFHLEtBQUs7SUFDckIsT0FBT0w7QUFDWDtBQUNBLFNBQVNNLDBDQUEwQ04sS0FBSyxFQUFFTyxNQUFNO0lBQzVEQyxPQUFPQyxjQUFjLENBQUNULE9BQU8sVUFBVTtRQUNuQ1UsT0FBT0g7SUFDWDtJQUNBQyxPQUFPQyxjQUFjLENBQUNULE9BQU8saUJBQWlCO1FBQzFDVSxPQUFPSDtJQUNYO0FBQ0o7QUFDQSxTQUFTSSwwQ0FBMENDLE1BQU07SUFDckQsSUFBSUMsV0FBVyxDQUFDLEdBQUdsQix5Q0FBWSxFQUFHO1FBQzlCbUIsV0FBVztRQUNYQyxVQUFVO0lBQ2Q7SUFDQSxtREFBbUQ7SUFDbEQsSUFBRzlCLDhEQUFxQixFQUFHO1FBQ3hCLE1BQU0rQixRQUFRSCxTQUFTSSxPQUFPO1FBQzlCLE9BQU87WUFDSCxJQUFJRCxNQUFNRCxRQUFRLEVBQUU7Z0JBQ2hCQyxNQUFNRCxRQUFRLENBQUNHLFVBQVU7Z0JBQ3pCRixNQUFNRCxRQUFRLEdBQUc7WUFDckI7UUFDSjtJQUNKLEdBQUcsRUFBRTtJQUNMLElBQUlJLGVBQWUsQ0FBQyxHQUFHaEMsNkRBQW9CLEVBQUcsQ0FBQ2lDO1FBQzNDUixXQUFXLFFBQVFBLFdBQVcsS0FBSyxJQUFJLEtBQUssSUFBSUEsT0FBT1E7SUFDM0Q7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LElBQUlBLEVBQUViLE1BQU0sS0FBS0EsVUFBVXNDLGNBQWN6QixFQUFFMEIsd0JBQXdCO0lBQ3ZFO0lBQ0EsSUFBSUksWUFBWSxDQUFDOUI7UUFDYixJQUFJQSxFQUFFYixNQUFNLEtBQUtBLFVBQVVzQyxjQUFjO1lBQ3JDekIsRUFBRTBCLHdCQUF3QjtZQUMxQixJQUFJLENBQUNELGNBQWM7Z0JBQ2ZBLGVBQWU7Z0JBQ2QsSUFBR3BELG9FQUEyQixFQUFHd0M7Z0JBQ2xDZTtZQUNKO1FBQ0o7SUFDSjtJQUNBSixPQUFPakIsZ0JBQWdCLENBQUMsUUFBUWYsUUFBUTtJQUN4Q2dDLE9BQU9qQixnQkFBZ0IsQ0FBQyxZQUFZb0IsWUFBWTtJQUNoREgsT0FBT2pCLGdCQUFnQixDQUFDLFdBQVd1QixXQUFXO0lBQzlDTixPQUFPakIsZ0JBQWdCLENBQUMsU0FBU3NCLFNBQVM7SUFDMUMsSUFBSUQsVUFBVTtRQUNWRyxxQkFBcUJDO1FBQ3JCUixPQUFPUyxtQkFBbUIsQ0FBQyxRQUFRekMsUUFBUTtRQUMzQ2dDLE9BQU9TLG1CQUFtQixDQUFDLFlBQVlOLFlBQVk7UUFDbkRILE9BQU9TLG1CQUFtQixDQUFDLFdBQVdILFdBQVc7UUFDakROLE9BQU9TLG1CQUFtQixDQUFDLFNBQVNKLFNBQVM7UUFDN0NSLDRDQUE0QztRQUM1Q0ksZUFBZTtJQUNuQjtJQUNBLElBQUlPLE1BQU1FLHNCQUFzQk47SUFDaEMsT0FBT0E7QUFDWDtBQUdxVSxDQUNyVSx3Q0FBd0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AcmVhY3QtYXJpYS9pbnRlcmFjdGlvbnMvZGlzdC91dGlscy5tanM/OTQ5NyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge3VzZUxheW91dEVmZmVjdCBhcyAkNmRmSWUkdXNlTGF5b3V0RWZmZWN0LCB1c2VFZmZlY3RFdmVudCBhcyAkNmRmSWUkdXNlRWZmZWN0RXZlbnQsIGlzRm9jdXNhYmxlIGFzICQ2ZGZJZSRpc0ZvY3VzYWJsZSwgZ2V0T3duZXJXaW5kb3cgYXMgJDZkZkllJGdldE93bmVyV2luZG93LCBmb2N1c1dpdGhvdXRTY3JvbGxpbmcgYXMgJDZkZkllJGZvY3VzV2l0aG91dFNjcm9sbGluZ30gZnJvbSBcIkByZWFjdC1hcmlhL3V0aWxzXCI7XG5pbXBvcnQge3VzZVJlZiBhcyAkNmRmSWUkdXNlUmVmLCB1c2VDYWxsYmFjayBhcyAkNmRmSWUkdXNlQ2FsbGJhY2t9IGZyb20gXCJyZWFjdFwiO1xuXG4vKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gXG5cbmZ1bmN0aW9uICQ4YTljYjI3OWRjODdlMTMwJGV4cG9ydCQ1MjViYzQ5MjFkNTZkNGEobmF0aXZlRXZlbnQpIHtcbiAgICBsZXQgZXZlbnQgPSBuYXRpdmVFdmVudDtcbiAgICBldmVudC5uYXRpdmVFdmVudCA9IG5hdGl2ZUV2ZW50O1xuICAgIGV2ZW50LmlzRGVmYXVsdFByZXZlbnRlZCA9ICgpPT5ldmVudC5kZWZhdWx0UHJldmVudGVkO1xuICAgIC8vIGNhbmNlbEJ1YmJsZSBpcyB0ZWNobmljYWxseSBkZXByZWNhdGVkIGluIHRoZSBzcGVjLCBidXQgc3RpbGwgc3VwcG9ydGVkIGluIGFsbCBicm93c2Vycy5cbiAgICBldmVudC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCA9ICgpPT5ldmVudC5jYW5jZWxCdWJibGU7XG4gICAgZXZlbnQucGVyc2lzdCA9ICgpPT57fTtcbiAgICByZXR1cm4gZXZlbnQ7XG59XG5mdW5jdGlvbiAkOGE5Y2IyNzlkYzg3ZTEzMCRleHBvcnQkYzJiN2FiZTVkNjFlYzY5NihldmVudCwgdGFyZ2V0KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV2ZW50LCAndGFyZ2V0Jywge1xuICAgICAgICB2YWx1ZTogdGFyZ2V0XG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV2ZW50LCAnY3VycmVudFRhcmdldCcsIHtcbiAgICAgICAgdmFsdWU6IHRhcmdldFxuICAgIH0pO1xufVxuZnVuY3Rpb24gJDhhOWNiMjc5ZGM4N2UxMzAkZXhwb3J0JDcxNWM2ODJkMDlkNjM5Y2Mob25CbHVyKSB7XG4gICAgbGV0IHN0YXRlUmVmID0gKDAsICQ2ZGZJZSR1c2VSZWYpKHtcbiAgICAgICAgaXNGb2N1c2VkOiBmYWxzZSxcbiAgICAgICAgb2JzZXJ2ZXI6IG51bGxcbiAgICB9KTtcbiAgICAvLyBDbGVhbiB1cCBNdXRhdGlvbk9ic2VydmVyIG9uIHVubW91bnQuIFNlZSBiZWxvdy5cbiAgICAoMCwgJDZkZkllJHVzZUxheW91dEVmZmVjdCkoKCk9PntcbiAgICAgICAgY29uc3Qgc3RhdGUgPSBzdGF0ZVJlZi5jdXJyZW50O1xuICAgICAgICByZXR1cm4gKCk9PntcbiAgICAgICAgICAgIGlmIChzdGF0ZS5vYnNlcnZlcikge1xuICAgICAgICAgICAgICAgIHN0YXRlLm9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICAgICAgICBzdGF0ZS5vYnNlcnZlciA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfSwgW10pO1xuICAgIGxldCBkaXNwYXRjaEJsdXIgPSAoMCwgJDZkZkllJHVzZUVmZmVjdEV2ZW50KSgoZSk9PntcbiAgICAgICAgb25CbHVyID09PSBudWxsIHx8IG9uQmx1ciA9PT0gdm9pZCAwID8gdm9pZCAwIDogb25CbHVyKGUpO1xuICAgIH0pO1xuICAgIC8vIFRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIGR1cmluZyBhIFJlYWN0IG9uRm9jdXMgZXZlbnQuXG4gICAgcmV0dXJuICgwLCAkNmRmSWUkdXNlQ2FsbGJhY2spKChlKT0+e1xuICAgICAgICAvLyBSZWFjdCBkb2VzIG5vdCBmaXJlIG9uQmx1ciB3aGVuIGFuIGVsZW1lbnQgaXMgZGlzYWJsZWQuIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvOTE0MlxuICAgICAgICAvLyBNb3N0IGJyb3dzZXJzIGZpcmUgYSBuYXRpdmUgZm9jdXNvdXQgZXZlbnQgaW4gdGhpcyBjYXNlLCBleGNlcHQgZm9yIEZpcmVmb3guIEluIHRoYXQgY2FzZSwgd2UgdXNlIGFcbiAgICAgICAgLy8gTXV0YXRpb25PYnNlcnZlciB0byB3YXRjaCBmb3IgdGhlIGRpc2FibGVkIGF0dHJpYnV0ZSwgYW5kIGRpc3BhdGNoIHRoZXNlIGV2ZW50cyBvdXJzZWx2ZXMuXG4gICAgICAgIC8vIEZvciBicm93c2VycyB0aGF0IGRvLCBmb2N1c291dCBmaXJlcyBiZWZvcmUgdGhlIE11dGF0aW9uT2JzZXJ2ZXIsIHNvIG9uQmx1ciBzaG91bGQgbm90IGZpcmUgdHdpY2UuXG4gICAgICAgIGlmIChlLnRhcmdldCBpbnN0YW5jZW9mIEhUTUxCdXR0b25FbGVtZW50IHx8IGUudGFyZ2V0IGluc3RhbmNlb2YgSFRNTElucHV0RWxlbWVudCB8fCBlLnRhcmdldCBpbnN0YW5jZW9mIEhUTUxUZXh0QXJlYUVsZW1lbnQgfHwgZS50YXJnZXQgaW5zdGFuY2VvZiBIVE1MU2VsZWN0RWxlbWVudCkge1xuICAgICAgICAgICAgc3RhdGVSZWYuY3VycmVudC5pc0ZvY3VzZWQgPSB0cnVlO1xuICAgICAgICAgICAgbGV0IHRhcmdldCA9IGUudGFyZ2V0O1xuICAgICAgICAgICAgbGV0IG9uQmx1ckhhbmRsZXIgPSAoZSk9PntcbiAgICAgICAgICAgICAgICBzdGF0ZVJlZi5jdXJyZW50LmlzRm9jdXNlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGlmICh0YXJnZXQuZGlzYWJsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIGRpc3BhdGNoIGEgKGZha2UpIFJlYWN0IHN5bnRoZXRpYyBldmVudC5cbiAgICAgICAgICAgICAgICAgICAgbGV0IGV2ZW50ID0gJDhhOWNiMjc5ZGM4N2UxMzAkZXhwb3J0JDUyNWJjNDkyMWQ1NmQ0YShlKTtcbiAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2hCbHVyKGV2ZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gV2Ugbm8gbG9uZ2VyIG5lZWQgdGhlIE11dGF0aW9uT2JzZXJ2ZXIgb25jZSB0aGUgdGFyZ2V0IGlzIGJsdXJyZWQuXG4gICAgICAgICAgICAgICAgaWYgKHN0YXRlUmVmLmN1cnJlbnQub2JzZXJ2ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGVSZWYuY3VycmVudC5vYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlUmVmLmN1cnJlbnQub2JzZXJ2ZXIgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcignZm9jdXNvdXQnLCBvbkJsdXJIYW5kbGVyLCB7XG4gICAgICAgICAgICAgICAgb25jZTogdHJ1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzdGF0ZVJlZi5jdXJyZW50Lm9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoKCk9PntcbiAgICAgICAgICAgICAgICBpZiAoc3RhdGVSZWYuY3VycmVudC5pc0ZvY3VzZWQgJiYgdGFyZ2V0LmRpc2FibGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfc3RhdGVSZWZfY3VycmVudF9vYnNlcnZlcjtcbiAgICAgICAgICAgICAgICAgICAgKF9zdGF0ZVJlZl9jdXJyZW50X29ic2VydmVyID0gc3RhdGVSZWYuY3VycmVudC5vYnNlcnZlcikgPT09IG51bGwgfHwgX3N0YXRlUmVmX2N1cnJlbnRfb2JzZXJ2ZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9zdGF0ZVJlZl9jdXJyZW50X29ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHJlbGF0ZWRUYXJnZXRFbCA9IHRhcmdldCA9PT0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCA/IG51bGwgOiBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXQuZGlzcGF0Y2hFdmVudChuZXcgRm9jdXNFdmVudCgnYmx1cicsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbGF0ZWRUYXJnZXQ6IHJlbGF0ZWRUYXJnZXRFbFxuICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldC5kaXNwYXRjaEV2ZW50KG5ldyBGb2N1c0V2ZW50KCdmb2N1c291dCcsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1YmJsZXM6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICByZWxhdGVkVGFyZ2V0OiByZWxhdGVkVGFyZ2V0RWxcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc3RhdGVSZWYuY3VycmVudC5vYnNlcnZlci5vYnNlcnZlKHRhcmdldCwge1xuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHRydWUsXG4gICAgICAgICAgICAgICAgYXR0cmlidXRlRmlsdGVyOiBbXG4gICAgICAgICAgICAgICAgICAgICdkaXNhYmxlZCdcbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0sIFtcbiAgICAgICAgZGlzcGF0Y2hCbHVyXG4gICAgXSk7XG59XG5sZXQgJDhhOWNiMjc5ZGM4N2UxMzAkZXhwb3J0JGZkYTdkYTczYWI1ZDRjNDggPSBmYWxzZTtcbmZ1bmN0aW9uICQ4YTljYjI3OWRjODdlMTMwJGV4cG9ydCRjYWJlNjFjNDk1ZWUzNjQ5KHRhcmdldCkge1xuICAgIC8vIFRoZSBicm93c2VyIHdpbGwgZm9jdXMgdGhlIG5lYXJlc3QgZm9jdXNhYmxlIGFuY2VzdG9yIG9mIG91ciB0YXJnZXQuXG4gICAgd2hpbGUodGFyZ2V0ICYmICEoMCwgJDZkZkllJGlzRm9jdXNhYmxlKSh0YXJnZXQpKXRhcmdldCA9IHRhcmdldC5wYXJlbnRFbGVtZW50O1xuICAgIGxldCB3aW5kb3cgPSAoMCwgJDZkZkllJGdldE93bmVyV2luZG93KSh0YXJnZXQpO1xuICAgIGxldCBhY3RpdmVFbGVtZW50ID0gd2luZG93LmRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG4gICAgaWYgKCFhY3RpdmVFbGVtZW50IHx8IGFjdGl2ZUVsZW1lbnQgPT09IHRhcmdldCkgcmV0dXJuO1xuICAgICQ4YTljYjI3OWRjODdlMTMwJGV4cG9ydCRmZGE3ZGE3M2FiNWQ0YzQ4ID0gdHJ1ZTtcbiAgICBsZXQgaXNSZWZvY3VzaW5nID0gZmFsc2U7XG4gICAgbGV0IG9uQmx1ciA9IChlKT0+e1xuICAgICAgICBpZiAoZS50YXJnZXQgPT09IGFjdGl2ZUVsZW1lbnQgfHwgaXNSZWZvY3VzaW5nKSBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuICAgIH07XG4gICAgbGV0IG9uRm9jdXNPdXQgPSAoZSk9PntcbiAgICAgICAgaWYgKGUudGFyZ2V0ID09PSBhY3RpdmVFbGVtZW50IHx8IGlzUmVmb2N1c2luZykge1xuICAgICAgICAgICAgZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgIC8vIElmIHRoZXJlIHdhcyBubyBmb2N1c2FibGUgYW5jZXN0b3IsIHdlIGRvbid0IGV4cGVjdCBhIGZvY3VzIGV2ZW50LlxuICAgICAgICAgICAgLy8gUmUtZm9jdXMgdGhlIG9yaWdpbmFsIGFjdGl2ZSBlbGVtZW50IGhlcmUuXG4gICAgICAgICAgICBpZiAoIXRhcmdldCAmJiAhaXNSZWZvY3VzaW5nKSB7XG4gICAgICAgICAgICAgICAgaXNSZWZvY3VzaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAoMCwgJDZkZkllJGZvY3VzV2l0aG91dFNjcm9sbGluZykoYWN0aXZlRWxlbWVudCk7XG4gICAgICAgICAgICAgICAgY2xlYW51cCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBsZXQgb25Gb2N1cyA9IChlKT0+e1xuICAgICAgICBpZiAoZS50YXJnZXQgPT09IHRhcmdldCB8fCBpc1JlZm9jdXNpbmcpIGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgfTtcbiAgICBsZXQgb25Gb2N1c0luID0gKGUpPT57XG4gICAgICAgIGlmIChlLnRhcmdldCA9PT0gdGFyZ2V0IHx8IGlzUmVmb2N1c2luZykge1xuICAgICAgICAgICAgZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgIGlmICghaXNSZWZvY3VzaW5nKSB7XG4gICAgICAgICAgICAgICAgaXNSZWZvY3VzaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAoMCwgJDZkZkllJGZvY3VzV2l0aG91dFNjcm9sbGluZykoYWN0aXZlRWxlbWVudCk7XG4gICAgICAgICAgICAgICAgY2xlYW51cCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignYmx1cicsIG9uQmx1ciwgdHJ1ZSk7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2ZvY3Vzb3V0Jywgb25Gb2N1c091dCwgdHJ1ZSk7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2ZvY3VzaW4nLCBvbkZvY3VzSW4sIHRydWUpO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdmb2N1cycsIG9uRm9jdXMsIHRydWUpO1xuICAgIGxldCBjbGVhbnVwID0gKCk9PntcbiAgICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUocmFmKTtcbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2JsdXInLCBvbkJsdXIsIHRydWUpO1xuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignZm9jdXNvdXQnLCBvbkZvY3VzT3V0LCB0cnVlKTtcbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2ZvY3VzaW4nLCBvbkZvY3VzSW4sIHRydWUpO1xuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignZm9jdXMnLCBvbkZvY3VzLCB0cnVlKTtcbiAgICAgICAgJDhhOWNiMjc5ZGM4N2UxMzAkZXhwb3J0JGZkYTdkYTczYWI1ZDRjNDggPSBmYWxzZTtcbiAgICAgICAgaXNSZWZvY3VzaW5nID0gZmFsc2U7XG4gICAgfTtcbiAgICBsZXQgcmFmID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGNsZWFudXApO1xuICAgIHJldHVybiBjbGVhbnVwO1xufVxuXG5cbmV4cG9ydCB7JDhhOWNiMjc5ZGM4N2UxMzAkZXhwb3J0JDUyNWJjNDkyMWQ1NmQ0YSBhcyBjcmVhdGVTeW50aGV0aWNFdmVudCwgJDhhOWNiMjc5ZGM4N2UxMzAkZXhwb3J0JGMyYjdhYmU1ZDYxZWM2OTYgYXMgc2V0RXZlbnRUYXJnZXQsICQ4YTljYjI3OWRjODdlMTMwJGV4cG9ydCQ3MTVjNjgyZDA5ZDYzOWNjIGFzIHVzZVN5bnRoZXRpY0JsdXJFdmVudCwgJDhhOWNiMjc5ZGM4N2UxMzAkZXhwb3J0JGZkYTdkYTczYWI1ZDRjNDggYXMgaWdub3JlRm9jdXNFdmVudCwgJDhhOWNiMjc5ZGM4N2UxMzAkZXhwb3J0JGNhYmU2MWM0OTVlZTM2NDkgYXMgcHJldmVudEZvY3VzfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0aWxzLm1vZHVsZS5qcy5tYXBcbiJdLCJuYW1lcyI6WyJ1c2VMYXlvdXRFZmZlY3QiLCIkNmRmSWUkdXNlTGF5b3V0RWZmZWN0IiwidXNlRWZmZWN0RXZlbnQiLCIkNmRmSWUkdXNlRWZmZWN0RXZlbnQiLCJpc0ZvY3VzYWJsZSIsIiQ2ZGZJZSRpc0ZvY3VzYWJsZSIsImdldE93bmVyV2luZG93IiwiJDZkZkllJGdldE93bmVyV2luZG93IiwiZm9jdXNXaXRob3V0U2Nyb2xsaW5nIiwiJDZkZkllJGZvY3VzV2l0aG91dFNjcm9sbGluZyIsInVzZVJlZiIsIiQ2ZGZJZSR1c2VSZWYiLCJ1c2VDYWxsYmFjayIsIiQ2ZGZJZSR1c2VDYWxsYmFjayIsIiQ4YTljYjI3OWRjODdlMTMwJGV4cG9ydCQ1MjViYzQ5MjFkNTZkNGEiLCJuYXRpdmVFdmVudCIsImV2ZW50IiwiaXNEZWZhdWx0UHJldmVudGVkIiwiZGVmYXVsdFByZXZlbnRlZCIsImlzUHJvcGFnYXRpb25TdG9wcGVkIiwiY2FuY2VsQnViYmxlIiwicGVyc2lzdCIsIiQ4YTljYjI3OWRjODdlMTMwJGV4cG9ydCRjMmI3YWJlNWQ2MWVjNjk2IiwidGFyZ2V0IiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJ2YWx1ZSIsIiQ4YTljYjI3OWRjODdlMTMwJGV4cG9ydCQ3MTVjNjgyZDA5ZDYzOWNjIiwib25CbHVyIiwic3RhdGVSZWYiLCJpc0ZvY3VzZWQiLCJvYnNlcnZlciIsInN0YXRlIiwiY3VycmVudCIsImRpc2Nvbm5lY3QiLCJkaXNwYXRjaEJsdXIiLCJlIiwiSFRNTEJ1dHRvbkVsZW1lbnQiLCJIVE1MSW5wdXRFbGVtZW50IiwiSFRNTFRleHRBcmVhRWxlbWVudCIsIkhUTUxTZWxlY3RFbGVtZW50Iiwib25CbHVySGFuZGxlciIsImRpc2FibGVkIiwiYWRkRXZlbnRMaXN0ZW5lciIsIm9uY2UiLCJNdXRhdGlvbk9ic2VydmVyIiwiX3N0YXRlUmVmX2N1cnJlbnRfb2JzZXJ2ZXIiLCJyZWxhdGVkVGFyZ2V0RWwiLCJkb2N1bWVudCIsImFjdGl2ZUVsZW1lbnQiLCJkaXNwYXRjaEV2ZW50IiwiRm9jdXNFdmVudCIsInJlbGF0ZWRUYXJnZXQiLCJidWJibGVzIiwib2JzZXJ2ZSIsImF0dHJpYnV0ZXMiLCJhdHRyaWJ1dGVGaWx0ZXIiLCIkOGE5Y2IyNzlkYzg3ZTEzMCRleHBvcnQkZmRhN2RhNzNhYjVkNGM0OCIsIiQ4YTljYjI3OWRjODdlMTMwJGV4cG9ydCRjYWJlNjFjNDk1ZWUzNjQ5IiwicGFyZW50RWxlbWVudCIsIndpbmRvdyIsImlzUmVmb2N1c2luZyIsInN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbiIsIm9uRm9jdXNPdXQiLCJjbGVhbnVwIiwib25Gb2N1cyIsIm9uRm9jdXNJbiIsImNhbmNlbEFuaW1hdGlvbkZyYW1lIiwicmFmIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsImNyZWF0ZVN5bnRoZXRpY0V2ZW50Iiwic2V0RXZlbnRUYXJnZXQiLCJ1c2VTeW50aGV0aWNCbHVyRXZlbnQiLCJpZ25vcmVGb2N1c0V2ZW50IiwicHJldmVudEZvY3VzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../../../node_modules/@react-aria/interactions/dist/utils.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/../../../../node_modules/@react-aria/ssr/dist/SSRProvider.mjs":
/*!*********************************************************************!*\
  !*** ../../../../node_modules/@react-aria/ssr/dist/SSRProvider.mjs ***!
  \*********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SSRProvider: function() { return /* binding */ $b5e257d569688ac6$export$9f8ac96af4b1b2ae; },\n/* harmony export */   useIsSSR: function() { return /* binding */ $b5e257d569688ac6$export$535bd6ca7f90a273; },\n/* harmony export */   useSSRSafeId: function() { return /* binding */ $b5e257d569688ac6$export$619500959fc48b26; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\nvar _s = $RefreshSig$();\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ // We must avoid a circular dependency with @react-aria/utils, and this useLayoutEffect is\n// guarded by a check that it only runs on the client side.\n// eslint-disable-next-line rulesdir/useLayoutEffectRule\n// Default context value to use in case there is no SSRProvider. This is fine for\n// client-only apps. In order to support multiple copies of React Aria potentially\n// being on the page at once, the prefix is set to a random number. SSRProvider\n// will reset this to zero for consistency between server and client, so in the\n// SSR case multiple copies of React Aria is not supported.\nconst $b5e257d569688ac6$var$defaultContext = {\n    prefix: String(Math.round(Math.random() * 10000000000)),\n    current: 0\n};\nconst $b5e257d569688ac6$var$SSRContext = /*#__PURE__*/ (0, react__WEBPACK_IMPORTED_MODULE_0__).createContext($b5e257d569688ac6$var$defaultContext);\nconst $b5e257d569688ac6$var$IsSSRContext = /*#__PURE__*/ (0, react__WEBPACK_IMPORTED_MODULE_0__).createContext(false);\n// This is only used in React < 18.\nfunction $b5e257d569688ac6$var$LegacySSRProvider(props) {\n    let cur = (0, react__WEBPACK_IMPORTED_MODULE_0__.useContext)($b5e257d569688ac6$var$SSRContext);\n    let counter = $b5e257d569688ac6$var$useCounter(cur === $b5e257d569688ac6$var$defaultContext);\n    let [isSSR, setIsSSR] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)(true);\n    let value = (0, react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>({\n            // If this is the first SSRProvider, start with an empty string prefix, otherwise\n            // append and increment the counter.\n            prefix: cur === $b5e257d569688ac6$var$defaultContext ? \"\" : \"\".concat(cur.prefix, \"-\").concat(counter),\n            current: 0\n        }), [\n        cur,\n        counter\n    ]);\n    // If on the client, and the component was initially server rendered,\n    // then schedule a layout effect to update the component after hydration.\n    if (typeof document !== \"undefined\") // because the condition never changes after mounting.\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    (0, react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)(()=>{\n        setIsSSR(false);\n    }, []);\n    return /*#__PURE__*/ (0, react__WEBPACK_IMPORTED_MODULE_0__).createElement($b5e257d569688ac6$var$SSRContext.Provider, {\n        value: value\n    }, /*#__PURE__*/ (0, react__WEBPACK_IMPORTED_MODULE_0__).createElement($b5e257d569688ac6$var$IsSSRContext.Provider, {\n        value: isSSR\n    }, props.children));\n}\nlet $b5e257d569688ac6$var$warnedAboutSSRProvider = false;\nfunction $b5e257d569688ac6$export$9f8ac96af4b1b2ae(props) {\n    if (typeof (0, react__WEBPACK_IMPORTED_MODULE_0__)[\"useId\"] === \"function\") {\n        if ( true && !$b5e257d569688ac6$var$warnedAboutSSRProvider) {\n            console.warn(\"In React 18, SSRProvider is not necessary and is a noop. You can remove it from your app.\");\n            $b5e257d569688ac6$var$warnedAboutSSRProvider = true;\n        }\n        return /*#__PURE__*/ (0, react__WEBPACK_IMPORTED_MODULE_0__).createElement((0, react__WEBPACK_IMPORTED_MODULE_0__).Fragment, null, props.children);\n    }\n    return /*#__PURE__*/ (0, react__WEBPACK_IMPORTED_MODULE_0__).createElement($b5e257d569688ac6$var$LegacySSRProvider, props);\n}\nlet $b5e257d569688ac6$var$canUseDOM = Boolean( true && window.document && window.document.createElement);\nlet $b5e257d569688ac6$var$componentIds = new WeakMap();\nfunction $b5e257d569688ac6$var$useCounter() {\n    let isDisabled = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;\n    let ctx = (0, react__WEBPACK_IMPORTED_MODULE_0__.useContext)($b5e257d569688ac6$var$SSRContext);\n    let ref = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    // eslint-disable-next-line rulesdir/pure-render\n    if (ref.current === null && !isDisabled) {\n        var _React___SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED_ReactCurrentOwner, _React___SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n        // In strict mode, React renders components twice, and the ref will be reset to null on the second render.\n        // This means our id counter will be incremented twice instead of once. This is a problem because on the\n        // server, components are only rendered once and so ids generated on the server won't match the client.\n        // In React 18, useId was introduced to solve this, but it is not available in older versions. So to solve this\n        // we need to use some React internals to access the underlying Fiber instance, which is stable between renders.\n        // This is exposed as ReactCurrentOwner in development, which is all we need since StrictMode only runs in development.\n        // To ensure that we only increment the global counter once, we store the starting id for this component in\n        // a weak map associated with the Fiber. On the second render, we reset the global counter to this value.\n        // Since React runs the second render immediately after the first, this is safe.\n        // @ts-ignore\n        let currentOwner = (_React___SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = (0, react__WEBPACK_IMPORTED_MODULE_0__).__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED) === null || _React___SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED === void 0 ? void 0 : (_React___SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED_ReactCurrentOwner = _React___SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner) === null || _React___SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED_ReactCurrentOwner === void 0 ? void 0 : _React___SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED_ReactCurrentOwner.current;\n        if (currentOwner) {\n            let prevComponentValue = $b5e257d569688ac6$var$componentIds.get(currentOwner);\n            if (prevComponentValue == null) $b5e257d569688ac6$var$componentIds.set(currentOwner, {\n                id: ctx.current,\n                state: currentOwner.memoizedState\n            });\n            else if (currentOwner.memoizedState !== prevComponentValue.state) {\n                // On the second render, the memoizedState gets reset by React.\n                // Reset the counter, and remove from the weak map so we don't\n                // do this for subsequent useId calls.\n                ctx.current = prevComponentValue.id;\n                $b5e257d569688ac6$var$componentIds.delete(currentOwner);\n            }\n        }\n        // eslint-disable-next-line rulesdir/pure-render\n        ref.current = ++ctx.current;\n    }\n    // eslint-disable-next-line rulesdir/pure-render\n    return ref.current;\n}\nfunction $b5e257d569688ac6$var$useLegacySSRSafeId(defaultId) {\n    let ctx = (0, react__WEBPACK_IMPORTED_MODULE_0__.useContext)($b5e257d569688ac6$var$SSRContext);\n    // If we are rendering in a non-DOM environment, and there's no SSRProvider,\n    // provide a warning to hint to the developer to add one.\n    if (ctx === $b5e257d569688ac6$var$defaultContext && !$b5e257d569688ac6$var$canUseDOM && \"development\" !== \"production\") console.warn(\"When server rendering, you must wrap your application in an <SSRProvider> to ensure consistent ids are generated between the client and server.\");\n    let counter = $b5e257d569688ac6$var$useCounter(!!defaultId);\n    let prefix = ctx === $b5e257d569688ac6$var$defaultContext && \"development\" === \"test\" ? 0 : \"react-aria\".concat(ctx.prefix);\n    return defaultId || \"\".concat(prefix, \"-\").concat(counter);\n}\nfunction $b5e257d569688ac6$var$useModernSSRSafeId(defaultId) {\n    _s();\n    let id = (0, react__WEBPACK_IMPORTED_MODULE_0__).useId();\n    let [didSSR] = (0, react__WEBPACK_IMPORTED_MODULE_0__.useState)($b5e257d569688ac6$export$535bd6ca7f90a273());\n    let prefix = didSSR || \"development\" === \"test\" ? \"react-aria\" : \"react-aria\".concat($b5e257d569688ac6$var$defaultContext.prefix);\n    return defaultId || \"\".concat(prefix, \"-\").concat(id);\n}\n_s($b5e257d569688ac6$var$useModernSSRSafeId, \"WhsuKpSQZEWeFcB7gWlfDRQktoQ=\");\nconst $b5e257d569688ac6$export$619500959fc48b26 = typeof (0, react__WEBPACK_IMPORTED_MODULE_0__)[\"useId\"] === \"function\" ? $b5e257d569688ac6$var$useModernSSRSafeId : $b5e257d569688ac6$var$useLegacySSRSafeId;\nfunction $b5e257d569688ac6$var$getSnapshot() {\n    return false;\n}\nfunction $b5e257d569688ac6$var$getServerSnapshot() {\n    return true;\n}\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nfunction $b5e257d569688ac6$var$subscribe(onStoreChange) {\n    // noop\n    return ()=>{};\n}\nfunction $b5e257d569688ac6$export$535bd6ca7f90a273() {\n    // In React 18, we can use useSyncExternalStore to detect if we're server rendering or hydrating.\n    if (typeof (0, react__WEBPACK_IMPORTED_MODULE_0__)[\"useSyncExternalStore\"] === \"function\") return (0, react__WEBPACK_IMPORTED_MODULE_0__)[\"useSyncExternalStore\"]($b5e257d569688ac6$var$subscribe, $b5e257d569688ac6$var$getSnapshot, $b5e257d569688ac6$var$getServerSnapshot);\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    return (0, react__WEBPACK_IMPORTED_MODULE_0__.useContext)($b5e257d569688ac6$var$IsSSRContext);\n}\n //# sourceMappingURL=SSRProvider.module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQHJlYWN0LWFyaWEvc3NyL2Rpc3QvU1NSUHJvdmlkZXIubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQWdNO0FBRWhNOzs7Ozs7Ozs7O0NBVUMsR0FBRywwRkFBMEY7QUFDOUYsMkRBQTJEO0FBQzNELHdEQUF3RDtBQUV4RCxpRkFBaUY7QUFDakYsa0ZBQWtGO0FBQ2xGLCtFQUErRTtBQUMvRSwrRUFBK0U7QUFDL0UsMkRBQTJEO0FBQzNELE1BQU1XLHVDQUF1QztJQUN6Q0MsUUFBUUMsT0FBT0MsS0FBS0MsS0FBSyxDQUFDRCxLQUFLRSxNQUFNLEtBQUs7SUFDMUNDLFNBQVM7QUFDYjtBQUNBLE1BQU1DLG1DQUFpRCxXQUFILEdBQUksSUFBR2xCLGtDQUFXLEVBQUdtQixhQUFhLENBQUNSO0FBQ3ZGLE1BQU1TLHFDQUFtRCxXQUFILEdBQUksSUFBR3BCLGtDQUFXLEVBQUdtQixhQUFhLENBQUM7QUFDekYsbUNBQW1DO0FBQ25DLFNBQVNFLHdDQUF3Q0MsS0FBSztJQUNsRCxJQUFJQyxNQUFNLENBQUMsR0FBR3JCLDZDQUFnQixFQUFHZ0I7SUFDakMsSUFBSU0sVUFBVUMsaUNBQWlDRixRQUFRWjtJQUN2RCxJQUFJLENBQUNlLE9BQU9DLFNBQVMsR0FBRyxDQUFDLEdBQUd2QiwyQ0FBYyxFQUFHO0lBQzdDLElBQUl3QixRQUFRLENBQUMsR0FBR3RCLDBDQUFhLEVBQUcsSUFBSztZQUM3QixpRkFBaUY7WUFDakYsb0NBQW9DO1lBQ3BDTSxRQUFRVyxRQUFRWix1Q0FBdUMsS0FBSyxHQUFpQmEsT0FBZEQsSUFBSVgsTUFBTSxFQUFDLEtBQVcsT0FBUlk7WUFDN0VQLFNBQVM7UUFDYixJQUFJO1FBQ0pNO1FBQ0FDO0tBQ0g7SUFDRCxxRUFBcUU7SUFDckUseUVBQXlFO0lBQ3pFLElBQUksT0FBT0ssYUFBYSxhQUd4QixzREFGc0Q7SUFDdEQsc0RBQXNEO0lBQ3JELElBQUdyQixrREFB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aWEvc3NyL2Rpc3QvU1NSUHJvdmlkZXIubWpzPzVhOTciXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICQ2NzBnQiRyZWFjdCwge3VzZUNvbnRleHQgYXMgJDY3MGdCJHVzZUNvbnRleHQsIHVzZVN0YXRlIGFzICQ2NzBnQiR1c2VTdGF0ZSwgdXNlTWVtbyBhcyAkNjcwZ0IkdXNlTWVtbywgdXNlTGF5b3V0RWZmZWN0IGFzICQ2NzBnQiR1c2VMYXlvdXRFZmZlY3QsIHVzZVJlZiBhcyAkNjcwZ0IkdXNlUmVmfSBmcm9tIFwicmVhY3RcIjtcblxuLypcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIC8vIFdlIG11c3QgYXZvaWQgYSBjaXJjdWxhciBkZXBlbmRlbmN5IHdpdGggQHJlYWN0LWFyaWEvdXRpbHMsIGFuZCB0aGlzIHVzZUxheW91dEVmZmVjdCBpc1xuLy8gZ3VhcmRlZCBieSBhIGNoZWNrIHRoYXQgaXQgb25seSBydW5zIG9uIHRoZSBjbGllbnQgc2lkZS5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBydWxlc2Rpci91c2VMYXlvdXRFZmZlY3RSdWxlXG5cbi8vIERlZmF1bHQgY29udGV4dCB2YWx1ZSB0byB1c2UgaW4gY2FzZSB0aGVyZSBpcyBubyBTU1JQcm92aWRlci4gVGhpcyBpcyBmaW5lIGZvclxuLy8gY2xpZW50LW9ubHkgYXBwcy4gSW4gb3JkZXIgdG8gc3VwcG9ydCBtdWx0aXBsZSBjb3BpZXMgb2YgUmVhY3QgQXJpYSBwb3RlbnRpYWxseVxuLy8gYmVpbmcgb24gdGhlIHBhZ2UgYXQgb25jZSwgdGhlIHByZWZpeCBpcyBzZXQgdG8gYSByYW5kb20gbnVtYmVyLiBTU1JQcm92aWRlclxuLy8gd2lsbCByZXNldCB0aGlzIHRvIHplcm8gZm9yIGNvbnNpc3RlbmN5IGJldHdlZW4gc2VydmVyIGFuZCBjbGllbnQsIHNvIGluIHRoZVxuLy8gU1NSIGNhc2UgbXVsdGlwbGUgY29waWVzIG9mIFJlYWN0IEFyaWEgaXMgbm90IHN1cHBvcnRlZC5cbmNvbnN0ICRiNWUyNTdkNTY5Njg4YWM2JHZhciRkZWZhdWx0Q29udGV4dCA9IHtcbiAgICBwcmVmaXg6IFN0cmluZyhNYXRoLnJvdW5kKE1hdGgucmFuZG9tKCkgKiAxMDAwMDAwMDAwMCkpLFxuICAgIGN1cnJlbnQ6IDBcbn07XG5jb25zdCAkYjVlMjU3ZDU2OTY4OGFjNiR2YXIkU1NSQ29udGV4dCA9IC8qI19fUFVSRV9fKi8gKDAsICQ2NzBnQiRyZWFjdCkuY3JlYXRlQ29udGV4dCgkYjVlMjU3ZDU2OTY4OGFjNiR2YXIkZGVmYXVsdENvbnRleHQpO1xuY29uc3QgJGI1ZTI1N2Q1Njk2ODhhYzYkdmFyJElzU1NSQ29udGV4dCA9IC8qI19fUFVSRV9fKi8gKDAsICQ2NzBnQiRyZWFjdCkuY3JlYXRlQ29udGV4dChmYWxzZSk7XG4vLyBUaGlzIGlzIG9ubHkgdXNlZCBpbiBSZWFjdCA8IDE4LlxuZnVuY3Rpb24gJGI1ZTI1N2Q1Njk2ODhhYzYkdmFyJExlZ2FjeVNTUlByb3ZpZGVyKHByb3BzKSB7XG4gICAgbGV0IGN1ciA9ICgwLCAkNjcwZ0IkdXNlQ29udGV4dCkoJGI1ZTI1N2Q1Njk2ODhhYzYkdmFyJFNTUkNvbnRleHQpO1xuICAgIGxldCBjb3VudGVyID0gJGI1ZTI1N2Q1Njk2ODhhYzYkdmFyJHVzZUNvdW50ZXIoY3VyID09PSAkYjVlMjU3ZDU2OTY4OGFjNiR2YXIkZGVmYXVsdENvbnRleHQpO1xuICAgIGxldCBbaXNTU1IsIHNldElzU1NSXSA9ICgwLCAkNjcwZ0IkdXNlU3RhdGUpKHRydWUpO1xuICAgIGxldCB2YWx1ZSA9ICgwLCAkNjcwZ0IkdXNlTWVtbykoKCk9Pih7XG4gICAgICAgICAgICAvLyBJZiB0aGlzIGlzIHRoZSBmaXJzdCBTU1JQcm92aWRlciwgc3RhcnQgd2l0aCBhbiBlbXB0eSBzdHJpbmcgcHJlZml4LCBvdGhlcndpc2VcbiAgICAgICAgICAgIC8vIGFwcGVuZCBhbmQgaW5jcmVtZW50IHRoZSBjb3VudGVyLlxuICAgICAgICAgICAgcHJlZml4OiBjdXIgPT09ICRiNWUyNTdkNTY5Njg4YWM2JHZhciRkZWZhdWx0Q29udGV4dCA/ICcnIDogYCR7Y3VyLnByZWZpeH0tJHtjb3VudGVyfWAsXG4gICAgICAgICAgICBjdXJyZW50OiAwXG4gICAgICAgIH0pLCBbXG4gICAgICAgIGN1cixcbiAgICAgICAgY291bnRlclxuICAgIF0pO1xuICAgIC8vIElmIG9uIHRoZSBjbGllbnQsIGFuZCB0aGUgY29tcG9uZW50IHdhcyBpbml0aWFsbHkgc2VydmVyIHJlbmRlcmVkLFxuICAgIC8vIHRoZW4gc2NoZWR1bGUgYSBsYXlvdXQgZWZmZWN0IHRvIHVwZGF0ZSB0aGUgY29tcG9uZW50IGFmdGVyIGh5ZHJhdGlvbi5cbiAgICBpZiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJykgLy8gVGhpcyBpZiBzdGF0ZW1lbnQgdGVjaG5pY2FsbHkgYnJlYWtzIHRoZSBydWxlcyBvZiBob29rcywgYnV0IGlzIHNhZmVcbiAgICAvLyBiZWNhdXNlIHRoZSBjb25kaXRpb24gbmV2ZXIgY2hhbmdlcyBhZnRlciBtb3VudGluZy5cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvcnVsZXMtb2YtaG9va3NcbiAgICAoMCwgJDY3MGdCJHVzZUxheW91dEVmZmVjdCkoKCk9PntcbiAgICAgICAgc2V0SXNTU1IoZmFsc2UpO1xuICAgIH0sIFtdKTtcbiAgICByZXR1cm4gLyojX19QVVJFX18qLyAoMCwgJDY3MGdCJHJlYWN0KS5jcmVhdGVFbGVtZW50KCRiNWUyNTdkNTY5Njg4YWM2JHZhciRTU1JDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgIH0sIC8qI19fUFVSRV9fKi8gKDAsICQ2NzBnQiRyZWFjdCkuY3JlYXRlRWxlbWVudCgkYjVlMjU3ZDU2OTY4OGFjNiR2YXIkSXNTU1JDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgICAgIHZhbHVlOiBpc1NTUlxuICAgIH0sIHByb3BzLmNoaWxkcmVuKSk7XG59XG5sZXQgJGI1ZTI1N2Q1Njk2ODhhYzYkdmFyJHdhcm5lZEFib3V0U1NSUHJvdmlkZXIgPSBmYWxzZTtcbmZ1bmN0aW9uICRiNWUyNTdkNTY5Njg4YWM2JGV4cG9ydCQ5ZjhhYzk2YWY0YjFiMmFlKHByb3BzKSB7XG4gICAgaWYgKHR5cGVvZiAoMCwgJDY3MGdCJHJlYWN0KVsndXNlSWQnXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICd0ZXN0JyAmJiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmICEkYjVlMjU3ZDU2OTY4OGFjNiR2YXIkd2FybmVkQWJvdXRTU1JQcm92aWRlcikge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdJbiBSZWFjdCAxOCwgU1NSUHJvdmlkZXIgaXMgbm90IG5lY2Vzc2FyeSBhbmQgaXMgYSBub29wLiBZb3UgY2FuIHJlbW92ZSBpdCBmcm9tIHlvdXIgYXBwLicpO1xuICAgICAgICAgICAgJGI1ZTI1N2Q1Njk2ODhhYzYkdmFyJHdhcm5lZEFib3V0U1NSUHJvdmlkZXIgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovICgwLCAkNjcwZ0IkcmVhY3QpLmNyZWF0ZUVsZW1lbnQoKDAsICQ2NzBnQiRyZWFjdCkuRnJhZ21lbnQsIG51bGwsIHByb3BzLmNoaWxkcmVuKTtcbiAgICB9XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi8gKDAsICQ2NzBnQiRyZWFjdCkuY3JlYXRlRWxlbWVudCgkYjVlMjU3ZDU2OTY4OGFjNiR2YXIkTGVnYWN5U1NSUHJvdmlkZXIsIHByb3BzKTtcbn1cbmxldCAkYjVlMjU3ZDU2OTY4OGFjNiR2YXIkY2FuVXNlRE9NID0gQm9vbGVhbih0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuZG9jdW1lbnQgJiYgd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQpO1xubGV0ICRiNWUyNTdkNTY5Njg4YWM2JHZhciRjb21wb25lbnRJZHMgPSBuZXcgV2Vha01hcCgpO1xuZnVuY3Rpb24gJGI1ZTI1N2Q1Njk2ODhhYzYkdmFyJHVzZUNvdW50ZXIoaXNEaXNhYmxlZCA9IGZhbHNlKSB7XG4gICAgbGV0IGN0eCA9ICgwLCAkNjcwZ0IkdXNlQ29udGV4dCkoJGI1ZTI1N2Q1Njk2ODhhYzYkdmFyJFNTUkNvbnRleHQpO1xuICAgIGxldCByZWYgPSAoMCwgJDY3MGdCJHVzZVJlZikobnVsbCk7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJ1bGVzZGlyL3B1cmUtcmVuZGVyXG4gICAgaWYgKHJlZi5jdXJyZW50ID09PSBudWxsICYmICFpc0Rpc2FibGVkKSB7XG4gICAgICAgIHZhciBfUmVhY3RfX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRURfUmVhY3RDdXJyZW50T3duZXIsIF9SZWFjdF9fX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRDtcbiAgICAgICAgLy8gSW4gc3RyaWN0IG1vZGUsIFJlYWN0IHJlbmRlcnMgY29tcG9uZW50cyB0d2ljZSwgYW5kIHRoZSByZWYgd2lsbCBiZSByZXNldCB0byBudWxsIG9uIHRoZSBzZWNvbmQgcmVuZGVyLlxuICAgICAgICAvLyBUaGlzIG1lYW5zIG91ciBpZCBjb3VudGVyIHdpbGwgYmUgaW5jcmVtZW50ZWQgdHdpY2UgaW5zdGVhZCBvZiBvbmNlLiBUaGlzIGlzIGEgcHJvYmxlbSBiZWNhdXNlIG9uIHRoZVxuICAgICAgICAvLyBzZXJ2ZXIsIGNvbXBvbmVudHMgYXJlIG9ubHkgcmVuZGVyZWQgb25jZSBhbmQgc28gaWRzIGdlbmVyYXRlZCBvbiB0aGUgc2VydmVyIHdvbid0IG1hdGNoIHRoZSBjbGllbnQuXG4gICAgICAgIC8vIEluIFJlYWN0IDE4LCB1c2VJZCB3YXMgaW50cm9kdWNlZCB0byBzb2x2ZSB0aGlzLCBidXQgaXQgaXMgbm90IGF2YWlsYWJsZSBpbiBvbGRlciB2ZXJzaW9ucy4gU28gdG8gc29sdmUgdGhpc1xuICAgICAgICAvLyB3ZSBuZWVkIHRvIHVzZSBzb21lIFJlYWN0IGludGVybmFscyB0byBhY2Nlc3MgdGhlIHVuZGVybHlpbmcgRmliZXIgaW5zdGFuY2UsIHdoaWNoIGlzIHN0YWJsZSBiZXR3ZWVuIHJlbmRlcnMuXG4gICAgICAgIC8vIFRoaXMgaXMgZXhwb3NlZCBhcyBSZWFjdEN1cnJlbnRPd25lciBpbiBkZXZlbG9wbWVudCwgd2hpY2ggaXMgYWxsIHdlIG5lZWQgc2luY2UgU3RyaWN0TW9kZSBvbmx5IHJ1bnMgaW4gZGV2ZWxvcG1lbnQuXG4gICAgICAgIC8vIFRvIGVuc3VyZSB0aGF0IHdlIG9ubHkgaW5jcmVtZW50IHRoZSBnbG9iYWwgY291bnRlciBvbmNlLCB3ZSBzdG9yZSB0aGUgc3RhcnRpbmcgaWQgZm9yIHRoaXMgY29tcG9uZW50IGluXG4gICAgICAgIC8vIGEgd2VhayBtYXAgYXNzb2NpYXRlZCB3aXRoIHRoZSBGaWJlci4gT24gdGhlIHNlY29uZCByZW5kZXIsIHdlIHJlc2V0IHRoZSBnbG9iYWwgY291bnRlciB0byB0aGlzIHZhbHVlLlxuICAgICAgICAvLyBTaW5jZSBSZWFjdCBydW5zIHRoZSBzZWNvbmQgcmVuZGVyIGltbWVkaWF0ZWx5IGFmdGVyIHRoZSBmaXJzdCwgdGhpcyBpcyBzYWZlLlxuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIGxldCBjdXJyZW50T3duZXIgPSAoX1JlYWN0X19fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEID0gKDAsICQ2NzBnQiRyZWFjdCkuX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQpID09PSBudWxsIHx8IF9SZWFjdF9fX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRCA9PT0gdm9pZCAwID8gdm9pZCAwIDogKF9SZWFjdF9fX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRF9SZWFjdEN1cnJlbnRPd25lciA9IF9SZWFjdF9fX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRC5SZWFjdEN1cnJlbnRPd25lcikgPT09IG51bGwgfHwgX1JlYWN0X19fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEX1JlYWN0Q3VycmVudE93bmVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfUmVhY3RfX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRURfUmVhY3RDdXJyZW50T3duZXIuY3VycmVudDtcbiAgICAgICAgaWYgKGN1cnJlbnRPd25lcikge1xuICAgICAgICAgICAgbGV0IHByZXZDb21wb25lbnRWYWx1ZSA9ICRiNWUyNTdkNTY5Njg4YWM2JHZhciRjb21wb25lbnRJZHMuZ2V0KGN1cnJlbnRPd25lcik7XG4gICAgICAgICAgICBpZiAocHJldkNvbXBvbmVudFZhbHVlID09IG51bGwpIC8vIE9uIHRoZSBmaXJzdCByZW5kZXIsIGFuZCBmaXJzdCBjYWxsIHRvIHVzZUlkLCBzdG9yZSB0aGUgaWQgYW5kIHN0YXRlIGluIG91ciB3ZWFrIG1hcC5cbiAgICAgICAgICAgICRiNWUyNTdkNTY5Njg4YWM2JHZhciRjb21wb25lbnRJZHMuc2V0KGN1cnJlbnRPd25lciwge1xuICAgICAgICAgICAgICAgIGlkOiBjdHguY3VycmVudCxcbiAgICAgICAgICAgICAgICBzdGF0ZTogY3VycmVudE93bmVyLm1lbW9pemVkU3RhdGVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZWxzZSBpZiAoY3VycmVudE93bmVyLm1lbW9pemVkU3RhdGUgIT09IHByZXZDb21wb25lbnRWYWx1ZS5zdGF0ZSkge1xuICAgICAgICAgICAgICAgIC8vIE9uIHRoZSBzZWNvbmQgcmVuZGVyLCB0aGUgbWVtb2l6ZWRTdGF0ZSBnZXRzIHJlc2V0IGJ5IFJlYWN0LlxuICAgICAgICAgICAgICAgIC8vIFJlc2V0IHRoZSBjb3VudGVyLCBhbmQgcmVtb3ZlIGZyb20gdGhlIHdlYWsgbWFwIHNvIHdlIGRvbid0XG4gICAgICAgICAgICAgICAgLy8gZG8gdGhpcyBmb3Igc3Vic2VxdWVudCB1c2VJZCBjYWxscy5cbiAgICAgICAgICAgICAgICBjdHguY3VycmVudCA9IHByZXZDb21wb25lbnRWYWx1ZS5pZDtcbiAgICAgICAgICAgICAgICAkYjVlMjU3ZDU2OTY4OGFjNiR2YXIkY29tcG9uZW50SWRzLmRlbGV0ZShjdXJyZW50T3duZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBydWxlc2Rpci9wdXJlLXJlbmRlclxuICAgICAgICByZWYuY3VycmVudCA9ICsrY3R4LmN1cnJlbnQ7XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBydWxlc2Rpci9wdXJlLXJlbmRlclxuICAgIHJldHVybiByZWYuY3VycmVudDtcbn1cbmZ1bmN0aW9uICRiNWUyNTdkNTY5Njg4YWM2JHZhciR1c2VMZWdhY3lTU1JTYWZlSWQoZGVmYXVsdElkKSB7XG4gICAgbGV0IGN0eCA9ICgwLCAkNjcwZ0IkdXNlQ29udGV4dCkoJGI1ZTI1N2Q1Njk2ODhhYzYkdmFyJFNTUkNvbnRleHQpO1xuICAgIC8vIElmIHdlIGFyZSByZW5kZXJpbmcgaW4gYSBub24tRE9NIGVudmlyb25tZW50LCBhbmQgdGhlcmUncyBubyBTU1JQcm92aWRlcixcbiAgICAvLyBwcm92aWRlIGEgd2FybmluZyB0byBoaW50IHRvIHRoZSBkZXZlbG9wZXIgdG8gYWRkIG9uZS5cbiAgICBpZiAoY3R4ID09PSAkYjVlMjU3ZDU2OTY4OGFjNiR2YXIkZGVmYXVsdENvbnRleHQgJiYgISRiNWUyNTdkNTY5Njg4YWM2JHZhciRjYW5Vc2VET00gJiYgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgY29uc29sZS53YXJuKCdXaGVuIHNlcnZlciByZW5kZXJpbmcsIHlvdSBtdXN0IHdyYXAgeW91ciBhcHBsaWNhdGlvbiBpbiBhbiA8U1NSUHJvdmlkZXI+IHRvIGVuc3VyZSBjb25zaXN0ZW50IGlkcyBhcmUgZ2VuZXJhdGVkIGJldHdlZW4gdGhlIGNsaWVudCBhbmQgc2VydmVyLicpO1xuICAgIGxldCBjb3VudGVyID0gJGI1ZTI1N2Q1Njk2ODhhYzYkdmFyJHVzZUNvdW50ZXIoISFkZWZhdWx0SWQpO1xuICAgIGxldCBwcmVmaXggPSBjdHggPT09ICRiNWUyNTdkNTY5Njg4YWM2JHZhciRkZWZhdWx0Q29udGV4dCAmJiBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Rlc3QnID8gJ3JlYWN0LWFyaWEnIDogYHJlYWN0LWFyaWEke2N0eC5wcmVmaXh9YDtcbiAgICByZXR1cm4gZGVmYXVsdElkIHx8IGAke3ByZWZpeH0tJHtjb3VudGVyfWA7XG59XG5mdW5jdGlvbiAkYjVlMjU3ZDU2OTY4OGFjNiR2YXIkdXNlTW9kZXJuU1NSU2FmZUlkKGRlZmF1bHRJZCkge1xuICAgIGxldCBpZCA9ICgwLCAkNjcwZ0IkcmVhY3QpLnVzZUlkKCk7XG4gICAgbGV0IFtkaWRTU1JdID0gKDAsICQ2NzBnQiR1c2VTdGF0ZSkoJGI1ZTI1N2Q1Njk2ODhhYzYkZXhwb3J0JDUzNWJkNmNhN2Y5MGEyNzMoKSk7XG4gICAgbGV0IHByZWZpeCA9IGRpZFNTUiB8fCBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Rlc3QnID8gJ3JlYWN0LWFyaWEnIDogYHJlYWN0LWFyaWEkeyRiNWUyNTdkNTY5Njg4YWM2JHZhciRkZWZhdWx0Q29udGV4dC5wcmVmaXh9YDtcbiAgICByZXR1cm4gZGVmYXVsdElkIHx8IGAke3ByZWZpeH0tJHtpZH1gO1xufVxuY29uc3QgJGI1ZTI1N2Q1Njk2ODhhYzYkZXhwb3J0JDYxOTUwMDk1OWZjNDhiMjYgPSB0eXBlb2YgKDAsICQ2NzBnQiRyZWFjdClbJ3VzZUlkJ10gPT09ICdmdW5jdGlvbicgPyAkYjVlMjU3ZDU2OTY4OGFjNiR2YXIkdXNlTW9kZXJuU1NSU2FmZUlkIDogJGI1ZTI1N2Q1Njk2ODhhYzYkdmFyJHVzZUxlZ2FjeVNTUlNhZmVJZDtcbmZ1bmN0aW9uICRiNWUyNTdkNTY5Njg4YWM2JHZhciRnZXRTbmFwc2hvdCgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiAkYjVlMjU3ZDU2OTY4OGFjNiR2YXIkZ2V0U2VydmVyU25hcHNob3QoKSB7XG4gICAgcmV0dXJuIHRydWU7XG59XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG5mdW5jdGlvbiAkYjVlMjU3ZDU2OTY4OGFjNiR2YXIkc3Vic2NyaWJlKG9uU3RvcmVDaGFuZ2UpIHtcbiAgICAvLyBub29wXG4gICAgcmV0dXJuICgpPT57fTtcbn1cbmZ1bmN0aW9uICRiNWUyNTdkNTY5Njg4YWM2JGV4cG9ydCQ1MzViZDZjYTdmOTBhMjczKCkge1xuICAgIC8vIEluIFJlYWN0IDE4LCB3ZSBjYW4gdXNlIHVzZVN5bmNFeHRlcm5hbFN0b3JlIHRvIGRldGVjdCBpZiB3ZSdyZSBzZXJ2ZXIgcmVuZGVyaW5nIG9yIGh5ZHJhdGluZy5cbiAgICBpZiAodHlwZW9mICgwLCAkNjcwZ0IkcmVhY3QpWyd1c2VTeW5jRXh0ZXJuYWxTdG9yZSddID09PSAnZnVuY3Rpb24nKSByZXR1cm4gKDAsICQ2NzBnQiRyZWFjdClbJ3VzZVN5bmNFeHRlcm5hbFN0b3JlJ10oJGI1ZTI1N2Q1Njk2ODhhYzYkdmFyJHN1YnNjcmliZSwgJGI1ZTI1N2Q1Njk2ODhhYzYkdmFyJGdldFNuYXBzaG90LCAkYjVlMjU3ZDU2OTY4OGFjNiR2YXIkZ2V0U2VydmVyU25hcHNob3QpO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9ydWxlcy1vZi1ob29rc1xuICAgIHJldHVybiAoMCwgJDY3MGdCJHVzZUNvbnRleHQpKCRiNWUyNTdkNTY5Njg4YWM2JHZhciRJc1NTUkNvbnRleHQpO1xufVxuXG5cbmV4cG9ydCB7JGI1ZTI1N2Q1Njk2ODhhYzYkZXhwb3J0JDlmOGFjOTZhZjRiMWIyYWUgYXMgU1NSUHJvdmlkZXIsICRiNWUyNTdkNTY5Njg4YWM2JGV4cG9ydCQ1MzViZDZjYTdmOTBhMjczIGFzIHVzZUlzU1NSLCAkYjVlMjU3ZDU2OTY4OGFjNiRleHBvcnQkNjE5NTAwOTU5ZmM0OGIyNiBhcyB1c2VTU1JTYWZlSWR9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U1NSUHJvdmlkZXIubW9kdWxlLmpzLm1hcFxuIl0sIm5hbWVzIjpbIiQ2NzBnQiRyZWFjdCIsInVzZUNvbnRleHQiLCIkNjcwZ0IkdXNlQ29udGV4dCIsInVzZVN0YXRlIiwiJDY3MGdCJHVzZVN0YXRlIiwidXNlTWVtbyIsIiQ2NzBnQiR1c2VNZW1vIiwidXNlTGF5b3V0RWZmZWN0IiwiJDY3MGdCJHVzZUxheW91dEVmZmVjdCIsInVzZVJlZiIsIiQ2NzBnQiR1c2VSZWYiLCIkYjVlMjU3ZDU2OTY4OGFjNiR2YXIkZGVmYXVsdENvbnRleHQiLCJwcmVmaXgiLCJTdHJpbmciLCJNYXRoIiwicm91bmQiLCJyYW5kb20iLCJjdXJyZW50IiwiJGI1ZTI1N2Q1Njk2ODhhYzYkdmFyJFNTUkNvbnRleHQiLCJjcmVhdGVDb250ZXh0IiwiJGI1ZTI1N2Q1Njk2ODhhYzYkdmFyJElzU1NSQ29udGV4dCIsIiRiNWUyNTdkNTY5Njg4YWM2JHZhciRMZWdhY3lTU1JQcm92aWRlciIsInByb3BzIiwiY3VyIiwiY291bnRlciIsIiRiNWUyNTdkNTY5Njg4YWM2JHZhciR1c2VDb3VudGVyIiwiaXNTU1IiLCJzZXRJc1NTUiIsInZhbHVlIiwiZG9jdW1lbnQiLCJjcmVhdGVFbGVtZW50IiwiUHJvdmlkZXIiLCJjaGlsZHJlbiIsIiRiNWUyNTdkNTY5Njg4YWM2JHZhciR3YXJuZWRBYm91dFNTUlByb3ZpZGVyIiwiJGI1ZTI1N2Q1Njk2ODhhYzYkZXhwb3J0JDlmOGFjOTZhZjRiMWIyYWUiLCJwcm9jZXNzIiwiY29uc29sZSIsIndhcm4iLCJGcmFnbWVudCIsIiRiNWUyNTdkNTY5Njg4YWM2JHZhciRjYW5Vc2VET00iLCJCb29sZWFuIiwid2luZG93IiwiJGI1ZTI1N2Q1Njk2ODhhYzYkdmFyJGNvbXBvbmVudElkcyIsIldlYWtNYXAiLCJpc0Rpc2FibGVkIiwiY3R4IiwicmVmIiwiX1JlYWN0X19fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEX1JlYWN0Q3VycmVudE93bmVyIiwiX1JlYWN0X19fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEIiwiY3VycmVudE93bmVyIiwiX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQiLCJSZWFjdEN1cnJlbnRPd25lciIsInByZXZDb21wb25lbnRWYWx1ZSIsImdldCIsInNldCIsImlkIiwic3RhdGUiLCJtZW1vaXplZFN0YXRlIiwiZGVsZXRlIiwiJGI1ZTI1N2Q1Njk2ODhhYzYkdmFyJHVzZUxlZ2FjeVNTUlNhZmVJZCIsImRlZmF1bHRJZCIsIiRiNWUyNTdkNTY5Njg4YWM2JHZhciR1c2VNb2Rlcm5TU1JTYWZlSWQiLCJ1c2VJZCIsImRpZFNTUiIsIiRiNWUyNTdkNTY5Njg4YWM2JGV4cG9ydCQ1MzViZDZjYTdmOTBhMjczIiwiJGI1ZTI1N2Q1Njk2ODhhYzYkZXhwb3J0JDYxOTUwMDk1OWZjNDhiMjYiLCIkYjVlMjU3ZDU2OTY4OGFjNiR2YXIkZ2V0U25hcHNob3QiLCIkYjVlMjU3ZDU2OTY4OGFjNiR2YXIkZ2V0U2VydmVyU25hcHNob3QiLCIkYjVlMjU3ZDU2OTY4OGFjNiR2YXIkc3Vic2NyaWJlIiwib25TdG9yZUNoYW5nZSIsIlNTUlByb3ZpZGVyIiwidXNlSXNTU1IiLCJ1c2VTU1JTYWZlSWQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../../../node_modules/@react-aria/ssr/dist/SSRProvider.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/../../../../node_modules/@react-aria/utils/dist/DOMFunctions.mjs":
/*!************************************************************************!*\
  !*** ../../../../node_modules/@react-aria/utils/dist/DOMFunctions.mjs ***!
  \************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getActiveElement: function() { return /* binding */ $d4ee10de306f2510$export$cd4e5573fbe2b576; },\n/* harmony export */   getEventTarget: function() { return /* binding */ $d4ee10de306f2510$export$e58f029f0fbfdb29; },\n/* harmony export */   nodeContains: function() { return /* binding */ $d4ee10de306f2510$export$4282f70798064fe0; }\n/* harmony export */ });\n/* harmony import */ var _domHelpers_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./domHelpers.mjs */ \"(app-pages-browser)/../../../../node_modules/@react-aria/utils/dist/domHelpers.mjs\");\n/* harmony import */ var _react_stately_flags__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @react-stately/flags */ \"(app-pages-browser)/../../../../node_modules/@react-stately/flags/dist/import.mjs\");\n\n\n// Source: https://github.com/microsoft/tabster/blob/a89fc5d7e332d48f68d03b1ca6e344489d1c3898/src/Shadowdomize/DOMFunctions.ts#L16\nfunction $d4ee10de306f2510$export$4282f70798064fe0(node, otherNode) {\n    if (!(0, _react_stately_flags__WEBPACK_IMPORTED_MODULE_0__.shadowDOM)()) return otherNode && node ? node.contains(otherNode) : false;\n    if (!node || !otherNode) return false;\n    let currentNode = otherNode;\n    while(currentNode !== null){\n        if (currentNode === node) return true;\n        if (currentNode.tagName === \"SLOT\" && currentNode.assignedSlot) currentNode = currentNode.assignedSlot.parentNode;\n        else if ((0, _domHelpers_mjs__WEBPACK_IMPORTED_MODULE_1__.isShadowRoot)(currentNode)) currentNode = currentNode.host;\n        else currentNode = currentNode.parentNode;\n    }\n    return false;\n}\nconst $d4ee10de306f2510$export$cd4e5573fbe2b576 = function() {\n    let doc = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : document;\n    var _activeElement_shadowRoot;\n    if (!(0, _react_stately_flags__WEBPACK_IMPORTED_MODULE_0__.shadowDOM)()) return doc.activeElement;\n    let activeElement = doc.activeElement;\n    while(activeElement && \"shadowRoot\" in activeElement && ((_activeElement_shadowRoot = activeElement.shadowRoot) === null || _activeElement_shadowRoot === void 0 ? void 0 : _activeElement_shadowRoot.activeElement))activeElement = activeElement.shadowRoot.activeElement;\n    return activeElement;\n};\nfunction $d4ee10de306f2510$export$e58f029f0fbfdb29(event) {\n    if ((0, _react_stately_flags__WEBPACK_IMPORTED_MODULE_0__.shadowDOM)() && event.target.shadowRoot) {\n        if (event.composedPath) return event.composedPath()[0];\n    }\n    return event.target;\n}\n //# sourceMappingURL=DOMFunctions.module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQHJlYWN0LWFyaWEvdXRpbHMvZGlzdC9ET01GdW5jdGlvbnMubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQTJGO0FBQ3hCO0FBRW5FLGtJQUFrSTtBQUdsSSxTQUFTSSwwQ0FBMENDLElBQUksRUFBRUMsU0FBUztJQUM5RCxJQUFJLENBQUMsQ0FBQyxHQUFHSCwyREFBZSxLQUFNLE9BQU9HLGFBQWFELE9BQU9BLEtBQUtFLFFBQVEsQ0FBQ0QsYUFBYTtJQUNwRixJQUFJLENBQUNELFFBQVEsQ0FBQ0MsV0FBVyxPQUFPO0lBQ2hDLElBQUlFLGNBQWNGO0lBQ2xCLE1BQU1FLGdCQUFnQixLQUFLO1FBQ3ZCLElBQUlBLGdCQUFnQkgsTUFBTSxPQUFPO1FBQ2pDLElBQUlHLFlBQVlDLE9BQU8sS0FBSyxVQUFVRCxZQUFZRSxZQUFZLEVBQzlERixjQUFjQSxZQUFZRSxZQUFZLENBQUNDLFVBQVU7YUFDNUMsSUFBSSxDQUFDLEdBQUdWLHlEQUF3QyxFQUFHTyxjQUN4REEsY0FBY0EsWUFBWUksSUFBSTthQUN6QkosY0FBY0EsWUFBWUcsVUFBVTtJQUM3QztJQUNBLE9BQU87QUFDWDtBQUNBLE1BQU1FLDRDQUE0QztRQUFDQyx1RUFBTUM7SUFDckQsSUFBSUM7SUFDSixJQUFJLENBQUMsQ0FBQyxHQUFHYiwyREFBZSxLQUFNLE9BQU9XLElBQUlHLGFBQWE7SUFDdEQsSUFBSUEsZ0JBQWdCSCxJQUFJRyxhQUFhO0lBQ3JDLE1BQU1BLGlCQUFpQixnQkFBZ0JBLGlCQUFrQixFQUFDRCw0QkFBNEJDLGNBQWNDLFVBQVUsTUFBTSxRQUFRRiw4QkFBOEIsS0FBSyxJQUFJLEtBQUssSUFBSUEsMEJBQTBCQyxhQUFhLEVBQUVBLGdCQUFnQkEsY0FBY0MsVUFBVSxDQUFDRCxhQUFhO0lBQzNRLE9BQU9BO0FBQ1g7QUFDQSxTQUFTRSwwQ0FBMENDLEtBQUs7SUFDcEQsSUFBSSxDQUFDLEdBQUdqQiwyREFBZSxPQUFRaUIsTUFBTUMsTUFBTSxDQUFDSCxVQUFVLEVBQUU7UUFDcEQsSUFBSUUsTUFBTUUsWUFBWSxFQUFFLE9BQU9GLE1BQU1FLFlBQVksRUFBRSxDQUFDLEVBQUU7SUFDMUQ7SUFDQSxPQUFPRixNQUFNQyxNQUFNO0FBQ3ZCO0FBRytMLENBQy9MLCtDQUErQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0ByZWFjdC1hcmlhL3V0aWxzL2Rpc3QvRE9NRnVuY3Rpb25zLm1qcz8yM2FhIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7aXNTaGFkb3dSb290IGFzICQ0MzFmYmQ4NmNhN2RjMjE2JGV4cG9ydCRhZjUxZjBmMDZjMGYzMjhhfSBmcm9tIFwiLi9kb21IZWxwZXJzLm1qc1wiO1xuaW1wb3J0IHtzaGFkb3dET00gYXMgJGxjU3U1JHNoYWRvd0RPTX0gZnJvbSBcIkByZWFjdC1zdGF0ZWx5L2ZsYWdzXCI7XG5cbi8vIFNvdXJjZTogaHR0cHM6Ly9naXRodWIuY29tL21pY3Jvc29mdC90YWJzdGVyL2Jsb2IvYTg5ZmM1ZDdlMzMyZDQ4ZjY4ZDAzYjFjYTZlMzQ0NDg5ZDFjMzg5OC9zcmMvU2hhZG93ZG9taXplL0RPTUZ1bmN0aW9ucy50cyNMMTZcblxuXG5mdW5jdGlvbiAkZDRlZTEwZGUzMDZmMjUxMCRleHBvcnQkNDI4MmY3MDc5ODA2NGZlMChub2RlLCBvdGhlck5vZGUpIHtcbiAgICBpZiAoISgwLCAkbGNTdTUkc2hhZG93RE9NKSgpKSByZXR1cm4gb3RoZXJOb2RlICYmIG5vZGUgPyBub2RlLmNvbnRhaW5zKG90aGVyTm9kZSkgOiBmYWxzZTtcbiAgICBpZiAoIW5vZGUgfHwgIW90aGVyTm9kZSkgcmV0dXJuIGZhbHNlO1xuICAgIGxldCBjdXJyZW50Tm9kZSA9IG90aGVyTm9kZTtcbiAgICB3aGlsZShjdXJyZW50Tm9kZSAhPT0gbnVsbCl7XG4gICAgICAgIGlmIChjdXJyZW50Tm9kZSA9PT0gbm9kZSkgcmV0dXJuIHRydWU7XG4gICAgICAgIGlmIChjdXJyZW50Tm9kZS50YWdOYW1lID09PSAnU0xPVCcgJiYgY3VycmVudE5vZGUuYXNzaWduZWRTbG90KSAvLyBFbGVtZW50IGlzIHNsb3R0ZWRcbiAgICAgICAgY3VycmVudE5vZGUgPSBjdXJyZW50Tm9kZS5hc3NpZ25lZFNsb3QucGFyZW50Tm9kZTtcbiAgICAgICAgZWxzZSBpZiAoKDAsICQ0MzFmYmQ4NmNhN2RjMjE2JGV4cG9ydCRhZjUxZjBmMDZjMGYzMjhhKShjdXJyZW50Tm9kZSkpIC8vIEVsZW1lbnQgaXMgaW4gc2hhZG93IHJvb3RcbiAgICAgICAgY3VycmVudE5vZGUgPSBjdXJyZW50Tm9kZS5ob3N0O1xuICAgICAgICBlbHNlIGN1cnJlbnROb2RlID0gY3VycmVudE5vZGUucGFyZW50Tm9kZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuY29uc3QgJGQ0ZWUxMGRlMzA2ZjI1MTAkZXhwb3J0JGNkNGU1NTczZmJlMmI1NzYgPSAoZG9jID0gZG9jdW1lbnQpPT57XG4gICAgdmFyIF9hY3RpdmVFbGVtZW50X3NoYWRvd1Jvb3Q7XG4gICAgaWYgKCEoMCwgJGxjU3U1JHNoYWRvd0RPTSkoKSkgcmV0dXJuIGRvYy5hY3RpdmVFbGVtZW50O1xuICAgIGxldCBhY3RpdmVFbGVtZW50ID0gZG9jLmFjdGl2ZUVsZW1lbnQ7XG4gICAgd2hpbGUoYWN0aXZlRWxlbWVudCAmJiAnc2hhZG93Um9vdCcgaW4gYWN0aXZlRWxlbWVudCAmJiAoKF9hY3RpdmVFbGVtZW50X3NoYWRvd1Jvb3QgPSBhY3RpdmVFbGVtZW50LnNoYWRvd1Jvb3QpID09PSBudWxsIHx8IF9hY3RpdmVFbGVtZW50X3NoYWRvd1Jvb3QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hY3RpdmVFbGVtZW50X3NoYWRvd1Jvb3QuYWN0aXZlRWxlbWVudCkpYWN0aXZlRWxlbWVudCA9IGFjdGl2ZUVsZW1lbnQuc2hhZG93Um9vdC5hY3RpdmVFbGVtZW50O1xuICAgIHJldHVybiBhY3RpdmVFbGVtZW50O1xufTtcbmZ1bmN0aW9uICRkNGVlMTBkZTMwNmYyNTEwJGV4cG9ydCRlNThmMDI5ZjBmYmZkYjI5KGV2ZW50KSB7XG4gICAgaWYgKCgwLCAkbGNTdTUkc2hhZG93RE9NKSgpICYmIGV2ZW50LnRhcmdldC5zaGFkb3dSb290KSB7XG4gICAgICAgIGlmIChldmVudC5jb21wb3NlZFBhdGgpIHJldHVybiBldmVudC5jb21wb3NlZFBhdGgoKVswXTtcbiAgICB9XG4gICAgcmV0dXJuIGV2ZW50LnRhcmdldDtcbn1cblxuXG5leHBvcnQgeyRkNGVlMTBkZTMwNmYyNTEwJGV4cG9ydCQ0MjgyZjcwNzk4MDY0ZmUwIGFzIG5vZGVDb250YWlucywgJGQ0ZWUxMGRlMzA2ZjI1MTAkZXhwb3J0JGNkNGU1NTczZmJlMmI1NzYgYXMgZ2V0QWN0aXZlRWxlbWVudCwgJGQ0ZWUxMGRlMzA2ZjI1MTAkZXhwb3J0JGU1OGYwMjlmMGZiZmRiMjkgYXMgZ2V0RXZlbnRUYXJnZXR9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RE9NRnVuY3Rpb25zLm1vZHVsZS5qcy5tYXBcbiJdLCJuYW1lcyI6WyJpc1NoYWRvd1Jvb3QiLCIkNDMxZmJkODZjYTdkYzIxNiRleHBvcnQkYWY1MWYwZjA2YzBmMzI4YSIsInNoYWRvd0RPTSIsIiRsY1N1NSRzaGFkb3dET00iLCIkZDRlZTEwZGUzMDZmMjUxMCRleHBvcnQkNDI4MmY3MDc5ODA2NGZlMCIsIm5vZGUiLCJvdGhlck5vZGUiLCJjb250YWlucyIsImN1cnJlbnROb2RlIiwidGFnTmFtZSIsImFzc2lnbmVkU2xvdCIsInBhcmVudE5vZGUiLCJob3N0IiwiJGQ0ZWUxMGRlMzA2ZjI1MTAkZXhwb3J0JGNkNGU1NTczZmJlMmI1NzYiLCJkb2MiLCJkb2N1bWVudCIsIl9hY3RpdmVFbGVtZW50X3NoYWRvd1Jvb3QiLCJhY3RpdmVFbGVtZW50Iiwic2hhZG93Um9vdCIsIiRkNGVlMTBkZTMwNmYyNTEwJGV4cG9ydCRlNThmMDI5ZjBmYmZkYjI5IiwiZXZlbnQiLCJ0YXJnZXQiLCJjb21wb3NlZFBhdGgiLCJub2RlQ29udGFpbnMiLCJnZXRBY3RpdmVFbGVtZW50IiwiZ2V0RXZlbnRUYXJnZXQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../../../node_modules/@react-aria/utils/dist/DOMFunctions.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/../../../../node_modules/@react-aria/utils/dist/domHelpers.mjs":
/*!**********************************************************************!*\
  !*** ../../../../node_modules/@react-aria/utils/dist/domHelpers.mjs ***!
  \**********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getOwnerDocument: function() { return /* binding */ $431fbd86ca7dc216$export$b204af158042fbac; },\n/* harmony export */   getOwnerWindow: function() { return /* binding */ $431fbd86ca7dc216$export$f21a1ffae260145a; },\n/* harmony export */   isShadowRoot: function() { return /* binding */ $431fbd86ca7dc216$export$af51f0f06c0f328a; }\n/* harmony export */ });\nconst $431fbd86ca7dc216$export$b204af158042fbac = (el)=>{\n    var _el_ownerDocument;\n    return (_el_ownerDocument = el === null || el === void 0 ? void 0 : el.ownerDocument) !== null && _el_ownerDocument !== void 0 ? _el_ownerDocument : document;\n};\nconst $431fbd86ca7dc216$export$f21a1ffae260145a = (el)=>{\n    if (el && \"window\" in el && el.window === el) return el;\n    const doc = $431fbd86ca7dc216$export$b204af158042fbac(el);\n    return doc.defaultView || window;\n};\n/**\n * Type guard that checks if a value is a Node. Verifies the presence and type of the nodeType property.\n */ function $431fbd86ca7dc216$var$isNode(value) {\n    return value !== null && typeof value === \"object\" && \"nodeType\" in value && typeof value.nodeType === \"number\";\n}\nfunction $431fbd86ca7dc216$export$af51f0f06c0f328a(node) {\n    return $431fbd86ca7dc216$var$isNode(node) && node.nodeType === Node.DOCUMENT_FRAGMENT_NODE && \"host\" in node;\n}\n //# sourceMappingURL=domHelpers.module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQHJlYWN0LWFyaWEvdXRpbHMvZGlzdC9kb21IZWxwZXJzLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQSxNQUFNQSw0Q0FBNEMsQ0FBQ0M7SUFDL0MsSUFBSUM7SUFDSixPQUFPLENBQUNBLG9CQUFvQkQsT0FBTyxRQUFRQSxPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUdFLGFBQWEsTUFBTSxRQUFRRCxzQkFBc0IsS0FBSyxJQUFJQSxvQkFBb0JFO0FBQ3pKO0FBQ0EsTUFBTUMsNENBQTRDLENBQUNKO0lBQy9DLElBQUlBLE1BQU0sWUFBWUEsTUFBTUEsR0FBR0ssTUFBTSxLQUFLTCxJQUFJLE9BQU9BO0lBQ3JELE1BQU1NLE1BQU1QLDBDQUEwQ0M7SUFDdEQsT0FBT00sSUFBSUMsV0FBVyxJQUFJRjtBQUM5QjtBQUNBOztDQUVDLEdBQUcsU0FBU0csNkJBQTZCQyxLQUFLO0lBQzNDLE9BQU9BLFVBQVUsUUFBUSxPQUFPQSxVQUFVLFlBQVksY0FBY0EsU0FBUyxPQUFPQSxNQUFNQyxRQUFRLEtBQUs7QUFDM0c7QUFDQSxTQUFTQywwQ0FBMENDLElBQUk7SUFDbkQsT0FBT0osNkJBQTZCSSxTQUFTQSxLQUFLRixRQUFRLEtBQUtHLEtBQUtDLHNCQUFzQixJQUFJLFVBQVVGO0FBQzVHO0FBRytMLENBQy9MLDZDQUE2QyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0ByZWFjdC1hcmlhL3V0aWxzL2Rpc3QvZG9tSGVscGVycy5tanM/OGQ5MyJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCAkNDMxZmJkODZjYTdkYzIxNiRleHBvcnQkYjIwNGFmMTU4MDQyZmJhYyA9IChlbCk9PntcbiAgICB2YXIgX2VsX293bmVyRG9jdW1lbnQ7XG4gICAgcmV0dXJuIChfZWxfb3duZXJEb2N1bWVudCA9IGVsID09PSBudWxsIHx8IGVsID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlbC5vd25lckRvY3VtZW50KSAhPT0gbnVsbCAmJiBfZWxfb3duZXJEb2N1bWVudCAhPT0gdm9pZCAwID8gX2VsX293bmVyRG9jdW1lbnQgOiBkb2N1bWVudDtcbn07XG5jb25zdCAkNDMxZmJkODZjYTdkYzIxNiRleHBvcnQkZjIxYTFmZmFlMjYwMTQ1YSA9IChlbCk9PntcbiAgICBpZiAoZWwgJiYgJ3dpbmRvdycgaW4gZWwgJiYgZWwud2luZG93ID09PSBlbCkgcmV0dXJuIGVsO1xuICAgIGNvbnN0IGRvYyA9ICQ0MzFmYmQ4NmNhN2RjMjE2JGV4cG9ydCRiMjA0YWYxNTgwNDJmYmFjKGVsKTtcbiAgICByZXR1cm4gZG9jLmRlZmF1bHRWaWV3IHx8IHdpbmRvdztcbn07XG4vKipcbiAqIFR5cGUgZ3VhcmQgdGhhdCBjaGVja3MgaWYgYSB2YWx1ZSBpcyBhIE5vZGUuIFZlcmlmaWVzIHRoZSBwcmVzZW5jZSBhbmQgdHlwZSBvZiB0aGUgbm9kZVR5cGUgcHJvcGVydHkuXG4gKi8gZnVuY3Rpb24gJDQzMWZiZDg2Y2E3ZGMyMTYkdmFyJGlzTm9kZSh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSAhPT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmICdub2RlVHlwZScgaW4gdmFsdWUgJiYgdHlwZW9mIHZhbHVlLm5vZGVUeXBlID09PSAnbnVtYmVyJztcbn1cbmZ1bmN0aW9uICQ0MzFmYmQ4NmNhN2RjMjE2JGV4cG9ydCRhZjUxZjBmMDZjMGYzMjhhKG5vZGUpIHtcbiAgICByZXR1cm4gJDQzMWZiZDg2Y2E3ZGMyMTYkdmFyJGlzTm9kZShub2RlKSAmJiBub2RlLm5vZGVUeXBlID09PSBOb2RlLkRPQ1VNRU5UX0ZSQUdNRU5UX05PREUgJiYgJ2hvc3QnIGluIG5vZGU7XG59XG5cblxuZXhwb3J0IHskNDMxZmJkODZjYTdkYzIxNiRleHBvcnQkYjIwNGFmMTU4MDQyZmJhYyBhcyBnZXRPd25lckRvY3VtZW50LCAkNDMxZmJkODZjYTdkYzIxNiRleHBvcnQkZjIxYTFmZmFlMjYwMTQ1YSBhcyBnZXRPd25lcldpbmRvdywgJDQzMWZiZDg2Y2E3ZGMyMTYkZXhwb3J0JGFmNTFmMGYwNmMwZjMyOGEgYXMgaXNTaGFkb3dSb290fTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRvbUhlbHBlcnMubW9kdWxlLmpzLm1hcFxuIl0sIm5hbWVzIjpbIiQ0MzFmYmQ4NmNhN2RjMjE2JGV4cG9ydCRiMjA0YWYxNTgwNDJmYmFjIiwiZWwiLCJfZWxfb3duZXJEb2N1bWVudCIsIm93bmVyRG9jdW1lbnQiLCJkb2N1bWVudCIsIiQ0MzFmYmQ4NmNhN2RjMjE2JGV4cG9ydCRmMjFhMWZmYWUyNjAxNDVhIiwid2luZG93IiwiZG9jIiwiZGVmYXVsdFZpZXciLCIkNDMxZmJkODZjYTdkYzIxNiR2YXIkaXNOb2RlIiwidmFsdWUiLCJub2RlVHlwZSIsIiQ0MzFmYmQ4NmNhN2RjMjE2JGV4cG9ydCRhZjUxZjBmMDZjMGYzMjhhIiwibm9kZSIsIk5vZGUiLCJET0NVTUVOVF9GUkFHTUVOVF9OT0RFIiwiZ2V0T3duZXJEb2N1bWVudCIsImdldE93bmVyV2luZG93IiwiaXNTaGFkb3dSb290Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../../../node_modules/@react-aria/utils/dist/domHelpers.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/../../../../node_modules/@react-aria/utils/dist/focusWithoutScrolling.mjs":
/*!*********************************************************************************!*\
  !*** ../../../../node_modules/@react-aria/utils/dist/focusWithoutScrolling.mjs ***!
  \*********************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   focusWithoutScrolling: function() { return /* binding */ $7215afc6de606d6b$export$de79e2c695e052f3; }\n/* harmony export */ });\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ function $7215afc6de606d6b$export$de79e2c695e052f3(element) {\n    if ($7215afc6de606d6b$var$supportsPreventScroll()) element.focus({\n        preventScroll: true\n    });\n    else {\n        let scrollableElements = $7215afc6de606d6b$var$getScrollableElements(element);\n        element.focus();\n        $7215afc6de606d6b$var$restoreScrollPosition(scrollableElements);\n    }\n}\nlet $7215afc6de606d6b$var$supportsPreventScrollCached = null;\nfunction $7215afc6de606d6b$var$supportsPreventScroll() {\n    if ($7215afc6de606d6b$var$supportsPreventScrollCached == null) {\n        $7215afc6de606d6b$var$supportsPreventScrollCached = false;\n        try {\n            let focusElem = document.createElement(\"div\");\n            focusElem.focus({\n                get preventScroll () {\n                    $7215afc6de606d6b$var$supportsPreventScrollCached = true;\n                    return true;\n                }\n            });\n        } catch (e) {\n        // Ignore\n        }\n    }\n    return $7215afc6de606d6b$var$supportsPreventScrollCached;\n}\nfunction $7215afc6de606d6b$var$getScrollableElements(element) {\n    let parent = element.parentNode;\n    let scrollableElements = [];\n    let rootScrollingElement = document.scrollingElement || document.documentElement;\n    while(parent instanceof HTMLElement && parent !== rootScrollingElement){\n        if (parent.offsetHeight < parent.scrollHeight || parent.offsetWidth < parent.scrollWidth) scrollableElements.push({\n            element: parent,\n            scrollTop: parent.scrollTop,\n            scrollLeft: parent.scrollLeft\n        });\n        parent = parent.parentNode;\n    }\n    if (rootScrollingElement instanceof HTMLElement) scrollableElements.push({\n        element: rootScrollingElement,\n        scrollTop: rootScrollingElement.scrollTop,\n        scrollLeft: rootScrollingElement.scrollLeft\n    });\n    return scrollableElements;\n}\nfunction $7215afc6de606d6b$var$restoreScrollPosition(scrollableElements) {\n    for (let { element: element, scrollTop: scrollTop, scrollLeft: scrollLeft } of scrollableElements){\n        element.scrollTop = scrollTop;\n        element.scrollLeft = scrollLeft;\n    }\n}\n //# sourceMappingURL=focusWithoutScrolling.module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQHJlYWN0LWFyaWEvdXRpbHMvZGlzdC9mb2N1c1dpdGhvdXRTY3JvbGxpbmcubWpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTs7Ozs7Ozs7OztDQVVDLEdBQUcsU0FBU0EsMENBQTBDQyxPQUFPO0lBQzFELElBQUlDLCtDQUErQ0QsUUFBUUUsS0FBSyxDQUFDO1FBQzdEQyxlQUFlO0lBQ25CO1NBQ0s7UUFDRCxJQUFJQyxxQkFBcUJDLDRDQUE0Q0w7UUFDckVBLFFBQVFFLEtBQUs7UUFDYkksNENBQTRDRjtJQUNoRDtBQUNKO0FBQ0EsSUFBSUcsb0RBQW9EO0FBQ3hELFNBQVNOO0lBQ0wsSUFBSU0scURBQXFELE1BQU07UUFDM0RBLG9EQUFvRDtRQUNwRCxJQUFJO1lBQ0EsSUFBSUMsWUFBWUMsU0FBU0MsYUFBYSxDQUFDO1lBQ3ZDRixVQUFVTixLQUFLLENBQUM7Z0JBQ1osSUFBSUMsaUJBQWlCO29CQUNqQkksb0RBQW9EO29CQUNwRCxPQUFPO2dCQUNYO1lBQ0o7UUFDSixFQUFFLFVBQU87UUFDVCxTQUFTO1FBQ1Q7SUFDSjtJQUNBLE9BQU9BO0FBQ1g7QUFDQSxTQUFTRiw0Q0FBNENMLE9BQU87SUFDeEQsSUFBSVcsU0FBU1gsUUFBUVksVUFBVTtJQUMvQixJQUFJUixxQkFBcUIsRUFBRTtJQUMzQixJQUFJUyx1QkFBdUJKLFNBQVNLLGdCQUFnQixJQUFJTCxTQUFTTSxlQUFlO0lBQ2hGLE1BQU1KLGtCQUFrQkssZUFBZUwsV0FBV0UscUJBQXFCO1FBQ25FLElBQUlGLE9BQU9NLFlBQVksR0FBR04sT0FBT08sWUFBWSxJQUFJUCxPQUFPUSxXQUFXLEdBQUdSLE9BQU9TLFdBQVcsRUFBRWhCLG1CQUFtQmlCLElBQUksQ0FBQztZQUM5R3JCLFNBQVNXO1lBQ1RXLFdBQVdYLE9BQU9XLFNBQVM7WUFDM0JDLFlBQVlaLE9BQU9ZLFVBQVU7UUFDakM7UUFDQVosU0FBU0EsT0FBT0MsVUFBVTtJQUM5QjtJQUNBLElBQUlDLGdDQUFnQ0csYUFBYVosbUJBQW1CaUIsSUFBSSxDQUFDO1FBQ3JFckIsU0FBU2E7UUFDVFMsV0FBV1QscUJBQXFCUyxTQUFTO1FBQ3pDQyxZQUFZVixxQkFBcUJVLFVBQVU7SUFDL0M7SUFDQSxPQUFPbkI7QUFDWDtBQUNBLFNBQVNFLDRDQUE0Q0Ysa0JBQWtCO0lBQ25FLEtBQUssSUFBSSxFQUFFSixTQUFTQSxPQUFPLEVBQUVzQixXQUFXQSxTQUFTLEVBQUVDLFlBQVlBLFVBQVUsRUFBRSxJQUFJbkIsbUJBQW1CO1FBQzlGSixRQUFRc0IsU0FBUyxHQUFHQTtRQUNwQnRCLFFBQVF1QixVQUFVLEdBQUdBO0lBQ3pCO0FBQ0o7QUFHNEUsQ0FDNUUsd0RBQXdEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQHJlYWN0LWFyaWEvdXRpbHMvZGlzdC9mb2N1c1dpdGhvdXRTY3JvbGxpbmcubWpzP2I4YWYiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIGZ1bmN0aW9uICQ3MjE1YWZjNmRlNjA2ZDZiJGV4cG9ydCRkZTc5ZTJjNjk1ZTA1MmYzKGVsZW1lbnQpIHtcbiAgICBpZiAoJDcyMTVhZmM2ZGU2MDZkNmIkdmFyJHN1cHBvcnRzUHJldmVudFNjcm9sbCgpKSBlbGVtZW50LmZvY3VzKHtcbiAgICAgICAgcHJldmVudFNjcm9sbDogdHJ1ZVxuICAgIH0pO1xuICAgIGVsc2Uge1xuICAgICAgICBsZXQgc2Nyb2xsYWJsZUVsZW1lbnRzID0gJDcyMTVhZmM2ZGU2MDZkNmIkdmFyJGdldFNjcm9sbGFibGVFbGVtZW50cyhlbGVtZW50KTtcbiAgICAgICAgZWxlbWVudC5mb2N1cygpO1xuICAgICAgICAkNzIxNWFmYzZkZTYwNmQ2YiR2YXIkcmVzdG9yZVNjcm9sbFBvc2l0aW9uKHNjcm9sbGFibGVFbGVtZW50cyk7XG4gICAgfVxufVxubGV0ICQ3MjE1YWZjNmRlNjA2ZDZiJHZhciRzdXBwb3J0c1ByZXZlbnRTY3JvbGxDYWNoZWQgPSBudWxsO1xuZnVuY3Rpb24gJDcyMTVhZmM2ZGU2MDZkNmIkdmFyJHN1cHBvcnRzUHJldmVudFNjcm9sbCgpIHtcbiAgICBpZiAoJDcyMTVhZmM2ZGU2MDZkNmIkdmFyJHN1cHBvcnRzUHJldmVudFNjcm9sbENhY2hlZCA9PSBudWxsKSB7XG4gICAgICAgICQ3MjE1YWZjNmRlNjA2ZDZiJHZhciRzdXBwb3J0c1ByZXZlbnRTY3JvbGxDYWNoZWQgPSBmYWxzZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGxldCBmb2N1c0VsZW0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgIGZvY3VzRWxlbS5mb2N1cyh7XG4gICAgICAgICAgICAgICAgZ2V0IHByZXZlbnRTY3JvbGwgKCkge1xuICAgICAgICAgICAgICAgICAgICAkNzIxNWFmYzZkZTYwNmQ2YiR2YXIkc3VwcG9ydHNQcmV2ZW50U2Nyb2xsQ2FjaGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gY2F0Y2ggIHtcbiAgICAgICAgLy8gSWdub3JlXG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuICQ3MjE1YWZjNmRlNjA2ZDZiJHZhciRzdXBwb3J0c1ByZXZlbnRTY3JvbGxDYWNoZWQ7XG59XG5mdW5jdGlvbiAkNzIxNWFmYzZkZTYwNmQ2YiR2YXIkZ2V0U2Nyb2xsYWJsZUVsZW1lbnRzKGVsZW1lbnQpIHtcbiAgICBsZXQgcGFyZW50ID0gZWxlbWVudC5wYXJlbnROb2RlO1xuICAgIGxldCBzY3JvbGxhYmxlRWxlbWVudHMgPSBbXTtcbiAgICBsZXQgcm9vdFNjcm9sbGluZ0VsZW1lbnQgPSBkb2N1bWVudC5zY3JvbGxpbmdFbGVtZW50IHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgICB3aGlsZShwYXJlbnQgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCAmJiBwYXJlbnQgIT09IHJvb3RTY3JvbGxpbmdFbGVtZW50KXtcbiAgICAgICAgaWYgKHBhcmVudC5vZmZzZXRIZWlnaHQgPCBwYXJlbnQuc2Nyb2xsSGVpZ2h0IHx8IHBhcmVudC5vZmZzZXRXaWR0aCA8IHBhcmVudC5zY3JvbGxXaWR0aCkgc2Nyb2xsYWJsZUVsZW1lbnRzLnB1c2goe1xuICAgICAgICAgICAgZWxlbWVudDogcGFyZW50LFxuICAgICAgICAgICAgc2Nyb2xsVG9wOiBwYXJlbnQuc2Nyb2xsVG9wLFxuICAgICAgICAgICAgc2Nyb2xsTGVmdDogcGFyZW50LnNjcm9sbExlZnRcbiAgICAgICAgfSk7XG4gICAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnROb2RlO1xuICAgIH1cbiAgICBpZiAocm9vdFNjcm9sbGluZ0VsZW1lbnQgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkgc2Nyb2xsYWJsZUVsZW1lbnRzLnB1c2goe1xuICAgICAgICBlbGVtZW50OiByb290U2Nyb2xsaW5nRWxlbWVudCxcbiAgICAgICAgc2Nyb2xsVG9wOiByb290U2Nyb2xsaW5nRWxlbWVudC5zY3JvbGxUb3AsXG4gICAgICAgIHNjcm9sbExlZnQ6IHJvb3RTY3JvbGxpbmdFbGVtZW50LnNjcm9sbExlZnRcbiAgICB9KTtcbiAgICByZXR1cm4gc2Nyb2xsYWJsZUVsZW1lbnRzO1xufVxuZnVuY3Rpb24gJDcyMTVhZmM2ZGU2MDZkNmIkdmFyJHJlc3RvcmVTY3JvbGxQb3NpdGlvbihzY3JvbGxhYmxlRWxlbWVudHMpIHtcbiAgICBmb3IgKGxldCB7IGVsZW1lbnQ6IGVsZW1lbnQsIHNjcm9sbFRvcDogc2Nyb2xsVG9wLCBzY3JvbGxMZWZ0OiBzY3JvbGxMZWZ0IH0gb2Ygc2Nyb2xsYWJsZUVsZW1lbnRzKXtcbiAgICAgICAgZWxlbWVudC5zY3JvbGxUb3AgPSBzY3JvbGxUb3A7XG4gICAgICAgIGVsZW1lbnQuc2Nyb2xsTGVmdCA9IHNjcm9sbExlZnQ7XG4gICAgfVxufVxuXG5cbmV4cG9ydCB7JDcyMTVhZmM2ZGU2MDZkNmIkZXhwb3J0JGRlNzllMmM2OTVlMDUyZjMgYXMgZm9jdXNXaXRob3V0U2Nyb2xsaW5nfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZvY3VzV2l0aG91dFNjcm9sbGluZy5tb2R1bGUuanMubWFwXG4iXSwibmFtZXMiOlsiJDcyMTVhZmM2ZGU2MDZkNmIkZXhwb3J0JGRlNzllMmM2OTVlMDUyZjMiLCJlbGVtZW50IiwiJDcyMTVhZmM2ZGU2MDZkNmIkdmFyJHN1cHBvcnRzUHJldmVudFNjcm9sbCIsImZvY3VzIiwicHJldmVudFNjcm9sbCIsInNjcm9sbGFibGVFbGVtZW50cyIsIiQ3MjE1YWZjNmRlNjA2ZDZiJHZhciRnZXRTY3JvbGxhYmxlRWxlbWVudHMiLCIkNzIxNWFmYzZkZTYwNmQ2YiR2YXIkcmVzdG9yZVNjcm9sbFBvc2l0aW9uIiwiJDcyMTVhZmM2ZGU2MDZkNmIkdmFyJHN1cHBvcnRzUHJldmVudFNjcm9sbENhY2hlZCIsImZvY3VzRWxlbSIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsInBhcmVudCIsInBhcmVudE5vZGUiLCJyb290U2Nyb2xsaW5nRWxlbWVudCIsInNjcm9sbGluZ0VsZW1lbnQiLCJkb2N1bWVudEVsZW1lbnQiLCJIVE1MRWxlbWVudCIsIm9mZnNldEhlaWdodCIsInNjcm9sbEhlaWdodCIsIm9mZnNldFdpZHRoIiwic2Nyb2xsV2lkdGgiLCJwdXNoIiwic2Nyb2xsVG9wIiwic2Nyb2xsTGVmdCIsImZvY3VzV2l0aG91dFNjcm9sbGluZyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../../../node_modules/@react-aria/utils/dist/focusWithoutScrolling.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/../../../../node_modules/@react-aria/utils/dist/isFocusable.mjs":
/*!***********************************************************************!*\
  !*** ../../../../node_modules/@react-aria/utils/dist/isFocusable.mjs ***!
  \***********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   isFocusable: function() { return /* binding */ $b4b717babfbb907b$export$4c063cf1350e6fed; },\n/* harmony export */   isTabbable: function() { return /* binding */ $b4b717babfbb907b$export$bebd5a1431fec25d; }\n/* harmony export */ });\nconst $b4b717babfbb907b$var$focusableElements = [\n    \"input:not([disabled]):not([type=hidden])\",\n    \"select:not([disabled])\",\n    \"textarea:not([disabled])\",\n    \"button:not([disabled])\",\n    \"a[href]\",\n    \"area[href]\",\n    \"summary\",\n    \"iframe\",\n    \"object\",\n    \"embed\",\n    \"audio[controls]\",\n    \"video[controls]\",\n    '[contenteditable]:not([contenteditable^=\"false\"])'\n];\nconst $b4b717babfbb907b$var$FOCUSABLE_ELEMENT_SELECTOR = $b4b717babfbb907b$var$focusableElements.join(\":not([hidden]),\") + \",[tabindex]:not([disabled]):not([hidden])\";\n$b4b717babfbb907b$var$focusableElements.push('[tabindex]:not([tabindex=\"-1\"]):not([disabled])');\nconst $b4b717babfbb907b$var$TABBABLE_ELEMENT_SELECTOR = $b4b717babfbb907b$var$focusableElements.join(':not([hidden]):not([tabindex=\"-1\"]),');\nfunction $b4b717babfbb907b$export$4c063cf1350e6fed(element) {\n    return element.matches($b4b717babfbb907b$var$FOCUSABLE_ELEMENT_SELECTOR);\n}\nfunction $b4b717babfbb907b$export$bebd5a1431fec25d(element) {\n    return element.matches($b4b717babfbb907b$var$TABBABLE_ELEMENT_SELECTOR);\n}\n //# sourceMappingURL=isFocusable.module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQHJlYWN0LWFyaWEvdXRpbHMvZGlzdC9pc0ZvY3VzYWJsZS5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQSxNQUFNQSwwQ0FBMEM7SUFDNUM7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7Q0FDSDtBQUNELE1BQU1DLG1EQUFtREQsd0NBQXdDRSxJQUFJLENBQUMscUJBQXFCO0FBQzNIRix3Q0FBd0NHLElBQUksQ0FBQztBQUM3QyxNQUFNQyxrREFBa0RKLHdDQUF3Q0UsSUFBSSxDQUFDO0FBQ3JHLFNBQVNHLDBDQUEwQ0MsT0FBTztJQUN0RCxPQUFPQSxRQUFRQyxPQUFPLENBQUNOO0FBQzNCO0FBQ0EsU0FBU08sMENBQTBDRixPQUFPO0lBQ3RELE9BQU9BLFFBQVFDLE9BQU8sQ0FBQ0g7QUFDM0I7QUFHMkgsQ0FDM0gsOENBQThDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQHJlYWN0LWFyaWEvdXRpbHMvZGlzdC9pc0ZvY3VzYWJsZS5tanM/MzZkMyJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCAkYjRiNzE3YmFiZmJiOTA3YiR2YXIkZm9jdXNhYmxlRWxlbWVudHMgPSBbXG4gICAgJ2lucHV0Om5vdChbZGlzYWJsZWRdKTpub3QoW3R5cGU9aGlkZGVuXSknLFxuICAgICdzZWxlY3Q6bm90KFtkaXNhYmxlZF0pJyxcbiAgICAndGV4dGFyZWE6bm90KFtkaXNhYmxlZF0pJyxcbiAgICAnYnV0dG9uOm5vdChbZGlzYWJsZWRdKScsXG4gICAgJ2FbaHJlZl0nLFxuICAgICdhcmVhW2hyZWZdJyxcbiAgICAnc3VtbWFyeScsXG4gICAgJ2lmcmFtZScsXG4gICAgJ29iamVjdCcsXG4gICAgJ2VtYmVkJyxcbiAgICAnYXVkaW9bY29udHJvbHNdJyxcbiAgICAndmlkZW9bY29udHJvbHNdJyxcbiAgICAnW2NvbnRlbnRlZGl0YWJsZV06bm90KFtjb250ZW50ZWRpdGFibGVePVwiZmFsc2VcIl0pJ1xuXTtcbmNvbnN0ICRiNGI3MTdiYWJmYmI5MDdiJHZhciRGT0NVU0FCTEVfRUxFTUVOVF9TRUxFQ1RPUiA9ICRiNGI3MTdiYWJmYmI5MDdiJHZhciRmb2N1c2FibGVFbGVtZW50cy5qb2luKCc6bm90KFtoaWRkZW5dKSwnKSArICcsW3RhYmluZGV4XTpub3QoW2Rpc2FibGVkXSk6bm90KFtoaWRkZW5dKSc7XG4kYjRiNzE3YmFiZmJiOTA3YiR2YXIkZm9jdXNhYmxlRWxlbWVudHMucHVzaCgnW3RhYmluZGV4XTpub3QoW3RhYmluZGV4PVwiLTFcIl0pOm5vdChbZGlzYWJsZWRdKScpO1xuY29uc3QgJGI0YjcxN2JhYmZiYjkwN2IkdmFyJFRBQkJBQkxFX0VMRU1FTlRfU0VMRUNUT1IgPSAkYjRiNzE3YmFiZmJiOTA3YiR2YXIkZm9jdXNhYmxlRWxlbWVudHMuam9pbignOm5vdChbaGlkZGVuXSk6bm90KFt0YWJpbmRleD1cIi0xXCJdKSwnKTtcbmZ1bmN0aW9uICRiNGI3MTdiYWJmYmI5MDdiJGV4cG9ydCQ0YzA2M2NmMTM1MGU2ZmVkKGVsZW1lbnQpIHtcbiAgICByZXR1cm4gZWxlbWVudC5tYXRjaGVzKCRiNGI3MTdiYWJmYmI5MDdiJHZhciRGT0NVU0FCTEVfRUxFTUVOVF9TRUxFQ1RPUik7XG59XG5mdW5jdGlvbiAkYjRiNzE3YmFiZmJiOTA3YiRleHBvcnQkYmViZDVhMTQzMWZlYzI1ZChlbGVtZW50KSB7XG4gICAgcmV0dXJuIGVsZW1lbnQubWF0Y2hlcygkYjRiNzE3YmFiZmJiOTA3YiR2YXIkVEFCQkFCTEVfRUxFTUVOVF9TRUxFQ1RPUik7XG59XG5cblxuZXhwb3J0IHskYjRiNzE3YmFiZmJiOTA3YiRleHBvcnQkNGMwNjNjZjEzNTBlNmZlZCBhcyBpc0ZvY3VzYWJsZSwgJGI0YjcxN2JhYmZiYjkwN2IkZXhwb3J0JGJlYmQ1YTE0MzFmZWMyNWQgYXMgaXNUYWJiYWJsZX07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pc0ZvY3VzYWJsZS5tb2R1bGUuanMubWFwXG4iXSwibmFtZXMiOlsiJGI0YjcxN2JhYmZiYjkwN2IkdmFyJGZvY3VzYWJsZUVsZW1lbnRzIiwiJGI0YjcxN2JhYmZiYjkwN2IkdmFyJEZPQ1VTQUJMRV9FTEVNRU5UX1NFTEVDVE9SIiwiam9pbiIsInB1c2giLCIkYjRiNzE3YmFiZmJiOTA3YiR2YXIkVEFCQkFCTEVfRUxFTUVOVF9TRUxFQ1RPUiIsIiRiNGI3MTdiYWJmYmI5MDdiJGV4cG9ydCQ0YzA2M2NmMTM1MGU2ZmVkIiwiZWxlbWVudCIsIm1hdGNoZXMiLCIkYjRiNzE3YmFiZmJiOTA3YiRleHBvcnQkYmViZDVhMTQzMWZlYzI1ZCIsImlzRm9jdXNhYmxlIiwiaXNUYWJiYWJsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../../../node_modules/@react-aria/utils/dist/isFocusable.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/../../../../node_modules/@react-aria/utils/dist/isVirtualEvent.mjs":
/*!**************************************************************************!*\
  !*** ../../../../node_modules/@react-aria/utils/dist/isVirtualEvent.mjs ***!
  \**************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   isVirtualClick: function() { return /* binding */ $6a7db85432448f7f$export$60278871457622de; },\n/* harmony export */   isVirtualPointerEvent: function() { return /* binding */ $6a7db85432448f7f$export$29bf1b5f2c56cf63; }\n/* harmony export */ });\n/* harmony import */ var _platform_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./platform.mjs */ \"(app-pages-browser)/../../../../node_modules/@react-aria/utils/dist/platform.mjs\");\n\n/*\n * Copyright 2022 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ function $6a7db85432448f7f$export$60278871457622de(event) {\n    // JAWS/NVDA with Firefox.\n    if (event.mozInputSource === 0 && event.isTrusted) return true;\n    // Android TalkBack's detail value varies depending on the event listener providing the event so we have specific logic here instead\n    // If pointerType is defined, event is from a click listener. For events from mousedown listener, detail === 0 is a sufficient check\n    // to detect TalkBack virtual clicks.\n    if ((0, _platform_mjs__WEBPACK_IMPORTED_MODULE_0__.isAndroid)() && event.pointerType) return event.type === \"click\" && event.buttons === 1;\n    return event.detail === 0 && !event.pointerType;\n}\nfunction $6a7db85432448f7f$export$29bf1b5f2c56cf63(event) {\n    // If the pointer size is zero, then we assume it's from a screen reader.\n    // Android TalkBack double tap will sometimes return a event with width and height of 1\n    // and pointerType === 'mouse' so we need to check for a specific combination of event attributes.\n    // Cannot use \"event.pressure === 0\" as the sole check due to Safari pointer events always returning pressure === 0\n    // instead of .5, see https://bugs.webkit.org/show_bug.cgi?id=206216. event.pointerType === 'mouse' is to distingush\n    // Talkback double tap from Windows Firefox touch screen press\n    return !(0, _platform_mjs__WEBPACK_IMPORTED_MODULE_0__.isAndroid)() && event.width === 0 && event.height === 0 || event.width === 1 && event.height === 1 && event.pressure === 0 && event.detail === 0 && event.pointerType === \"mouse\";\n}\n //# sourceMappingURL=isVirtualEvent.module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQHJlYWN0LWFyaWEvdXRpbHMvZGlzdC9pc1ZpcnR1YWxFdmVudC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQXNGO0FBRXRGOzs7Ozs7Ozs7O0NBVUMsR0FDRCxTQUFTRSwwQ0FBMENDLEtBQUs7SUFDcEQsMEJBQTBCO0lBQzFCLElBQUlBLE1BQU1DLGNBQWMsS0FBSyxLQUFLRCxNQUFNRSxTQUFTLEVBQUUsT0FBTztJQUMxRCxvSUFBb0k7SUFDcEksb0lBQW9JO0lBQ3BJLHFDQUFxQztJQUNyQyxJQUFJLENBQUMsR0FBR0osb0RBQXdDLE9BQVFFLE1BQU1HLFdBQVcsRUFBRSxPQUFPSCxNQUFNSSxJQUFJLEtBQUssV0FBV0osTUFBTUssT0FBTyxLQUFLO0lBQzlILE9BQU9MLE1BQU1NLE1BQU0sS0FBSyxLQUFLLENBQUNOLE1BQU1HLFdBQVc7QUFDbkQ7QUFDQSxTQUFTSSwwQ0FBMENQLEtBQUs7SUFDcEQseUVBQXlFO0lBQ3pFLHVGQUF1RjtJQUN2RixrR0FBa0c7SUFDbEcsbUhBQW1IO0lBQ25ILG9IQUFvSDtJQUNwSCw4REFBOEQ7SUFDOUQsT0FBTyxDQUFDLENBQUMsR0FBR0Ysb0RBQXdDLE9BQVFFLE1BQU1RLEtBQUssS0FBSyxLQUFLUixNQUFNUyxNQUFNLEtBQUssS0FBS1QsTUFBTVEsS0FBSyxLQUFLLEtBQUtSLE1BQU1TLE1BQU0sS0FBSyxLQUFLVCxNQUFNVSxRQUFRLEtBQUssS0FBS1YsTUFBTU0sTUFBTSxLQUFLLEtBQUtOLE1BQU1HLFdBQVcsS0FBSztBQUMxTjtBQUd5SSxDQUN6SSxpREFBaUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AcmVhY3QtYXJpYS91dGlscy9kaXN0L2lzVmlydHVhbEV2ZW50Lm1qcz9lYmQ3Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7aXNBbmRyb2lkIGFzICRjODczMTE0MjRlYTMwYTA1JGV4cG9ydCRhMTFiMDA1OTkwMGNlZWM4fSBmcm9tIFwiLi9wbGF0Zm9ybS5tanNcIjtcblxuLypcbiAqIENvcHlyaWdodCAyMDIyIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIFxuZnVuY3Rpb24gJDZhN2RiODU0MzI0NDhmN2YkZXhwb3J0JDYwMjc4ODcxNDU3NjIyZGUoZXZlbnQpIHtcbiAgICAvLyBKQVdTL05WREEgd2l0aCBGaXJlZm94LlxuICAgIGlmIChldmVudC5tb3pJbnB1dFNvdXJjZSA9PT0gMCAmJiBldmVudC5pc1RydXN0ZWQpIHJldHVybiB0cnVlO1xuICAgIC8vIEFuZHJvaWQgVGFsa0JhY2sncyBkZXRhaWwgdmFsdWUgdmFyaWVzIGRlcGVuZGluZyBvbiB0aGUgZXZlbnQgbGlzdGVuZXIgcHJvdmlkaW5nIHRoZSBldmVudCBzbyB3ZSBoYXZlIHNwZWNpZmljIGxvZ2ljIGhlcmUgaW5zdGVhZFxuICAgIC8vIElmIHBvaW50ZXJUeXBlIGlzIGRlZmluZWQsIGV2ZW50IGlzIGZyb20gYSBjbGljayBsaXN0ZW5lci4gRm9yIGV2ZW50cyBmcm9tIG1vdXNlZG93biBsaXN0ZW5lciwgZGV0YWlsID09PSAwIGlzIGEgc3VmZmljaWVudCBjaGVja1xuICAgIC8vIHRvIGRldGVjdCBUYWxrQmFjayB2aXJ0dWFsIGNsaWNrcy5cbiAgICBpZiAoKDAsICRjODczMTE0MjRlYTMwYTA1JGV4cG9ydCRhMTFiMDA1OTkwMGNlZWM4KSgpICYmIGV2ZW50LnBvaW50ZXJUeXBlKSByZXR1cm4gZXZlbnQudHlwZSA9PT0gJ2NsaWNrJyAmJiBldmVudC5idXR0b25zID09PSAxO1xuICAgIHJldHVybiBldmVudC5kZXRhaWwgPT09IDAgJiYgIWV2ZW50LnBvaW50ZXJUeXBlO1xufVxuZnVuY3Rpb24gJDZhN2RiODU0MzI0NDhmN2YkZXhwb3J0JDI5YmYxYjVmMmM1NmNmNjMoZXZlbnQpIHtcbiAgICAvLyBJZiB0aGUgcG9pbnRlciBzaXplIGlzIHplcm8sIHRoZW4gd2UgYXNzdW1lIGl0J3MgZnJvbSBhIHNjcmVlbiByZWFkZXIuXG4gICAgLy8gQW5kcm9pZCBUYWxrQmFjayBkb3VibGUgdGFwIHdpbGwgc29tZXRpbWVzIHJldHVybiBhIGV2ZW50IHdpdGggd2lkdGggYW5kIGhlaWdodCBvZiAxXG4gICAgLy8gYW5kIHBvaW50ZXJUeXBlID09PSAnbW91c2UnIHNvIHdlIG5lZWQgdG8gY2hlY2sgZm9yIGEgc3BlY2lmaWMgY29tYmluYXRpb24gb2YgZXZlbnQgYXR0cmlidXRlcy5cbiAgICAvLyBDYW5ub3QgdXNlIFwiZXZlbnQucHJlc3N1cmUgPT09IDBcIiBhcyB0aGUgc29sZSBjaGVjayBkdWUgdG8gU2FmYXJpIHBvaW50ZXIgZXZlbnRzIGFsd2F5cyByZXR1cm5pbmcgcHJlc3N1cmUgPT09IDBcbiAgICAvLyBpbnN0ZWFkIG9mIC41LCBzZWUgaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTIwNjIxNi4gZXZlbnQucG9pbnRlclR5cGUgPT09ICdtb3VzZScgaXMgdG8gZGlzdGluZ3VzaFxuICAgIC8vIFRhbGtiYWNrIGRvdWJsZSB0YXAgZnJvbSBXaW5kb3dzIEZpcmVmb3ggdG91Y2ggc2NyZWVuIHByZXNzXG4gICAgcmV0dXJuICEoMCwgJGM4NzMxMTQyNGVhMzBhMDUkZXhwb3J0JGExMWIwMDU5OTAwY2VlYzgpKCkgJiYgZXZlbnQud2lkdGggPT09IDAgJiYgZXZlbnQuaGVpZ2h0ID09PSAwIHx8IGV2ZW50LndpZHRoID09PSAxICYmIGV2ZW50LmhlaWdodCA9PT0gMSAmJiBldmVudC5wcmVzc3VyZSA9PT0gMCAmJiBldmVudC5kZXRhaWwgPT09IDAgJiYgZXZlbnQucG9pbnRlclR5cGUgPT09ICdtb3VzZSc7XG59XG5cblxuZXhwb3J0IHskNmE3ZGI4NTQzMjQ0OGY3ZiRleHBvcnQkNjAyNzg4NzE0NTc2MjJkZSBhcyBpc1ZpcnR1YWxDbGljaywgJDZhN2RiODU0MzI0NDhmN2YkZXhwb3J0JDI5YmYxYjVmMmM1NmNmNjMgYXMgaXNWaXJ0dWFsUG9pbnRlckV2ZW50fTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlzVmlydHVhbEV2ZW50Lm1vZHVsZS5qcy5tYXBcbiJdLCJuYW1lcyI6WyJpc0FuZHJvaWQiLCIkYzg3MzExNDI0ZWEzMGEwNSRleHBvcnQkYTExYjAwNTk5MDBjZWVjOCIsIiQ2YTdkYjg1NDMyNDQ4ZjdmJGV4cG9ydCQ2MDI3ODg3MTQ1NzYyMmRlIiwiZXZlbnQiLCJtb3pJbnB1dFNvdXJjZSIsImlzVHJ1c3RlZCIsInBvaW50ZXJUeXBlIiwidHlwZSIsImJ1dHRvbnMiLCJkZXRhaWwiLCIkNmE3ZGI4NTQzMjQ0OGY3ZiRleHBvcnQkMjliZjFiNWYyYzU2Y2Y2MyIsIndpZHRoIiwiaGVpZ2h0IiwicHJlc3N1cmUiLCJpc1ZpcnR1YWxDbGljayIsImlzVmlydHVhbFBvaW50ZXJFdmVudCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../../../node_modules/@react-aria/utils/dist/isVirtualEvent.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/../../../../node_modules/@react-aria/utils/dist/platform.mjs":
/*!********************************************************************!*\
  !*** ../../../../node_modules/@react-aria/utils/dist/platform.mjs ***!
  \********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   isAndroid: function() { return /* binding */ $c87311424ea30a05$export$a11b0059900ceec8; },\n/* harmony export */   isAppleDevice: function() { return /* binding */ $c87311424ea30a05$export$e1865c3bedcd822b; },\n/* harmony export */   isChrome: function() { return /* binding */ $c87311424ea30a05$export$6446a186d09e379e; },\n/* harmony export */   isFirefox: function() { return /* binding */ $c87311424ea30a05$export$b7d78993b74f766d; },\n/* harmony export */   isIOS: function() { return /* binding */ $c87311424ea30a05$export$fedb369cb70207f1; },\n/* harmony export */   isIPad: function() { return /* binding */ $c87311424ea30a05$export$7bef049ce92e4224; },\n/* harmony export */   isIPhone: function() { return /* binding */ $c87311424ea30a05$export$186c6964ca17d99; },\n/* harmony export */   isMac: function() { return /* binding */ $c87311424ea30a05$export$9ac100e40613ea10; },\n/* harmony export */   isWebKit: function() { return /* binding */ $c87311424ea30a05$export$78551043582a6a98; }\n/* harmony export */ });\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ function $c87311424ea30a05$var$testUserAgent(re) {\n    var _window_navigator_userAgentData;\n    if ( false || window.navigator == null) return false;\n    return ((_window_navigator_userAgentData = window.navigator[\"userAgentData\"]) === null || _window_navigator_userAgentData === void 0 ? void 0 : _window_navigator_userAgentData.brands.some((brand)=>re.test(brand.brand))) || re.test(window.navigator.userAgent);\n}\nfunction $c87311424ea30a05$var$testPlatform(re) {\n    var _window_navigator_userAgentData;\n    return  true && window.navigator != null ? re.test(((_window_navigator_userAgentData = window.navigator[\"userAgentData\"]) === null || _window_navigator_userAgentData === void 0 ? void 0 : _window_navigator_userAgentData.platform) || window.navigator.platform) : false;\n}\nfunction $c87311424ea30a05$var$cached(fn) {\n    if (false) {}\n    let res = null;\n    return ()=>{\n        if (res == null) res = fn();\n        return res;\n    };\n}\nconst $c87311424ea30a05$export$9ac100e40613ea10 = $c87311424ea30a05$var$cached(function() {\n    return $c87311424ea30a05$var$testPlatform(/^Mac/i);\n});\nconst $c87311424ea30a05$export$186c6964ca17d99 = $c87311424ea30a05$var$cached(function() {\n    return $c87311424ea30a05$var$testPlatform(/^iPhone/i);\n});\nconst $c87311424ea30a05$export$7bef049ce92e4224 = $c87311424ea30a05$var$cached(function() {\n    return $c87311424ea30a05$var$testPlatform(/^iPad/i) || // iPadOS 13 lies and says it's a Mac, but we can distinguish by detecting touch support.\n    $c87311424ea30a05$export$9ac100e40613ea10() && navigator.maxTouchPoints > 1;\n});\nconst $c87311424ea30a05$export$fedb369cb70207f1 = $c87311424ea30a05$var$cached(function() {\n    return $c87311424ea30a05$export$186c6964ca17d99() || $c87311424ea30a05$export$7bef049ce92e4224();\n});\nconst $c87311424ea30a05$export$e1865c3bedcd822b = $c87311424ea30a05$var$cached(function() {\n    return $c87311424ea30a05$export$9ac100e40613ea10() || $c87311424ea30a05$export$fedb369cb70207f1();\n});\nconst $c87311424ea30a05$export$78551043582a6a98 = $c87311424ea30a05$var$cached(function() {\n    return $c87311424ea30a05$var$testUserAgent(/AppleWebKit/i) && !$c87311424ea30a05$export$6446a186d09e379e();\n});\nconst $c87311424ea30a05$export$6446a186d09e379e = $c87311424ea30a05$var$cached(function() {\n    return $c87311424ea30a05$var$testUserAgent(/Chrome/i);\n});\nconst $c87311424ea30a05$export$a11b0059900ceec8 = $c87311424ea30a05$var$cached(function() {\n    return $c87311424ea30a05$var$testUserAgent(/Android/i);\n});\nconst $c87311424ea30a05$export$b7d78993b74f766d = $c87311424ea30a05$var$cached(function() {\n    return $c87311424ea30a05$var$testUserAgent(/Firefox/i);\n});\n //# sourceMappingURL=platform.module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQHJlYWN0LWFyaWEvdXRpbHMvZGlzdC9wbGF0Zm9ybS5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQUE7Ozs7Ozs7Ozs7Q0FVQyxHQUFHLFNBQVNBLG9DQUFvQ0MsRUFBRTtJQUMvQyxJQUFJQztJQUNKLElBQUksTUFBa0IsSUFBZUMsT0FBT0MsU0FBUyxJQUFJLE1BQU0sT0FBTztJQUN0RSxPQUFPLENBQUMsQ0FBQ0Ysa0NBQWtDQyxPQUFPQyxTQUFTLENBQUMsZ0JBQWdCLE1BQU0sUUFBUUYsb0NBQW9DLEtBQUssSUFBSSxLQUFLLElBQUlBLGdDQUFnQ0csTUFBTSxDQUFDQyxJQUFJLENBQUMsQ0FBQ0MsUUFBUU4sR0FBR08sSUFBSSxDQUFDRCxNQUFNQSxLQUFLLEVBQUMsS0FBTU4sR0FBR08sSUFBSSxDQUFDTCxPQUFPQyxTQUFTLENBQUNLLFNBQVM7QUFDclE7QUFDQSxTQUFTQyxtQ0FBbUNULEVBQUU7SUFDMUMsSUFBSUM7SUFDSixPQUFPLEtBQWtCLElBQWVDLE9BQU9DLFNBQVMsSUFBSSxPQUFPSCxHQUFHTyxJQUFJLENBQUMsQ0FBQyxDQUFDTixrQ0FBa0NDLE9BQU9DLFNBQVMsQ0FBQyxnQkFBZ0IsTUFBTSxRQUFRRixvQ0FBb0MsS0FBSyxJQUFJLEtBQUssSUFBSUEsZ0NBQWdDUyxRQUFRLEtBQUtSLE9BQU9DLFNBQVMsQ0FBQ08sUUFBUSxJQUFJO0FBQ2xTO0FBQ0EsU0FBU0MsNkJBQTZCQyxFQUFFO0lBQ3BDLElBQUlDLEtBQXlCLEVBQVEsRUFBVUQ7SUFDL0MsSUFBSUUsTUFBTTtJQUNWLE9BQU87UUFDSCxJQUFJQSxPQUFPLE1BQU1BLE1BQU1GO1FBQ3ZCLE9BQU9FO0lBQ1g7QUFDSjtBQUNBLE1BQU1DLDRDQUE0Q0osNkJBQTZCO0lBQzNFLE9BQU9GLG1DQUFtQztBQUM5QztBQUNBLE1BQU1PLDJDQUEyQ0wsNkJBQTZCO0lBQzFFLE9BQU9GLG1DQUFtQztBQUM5QztBQUNBLE1BQU1RLDRDQUE0Q04sNkJBQTZCO0lBQzNFLE9BQU9GLG1DQUFtQyxhQUFhLHlGQUF5RjtJQUNoSk0sK0NBQStDWixVQUFVZSxjQUFjLEdBQUc7QUFDOUU7QUFDQSxNQUFNQyw0Q0FBNENSLDZCQUE2QjtJQUMzRSxPQUFPSyw4Q0FBOENDO0FBQ3pEO0FBQ0EsTUFBTUcsNENBQTRDVCw2QkFBNkI7SUFDM0UsT0FBT0ksK0NBQStDSTtBQUMxRDtBQUNBLE1BQU1FLDRDQUE0Q1YsNkJBQTZCO0lBQzNFLE9BQU9aLG9DQUFvQyxtQkFBbUIsQ0FBQ3VCO0FBQ25FO0FBQ0EsTUFBTUEsNENBQTRDWCw2QkFBNkI7SUFDM0UsT0FBT1osb0NBQW9DO0FBQy9DO0FBQ0EsTUFBTXdCLDRDQUE0Q1osNkJBQTZCO0lBQzNFLE9BQU9aLG9DQUFvQztBQUMvQztBQUNBLE1BQU15Qiw0Q0FBNENiLDZCQUE2QjtJQUMzRSxPQUFPWixvQ0FBb0M7QUFDL0M7QUFHcWYsQ0FDcmYsMkNBQTJDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQHJlYWN0LWFyaWEvdXRpbHMvZGlzdC9wbGF0Zm9ybS5tanM/YzM3MCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICogQ29weXJpZ2h0IDIwMjAgQWRvYmUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGZpbGUgaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlclxuICogdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgUkVQUkVTRU5UQVRJT05TXG4gKiBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi8gZnVuY3Rpb24gJGM4NzMxMTQyNGVhMzBhMDUkdmFyJHRlc3RVc2VyQWdlbnQocmUpIHtcbiAgICB2YXIgX3dpbmRvd19uYXZpZ2F0b3JfdXNlckFnZW50RGF0YTtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgfHwgd2luZG93Lm5hdmlnYXRvciA9PSBudWxsKSByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuICgoX3dpbmRvd19uYXZpZ2F0b3JfdXNlckFnZW50RGF0YSA9IHdpbmRvdy5uYXZpZ2F0b3JbJ3VzZXJBZ2VudERhdGEnXSkgPT09IG51bGwgfHwgX3dpbmRvd19uYXZpZ2F0b3JfdXNlckFnZW50RGF0YSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3dpbmRvd19uYXZpZ2F0b3JfdXNlckFnZW50RGF0YS5icmFuZHMuc29tZSgoYnJhbmQpPT5yZS50ZXN0KGJyYW5kLmJyYW5kKSkpIHx8IHJlLnRlc3Qod2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQpO1xufVxuZnVuY3Rpb24gJGM4NzMxMTQyNGVhMzBhMDUkdmFyJHRlc3RQbGF0Zm9ybShyZSkge1xuICAgIHZhciBfd2luZG93X25hdmlnYXRvcl91c2VyQWdlbnREYXRhO1xuICAgIHJldHVybiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cubmF2aWdhdG9yICE9IG51bGwgPyByZS50ZXN0KCgoX3dpbmRvd19uYXZpZ2F0b3JfdXNlckFnZW50RGF0YSA9IHdpbmRvdy5uYXZpZ2F0b3JbJ3VzZXJBZ2VudERhdGEnXSkgPT09IG51bGwgfHwgX3dpbmRvd19uYXZpZ2F0b3JfdXNlckFnZW50RGF0YSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3dpbmRvd19uYXZpZ2F0b3JfdXNlckFnZW50RGF0YS5wbGF0Zm9ybSkgfHwgd2luZG93Lm5hdmlnYXRvci5wbGF0Zm9ybSkgOiBmYWxzZTtcbn1cbmZ1bmN0aW9uICRjODczMTE0MjRlYTMwYTA1JHZhciRjYWNoZWQoZm4pIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICd0ZXN0JykgcmV0dXJuIGZuO1xuICAgIGxldCByZXMgPSBudWxsO1xuICAgIHJldHVybiAoKT0+e1xuICAgICAgICBpZiAocmVzID09IG51bGwpIHJlcyA9IGZuKCk7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfTtcbn1cbmNvbnN0ICRjODczMTE0MjRlYTMwYTA1JGV4cG9ydCQ5YWMxMDBlNDA2MTNlYTEwID0gJGM4NzMxMTQyNGVhMzBhMDUkdmFyJGNhY2hlZChmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gJGM4NzMxMTQyNGVhMzBhMDUkdmFyJHRlc3RQbGF0Zm9ybSgvXk1hYy9pKTtcbn0pO1xuY29uc3QgJGM4NzMxMTQyNGVhMzBhMDUkZXhwb3J0JDE4NmM2OTY0Y2ExN2Q5OSA9ICRjODczMTE0MjRlYTMwYTA1JHZhciRjYWNoZWQoZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuICRjODczMTE0MjRlYTMwYTA1JHZhciR0ZXN0UGxhdGZvcm0oL15pUGhvbmUvaSk7XG59KTtcbmNvbnN0ICRjODczMTE0MjRlYTMwYTA1JGV4cG9ydCQ3YmVmMDQ5Y2U5MmU0MjI0ID0gJGM4NzMxMTQyNGVhMzBhMDUkdmFyJGNhY2hlZChmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gJGM4NzMxMTQyNGVhMzBhMDUkdmFyJHRlc3RQbGF0Zm9ybSgvXmlQYWQvaSkgfHwgLy8gaVBhZE9TIDEzIGxpZXMgYW5kIHNheXMgaXQncyBhIE1hYywgYnV0IHdlIGNhbiBkaXN0aW5ndWlzaCBieSBkZXRlY3RpbmcgdG91Y2ggc3VwcG9ydC5cbiAgICAkYzg3MzExNDI0ZWEzMGEwNSRleHBvcnQkOWFjMTAwZTQwNjEzZWExMCgpICYmIG5hdmlnYXRvci5tYXhUb3VjaFBvaW50cyA+IDE7XG59KTtcbmNvbnN0ICRjODczMTE0MjRlYTMwYTA1JGV4cG9ydCRmZWRiMzY5Y2I3MDIwN2YxID0gJGM4NzMxMTQyNGVhMzBhMDUkdmFyJGNhY2hlZChmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gJGM4NzMxMTQyNGVhMzBhMDUkZXhwb3J0JDE4NmM2OTY0Y2ExN2Q5OSgpIHx8ICRjODczMTE0MjRlYTMwYTA1JGV4cG9ydCQ3YmVmMDQ5Y2U5MmU0MjI0KCk7XG59KTtcbmNvbnN0ICRjODczMTE0MjRlYTMwYTA1JGV4cG9ydCRlMTg2NWMzYmVkY2Q4MjJiID0gJGM4NzMxMTQyNGVhMzBhMDUkdmFyJGNhY2hlZChmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gJGM4NzMxMTQyNGVhMzBhMDUkZXhwb3J0JDlhYzEwMGU0MDYxM2VhMTAoKSB8fCAkYzg3MzExNDI0ZWEzMGEwNSRleHBvcnQkZmVkYjM2OWNiNzAyMDdmMSgpO1xufSk7XG5jb25zdCAkYzg3MzExNDI0ZWEzMGEwNSRleHBvcnQkNzg1NTEwNDM1ODJhNmE5OCA9ICRjODczMTE0MjRlYTMwYTA1JHZhciRjYWNoZWQoZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuICRjODczMTE0MjRlYTMwYTA1JHZhciR0ZXN0VXNlckFnZW50KC9BcHBsZVdlYktpdC9pKSAmJiAhJGM4NzMxMTQyNGVhMzBhMDUkZXhwb3J0JDY0NDZhMTg2ZDA5ZTM3OWUoKTtcbn0pO1xuY29uc3QgJGM4NzMxMTQyNGVhMzBhMDUkZXhwb3J0JDY0NDZhMTg2ZDA5ZTM3OWUgPSAkYzg3MzExNDI0ZWEzMGEwNSR2YXIkY2FjaGVkKGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiAkYzg3MzExNDI0ZWEzMGEwNSR2YXIkdGVzdFVzZXJBZ2VudCgvQ2hyb21lL2kpO1xufSk7XG5jb25zdCAkYzg3MzExNDI0ZWEzMGEwNSRleHBvcnQkYTExYjAwNTk5MDBjZWVjOCA9ICRjODczMTE0MjRlYTMwYTA1JHZhciRjYWNoZWQoZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuICRjODczMTE0MjRlYTMwYTA1JHZhciR0ZXN0VXNlckFnZW50KC9BbmRyb2lkL2kpO1xufSk7XG5jb25zdCAkYzg3MzExNDI0ZWEzMGEwNSRleHBvcnQkYjdkNzg5OTNiNzRmNzY2ZCA9ICRjODczMTE0MjRlYTMwYTA1JHZhciRjYWNoZWQoZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuICRjODczMTE0MjRlYTMwYTA1JHZhciR0ZXN0VXNlckFnZW50KC9GaXJlZm94L2kpO1xufSk7XG5cblxuZXhwb3J0IHskYzg3MzExNDI0ZWEzMGEwNSRleHBvcnQkOWFjMTAwZTQwNjEzZWExMCBhcyBpc01hYywgJGM4NzMxMTQyNGVhMzBhMDUkZXhwb3J0JDE4NmM2OTY0Y2ExN2Q5OSBhcyBpc0lQaG9uZSwgJGM4NzMxMTQyNGVhMzBhMDUkZXhwb3J0JDdiZWYwNDljZTkyZTQyMjQgYXMgaXNJUGFkLCAkYzg3MzExNDI0ZWEzMGEwNSRleHBvcnQkZmVkYjM2OWNiNzAyMDdmMSBhcyBpc0lPUywgJGM4NzMxMTQyNGVhMzBhMDUkZXhwb3J0JGUxODY1YzNiZWRjZDgyMmIgYXMgaXNBcHBsZURldmljZSwgJGM4NzMxMTQyNGVhMzBhMDUkZXhwb3J0JDc4NTUxMDQzNTgyYTZhOTggYXMgaXNXZWJLaXQsICRjODczMTE0MjRlYTMwYTA1JGV4cG9ydCQ2NDQ2YTE4NmQwOWUzNzllIGFzIGlzQ2hyb21lLCAkYzg3MzExNDI0ZWEzMGEwNSRleHBvcnQkYTExYjAwNTk5MDBjZWVjOCBhcyBpc0FuZHJvaWQsICRjODczMTE0MjRlYTMwYTA1JGV4cG9ydCRiN2Q3ODk5M2I3NGY3NjZkIGFzIGlzRmlyZWZveH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wbGF0Zm9ybS5tb2R1bGUuanMubWFwXG4iXSwibmFtZXMiOlsiJGM4NzMxMTQyNGVhMzBhMDUkdmFyJHRlc3RVc2VyQWdlbnQiLCJyZSIsIl93aW5kb3dfbmF2aWdhdG9yX3VzZXJBZ2VudERhdGEiLCJ3aW5kb3ciLCJuYXZpZ2F0b3IiLCJicmFuZHMiLCJzb21lIiwiYnJhbmQiLCJ0ZXN0IiwidXNlckFnZW50IiwiJGM4NzMxMTQyNGVhMzBhMDUkdmFyJHRlc3RQbGF0Zm9ybSIsInBsYXRmb3JtIiwiJGM4NzMxMTQyNGVhMzBhMDUkdmFyJGNhY2hlZCIsImZuIiwicHJvY2VzcyIsInJlcyIsIiRjODczMTE0MjRlYTMwYTA1JGV4cG9ydCQ5YWMxMDBlNDA2MTNlYTEwIiwiJGM4NzMxMTQyNGVhMzBhMDUkZXhwb3J0JDE4NmM2OTY0Y2ExN2Q5OSIsIiRjODczMTE0MjRlYTMwYTA1JGV4cG9ydCQ3YmVmMDQ5Y2U5MmU0MjI0IiwibWF4VG91Y2hQb2ludHMiLCIkYzg3MzExNDI0ZWEzMGEwNSRleHBvcnQkZmVkYjM2OWNiNzAyMDdmMSIsIiRjODczMTE0MjRlYTMwYTA1JGV4cG9ydCRlMTg2NWMzYmVkY2Q4MjJiIiwiJGM4NzMxMTQyNGVhMzBhMDUkZXhwb3J0JDc4NTUxMDQzNTgyYTZhOTgiLCIkYzg3MzExNDI0ZWEzMGEwNSRleHBvcnQkNjQ0NmExODZkMDllMzc5ZSIsIiRjODczMTE0MjRlYTMwYTA1JGV4cG9ydCRhMTFiMDA1OTkwMGNlZWM4IiwiJGM4NzMxMTQyNGVhMzBhMDUkZXhwb3J0JGI3ZDc4OTkzYjc0Zjc2NmQiLCJpc01hYyIsImlzSVBob25lIiwiaXNJUGFkIiwiaXNJT1MiLCJpc0FwcGxlRGV2aWNlIiwiaXNXZWJLaXQiLCJpc0Nocm9tZSIsImlzQW5kcm9pZCIsImlzRmlyZWZveCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../../../node_modules/@react-aria/utils/dist/platform.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/../../../../node_modules/@react-aria/utils/dist/useEffectEvent.mjs":
/*!**************************************************************************!*\
  !*** ../../../../node_modules/@react-aria/utils/dist/useEffectEvent.mjs ***!
  \**************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useEffectEvent: function() { return /* binding */ $8ae05eaa5c114e9c$export$7f54fc3180508a52; }\n/* harmony export */ });\n/* harmony import */ var _useLayoutEffect_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./useLayoutEffect.mjs */ \"(app-pages-browser)/../../../../node_modules/@react-aria/utils/dist/useLayoutEffect.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n\n\n/*\n * Copyright 2023 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ function $8ae05eaa5c114e9c$export$7f54fc3180508a52(fn) {\n    const ref = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    (0, _useLayoutEffect_mjs__WEBPACK_IMPORTED_MODULE_1__.useLayoutEffect)(()=>{\n        ref.current = fn;\n    }, [\n        fn\n    ]);\n    // @ts-ignore\n    return (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(function() {\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        const f = ref.current;\n        return f === null || f === void 0 ? void 0 : f(...args);\n    }, []);\n}\n //# sourceMappingURL=useEffectEvent.module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQHJlYWN0LWFyaWEvdXRpbHMvZGlzdC91c2VFZmZlY3RFdmVudC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQW1HO0FBQ2xCO0FBRWpGOzs7Ozs7Ozs7O0NBVUMsR0FFRCxTQUFTTSwwQ0FBMENDLEVBQUU7SUFDakQsTUFBTUMsTUFBTSxDQUFDLEdBQUdMLHlDQUFZLEVBQUc7SUFDOUIsSUFBR0YsaUVBQXdDLEVBQUc7UUFDM0NPLElBQUlDLE9BQU8sR0FBR0Y7SUFDbEIsR0FBRztRQUNDQTtLQUNIO0lBQ0QsYUFBYTtJQUNiLE9BQU8sQ0FBQyxHQUFHRiw4Q0FBaUIsRUFBRzt5Q0FBSUs7WUFBQUE7O1FBQy9CLE1BQU1DLElBQUlILElBQUlDLE9BQU87UUFDckIsT0FBT0UsTUFBTSxRQUFRQSxNQUFNLEtBQUssSUFBSSxLQUFLLElBQUlBLEtBQUtEO0lBQ3RELEdBQUcsRUFBRTtBQUNUO0FBR3FFLENBQ3JFLGlEQUFpRCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0ByZWFjdC1hcmlhL3V0aWxzL2Rpc3QvdXNlRWZmZWN0RXZlbnQubWpzPzljMDAiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHt1c2VMYXlvdXRFZmZlY3QgYXMgJGYwYTA0Y2NkOGRiZGQ4M2IkZXhwb3J0JGU1YzVhNWY5MTdhNTg3MWN9IGZyb20gXCIuL3VzZUxheW91dEVmZmVjdC5tanNcIjtcbmltcG9ydCB7dXNlUmVmIGFzICRsbWFZciR1c2VSZWYsIHVzZUNhbGxiYWNrIGFzICRsbWFZciR1c2VDYWxsYmFja30gZnJvbSBcInJlYWN0XCI7XG5cbi8qXG4gKiBDb3B5cmlnaHQgMjAyMyBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyBcblxuZnVuY3Rpb24gJDhhZTA1ZWFhNWMxMTRlOWMkZXhwb3J0JDdmNTRmYzMxODA1MDhhNTIoZm4pIHtcbiAgICBjb25zdCByZWYgPSAoMCwgJGxtYVlyJHVzZVJlZikobnVsbCk7XG4gICAgKDAsICRmMGEwNGNjZDhkYmRkODNiJGV4cG9ydCRlNWM1YTVmOTE3YTU4NzFjKSgoKT0+e1xuICAgICAgICByZWYuY3VycmVudCA9IGZuO1xuICAgIH0sIFtcbiAgICAgICAgZm5cbiAgICBdKTtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgcmV0dXJuICgwLCAkbG1hWXIkdXNlQ2FsbGJhY2spKCguLi5hcmdzKT0+e1xuICAgICAgICBjb25zdCBmID0gcmVmLmN1cnJlbnQ7XG4gICAgICAgIHJldHVybiBmID09PSBudWxsIHx8IGYgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGYoLi4uYXJncyk7XG4gICAgfSwgW10pO1xufVxuXG5cbmV4cG9ydCB7JDhhZTA1ZWFhNWMxMTRlOWMkZXhwb3J0JDdmNTRmYzMxODA1MDhhNTIgYXMgdXNlRWZmZWN0RXZlbnR9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXNlRWZmZWN0RXZlbnQubW9kdWxlLmpzLm1hcFxuIl0sIm5hbWVzIjpbInVzZUxheW91dEVmZmVjdCIsIiRmMGEwNGNjZDhkYmRkODNiJGV4cG9ydCRlNWM1YTVmOTE3YTU4NzFjIiwidXNlUmVmIiwiJGxtYVlyJHVzZVJlZiIsInVzZUNhbGxiYWNrIiwiJGxtYVlyJHVzZUNhbGxiYWNrIiwiJDhhZTA1ZWFhNWMxMTRlOWMkZXhwb3J0JDdmNTRmYzMxODA1MDhhNTIiLCJmbiIsInJlZiIsImN1cnJlbnQiLCJhcmdzIiwiZiIsInVzZUVmZmVjdEV2ZW50Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../../../node_modules/@react-aria/utils/dist/useEffectEvent.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/../../../../node_modules/@react-aria/utils/dist/useGlobalListeners.mjs":
/*!******************************************************************************!*\
  !*** ../../../../node_modules/@react-aria/utils/dist/useGlobalListeners.mjs ***!
  \******************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useGlobalListeners: function() { return /* binding */ $03deb23ff14920c4$export$4eaf04e54aa8eed6; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ function $03deb23ff14920c4$export$4eaf04e54aa8eed6() {\n    let globalListeners = (0, react__WEBPACK_IMPORTED_MODULE_0__.useRef)(new Map());\n    let addGlobalListener = (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((eventTarget, type, listener, options)=>{\n        // Make sure we remove the listener after it is called with the `once` option.\n        let fn = (options === null || options === void 0 ? void 0 : options.once) ? function() {\n            for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n                args[_key] = arguments[_key];\n            }\n            globalListeners.current.delete(listener);\n            listener(...args);\n        } : listener;\n        globalListeners.current.set(listener, {\n            type: type,\n            eventTarget: eventTarget,\n            fn: fn,\n            options: options\n        });\n        eventTarget.addEventListener(type, fn, options);\n    }, []);\n    let removeGlobalListener = (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((eventTarget, type, listener, options)=>{\n        var _globalListeners_current_get;\n        let fn = ((_globalListeners_current_get = globalListeners.current.get(listener)) === null || _globalListeners_current_get === void 0 ? void 0 : _globalListeners_current_get.fn) || listener;\n        eventTarget.removeEventListener(type, fn, options);\n        globalListeners.current.delete(listener);\n    }, []);\n    let removeAllGlobalListeners = (0, react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        globalListeners.current.forEach((value, key)=>{\n            removeGlobalListener(value.eventTarget, value.type, key, value.options);\n        });\n    }, [\n        removeGlobalListener\n    ]);\n    (0, react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        return removeAllGlobalListeners;\n    }, [\n        removeAllGlobalListeners\n    ]);\n    return {\n        addGlobalListener: addGlobalListener,\n        removeGlobalListener: removeGlobalListener,\n        removeAllGlobalListeners: removeAllGlobalListeners\n    };\n}\n //# sourceMappingURL=useGlobalListeners.module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQHJlYWN0LWFyaWEvdXRpbHMvZGlzdC91c2VHbG9iYWxMaXN0ZW5lcnMubWpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQWdIO0FBRWhIOzs7Ozs7Ozs7O0NBVUMsR0FDRCxTQUFTTTtJQUNMLElBQUlDLGtCQUFrQixDQUFDLEdBQUdOLHlDQUFZLEVBQUcsSUFBSU87SUFDN0MsSUFBSUMsb0JBQW9CLENBQUMsR0FBR04sOENBQWlCLEVBQUcsQ0FBQ08sYUFBYUMsTUFBTUMsVUFBVUM7UUFDMUUsOEVBQThFO1FBQzlFLElBQUlDLEtBQUssQ0FBQ0QsWUFBWSxRQUFRQSxZQUFZLEtBQUssSUFBSSxLQUFLLElBQUlBLFFBQVFFLElBQUksSUFBSTs2Q0FBSUM7Z0JBQUFBOztZQUM1RVQsZ0JBQWdCVSxPQUFPLENBQUNDLE1BQU0sQ0FBQ047WUFDL0JBLFlBQVlJO1FBQ2hCLElBQUlKO1FBQ0pMLGdCQUFnQlUsT0FBTyxDQUFDRSxHQUFHLENBQUNQLFVBQVU7WUFDbENELE1BQU1BO1lBQ05ELGFBQWFBO1lBQ2JJLElBQUlBO1lBQ0pELFNBQVNBO1FBQ2I7UUFDQUgsWUFBWVUsZ0JBQWdCLENBQUNULE1BQU1HLElBQUlEO0lBQzNDLEdBQUcsRUFBRTtJQUNMLElBQUlRLHVCQUF1QixDQUFDLEdBQUdsQiw4Q0FBaUIsRUFBRyxDQUFDTyxhQUFhQyxNQUFNQyxVQUFVQztRQUM3RSxJQUFJUztRQUNKLElBQUlSLEtBQUssQ0FBQyxDQUFDUSwrQkFBK0JmLGdCQUFnQlUsT0FBTyxDQUFDTSxHQUFHLENBQUNYLFNBQVEsTUFBTyxRQUFRVSxpQ0FBaUMsS0FBSyxJQUFJLEtBQUssSUFBSUEsNkJBQTZCUixFQUFFLEtBQUtGO1FBQ3BMRixZQUFZYyxtQkFBbUIsQ0FBQ2IsTUFBTUcsSUFBSUQ7UUFDMUNOLGdCQUFnQlUsT0FBTyxDQUFDQyxNQUFNLENBQUNOO0lBQ25DLEdBQUcsRUFBRTtJQUNMLElBQUlhLDJCQUEyQixDQUFDLEdBQUd0Qiw4Q0FBaUIsRUFBRztRQUNuREksZ0JBQWdCVSxPQUFPLENBQUNTLE9BQU8sQ0FBQyxDQUFDQyxPQUFPQztZQUNwQ1AscUJBQXFCTSxNQUFNakIsV0FBVyxFQUFFaUIsTUFBTWhCLElBQUksRUFBRWlCLEtBQUtELE1BQU1kLE9BQU87UUFDMUU7SUFDSixHQUFHO1FBQ0NRO0tBQ0g7SUFDQSxJQUFHaEIsNENBQWUsRUFBRztRQUNsQixPQUFPb0I7SUFDWCxHQUFHO1FBQ0NBO0tBQ0g7SUFDRCxPQUFPO1FBQ0hoQixtQkFBbUJBO1FBQ25CWSxzQkFBc0JBO1FBQ3RCSSwwQkFBMEJBO0lBQzlCO0FBQ0o7QUFHeUUsQ0FDekUscURBQXFEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQHJlYWN0LWFyaWEvdXRpbHMvZGlzdC91c2VHbG9iYWxMaXN0ZW5lcnMubWpzP2QwNTYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHt1c2VSZWYgYXMgJGxQQXd0JHVzZVJlZiwgdXNlQ2FsbGJhY2sgYXMgJGxQQXd0JHVzZUNhbGxiYWNrLCB1c2VFZmZlY3QgYXMgJGxQQXd0JHVzZUVmZmVjdH0gZnJvbSBcInJlYWN0XCI7XG5cbi8qXG4gKiBDb3B5cmlnaHQgMjAyMCBBZG9iZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgZmlsZSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XG4gKiBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyXG4gKiB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBSRVBSRVNFTlRBVElPTlNcbiAqIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZVxuICogZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqLyBcbmZ1bmN0aW9uICQwM2RlYjIzZmYxNDkyMGM0JGV4cG9ydCQ0ZWFmMDRlNTRhYThlZWQ2KCkge1xuICAgIGxldCBnbG9iYWxMaXN0ZW5lcnMgPSAoMCwgJGxQQXd0JHVzZVJlZikobmV3IE1hcCgpKTtcbiAgICBsZXQgYWRkR2xvYmFsTGlzdGVuZXIgPSAoMCwgJGxQQXd0JHVzZUNhbGxiYWNrKSgoZXZlbnRUYXJnZXQsIHR5cGUsIGxpc3RlbmVyLCBvcHRpb25zKT0+e1xuICAgICAgICAvLyBNYWtlIHN1cmUgd2UgcmVtb3ZlIHRoZSBsaXN0ZW5lciBhZnRlciBpdCBpcyBjYWxsZWQgd2l0aCB0aGUgYG9uY2VgIG9wdGlvbi5cbiAgICAgICAgbGV0IGZuID0gKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5vbmNlKSA/ICguLi5hcmdzKT0+e1xuICAgICAgICAgICAgZ2xvYmFsTGlzdGVuZXJzLmN1cnJlbnQuZGVsZXRlKGxpc3RlbmVyKTtcbiAgICAgICAgICAgIGxpc3RlbmVyKC4uLmFyZ3MpO1xuICAgICAgICB9IDogbGlzdGVuZXI7XG4gICAgICAgIGdsb2JhbExpc3RlbmVycy5jdXJyZW50LnNldChsaXN0ZW5lciwge1xuICAgICAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgICAgIGV2ZW50VGFyZ2V0OiBldmVudFRhcmdldCxcbiAgICAgICAgICAgIGZuOiBmbixcbiAgICAgICAgICAgIG9wdGlvbnM6IG9wdGlvbnNcbiAgICAgICAgfSk7XG4gICAgICAgIGV2ZW50VGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgZm4sIG9wdGlvbnMpO1xuICAgIH0sIFtdKTtcbiAgICBsZXQgcmVtb3ZlR2xvYmFsTGlzdGVuZXIgPSAoMCwgJGxQQXd0JHVzZUNhbGxiYWNrKSgoZXZlbnRUYXJnZXQsIHR5cGUsIGxpc3RlbmVyLCBvcHRpb25zKT0+e1xuICAgICAgICB2YXIgX2dsb2JhbExpc3RlbmVyc19jdXJyZW50X2dldDtcbiAgICAgICAgbGV0IGZuID0gKChfZ2xvYmFsTGlzdGVuZXJzX2N1cnJlbnRfZ2V0ID0gZ2xvYmFsTGlzdGVuZXJzLmN1cnJlbnQuZ2V0KGxpc3RlbmVyKSkgPT09IG51bGwgfHwgX2dsb2JhbExpc3RlbmVyc19jdXJyZW50X2dldCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2dsb2JhbExpc3RlbmVyc19jdXJyZW50X2dldC5mbikgfHwgbGlzdGVuZXI7XG4gICAgICAgIGV2ZW50VGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgZm4sIG9wdGlvbnMpO1xuICAgICAgICBnbG9iYWxMaXN0ZW5lcnMuY3VycmVudC5kZWxldGUobGlzdGVuZXIpO1xuICAgIH0sIFtdKTtcbiAgICBsZXQgcmVtb3ZlQWxsR2xvYmFsTGlzdGVuZXJzID0gKDAsICRsUEF3dCR1c2VDYWxsYmFjaykoKCk9PntcbiAgICAgICAgZ2xvYmFsTGlzdGVuZXJzLmN1cnJlbnQuZm9yRWFjaCgodmFsdWUsIGtleSk9PntcbiAgICAgICAgICAgIHJlbW92ZUdsb2JhbExpc3RlbmVyKHZhbHVlLmV2ZW50VGFyZ2V0LCB2YWx1ZS50eXBlLCBrZXksIHZhbHVlLm9wdGlvbnMpO1xuICAgICAgICB9KTtcbiAgICB9LCBbXG4gICAgICAgIHJlbW92ZUdsb2JhbExpc3RlbmVyXG4gICAgXSk7XG4gICAgKDAsICRsUEF3dCR1c2VFZmZlY3QpKCgpPT57XG4gICAgICAgIHJldHVybiByZW1vdmVBbGxHbG9iYWxMaXN0ZW5lcnM7XG4gICAgfSwgW1xuICAgICAgICByZW1vdmVBbGxHbG9iYWxMaXN0ZW5lcnNcbiAgICBdKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBhZGRHbG9iYWxMaXN0ZW5lcjogYWRkR2xvYmFsTGlzdGVuZXIsXG4gICAgICAgIHJlbW92ZUdsb2JhbExpc3RlbmVyOiByZW1vdmVHbG9iYWxMaXN0ZW5lcixcbiAgICAgICAgcmVtb3ZlQWxsR2xvYmFsTGlzdGVuZXJzOiByZW1vdmVBbGxHbG9iYWxMaXN0ZW5lcnNcbiAgICB9O1xufVxuXG5cbmV4cG9ydCB7JDAzZGViMjNmZjE0OTIwYzQkZXhwb3J0JDRlYWYwNGU1NGFhOGVlZDYgYXMgdXNlR2xvYmFsTGlzdGVuZXJzfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVzZUdsb2JhbExpc3RlbmVycy5tb2R1bGUuanMubWFwXG4iXSwibmFtZXMiOlsidXNlUmVmIiwiJGxQQXd0JHVzZVJlZiIsInVzZUNhbGxiYWNrIiwiJGxQQXd0JHVzZUNhbGxiYWNrIiwidXNlRWZmZWN0IiwiJGxQQXd0JHVzZUVmZmVjdCIsIiQwM2RlYjIzZmYxNDkyMGM0JGV4cG9ydCQ0ZWFmMDRlNTRhYThlZWQ2IiwiZ2xvYmFsTGlzdGVuZXJzIiwiTWFwIiwiYWRkR2xvYmFsTGlzdGVuZXIiLCJldmVudFRhcmdldCIsInR5cGUiLCJsaXN0ZW5lciIsIm9wdGlvbnMiLCJmbiIsIm9uY2UiLCJhcmdzIiwiY3VycmVudCIsImRlbGV0ZSIsInNldCIsImFkZEV2ZW50TGlzdGVuZXIiLCJyZW1vdmVHbG9iYWxMaXN0ZW5lciIsIl9nbG9iYWxMaXN0ZW5lcnNfY3VycmVudF9nZXQiLCJnZXQiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwicmVtb3ZlQWxsR2xvYmFsTGlzdGVuZXJzIiwiZm9yRWFjaCIsInZhbHVlIiwia2V5IiwidXNlR2xvYmFsTGlzdGVuZXJzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../../../node_modules/@react-aria/utils/dist/useGlobalListeners.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/../../../../node_modules/@react-aria/utils/dist/useLayoutEffect.mjs":
/*!***************************************************************************!*\
  !*** ../../../../node_modules/@react-aria/utils/dist/useLayoutEffect.mjs ***!
  \***************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useLayoutEffect: function() { return /* binding */ $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ const $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c = typeof document !== \"undefined\" ? (0, react__WEBPACK_IMPORTED_MODULE_0__).useLayoutEffect : ()=>{};\n //# sourceMappingURL=useLayoutEffect.module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQHJlYWN0LWFyaWEvdXRpbHMvZGlzdC91c2VMYXlvdXRFZmZlY3QubWpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQWlDO0FBRWpDOzs7Ozs7Ozs7O0NBVUMsR0FDRCxNQUFNQyw0Q0FBNEMsT0FBT0MsYUFBYSxjQUFjLENBQUMsR0FBR0Ysa0NBQVcsRUFBR0csZUFBZSxHQUFHLEtBQUs7QUFHdkQsQ0FDdEUsa0RBQWtEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQHJlYWN0LWFyaWEvdXRpbHMvZGlzdC91c2VMYXlvdXRFZmZlY3QubWpzP2YxMWUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICRIZ0FOZCRyZWFjdCBmcm9tIFwicmVhY3RcIjtcblxuLypcbiAqIENvcHlyaWdodCAyMDIwIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIFxuY29uc3QgJGYwYTA0Y2NkOGRiZGQ4M2IkZXhwb3J0JGU1YzVhNWY5MTdhNTg3MWMgPSB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnID8gKDAsICRIZ0FOZCRyZWFjdCkudXNlTGF5b3V0RWZmZWN0IDogKCk9Pnt9O1xuXG5cbmV4cG9ydCB7JGYwYTA0Y2NkOGRiZGQ4M2IkZXhwb3J0JGU1YzVhNWY5MTdhNTg3MWMgYXMgdXNlTGF5b3V0RWZmZWN0fTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVzZUxheW91dEVmZmVjdC5tb2R1bGUuanMubWFwXG4iXSwibmFtZXMiOlsiJEhnQU5kJHJlYWN0IiwiJGYwYTA0Y2NkOGRiZGQ4M2IkZXhwb3J0JGU1YzVhNWY5MTdhNTg3MWMiLCJkb2N1bWVudCIsInVzZUxheW91dEVmZmVjdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../../../node_modules/@react-aria/utils/dist/useLayoutEffect.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/../../../../node_modules/@react-stately/flags/dist/import.mjs":
/*!*********************************************************************!*\
  !*** ../../../../node_modules/@react-stately/flags/dist/import.mjs ***!
  \*********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   enableShadowDOM: function() { return /* binding */ $f4e2df6bd15f8569$export$12b151d9882e9985; },\n/* harmony export */   enableTableNestedRows: function() { return /* binding */ $f4e2df6bd15f8569$export$d9d8a0f82de49530; },\n/* harmony export */   shadowDOM: function() { return /* binding */ $f4e2df6bd15f8569$export$98658e8c59125e6a; },\n/* harmony export */   tableNestedRows: function() { return /* binding */ $f4e2df6bd15f8569$export$1b00cb14a96194e6; }\n/* harmony export */ });\n/*\n * Copyright 2023 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ let $f4e2df6bd15f8569$var$_tableNestedRows = false;\nlet $f4e2df6bd15f8569$var$_shadowDOM = false;\nfunction $f4e2df6bd15f8569$export$d9d8a0f82de49530() {\n    $f4e2df6bd15f8569$var$_tableNestedRows = true;\n}\nfunction $f4e2df6bd15f8569$export$1b00cb14a96194e6() {\n    return $f4e2df6bd15f8569$var$_tableNestedRows;\n}\nfunction $f4e2df6bd15f8569$export$12b151d9882e9985() {\n    $f4e2df6bd15f8569$var$_shadowDOM = true;\n}\nfunction $f4e2df6bd15f8569$export$98658e8c59125e6a() {\n    return $f4e2df6bd15f8569$var$_shadowDOM;\n}\n //# sourceMappingURL=module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQHJlYWN0LXN0YXRlbHkvZmxhZ3MvZGlzdC9pbXBvcnQubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTs7Ozs7Ozs7OztDQVVDLEdBQUcsSUFBSUEseUNBQXlDO0FBQ2pELElBQUlDLG1DQUFtQztBQUN2QyxTQUFTQztJQUNMRix5Q0FBeUM7QUFDN0M7QUFDQSxTQUFTRztJQUNMLE9BQU9IO0FBQ1g7QUFDQSxTQUFTSTtJQUNMSCxtQ0FBbUM7QUFDdkM7QUFDQSxTQUFTSTtJQUNMLE9BQU9KO0FBQ1g7QUFHZ1EsQ0FDaFEsa0NBQWtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQHJlYWN0LXN0YXRlbHkvZmxhZ3MvZGlzdC9pbXBvcnQubWpzPzVjOWEiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiAqIENvcHlyaWdodCAyMDIzIEFkb2JlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBmaWxlIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXJcbiAqIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIFJFUFJFU0VOVEFUSU9OU1xuICogT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovIGxldCAkZjRlMmRmNmJkMTVmODU2OSR2YXIkX3RhYmxlTmVzdGVkUm93cyA9IGZhbHNlO1xubGV0ICRmNGUyZGY2YmQxNWY4NTY5JHZhciRfc2hhZG93RE9NID0gZmFsc2U7XG5mdW5jdGlvbiAkZjRlMmRmNmJkMTVmODU2OSRleHBvcnQkZDlkOGEwZjgyZGU0OTUzMCgpIHtcbiAgICAkZjRlMmRmNmJkMTVmODU2OSR2YXIkX3RhYmxlTmVzdGVkUm93cyA9IHRydWU7XG59XG5mdW5jdGlvbiAkZjRlMmRmNmJkMTVmODU2OSRleHBvcnQkMWIwMGNiMTRhOTYxOTRlNigpIHtcbiAgICByZXR1cm4gJGY0ZTJkZjZiZDE1Zjg1NjkkdmFyJF90YWJsZU5lc3RlZFJvd3M7XG59XG5mdW5jdGlvbiAkZjRlMmRmNmJkMTVmODU2OSRleHBvcnQkMTJiMTUxZDk4ODJlOTk4NSgpIHtcbiAgICAkZjRlMmRmNmJkMTVmODU2OSR2YXIkX3NoYWRvd0RPTSA9IHRydWU7XG59XG5mdW5jdGlvbiAkZjRlMmRmNmJkMTVmODU2OSRleHBvcnQkOTg2NThlOGM1OTEyNWU2YSgpIHtcbiAgICByZXR1cm4gJGY0ZTJkZjZiZDE1Zjg1NjkkdmFyJF9zaGFkb3dET007XG59XG5cblxuZXhwb3J0IHskZjRlMmRmNmJkMTVmODU2OSRleHBvcnQkZDlkOGEwZjgyZGU0OTUzMCBhcyBlbmFibGVUYWJsZU5lc3RlZFJvd3MsICRmNGUyZGY2YmQxNWY4NTY5JGV4cG9ydCQxYjAwY2IxNGE5NjE5NGU2IGFzIHRhYmxlTmVzdGVkUm93cywgJGY0ZTJkZjZiZDE1Zjg1NjkkZXhwb3J0JDEyYjE1MWQ5ODgyZTk5ODUgYXMgZW5hYmxlU2hhZG93RE9NLCAkZjRlMmRmNmJkMTVmODU2OSRleHBvcnQkOTg2NThlOGM1OTEyNWU2YSBhcyBzaGFkb3dET019O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bW9kdWxlLmpzLm1hcFxuIl0sIm5hbWVzIjpbIiRmNGUyZGY2YmQxNWY4NTY5JHZhciRfdGFibGVOZXN0ZWRSb3dzIiwiJGY0ZTJkZjZiZDE1Zjg1NjkkdmFyJF9zaGFkb3dET00iLCIkZjRlMmRmNmJkMTVmODU2OSRleHBvcnQkZDlkOGEwZjgyZGU0OTUzMCIsIiRmNGUyZGY2YmQxNWY4NTY5JGV4cG9ydCQxYjAwY2IxNGE5NjE5NGU2IiwiJGY0ZTJkZjZiZDE1Zjg1NjkkZXhwb3J0JDEyYjE1MWQ5ODgyZTk5ODUiLCIkZjRlMmRmNmJkMTVmODU2OSRleHBvcnQkOTg2NThlOGM1OTEyNWU2YSIsImVuYWJsZVRhYmxlTmVzdGVkUm93cyIsInRhYmxlTmVzdGVkUm93cyIsImVuYWJsZVNoYWRvd0RPTSIsInNoYWRvd0RPTSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../../../node_modules/@react-stately/flags/dist/import.mjs\n"));

/***/ })

});